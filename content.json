{"meta":{"title":"Memory","subtitle":"永远相信美好的事情即将发生","description":null,"author":"nlby","url":"https://shadowbynl.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2021-08-28T04:29:51.390Z","updated":"2021-08-28T04:22:33.454Z","comments":true,"path":"archive.html","permalink":"https://shadowbynl.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"工具之一：一个爬虫小demo","slug":"tool-00","date":"2021-10-04T12:27:12.000Z","updated":"2021-10-07T08:19:00.362Z","comments":true,"path":"2021/10/04/tool-00/","link":"","permalink":"https://shadowbynl.github.io/2021/10/04/tool-00/","excerpt":"2021.10.04 恰逢绿群换届，加入绿群半年多了，深感绿群给我认识上的帮助还是不小的，为表纪念，编程实现一下把两个绿群当前的群成员信息（为了以后还能留在里面，得每天早上打卡了，）","text":"2021.10.04 恰逢绿群换届，加入绿群半年多了，深感绿群给我认识上的帮助还是不小的，为表纪念，编程实现一下把两个绿群当前的群成员信息（为了以后还能留在里面，得每天早上打卡了，） 先前的工作 实现 问题与参考 总结 先前的工作根据前两三天的测试，发现只能通过网页版群管理网站访问自己加入群的信息，且初始群成员仅显示几十条，随手动刷新变化，因此 121 需要登录信息cookie2 需要调整访问参数或者自己创建客户端 后面用chrome + postman进行了接口测试发现仿照chrome对接口https://qun.qq.com/cgi-bin/qun_mgr/search_group_members 的请求，自己填写请求头和cookie很难访问成功，后通过postman的拦截器，拦截到请求（主要是headers），再手动设置cookie，可以请求到数据，但现在两天后已经失效了，需要重新考虑，并且经过测试一次请求的数据最多为40条 那么 1 手动调整参数2 编程实现 1决定还是用python实现，有python脚本且python写爬虫和操作数据库简单多了 实现在用复杂方法实现之前，先试试能不能用xpath抓到不能 以下为成功实现（json数据存储在文本中，解析后的数据存入数据库） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import requestsimport jsonimport datetimeimport pymysqldef get_data(st, end): url = &quot;https://qun.qq.com/cgi-bin/qun_mgr/search_group_members&quot; payload=&#x27;bkn=17&amp;end=%d&amp;gc=60&amp;sort=0&amp;st=%d&#x27; % (end, st) print(payload) headers = &#123; &#x27;sec-ch-ua&#x27;: &#x27;&quot;Google Chrome&quot;;v=&quot;93&quot;, &quot; Not;A Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;93&quot;&#x27;, &#x27;Accept&#x27;: &#x27;application/json, text/javascript, */*; q=0.01&#x27;, &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;, &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;, &#x27;sec-ch-ua-mobile&#x27;: &#x27;?0&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36&#x27;, &#x27;sec-ch-ua-platform&#x27;: &#x27;&quot;Windows&quot;&#x27;, &#x27;Sec-Fetch-Site&#x27;: &#x27;same-origin&#x27;, &#x27;Sec-Fetch-Mode&#x27;: &#x27;cors&#x27;, &#x27;Sec-Fetch-Dest&#x27;: &#x27;empty&#x27;, &#x27;cookie&#x27;: &#x27;pgv_pvid=4807424512; RK=CnitUqaOzk; ptcz=2bff5fa480b335df4dea5136dd81406309b8f15f73ff199cd4a10aab809851c6; ptui_loginuin=1029253541@qq.com; o_cookie=1029253541; pac_uid=1_1029253541; pt_sms_phone=152******68; tvfe_boss_uuid=64df391d6a4d651e; luin=o1029253541; lskey=000100000e1cf2eae4b33b52500045ff70be94a0d1970a5bef9d1b131ed869f75fa730c46612f21ab51145fd; pgv_info=ssid=s7817371752; rv2=8071853B4A6553C74DF68DE54D4BA72CAE91A028BB765C5D46; property20=A93EDBD10D788C397EE1080CE04FEC49CCE5ED74FAD10405A78EB5850B3C3DFDDFD043AC9328A585; uin=o3347893023; _qpsvr_localtk=0.05728061992185873; p_uin=o3347893023; traceid=4260966dcc; midas_openid=F7D08CE2D8B70939D1A41C59F768CFD3; midas_openkey=BF1126A37F21BE7734072884A99E4C88; skey=@rLW4zF2XC; pt4_token=dFtpDgb38HJDsbh-LofFjunN7VgVFhV-nb62YQdGqDo_; p_skey=C9bpnITdlIJZ2w2697GG4yD4w*v*ccsw76wzZN6J-qA_; traceid=3bf6119017&#x27; &#125; response = requests.request(&quot;POST&quot;, url, headers=headers, data=payload) content = response.text # print(response.text) return contentdef parse(content, file): with open(file, &quot;a&quot;, encoding=&#x27;utf-8&#x27;) as f: f.write(content + &quot;\\n&quot;) # 转换为python对象 data = json.loads(content) mems = data[&quot;mems&quot;] conn = pymysql.connect(host=&quot;ip&quot;, port=3306, user=&quot;root&quot;, password=&quot;pwd&quot;, database=&quot;ggu&quot;, charset=&quot;utf8mb4&quot;) for mem in mems: qq_id = mem[&quot;uin&quot;] qq_name = mem[&quot;nick&quot;] print(qq_name) qq_card = mem[&quot;card&quot;] qq_age = str(mem[&quot;qage&quot;]) qq_join_time = mem[&quot;join_time&quot;] dateArray = datetime.datetime.utcfromtimestamp(qq_join_time) qq_join_time = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) qq_speak_time = mem[&quot;last_speak_time&quot;] dateArray = datetime.datetime.utcfromtimestamp(qq_speak_time) qq_speak_time = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) cursor = conn.cursor() sql = &quot;INSERT INTO membera(qq_id, qq_name, qq_card, qq_age, qq_join_time, qq_speak_time) VALUES (%s, %s, %s, %s, %s, %s);&quot; cursor.execute(sql, [qq_id, qq_name, qq_card, qq_age, qq_join_time, qq_speak_time]) conn.commit() cursor.close()# timeStamp = 1591780240# dateArray = datetime.datetime.utcfromtimestamp(timeStamp)# otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)# print(otherStyleTime)if __name__ == &#x27;__main__&#x27;: for st in range(0, 2800, 40): content = get_data(st, st + 40) parse(content, file=&quot;membera.txt&quot;) 问题与参考 python时间戳转换日期格式 https://www.runoob.com/python3/python-timstamp-str.html 123456import datetime timeStamp = 1557502800dateArray = datetime.datetime.utcfromtimestamp(timeStamp)otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)print(otherStyleTime) python json解析 https://www.runoob.com/python/python-json.html python格式化字符串 https://www.cnblogs.com/wilber2013/p/4641616.html python循环 https://www.cnblogs.com/anyview/p/5569016.html utf8编码和utf8mb4编码的差别 存数据库时报错 Incorrect string value: &#39;\\\\xF0\\\\x9F\\\\x92\\\\xAD\\\\xF0\\\\x9F... 经查是字段编码导致（原为utf8三字节存不下，需要换成utf8mb4四字节，注意必须在字段设计上换，单纯更改数据库编码不行）https://blog.csdn.net/qq_36090463/article/details/82353327https://blog.csdn.net/qq_17555933/article/details/101445526 总结 利用postman捕获分析请求有助于获取一般难以爬取的信息，且提供了多种语言的脚本，可以说作用很大了 utf8和utf8mb4的区别","categories":[{"name":"工具","slug":"工具","permalink":"https://shadowbynl.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"java爬虫相关","slug":"jaspider","date":"2021-10-01T13:36:45.000Z","updated":"2021-10-07T08:36:12.445Z","comments":true,"path":"2021/10/01/jaspider/","link":"","permalink":"https://shadowbynl.github.io/2021/10/01/jaspider/","excerpt":"占位","text":"占位 爬虫：采集–处理–存储用途：实现搜索引擎 获取更多的数据源 进行搜索引擎优化","categories":[{"name":"数据","slug":"数据","permalink":"https://shadowbynl.github.io/categories/%E6%95%B0%E6%8D%AE/"}],"tags":[]},{"title":"2021年9月保研结束后总结","slug":"202109summary","date":"2021-09-28T14:48:19.000Z","updated":"2021-10-07T08:35:05.694Z","comments":true,"path":"2021/09/28/202109summary/","link":"","permalink":"https://shadowbynl.github.io/2021/09/28/202109summary/","excerpt":"占位","text":"占位 目标 10.8 前 不多说了，勉强上个学，夏令营后两个月基本没有做保研相关的准备，拿到现在的结果也算是将就吧，之后的路就全看自己把握了。充足的写代码时间，自学时间，和短期的与长期的找工作的目标，将是我未来三年内的主题。未来的半年内，实习，毕设，写代码，学英语，深化对计算机知识的理解，尝试一些事，为研究生打工做准备，锻炼身体。。所有一切需要足够的自律和坚定的信念。这是一个新的起点，与我竞争的不单单是同校同专业的同学，更是全国千千万万学历或高或低经验或多或少的相关从业者。在这行立足，并做久，需要我持续慎重思考并践行。总会有遗憾，但要努力让自己以后不要做会让未来后悔的事。现在我的路已经很明确了。 目标10.8 前1 步入正轨 按920的安排进行2 做简历，准备投递（目标，了解）3 了解之后研究生的规划安排/情况（小概率考虑其他导师）","categories":[{"name":"规划","slug":"规划","permalink":"https://shadowbynl.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"npm相关环境","slug":"env-npm","date":"2021-09-22T01:42:20.000Z","updated":"2021-10-07T08:35:49.810Z","comments":true,"path":"2021/09/22/env-npm/","link":"","permalink":"https://shadowbynl.github.io/2021/09/22/env-npm/","excerpt":"占位","text":"占位 npm查看全局安装过的包npm list -g –depth 0https://www.cnblogs.com/zhou-135/articles/11816745.html","categories":[{"name":"环境","slug":"环境","permalink":"https://shadowbynl.github.io/categories/%E7%8E%AF%E5%A2%83/"}],"tags":[]},{"title":"nk社区","slug":"pro-00","date":"2021-09-21T12:21:15.000Z","updated":"2021-10-07T08:32:08.128Z","comments":true,"path":"2021/09/21/pro-00/","link":"","permalink":"https://shadowbynl.github.io/2021/09/21/pro-00/","excerpt":"占位","text":"占位 nk社区 1 首页 2 登录模块 2-1 发送邮件 2-2 开发注册功能 代码 2-3 会话管理 代码 2-4 生成验证码 代码 2-5 开发登录、退出功能 代码 2-6 显示登录信息 代码 2-7 账号设置 代码 2-8 检查登录状态 代码 3 核心功能 3-1 过滤敏感词 代码 3-2 发布帖子 3-3 帖子详情 3-4 事务管理 3-5 显示评论 3-6 添加评论 3-7 私信列表 3-8 发送私信 3-9 统一处理异常 3-10 统一处理日志（针对业务组件） 四 Redis缓存 4.1 Redis入门 4.2 spring整合redis 4.3 点赞（获取赞信息） 4.4 我收到的赞 4.5 关注、取消关注 4.6 关注列表、粉丝列表 4.7 优化登录模块 五 Kafka消息队列 5.1 阻塞队列 5.2 Kafka入门 5.3 Spring整合Kafka 测试 5.4 发送系统通知 5.5 显示系统通知 六 搜索 6.1 Elasticsearch入门 nk社区（编写） 0 框架与环境 0-1 框架 0-2 数据库 1 基本环境 1-1 用户实体相关 1-2 基本环境配置 1-3 帖子实体与分页实现 2 登录模块 2-1 邮件功能 2-2 注册 2-3 问题 nk社区1 首页123456789101112131415161718192021222324252627用户实体帖子实体帖子mapper1 （分页）查询帖子（用户id）2 查询帖子数量关于帖子关联的用户名的问题，采用得到帖子后，再查询的方式，不在mapper中统一关联查询，因此需要提供查询用户（id)的方法静态资源 static模板文件 templatesHomeController返回帖子-用户的键值列表首页渲染 帖子列表分页功能分页实体 方法 使用page实体 处理逻辑首页 分页实现项目调试技巧f8 7 9 日志默认logbacklogback-spring.xml 2 登录模块2-1 发送邮件12345678• 邮箱设置- 启用客户端SMTP服务• Spring Email- 导入 jar 包- 邮箱参数配置- 使用 JavaMailSender 发送邮件• 模板引擎- 使用 Thymeleaf 发送 HTML 邮件 2-2 开发注册功能12345678• 访问注册页面- 点击顶部区域内的链接，打开注册页面。• 提交注册数据- 通过表单提交数据。- 服务端验证账号是否已存在、邮箱是否已注册。- 服务端发送激活邮件。• 激活注册账号- 点击邮件中的链接，访问服务端的激活服务 拆解为三次请求 1234567首页跳转至注册页 首部的复用两个工具类 生成uuid md加盐加密注册业务 判空 验证账号 验证邮箱 注册用户 激活邮件注册controller 成功后到执行成功页注册页面 注册失败后跳回还需要留存信息th:value激活注册账号（邮箱链接）三种结果--常量类 激活业务激活controller 登录模板 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279# 首页跳转至注册页 首部的复用@GetMapping(&quot;/register&quot;)public String getRegisterPage() &#123; return &quot;/site/register&quot;;&#125;th:fragment=&quot;header&quot;th:href=&quot;@&#123;/index&#125;&quot;th:replace=&quot;index::header&quot;# 两个工具类 生成uuid md加盐加密&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;// 生成随机字符串public static String generateUUID() &#123; return UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);&#125;// MD5加密// hello -&gt; abc123def456// hello + 3e4a8 -&gt; abc123def456abcpublic static String md5(String key) &#123; if (StringUtils.isBlank(key)) &#123; return null; &#125; return DigestUtils.md5DigestAsHex(key.getBytes());&#125;# 注册业务 判空 验证账号 验证邮箱 注册用户 激活邮件@Servicepublic class UserService implements CommunityConstant &#123; @Autowired private UserMapper userMapper; @Autowired private MailClient mailClient; @Autowired private TemplateEngine templateEngine; @Value(&quot;$&#123;community.path.domain&#125;&quot;) private String domain; @Value(&quot;$&#123;server.servlet.context-path&#125;&quot;) private String contextPath; public User findUserById(int id) &#123; return userMapper.selectById(id); &#125; public Map&lt;String, Object&gt; register(User user) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 空值处理 if (user == null) &#123; throw new IllegalArgumentException(&quot;参数不能为空!&quot;); &#125; if (StringUtils.isBlank(user.getUsername())) &#123; map.put(&quot;usernameMsg&quot;, &quot;账号不能为空!&quot;); return map; &#125; if (StringUtils.isBlank(user.getPassword())) &#123; map.put(&quot;passwordMsg&quot;, &quot;密码不能为空!&quot;); return map; &#125; if (StringUtils.isBlank(user.getEmail())) &#123; map.put(&quot;emailMsg&quot;, &quot;邮箱不能为空!&quot;); return map; &#125; // 验证账号 User u = userMapper.selectByName(user.getUsername()); if (u != null) &#123; map.put(&quot;usernameMsg&quot;, &quot;该账号已存在!&quot;); return map; &#125; // 验证邮箱 u = userMapper.selectByEmail(user.getEmail()); if (u != null) &#123; map.put(&quot;emailMsg&quot;, &quot;该邮箱已被注册!&quot;); return map; &#125; // 注册用户 user.setSalt(CommunityUtil.generateUUID().substring(0, 5)); user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt())); user.setType(0); user.setStatus(0); user.setActivationCode(CommunityUtil.generateUUID()); user.setHeaderUrl(String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;, new Random().nextInt(1000))); user.setCreateTime(new Date()); userMapper.insertUser(user); // 激活邮件 Context context = new Context(); context.setVariable(&quot;email&quot;, user.getEmail()); // http://localhost:8080/community/activation/101/code String url = domain + contextPath + &quot;/activation/&quot; + user.getId() + &quot;/&quot; + user.getActivationCode(); context.setVariable(&quot;url&quot;, url); String content = templateEngine.process(&quot;/mail/activation&quot;, context); mailClient.sendMail(user.getEmail(), &quot;激活账号&quot;, content); return map; &#125; public int activation(int userId, String code) &#123; User user = userMapper.selectById(userId); if (user.getStatus() == 1) &#123; return ACTIVATION_REPEAT; &#125; else if (user.getActivationCode().equals(code)) &#123; userMapper.updateStatus(userId, 1); return ACTIVATION_SUCCESS; &#125; else &#123; return ACTIVATION_FAILURE; &#125; &#125;&#125;# 注册controller 成功后到执行成功页@Controllerpublic class LoginController implements CommunityConstant &#123; @Autowired private UserService userService; @RequestMapping(path = &quot;/register&quot;, method = RequestMethod.GET) public String getRegisterPage() &#123; return &quot;/site/register&quot;; &#125; @RequestMapping(path = &quot;/login&quot;, method = RequestMethod.GET) public String getLoginPage() &#123; return &quot;/site/login&quot;; &#125; @RequestMapping(path = &quot;/register&quot;, method = RequestMethod.POST) public String register(Model model, User user) &#123; Map&lt;String, Object&gt; map = userService.register(user); if (map == null || map.isEmpty()) &#123; model.addAttribute(&quot;msg&quot;, &quot;注册成功,我们已经向您的邮箱发送了一封激活邮件,请尽快激活!&quot;); model.addAttribute(&quot;target&quot;, &quot;/index&quot;); return &quot;/site/operate-result&quot;; &#125; else &#123; model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;)); model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;)); model.addAttribute(&quot;emailMsg&quot;, map.get(&quot;emailMsg&quot;)); return &quot;/site/register&quot;; &#125; &#125; // http://localhost:8080/community/activation/101/code @RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET) public String activation(Model model, @PathVariable(&quot;userId&quot;) int userId, @PathVariable(&quot;code&quot;) String code) &#123; int result = userService.activation(userId, code); if (result == ACTIVATION_SUCCESS) &#123; model.addAttribute(&quot;msg&quot;, &quot;激活成功,您的账号已经可以正常使用了!&quot;); model.addAttribute(&quot;target&quot;, &quot;/login&quot;); &#125; else if (result == ACTIVATION_REPEAT) &#123; model.addAttribute(&quot;msg&quot;, &quot;无效操作,该账号已经激活过了!&quot;); model.addAttribute(&quot;target&quot;, &quot;/index&quot;); &#125; else &#123; model.addAttribute(&quot;msg&quot;, &quot;激活失败,您提供的激活码不正确!&quot;); model.addAttribute(&quot;target&quot;, &quot;/index&quot;); &#125; return &quot;/site/operate-result&quot;; &#125;&#125;# 注册页面 注册失败后跳回还需要留存信息th:value&lt;!-- 内容 --&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3&quot;&gt; &lt;h3 class=&quot;text-center text-info border-bottom pb-3&quot;&gt;注&amp;nbsp;&amp;nbsp;册&lt;/h3&gt; &lt;form class=&quot;mt-5&quot; method=&quot;post&quot; th:action=&quot;@&#123;/register&#125;&quot;&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;username&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;账号:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; th:class=&quot;|form-control $&#123;usernameMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;user!=null?user.username:&#x27;&#x27;&#125;&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;usernameMsg&#125;&quot;&gt; 该账号已存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; th:class=&quot;|form-control $&#123;passwordMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;user!=null?user.password:&#x27;&#x27;&#125;&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入您的密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;passwordMsg&#125;&quot;&gt; 密码长度不能小于8位! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;confirm-password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;确认密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; th:value=&quot;$&#123;user!=null?user.password:&#x27;&#x27;&#125;&quot; id=&quot;confirm-password&quot; placeholder=&quot;请再次输入密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 两次输入的密码不一致! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;email&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;邮箱:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;email&quot; th:class=&quot;|form-control $&#123;emailMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;user!=null?user.email:&#x27;&#x27;&#125;&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;请输入您的邮箱!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;emailMsg&#125;&quot;&gt; 该邮箱已注册! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即注册&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;# 激活注册账号（邮箱链接）三种结果--常量类 激活业务public interface CommunityConstant &#123; /** * 激活成功 */ int ACTIVATION_SUCCESS = 0; /** * 重复激活 */ int ACTIVATION_REPEAT = 1; /** * 激活失败 */ int ACTIVATION_FAILURE = 2;&#125;# 激活controller 登录模板&lt;!doctype html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;https://static.nowcoder.com/images/logo_87_87.png&quot;/&gt; &lt;title&gt;牛客网-激活账号&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;b th:text=&quot;$&#123;email&#125;&quot;&gt;xxx@xxx.com&lt;/b&gt;, 您好! &lt;/p&gt; &lt;p&gt; 您正在注册牛客网, 这是一封激活邮件, 请点击 &lt;a th:href=&quot;$&#123;url&#125;&quot;&gt;此链接&lt;/a&gt;, 激活您的牛客账号! &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2-3 会话管理12345678910• HTTP的基本性质- HTTP是简单的- HTTP是可扩展的- HTTP是无状态的，有会话的• Cookie- 是服务器发送到浏览器，并保存在浏览器端的一小块数据。- 浏览器下次访问该服务器时，会自动携带块该数据，将其发送给服务器。• Session- 是JavaEE的标准，用于在服务端记录客户端信息。- 数据存放在服务端更加安全，但是也会增加服务端的内存压力。 12cookie测试session测试 多服务器情况 粘性session 同步session session服务器 会话数据存储 数据库（非关系） 代码1234567891011121314151617181920212223242526272829303132333435// cookie示例@RequestMapping(path = &quot;/cookie/set&quot;, method = RequestMethod.GET)@ResponseBodypublic String setCookie(HttpServletResponse response) &#123; // 创建cookie Cookie cookie = new Cookie(&quot;code&quot;, CommunityUtil.generateUUID()); // 设置cookie生效的范围 cookie.setPath(&quot;/community/alpha&quot;); // 设置cookie的生存时间 cookie.setMaxAge(60 * 10); // 发送cookie response.addCookie(cookie); return &quot;set cookie&quot;;&#125;@RequestMapping(path = &quot;/cookie/get&quot;, method = RequestMethod.GET)@ResponseBodypublic String getCookie(@CookieValue(&quot;code&quot;) String code) &#123; System.out.println(code); return &quot;get cookie&quot;;&#125;// session示例@RequestMapping(path = &quot;/session/set&quot;, method = RequestMethod.GET)@ResponseBodypublic String setSession(HttpSession session) &#123; session.setAttribute(&quot;id&quot;, 1); session.setAttribute(&quot;name&quot;, &quot;Test&quot;); return &quot;set session&quot;;&#125;@RequestMapping(path = &quot;/session/get&quot;, method = RequestMethod.GET)@ResponseBodypublic String getSession(HttpSession session) &#123; System.out.println(session.getAttribute(&quot;id&quot;)); System.out.println(session.getAttribute(&quot;name&quot;)); return &quot;get session&quot;;&#125; 2-4 生成验证码1234Kaptcha- 导入 jar 包- 编写 Kaptcha 配置类- 生成随机字符、生成图片 生成验证码的配置类 controller login图片 js 统一路径 随机参数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# 导入 jar 包&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt;# 编写 Kaptcha 配置类@Configurationpublic class KaptchaConfig &#123; @Bean public Producer kaptchaProducer() &#123; Properties properties = new Properties(); properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;100&quot;); properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;40&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;32&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;0,0,0&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYAZ&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;); properties.setProperty(&quot;kaptcha.noise.impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;); DefaultKaptcha kaptcha = new DefaultKaptcha(); Config config = new Config(properties); kaptcha.setConfig(config); return kaptcha; &#125;&#125;# 生成随机字符、生成图片@RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET)public void getKaptcha(HttpServletResponse response, HttpSession session) &#123; // 生成验证码 String text = kaptchaProducer.createText(); BufferedImage image = kaptchaProducer.createImage(text); // 将验证码存入session session.setAttribute(&quot;kaptcha&quot;, text); // 将突图片输出给浏览器 response.setContentType(&quot;image/png&quot;); try &#123; OutputStream os = response.getOutputStream(); ImageIO.write(image, &quot;png&quot;, os); &#125; catch (IOException e) &#123; logger.error(&quot;响应验证码失败:&quot; + e.getMessage()); &#125;&#125;# 前端&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3&quot;&gt; &lt;h3 class=&quot;text-center text-info border-bottom pb-3&quot;&gt;登&amp;nbsp;&amp;nbsp;录&lt;/h3&gt; &lt;form class=&quot;mt-5&quot;&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;username&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;账号:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control is-invalid&quot; id=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 该账号不存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control is-invalid&quot; id=&quot;password&quot; placeholder=&quot;请输入您的密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 密码长度不能小于8位! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;verifycode&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;验证码:&lt;/label&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control is-invalid&quot; id=&quot;verifycode&quot; placeholder=&quot;请输入验证码!&quot;&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 验证码不正确! &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;img th:src=&quot;@&#123;/kaptcha&#125;&quot; id=&quot;kaptcha&quot; style=&quot;width:100px;height:40px;&quot; class=&quot;mr-2&quot;/&gt; &lt;a href=&quot;javascript:refresh_kaptcha();&quot; class=&quot;font-size-12 align-bottom&quot;&gt;刷新验证码&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;remember-me&quot; checked=&quot;checked&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;remember-me&quot;&gt;记住我&lt;/label&gt; &lt;a href=&quot;forget.html&quot; class=&quot;text-danger float-right&quot;&gt;忘记密码?&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;var CONTEXT_PATH = &quot;/community&quot;;&lt;script th:src=&quot;@&#123;/js/global.js&#125;&quot;&gt;&lt;/script&gt;&lt;script&gt; function refresh_kaptcha() &#123; var path = CONTEXT_PATH + &quot;/kaptcha?p=&quot; + Math.random(); $(&quot;#kaptcha&quot;).attr(&quot;src&quot;, path); &#125;&lt;/script&gt; 2-5 开发登录、退出功能123456789• 访问登录页面- 点击顶部区域内的链接，打开登录页面。• 登录- 验证账号、密码、验证码。- 成功时，生成登录凭证，发放给客户端。- 失败时，跳转回登录页。• 退出- 将登录凭证修改为失效状态。- 跳转至网站首页。 登录凭证实体登录业务（空值处理 验证账号|是否存在/是否激活 验证密码 生成登录凭证）controller（检查验证码 登录凭证超时时间设置 检查账号密码登录页 表单 请求参数（输入回显 提示文本）退出功能（凭证失效 重定向到登录页 退出链接） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155# 登录凭证public class LoginTicket &#123; private int id; private int userId; private String ticket; private int status; private Date expired;&#125;# 实体# 登录业务（空值处理 验证账号|是否存在/是否激活 验证密码 生成登录凭证）public Map&lt;String, Object&gt; login(String username, String password, int expiredSeconds) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 空值处理 if (StringUtils.isBlank(username)) &#123; map.put(&quot;usernameMsg&quot;, &quot;账号不能为空!&quot;); return map; &#125; if (StringUtils.isBlank(password)) &#123; map.put(&quot;passwordMsg&quot;, &quot;密码不能为空!&quot;); return map; &#125; // 验证账号 User user = userMapper.selectByName(username); if (user == null) &#123; map.put(&quot;usernameMsg&quot;, &quot;该账号不存在!&quot;); return map; &#125; // 验证状态 if (user.getStatus() == 0) &#123; map.put(&quot;usernameMsg&quot;, &quot;该账号未激活!&quot;); return map; &#125; // 验证密码 password = CommunityUtil.md5(password + user.getSalt()); if (!user.getPassword().equals(password)) &#123; map.put(&quot;passwordMsg&quot;, &quot;密码不正确!&quot;); return map; &#125; // 生成登录凭证 LoginTicket loginTicket = new LoginTicket(); loginTicket.setUserId(user.getId()); loginTicket.setTicket(CommunityUtil.generateUUID()); loginTicket.setStatus(0); loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000)); loginTicketMapper.insertLoginTicket(loginTicket); map.put(&quot;ticket&quot;, loginTicket.getTicket()); return map;&#125;# controller（检查验证码 登录凭证超时时间设置 检查账号密码@RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST)public String login(String username, String password, String code, boolean rememberme, Model model, HttpSession session, HttpServletResponse response) &#123; // 检查验证码 String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;); if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) &#123; model.addAttribute(&quot;codeMsg&quot;, &quot;验证码不正确!&quot;); return &quot;/site/login&quot;; &#125; // 检查账号,密码 int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS; Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds); if (map.containsKey(&quot;ticket&quot;)) &#123; Cookie cookie = new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString()); cookie.setPath(contextPath); cookie.setMaxAge(expiredSeconds); response.addCookie(cookie); return &quot;redirect:/index&quot;; &#125; else &#123; model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;)); model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;)); return &quot;/site/login&quot;; &#125;&#125;/** * 默认状态的登录凭证的超时时间 */int DEFAULT_EXPIRED_SECONDS = 3600 * 12;/** * 记住状态的登录凭证超时时间 */int REMEMBER_EXPIRED_SECONDS = 3600 * 24 * 100;# 登录页 表单 请求参数（输入回显 提示文本）&lt;!-- 内容 --&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3&quot;&gt; &lt;h3 class=&quot;text-center text-info border-bottom pb-3&quot;&gt;登&amp;nbsp;&amp;nbsp;录&lt;/h3&gt; &lt;form class=&quot;mt-5&quot; method=&quot;post&quot; th:action=&quot;@&#123;/login&#125;&quot;&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;username&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;账号:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; th:class=&quot;|form-control $&#123;usernameMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;param.username&#125;&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;usernameMsg&#125;&quot;&gt; 该账号不存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; th:class=&quot;|form-control $&#123;passwordMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;param.password&#125;&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入您的密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;passwordMsg&#125;&quot;&gt; 密码长度不能小于8位! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;verifycode&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;验证码:&lt;/label&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &lt;input type=&quot;text&quot; th:class=&quot;|form-control $&#123;codeMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; id=&quot;verifycode&quot; name=&quot;code&quot; placeholder=&quot;请输入验证码!&quot;&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;codeMsg&#125;&quot;&gt; 验证码不正确! &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;img th:src=&quot;@&#123;/kaptcha&#125;&quot; id=&quot;kaptcha&quot; style=&quot;width:100px;height:40px;&quot; class=&quot;mr-2&quot;/&gt; &lt;a href=&quot;javascript:refresh_kaptcha();&quot; class=&quot;font-size-12 align-bottom&quot;&gt;刷新验证码&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;remember-me&quot; name=&quot;rememberme&quot; th:checked=&quot;$&#123;param.rememberme&#125;&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;remember-me&quot;&gt;记住我&lt;/label&gt; &lt;a href=&quot;forget.html&quot; class=&quot;text-danger float-right&quot;&gt;忘记密码?&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;# 退出功能（凭证失效 重定向到登录页 退出链接）public void logout(String ticket) &#123; loginTicketMapper.updateStatus(ticket, 1);&#125;@RequestMapping(path = &quot;/logout&quot;, method = RequestMethod.GET)public String logout(@CookieValue(&quot;ticket&quot;) String ticket) &#123; userService.logout(ticket); return &quot;redirect:/login&quot;;&#125; 2-6 显示登录信息12345678• 拦截器示例- 定义拦截器，实现HandlerInterceptor- 配置拦截器，为它指定拦截、排除的路径• 拦截器应用- 在请求开始时查询登录用户- 在本次请求中持有用户数据- 在模板视图上显示用户数据- 在请求结束时清理用户数据 12345拦截器测试 interceptor mvc配置利用cookie获取凭证-用户实体获取cookie的工具类LoginTicketInterceptor（获取凭证 获取用户--持有用户信息的工具类 ThreadLocal）页面th:if 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# 拦截器测试 interceptor mvc配置@Componentpublic class AlphaInterceptor implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(AlphaInterceptor.class); // 在Controller之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug(&quot;preHandle: &quot; + handler.toString()); return true; &#125; // 在Controller之后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; logger.debug(&quot;postHandle: &quot; + handler.toString()); &#125; // 在TemplateEngine之后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; logger.debug(&quot;afterCompletion: &quot; + handler.toString()); &#125;&#125;@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Autowired private AlphaInterceptor alphaInterceptor; @Autowired private LoginTicketInterceptor loginTicketInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(alphaInterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;) .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;); registry.addInterceptor(loginTicketInterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); &#125;&#125;# 利用cookie获取凭证-用户实体# 获取cookie的工具类public class CookieUtil &#123; public static String getValue(HttpServletRequest request, String name) &#123; if (request == null || name == null) &#123; throw new IllegalArgumentException(&quot;参数为空!&quot;); &#125; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(name)) &#123; return cookie.getValue(); &#125; &#125; &#125; return null; &#125;&#125;# LoginTicketInterceptor（获取凭证 获取用户--持有用户信息的工具类 ThreadLocal）/** * 持有用户信息,用于代替session对象. */@Componentpublic class HostHolder &#123; private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;&gt;(); public void setUser(User user) &#123; users.set(user); &#125; public User getUser() &#123; return users.get(); &#125; public void clear() &#123; users.remove(); &#125;&#125;@Componentpublic class LoginTicketInterceptor implements HandlerInterceptor &#123; @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 从cookie中获取凭证 String ticket = CookieUtil.getValue(request, &quot;ticket&quot;); if (ticket != null) &#123; // 查询凭证 LoginTicket loginTicket = userService.findLoginTicket(ticket); // 检查凭证是否有效 if (loginTicket != null &amp;&amp; loginTicket.getStatus() == 0 &amp;&amp; loginTicket.getExpired().after(new Date())) &#123; // 根据凭证查询用户 User user = userService.findUserById(loginTicket.getUserId()); // 在本次请求中持有用户 hostHolder.setUser(user); &#125; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; User user = hostHolder.getUser(); if (user != null &amp;&amp; modelAndView != null) &#123; modelAndView.addObject(&quot;loginUser&quot;, user); &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; hostHolder.clear(); &#125;&#125;# 页面th:if&lt;!-- 头部 --&gt;&lt;header class=&quot;bg-dark sticky-top&quot; th:fragment=&quot;header&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 导航 --&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark&quot;&gt; &lt;!-- logo --&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;!-- 功能 --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt; &lt;ul class=&quot;navbar-nav mr-auto&quot;&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot;&gt; &lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/index&#125;&quot;&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot; th:if=&quot;$&#123;loginUser!=null&#125;&quot;&gt; &lt;a class=&quot;nav-link position-relative&quot; href=&quot;site/letter.html&quot;&gt;消息&lt;span class=&quot;badge badge-danger&quot;&gt;12&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot; th:if=&quot;$&#123;loginUser==null&#125;&quot;&gt; &lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/register&#125;&quot;&gt;注册&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot; th:if=&quot;$&#123;loginUser==null&#125;&quot;&gt; &lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical dropdown&quot; th:if=&quot;$&#123;loginUser!=null&#125;&quot;&gt; &lt;a class=&quot;nav-link dropdown-toggle&quot; href=&quot;#&quot; id=&quot;navbarDropdown&quot; role=&quot;button&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; &lt;img th:src=&quot;$&#123;loginUser.headerUrl&#125;&quot; class=&quot;rounded-circle&quot; style=&quot;width:30px;&quot;/&gt; &lt;/a&gt; &lt;div class=&quot;dropdown-menu&quot; aria-labelledby=&quot;navbarDropdown&quot;&gt; &lt;a class=&quot;dropdown-item text-center&quot; href=&quot;site/profile.html&quot;&gt;个人主页&lt;/a&gt; &lt;a class=&quot;dropdown-item text-center&quot; href=&quot;site/setting.html&quot;&gt;账号设置&lt;/a&gt; &lt;a class=&quot;dropdown-item text-center&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;退出登录&lt;/a&gt; &lt;div class=&quot;dropdown-divider&quot;&gt;&lt;/div&gt; &lt;span class=&quot;dropdown-item text-center text-secondary&quot; th:utext=&quot;$&#123;loginUser.username&#125;&quot;&gt;nowcoder&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 搜索 --&gt; &lt;form class=&quot;form-inline my-2 my-lg-0&quot; action=&quot;site/search.html&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;search&quot; aria-label=&quot;Search&quot; /&gt; &lt;button class=&quot;btn btn-outline-light my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/header&gt; 2-7 账号设置12345678• 上传文件- 请求：必须是POST请求- 表单：enctype=“multipart/form-data”- Spring MVC：通过 MultipartFile 处理上传文件• 开发步骤- 访问账号设置页面- 上传头像- 获取头像 1234设置页配置上传路径上传controller方法（model返回提示信息）获取头像 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# 设置页&lt;!-- 上传头像 --&gt;&lt;h6 class=&quot;text-left text-info border-bottom pb-2&quot;&gt;上传头像&lt;/h6&gt;&lt;form class=&quot;mt-5&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; th:action=&quot;@&#123;/user/upload&#125;&quot;&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;head-image&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;选择头像:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;div class=&quot;custom-file&quot;&gt; &lt;input type=&quot;file&quot; th:class=&quot;|custom-file-input $&#123;error!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; id=&quot;head-image&quot; name=&quot;headerImage&quot; lang=&quot;es&quot; required=&quot;&quot;&gt; &lt;label class=&quot;custom-file-label&quot; for=&quot;head-image&quot; data-browse=&quot;文件&quot;&gt;选择一张图片&lt;/label&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;error&#125;&quot;&gt; 该账号不存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即上传&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;# 配置上传路径community.path.domain=http://localhost:8080community.path.upload=d:/work/data/upload# 上传controller方法（model返回提示信息）@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; private static final Logger logger = LoggerFactory.getLogger(UserController.class); @Value(&quot;$&#123;community.path.upload&#125;&quot;) private String uploadPath; @Value(&quot;$&#123;community.path.domain&#125;&quot;) private String domain; @Value(&quot;$&#123;server.servlet.context-path&#125;&quot;) private String contextPath; @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET) public String getSettingPage() &#123; return &quot;/site/setting&quot;; &#125; @RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST) public String uploadHeader(MultipartFile headerImage, Model model) &#123; if (headerImage == null) &#123; model.addAttribute(&quot;error&quot;, &quot;您还没有选择图片!&quot;); return &quot;/site/setting&quot;; &#125; String fileName = headerImage.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); if (StringUtils.isBlank(suffix)) &#123; model.addAttribute(&quot;error&quot;, &quot;文件的格式不正确!&quot;); return &quot;/site/setting&quot;; &#125; // 生成随机文件名 fileName = CommunityUtil.generateUUID() + suffix; // 确定文件存放的路径 File dest = new File(uploadPath + &quot;/&quot; + fileName); try &#123; // 存储文件 headerImage.transferTo(dest); &#125; catch (IOException e) &#123; logger.error(&quot;上传文件失败: &quot; + e.getMessage()); throw new RuntimeException(&quot;上传文件失败,服务器发生异常!&quot;, e); &#125; // 更新当前用户的头像的路径(web访问路径) // http://localhost:8080/community/user/header/xxx.png User user = hostHolder.getUser(); String headerUrl = domain + contextPath + &quot;/user/header/&quot; + fileName; userService.updateHeader(user.getId(), headerUrl); return &quot;redirect:/index&quot;; &#125; @RequestMapping(path = &quot;/header/&#123;fileName&#125;&quot;, method = RequestMethod.GET) public void getHeader(@PathVariable(&quot;fileName&quot;) String fileName, HttpServletResponse response) &#123; // 服务器存放路径 fileName = uploadPath + &quot;/&quot; + fileName; // 文件后缀 String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); // 响应图片 response.setContentType(&quot;image/&quot; + suffix); try ( FileInputStream fis = new FileInputStream(fileName); OutputStream os = response.getOutputStream(); ) &#123; byte[] buffer = new byte[1024]; int b = 0; while ((b = fis.read(buffer)) != -1) &#123; os.write(buffer, 0, b); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;读取头像失败: &quot; + e.getMessage()); &#125; &#125;&#125;# 获取头像 2-8 检查登录状态123456789• 使用拦截器- 在方法前标注自定义注解- 拦截所有请求，只处理带有该注解的方法• 自定义注解- 常用的元注解：@Target、@Retention、@Document、@Inherited- 如何读取注解：Method.getDeclaredAnnotations​()Method.getAnnotation​(Class&lt;T&gt; annotationClass) 12自定义注解拦截器 代码1234567891011121314151617181920212223242526272829# 自定义注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LoginRequired &#123;&#125;# 拦截器@Componentpublic class LoginRequiredInterceptor implements HandlerInterceptor &#123; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (handler instanceof HandlerMethod) &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); LoginRequired loginRequired = method.getAnnotation(LoginRequired.class); if (loginRequired != null &amp;&amp; hostHolder.getUser() == null) &#123; response.sendRedirect(request.getContextPath() + &quot;/login&quot;); return false; &#125; &#125; return true; &#125;&#125;registry.addInterceptor(loginRequiredInterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); 3 核心功能3-1 过滤敏感词12345678• 前缀树- 名称：Trie、字典树、查找树- 特点：查找效率高，消耗内存大- 应用：字符串检索、词频统计、字符串排序等• 敏感词过滤器- 定义前缀树- 根据敏感词，初始化前缀树- 编写过滤敏感词的方法 12345678910111213141516如果使用jdk的字符串替换api 性能太差 用自己实现的前缀树进行过滤# 思想讲解1 定义敏感词 abc,bf,be 2 由敏感词构造前缀树（根节点空 标记）3 输入字符串 三个指针（两个指针指定一个单词，一个指针扫前缀树）4 示例过程 20min（以字符为单位，任意语言都可以）# 实现1 用文本记录敏感词2 工具类（敏感词过滤器）2.1 前缀树节点类（关键词结束标识 子节点--字符到节点的map 添加子节点方法 获取子节点方法2.2 初始化前缀树 根节点-替换符 init（字节流--字符缓冲流 遍历每个敏感词加入到前缀树）添加方法（传入敏感词 遍历每个字符）2.3 过滤方法（传入文本 判空 三个指针 判断是否为普通字符 逻辑）3 测试 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152@Componentpublic class SensitiveFilter &#123; private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class); // 替换符 private static final String REPLACEMENT = &quot;***&quot;; // 根节点 private TrieNode rootNode = new TrieNode(); @PostConstruct public void init() &#123; try ( InputStream is = this.getClass().getClassLoader().getResourceAsStream(&quot;sensitive-words.txt&quot;); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); ) &#123; String keyword; while ((keyword = reader.readLine()) != null) &#123; // 添加到前缀树 this.addKeyword(keyword); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;加载敏感词文件失败: &quot; + e.getMessage()); &#125; &#125; // 将一个敏感词添加到前缀树中 private void addKeyword(String keyword) &#123; TrieNode tempNode = rootNode; for (int i = 0; i &lt; keyword.length(); i++) &#123; char c = keyword.charAt(i); TrieNode subNode = tempNode.getSubNode(c); if (subNode == null) &#123; // 初始化子节点 subNode = new TrieNode(); tempNode.addSubNode(c, subNode); &#125; // 指向子节点,进入下一轮循环 tempNode = subNode; // 设置结束标识 if (i == keyword.length() - 1) &#123; tempNode.setKeywordEnd(true); &#125; &#125; &#125; /** * 过滤敏感词 * * @param text 待过滤的文本 * @return 过滤后的文本 */ public String filter(String text) &#123; if (StringUtils.isBlank(text)) &#123; return null; &#125; // 指针1 TrieNode tempNode = rootNode; // 指针2 int begin = 0; // 指针3 int position = 0; // 结果 StringBuilder sb = new StringBuilder(); while (position &lt; text.length()) &#123; char c = text.charAt(position); // 跳过符号 if (isSymbol(c)) &#123; // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步 if (tempNode == rootNode) &#123; sb.append(c); begin++; &#125; // 无论符号在开头或中间,指针3都向下走一步 position++; continue; &#125; // 检查下级节点 tempNode = tempNode.getSubNode(c); if (tempNode == null) &#123; // 以begin开头的字符串不是敏感词 sb.append(text.charAt(begin)); // 进入下一个位置 position = ++begin; // 重新指向根节点 tempNode = rootNode; &#125; else if (tempNode.isKeywordEnd()) &#123; // 发现敏感词,将begin~position字符串替换掉 sb.append(REPLACEMENT); // 进入下一个位置 begin = ++position; // 重新指向根节点 tempNode = rootNode; &#125; else &#123; // 检查下一个字符 position++; &#125; &#125; // 将最后一批字符计入结果 sb.append(text.substring(begin)); return sb.toString(); &#125; // 判断是否为符号 private boolean isSymbol(Character c) &#123; // 0x2E80~0x9FFF 是东亚文字范围 return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c &gt; 0x9FFF); &#125; // 前缀树 private class TrieNode &#123; // 关键词结束标识 private boolean isKeywordEnd = false; // 子节点(key是下级字符,value是下级节点) private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); public boolean isKeywordEnd() &#123; return isKeywordEnd; &#125; public void setKeywordEnd(boolean keywordEnd) &#123; isKeywordEnd = keywordEnd; &#125; // 添加子节点 public void addSubNode(Character c, TrieNode node) &#123; subNodes.put(c, node); &#125; // 获取子节点 public TrieNode getSubNode(Character c) &#123; return subNodes.get(c); &#125; &#125;&#125; 3-2 发布帖子12345678910• AJAX- Asynchronous JavaScript and XML- 异步的JavaScript与XML，不是一门新技术，只是一个新的术语。- 使用AJAX，网页能够将增量更新呈现在页面上，而不需要刷新整个页面。- 虽然X代表XML，但目前JSON的使用比XML更加普遍。- https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX• 示例- 使用jQuery发送AJAX请求。• 实践- 采用AJAX请求，实现发布帖子的功能。 123456789101112131415161718192021# json处理--ajax1 引入 fastjson2 在CommunityUtil中编写json对象转换为字符串的方法（重载）3 AlphaController ajax示例 static/html/ajax-demo.html# 实现发布帖子功能1 discusspostmapper 增加帖子方法 xml中加上一个insert语句 2 帖子业务中 addDiscussPost2.1 判空2.2 对标题、内容进行转义处理（处理含有Html标签的内容）2.3 对标题、内容进行过滤敏感词处理 3 帖子Controller问题 为什么hostHolder能取代session的作用 作为存储当前用户的对象3.1 检查用户3.2 新增帖子4 页面4.1 index 弹出框 70多行 对发布按钮进行登录用户判定4.2 static/js/index.js publish方法4.2.1 弹出框隐藏4.2.2 获取标题和内容4.2.3 发布异步请求（显示返回消息 提示 刷新页面） 3-3 帖子详情123456789101112131415161718192021• DiscussPostMapper根据id查询的方法 mapper• DiscussPostServicefindxxx 根据id查询• DiscussPostControllergetxxx 根据id查询 id参数 model返回携带信息注意，一个帖子需要关联用户信息，此处如何处理？（1）效率更好的方法是 sql中关联查询 效率高 但可能会造成业务冗余（2）在controller中单独再查询 效率低 后续可用缓存优化根据帖子的用户id查到用户，也需返回此处先不处理帖子的评论回复相关• index.html- 在帖子标题上增加访问详情页面的链接在帖子列表的超链接上进行修改• discuss-detail.html- 处理静态资源的访问路径- 复用index.html的header区域- 显示标题、作者、发布时间、帖子正文等内容帖子详情 3-4 事务管理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364回顾• 什么是事务- 事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行。• 事务的特性（ACID）- 原子性（Atomicity）：事务是应用中不可再分的最小执行体。- 一致性（Consistency）：事务执行的结果，须使数据从一个一致性状态，变为另一个一致性状态。- 隔离性（Isolation）：各个事务的执行互不干扰，任何事务的内部操作对其他的事务都是隔离的。- 持久性（Durability）：事务一旦提交，对数据所做的任何改变都要记录到永久存储器中。事务的隔离性• 常见的并发异常- 第一类丢失更新、第二类丢失更新。- 脏读、不可重复读、幻读。• 常见的隔离级别- Read Uncommitted：读取未提交的数据。- Read Committed：读取已提交的数据。- Repeatable Read：可重复读。- Serializable：串行化。第一类丢失更新某一个事务的回滚，导致另外一个事务已更新的数据丢失了。第二类丢失更新某一个事务的提交，导致另外一个事务已更新的数据丢失了。脏读某一个事务，读取了另外一个事务未提交的数据。不可重复读某一个事务，对同一个数据前后读取的结果不一致。幻读某一个事务，对同一个表前后查询到的行数不一致。事务隔离级别隔离级别 第一类丢失更新 脏读 第二类丢失更新 不可重复读 幻读Read Uncommitted Y Y Y Y YRead Committed N N Y Y YRepeatable Read N N N N YSerializable N N N N N实现机制• 悲观锁（数据库）- 共享锁（S锁）事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。- 排他锁（X锁）事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。• 乐观锁（自定义）- 版本号、时间戳等在更新数据前，检查版本号是否发生变化。若变化则取消本次更新，否则就更新数据（版本号+1）。Spring事务管理• 声明式事务- 通过XML配置，声明某方法的事务特征。- 通过注解，声明某方法的事务特征。• 编程式事务- 通过 TransactionTemplate 管理事务，并通过它执行数据库的操作。 123456789多线程环境下，多个环境下同时访问同一数据隔离级别一般选中间两种# Spring事务测试Alpha业务中 save1 新增用户 新增帖子 注解：隔离机制 传播机制（业务方法相互调用）事务测试类 完整回滚编程式事务 save2 3-5 显示评论123456789• 数据层- 根据实体查询一页评论数据。- 根据实体查询评论的数量。• 业务层- 处理查询评论的业务。处理查询评论数量的业务。• 表现层- 显示帖子详情数据时，同时显示该帖子所有的评论数据。 1234567891011121314151617181920212218# 评论表可以对帖子评论 可以对评论评论1 设计一个entity_type 对应评论的对象 entity_id target_id是在回复某个回复时要指明针对的对象# 实体类 Mapper1 实体类2 方法：根据评论的对象查询评论、数量（分页辅助） 3 xml # 业务 控制器1 业务 两个方法2 控制器 getDiscussPost 获取评论分页信息+ 每个帖子有一个字段评论数量 实体类型 + 对每个评论，需要和用户关联 再逐一查询 和index帖子列表类似+ 评论的评论（回复）查所有 回复列表 对其也要设置一个Vo列表 比较特殊的是有一个指向性，回复的目标，普通的回复即回复评论target_id=0，特殊的是回复回复的回复，那么需要一个目标用户，vo里还需加一个键值对+ 帖子有评论数量字段 但评论的回复数量就需要单独查了# 页面1 index.html 帖子列表 回帖数2 帖子详情页 内容--回帖部分 回帖数量-回帖列表 基本--回复列表 特殊处理目标用户--回复回复的回复的情况 id3 复用分页 3-6 添加评论123456789• 数据层- 增加评论数据。- 修改帖子的评论数量。• 业务层- 处理添加评论的业务：先增加评论、再更新帖子的评论数量。• 表现层- 处理添加评论数据的请求。- 设置添加评论的表单 123456789101112131415191 comment mapper xml insert方法2 帖子 mapper xml 更新评论数量方法 帖子 service 更新评论数量方法3 评论 业务 增加评论方法（包含事务管理）3.1 参数判空3.2 评论 转义 敏感词过滤3.3 存入数据库3.4 更新评论数量（需要判断是帖子的评论，即需要判断entity_type，然后查到对应的帖子实体，调用帖子的更新评论数量业务方法进行更新）4 评论 controller 新增方法5 页面评论详情页5.1 回帖输入部分（表单 method action 文本域 隐藏域/两个entity_xxx）5.2 回复输入框（和5.1同 区别是针对的对象是评论/回复 还需要携带targetId 提示回复给xxx） 3-7 私信列表1234567• 私信列表- 查询当前用户的会话列表，每个会话只显示一条最新的私信。- 支持分页显示。• 私信详情- 查询某个会话所包含的私信。- 支持分页显示。 123456789101112131415161718192021222324252627282920# 表 messagefrom_id to_id 会话id（规则，小id_大id）# 实现1 Message实体2 MessageMapper（5个方法）xml（1）查询用户会话列表（分页）（2）会话数量（3）查询某个会话包含的私信列表（4）查询某个会话包含的私信数量（5）查询未读的私信的数量xml1/查询时status=2表删除 from_id=1表系统通知3 Mapper测试4 业务message 55 controller 私信列表 私信详情 注意逻辑6 页面6.1 index.html 消息链接6.2 letter.html引入css js 首部选项卡部分（链接 未读消息）私信列表-------------letter.html 详情链接6.3 私信详情页面目标用户私信列表返回和js方法 3-8 发送私信123456• 发送私信- 采用异步的方式发送私信。- 发送成功后刷新私信列表。• 设置已读- 访问私信详情时，将显示的私信设置为已读状态。 1234567891011121321# 两个地方可以发起私信# 进入私信详情，修改私信状态# 实现1 mapper 新增消息 修改消息状态2 业务 需要过滤 add read3 controller 异步send 用户业务补充一个根据用户名查询用户的方法 修改状态3.1 根据用户名查到发送的用户对象3.2 构造私信对象 from to 会话4 页面4.1 letter.js里send_letter方法4.2 私信详情页处理 3-9 统一处理异常12345678910• @ControllerAdvice- 用于修饰类，表示该类是Controller的全局配置类。- 在此类中，可以对Controller进行如下三种全局配置：异常处理方案、绑定数据方案、绑定参数方案。• @ExceptionHandler- 用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。• @ModelAttribute- 用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。• @DataBinder- 用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。 1231 错误页面模板 templates/error 自动跳转2 HomeController/getErrorPage3 异常处理类 区分处理异步请求和普通请求 3-10 统一处理日志（针对业务组件）12345678910111213141516171819202122AOP的概念• Aspect Oriented Programing，即面向方面（切面）编程。• AOP是一种编程思想，是对OOP的补充，可以进一步提高编程的效率。AOP的实现• AspectJ- AspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法。- AspectJ在编译期织入代码，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。• Spring AOP- Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器。- Spring AOP在运行时通过代理的方式织入代码，只支持方法类型的连接点。- Spring支持对AspectJ的集成。Spring AOP• JDK动态代理- Java提供的动态代理技术，可以在运行时创建接口的代理实例。- Spring AOP默认采用此种方式，在接口的代理实例中织入代码。• CGLib动态代理- 采用底层的字节码技术，在运行时创建子类代理实例。- 当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码。 1234567拦截器等和上述方法是针对controller的对于业务组件来说，不应该把记录日志的代码在每个地方都明写出来（硬编码）目标对象 joinpoint 切面组件两个类 四 Redis缓存4.1 Redis入门12345• Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。• Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人。同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性。• Redis典型的应用场景包括：缓存、排行榜、计数器、社交网络、消息队列等。 12345678910111213141516171819202122232425262728293031323334353637381 快照存储 完全存储 不能实时2 日志存储AOF 实时命令 追加3 主要是 数据结构--对应命令--------常用命令select nflushdb&gt; stringset test:count 1get test:countincr test:countdecr test:counthset test:user id 1hset test:user username zshget test:user idlpush test:ids 101 102 103 列表左进右出 索引左到右递增llen test:idslindex test:ids 0lindex test:ids 2lrange test:ids 0 2rpop test:idssadd test:teachers aaa bbb cc dd eeescard test:teachersspop test:teacherssmembers test:teacherszadd test:students 10 aaa 20 bbb 30 ccc 40 dddzcard test:studentszscore test:students ccczrank test:studentszrange test:students 0 2keys *keys test*type test:userexists keydel key 4.2 spring整合redis1234567891011• 引入依赖- spring-boot-starter-data-redis• 配置Redis- 配置数据库参数- 编写配置类，构造RedisTemplate• 访问Redis- redisTemplate.opsForValue()- redisTemplate.opsForHash()- redisTemplate.opsForList()- redisTemplate.opsForSet()- redisTemplate.opsForZSet() 123456724RedisTemplate默认的key是object类型 用的不方便 需要重新配置1 依赖不写版本 默认用的父pom中规定的版本2 配置：数据库 主机 端口配置类：配置RedisTemplate（返回泛型 连接工厂 设置key 普通value hash的key value的序列化方式 生效）3 测试方法 4.3 点赞（获取赞信息）12345678• 点赞- 支持对帖子、评论点赞。- 第1次点赞，第2次取消点赞。• 首页点赞数量- 统计帖子的点赞数量。• 详情页点赞数量- 统计点赞数量。- 显示点赞状态。 12345678910111213141516171819202122# 说明点赞可能同时很多人进行 存到内存里提升性能两处支持点赞 帖子 评论存到redis中 数据访问层就省去了 # 实现 1 工具类 RedisKeyUtil 获取key 2 点赞业务 likeservice 点赞方法 查询某实体点赞的数量 查询某人对某实体的点赞状态 3 表现层 异步请求 likecontroller 4 页面 4.1 discuss-detail 1赞（帖子） 80多行 2赞（评论） 100多行 3赞（回复）160多行 此处是点赞操作 请求的是likecontroller 4.2 创建一个discuss.js like方法 ---------------- 1 HomeController 补充逻辑 返回帖子的赞 2 修改首页 赞相关 3 帖子详情页面 帖子Controller 补充点赞相关的信息（帖子 评论 回复） 4 详情页面 获取赞的信息 三处 4.4 我收到的赞12345• 重构点赞功能- 以用户为key，记录点赞数量- increment(key)，decrement(key)• 开发个人主页- 以用户为key，查询点赞数量 1234567891011121314151626# 实现1 在RedisKeyUtil中增加一个方法 以用户名为键 统计其获赞数量2 在点赞的业务方法中 修改实体赞的数量的同时，也需要修改用户的赞的数量，涉及到事务，redis需要使用编程式事务 multi-exec3 点赞业务 查询有个用户获赞的数量4 likecontroller 参数5 帖子详情页 三处 需要对请求调用处修改 补充参数6 discuss.js 修改方法--------------------# 个人主页不仅查看自己的，而且可以查看别人的 传入userId1 UserControllergetProfilePage(userId) （用户 点赞数量）2 index.html 个人主页 43行 帖子列表-用户头像-超链接-1223 profile.html 4.5 关注、取消关注123456• 需求- 开发关注、取消关注功能。- 统计用户的关注数、粉丝数。• 关键- 若A关注了B，则A是B的Follower（粉丝），B是A的Followee（目标）。- 关注的目标可以是用户、帖子、题目等，在实现时将这些目标抽象为实体。 1234567891011121314151617181920212223242526272829# 说明A和B关注目标--用户帖子--实体存到redis里 所以还是从key开始# 实现1 RedisKeyUtil 两个键 followee 关注的目标集合 follower 关注者集合关注的实体 zsets 实体id 由关注时间为分数useid-实体类型 为键某个实体拥有的粉丝 zset2 FollowService&gt; 关注方法（用户id 实体类型 实体id）编程式事务（要操作两个zset）&gt; 取关方法移除3 FollowController 异步请求关注 取关3 profile.html 关注取关--profile.js 发送异步请求profile.html 隐藏框携带用户id-----------还需处理关注数量的回显 和 改变关注状态1 service中 方法：查询关注的实体的数量（目标）zcard查询实体的粉丝的数量 查询当前用户是否已关注该实体2 修改usercontroller中的个人主页的方法 返回关注相关（关注数量 粉丝数量 是否已关注）3 页面 profile.html 关注操作还需处理非自己时才显示 关注/取关按钮的样式还需动态拼接 4.6 关注列表、粉丝列表123456• 业务层- 查询某个用户关注的人，支持分页。- 查询某个用户的粉丝，支持分页。• 表现层- 处理“查询关注的人”、“查询粉丝”请求。- 编写“查询关注的人”、“查询粉丝”模板。 123456789101112131428# 实现1 Follow业务查询某用户关注的人（倒序 分页--关注的id列表 需要再进行遍历 根据id查到对应实体和分数/关注时间）查询某用户的粉丝2 Controller 分页查询关注 followee查询粉丝 follower为什么controller里还需要判断一遍是不是已关注？粉丝列表可能还需要该信息 但关注列表里不都是已关注吗解答：查看的是别人的关注列表时，不一定是已关注的3 profile.html 链接 关注 粉丝followee.html 标签连接 返回 关注列表（头像 用户主页链接 关注时间 分页 关注他--按钮样式--非自己--字）follower.html 类似 4.7 优化登录模块12345678• 使用Redis存储验证码- 验证码需要频繁的访问与刷新，对性能要求较高。- 验证码不需永久保存，通常在很短的时间后就会失效。- 分布式部署时，存在Session共享的问题。• 使用Redis存储登录凭证- 处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。• 使用Redis缓存用户信息- 处理每次请求时，都要根据凭证查询用户信息，访问的频率非常高。 12345678910111213141516171819202122232425262728293031323334# 说明1 验证码先前存在session里 redis可解决共享问题 设置过期时间2 登录凭证 先前每次都要查用户凭证3 缓存用户信息# 验证码1 RedisKeyUtilkaptcha获取验证码的方法2 重构LoginController中的getKaptcha存入session-&gt;存入redis-&gt;键规定为“归属”，一个临时字符串，存入cookie，设置其过期时间登录login方法取验证码：设置一个参数从cookie中取值（之前存的时候生成的随机字符串-&gt;取到之后到redis中取验证码# 登录凭证1 RedisKeyUtil键和方法（传入ticket）后续可以用redis存凭证代替之前的登录凭证表2 设置原来的登录凭证Mapper为@Deprecated 不推荐使用3 三处重构3.1 UserService 登录处 修改为将登录凭证对象序列化后存入redis 3.2 登出时，将登录凭证取出，修改状态，再存3.3 查询凭证 到redis里查# 缓存用户信息1 RedisKeyUtil2 重构UserService中的findUserById方法+ 查的时候优先从缓存查+ 取不到时初始化+ 数据变更时清楚缓存数据三个方法重写findUserById 调用上面的方法修改User的地方 + 激活的时候修改了用户状态+ 更新头像 五 Kafka消息队列Kafka性能最好的消息队列系统通知 日志 性能问题 5.1 阻塞队列1234567891011121314151617181920• BlockingQueue- 解决线程通信的问题。- 阻塞方法：put、take。• 生产者消费者模式- 生产者：产生数据的线程。- 消费者：使用数据的线程。• 实现类- ArrayBlockingQueue- LinkedBlockingQueue- PriorityBlockingQueue、SynchronousQueue、DelayQueue等。```````markdown30阻塞队列：一组接口，解决线程通信的问题线程1put 生产者 线程2take 消费者 阻塞队列--缓冲区域 线程阻塞不占用CPU资源实现类# 测试BlockingQueueTests生产者线程 消费者线程 缓冲区 5.2 Kafka入门123456789• Kafka简介- Kafka是一个分布式的流媒体平台。- 应用：消息系统、日志收集、用户行为追踪、流式处理。• Kafka特点- 高吞吐量、消息持久化、高可靠性、高扩展性。• Kafka术语- Broker、Zookeeper- Topic、Partition、Offset- Leader Replica 、Follower Replica 1234567891011121314151617181920212223242526272829303132# 简介分布式流媒体平台 消息 日志 特点：高吞吐量消息持久化（存储海量数据的前提）# 术语消息队列两种实现方式：点对点 发布-订阅方式（kafka采用）服务器Brokerzookeeper管理集群Topic主题（存放消息的位置）Partition 对主题的分区Offset 消息在分区内存放的索引Replica 副本 每个分区会有多个副本 Leader响应 Follower# 安装官网下载 解压缩配置 config/zookeeper.properties datadir config/server.properties logdir启动 bin/windows先启动zookeeperbin\\windows\\zookeeper-server-start.bat config\\zookeeper.properties再启动kafkabin\\windows\\kafka-server-start.bat config\\server.properties使用kafka的命令工具+ 创建主题 kafka-topics.bat --create --bootstrap-server localhost:9092（默认端口）--replication-factor 1（1个副本）--partitions 1 --topic test+ 列举所有主题 kafka-topics.bat --list --bootstrap-server localhost:9092+ 生产者发消息 kafka-console-produce.bat --broker-list localhost:9092 --topic test 指定服务器和主题 一个回车一个消息+ 消费者查看 kafka-console-consumer.bat --broker-list localhost:9092 --topic test --from-beginning 从头开始读消息 5.3 Spring整合Kafka12345678910• 引入依赖- spring-kafka• 配置Kafka- 配置server、consumer• 访问Kafka- 生产者kafkaTemplate.send(topic, data);- 消费者@KafkaListener(topics = &#123;&quot;test&quot;&#125;)public void handleMessage(ConsumerRecord record) &#123;&#125; 123依赖配置测试类 生产者 消费者 测试在windows上测试不要使用最新版的kafka 配置路径用/或\\参考 https://blog.csdn.net/yinianxx/article/details/106283443https://stackoverflow.com/questions/67317088/kafka-error-failed-to-write-meta-properties-due-to-kafka-server-brokermetadat 5.4 发送系统通知12345678• 触发事件- 评论后，发布通知- 点赞后，发布通知- 关注后，发布通知• 处理事件- 封装事件对象- 开发事件的生产者- 开发事件的消费者 1234567891011121314151617181920212223242526272829303132333435# 说明发布通知非常频繁 为了保证性能 使用消息队列定义三种主题 异步技术：kafka 业务：事件驱动1 封装事件对象# 实现1 实体 Event+ 属性 topic 用户id 实体类型id 实体所属的用户id 额外数据集data+ getset set返回 setData2 event包2.1 EventProducer将消息发到指定主题2.2 EventConsumer一个方法处理三种主题定义三个常量步骤：判空 获取event数据 构造message（from_id=1系统常量 to_id data存入content 通知对象区分处理）生产者生产3 controller3.1 评论 addComment（触发评论事件 补充一个根据id查commentid的方法（mapper service）3.2 点赞 likeController 在触发点赞事件时才进行（取消不通知） 需要获取帖子id来跳转3.2 关注 follow方法 触发关注事件（当前只有关注用户功能） 4 页面处理4.1 帖子详情 点赞请求处多一个帖子id参数（三处）discuss.js方法补充参数5 注意kafka windows客户端容易崩溃 一般linux下比较稳定6 调试由于消费者service没有请求 导致统一日志切面产生空指针异常ServiceLogAspect 5.5 显示系统通知123456• 通知列表- 显示评论、点赞、关注三种类型的通知• 通知详情- 分页显示某一类主题所包含的通知• 未读消息- 在页面头部显示所有的未读消息数量 1234567891011121314151617181933# 列表实现1 MessageMapper查询某个主题下最新的通知（用户id，主题)查询某个主题所包含的通知数量查询未读的通知数量2 service三个方法getNoticeList 三类通知 letterUnreadCount&amp;noticeUnreadCount 3 页面 letter.html 选项-系统通知notice.html # 详情实现1 MessageMapper查询某个主题包含的通知列表 用户id 主题 分页2 Service3 controller4 notice详情5 Message拦截器 每个请求都要显示未读消息的数量 需要加入mvc config 12后端的四个文件+letter notice notice详情 index消息处修改 拦截器+mvc配置注意私信+通知是必须查到返回才修改状态 分页的话后面的没查状态改不了的 六 搜索6.1 Elasticsearch入门12345678• Elasticsearch简介- 一个分布式的、Restful风格的搜索引擎。- 支持对各种类型的数据的检索。- 搜索速度快，可以提供实时的搜索服务。- 便于水平扩展，每秒可以处理PB级海量数据。• Elasticsearch术语- 索引、类型、文档、字段。- 集群、节点、分片、副本。 1 nk社区（编写） 2021.9.22开始做这个社区项目，后面几天就以此为主要任务，做完为止。一个典型的crud的单体应用。 0 框架与环境0-1 框架装载beanspringmvc注解 0-2 数据库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `password` varchar(50) DEFAULT NULL, `salt` varchar(50) DEFAULT NULL, `email` varchar(100) DEFAULT NULL, `type` int(11) DEFAULT NULL COMMENT &#x27;0-普通用户; 1-超级管理员; 2-版主;&#x27;, `status` int(11) DEFAULT NULL COMMENT &#x27;0-未激活; 1-已激活;&#x27;, `activation_code` varchar(100) DEFAULT NULL, `header_url` varchar(200) DEFAULT NULL, `create_time` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_username` (`username`(20)), KEY `index_email` (`email`(20))) ENGINE=InnoDB AUTO_INCREMENT=101 DEFAULT CHARSET=utf8;CREATE TABLE `discuss_post` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` varchar(45) DEFAULT NULL, `title` varchar(100) DEFAULT NULL, `content` text, `type` int(11) DEFAULT NULL COMMENT &#x27;0-普通; 1-置顶;&#x27;, `status` int(11) DEFAULT NULL COMMENT &#x27;0-正常; 1-精华; 2-拉黑;&#x27;, `create_time` timestamp NULL DEFAULT NULL, `comment_count` int(11) DEFAULT NULL, `score` double DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_user_id` (`user_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `message` ( `id` int(11) NOT NULL AUTO_INCREMENT, `from_id` int(11) DEFAULT NULL, `to_id` int(11) DEFAULT NULL, `conversation_id` varchar(45) NOT NULL, `content` text, `status` int(11) DEFAULT NULL COMMENT &#x27;0-未读;1-已读;2-删除;&#x27;, `create_time` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_from_id` (`from_id`), KEY `index_to_id` (`to_id`), KEY `index_conversation_id` (`conversation_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `comment` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) DEFAULT NULL, `entity_type` int(11) DEFAULT NULL, `entity_id` int(11) DEFAULT NULL, `target_id` int(11) DEFAULT NULL, `content` text, `status` int(11) DEFAULT NULL, `create_time` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_user_id` (`user_id`) /*!80000 INVISIBLE */, KEY `index_entity_id` (`entity_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `login_ticket` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL, `ticket` varchar(45) NOT NULL, `status` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;0-有效; 1-无效;&#x27;, `expired` timestamp NOT NULL, PRIMARY KEY (`id`), KEY `index_ticket` (`ticket`(20))) ENGINE=InnoDB DEFAULT CHARSET=utf8; 12345678UserMapper selectById selectByName selectByEmail insertUser updateStatus updateHeader updatePassword 1 基本环境1-1 用户实体相关先看着敲一遍，然后自己写一遍，再对照，在此前先熟悉下数据库 123456789101112131415create table `user` ( `id` int(11) not null auto_increment, `username` varchar(50) default null, `password` varchar(50) default null, `salt` varchar(50) default null, `email` varchar(100) default null, `type` int(11) default null, `status` int(11) default null, `activation_code` varchar(100) default null, `header_url` varchar(200) default null, `create_time` timestamp null default null, primary key(`id`), key `index_username`(`username`(20)), key `index_email`(`email`(20))) engine = innodb auto_increment=101 default charset=utf8; 编写测试完用户实体的总结 12345678流程依赖：数据库驱动+mybatis配置：数据源 连接池配置实体mapper 测试crud注意测试，用到容器中的bean 须用@SpringBootTest 1-2 基本环境配置 原始网页素材已经没有了，初始是配置好分页相关的 thymeleaf语法 https://fanlychie.github.io/post/thymeleaf.html 日志默认 logback-spring.xml 1-3 帖子实体与分页实现帖子实体 mapper分页实体 thymeleaf 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 帖子列表 --&gt;&lt;ul class=&quot;list-unstyled&quot;&gt; &lt;li class=&quot;media pb-3 pt-3 mb-3 border-bottom&quot; th:each=&quot;map:$&#123;discussPosts&#125;&quot;&gt; &lt;a href=&quot;site/profile.html&quot;&gt; &lt;img th:src=&quot;$&#123;map.user.headerUrl&#125;&quot; class=&quot;mr-4 rounded-circle&quot; alt=&quot;用户头像&quot; style=&quot;width:50px;height:50px;&quot;&gt; &lt;/a&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h6 class=&quot;mt-0 mb-3&quot;&gt; &lt;a href=&quot;#&quot; th:utext=&quot;$&#123;map.post.title&#125;&quot;&gt;备战春招，面试刷题跟他复习，一个月全搞定！&lt;/a&gt; &lt;span class=&quot;badge badge-secondary bg-primary&quot; th:if=&quot;$&#123;map.post.type==1&#125;&quot;&gt;置顶&lt;/span&gt; &lt;span class=&quot;badge badge-secondary bg-danger&quot; th:if=&quot;$&#123;map.post.status==1&#125;&quot;&gt;精华&lt;/span&gt; &lt;/h6&gt; &lt;div class=&quot;text-muted font-size-12&quot;&gt; &lt;u class=&quot;mr-3&quot; th:utext=&quot;$&#123;map.user.username&#125;&quot;&gt;寒江雪&lt;/u&gt; 发布于 &lt;b th:text=&quot;$&#123;#dates.format(map.post.createTime,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;2019-04-15 15:32:18&lt;/b&gt; &lt;ul class=&quot;d-inline float-right&quot;&gt; &lt;li class=&quot;d-inline ml-2&quot;&gt;赞 11&lt;/li&gt; &lt;li class=&quot;d-inline ml-2&quot;&gt;|&lt;/li&gt; &lt;li class=&quot;d-inline ml-2&quot;&gt;回帖 7&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 分页 --&gt;&lt;nav class=&quot;mt-5&quot; th:if=&quot;$&#123;page.rows&gt;0&#125;&quot;&gt; &lt;ul class=&quot;pagination justify-content-center&quot;&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=1)&#125;&quot;&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;|page-item $&#123;page.current==1?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current-1&#125;)&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li th:class=&quot;|page-item $&#123;i==page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;|&quot; th:each=&quot;i:$&#123;#numbers.sequence(page.from,page.to)&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;i&#125;)&#125;&quot; th:text=&quot;$&#123;i&#125;&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;|page-item $&#123;page.current==page.total?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current+1&#125;)&#125;&quot;&gt;下一页&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.total&#125;)&#125;&quot;&gt;末页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 12345涉及到对象及运算的都用$&#123;&#125;th:href=@&#123;$&#123;&#125;()&#125;th:class=&quot;||&quot;th:each=&quot;map:$&#123;&#125;&quot;th:text=&quot;&quot; 分页测试报错 There is no getter for property named ‘userId’ in ‘class java.lang.Integer’https://blog.csdn.net/qq_30604989/article/details/81297400 2 登录模块2-1 邮件功能注意测试时有延迟，可能需要几分钟才能发送成功参考 https://blog.csdn.net/breakaway_01/article/details/111474564 2-2 注册123th:fragment=&quot;header&quot;th:href=&quot;@&#123;/index&#125;&quot;th:replace=&quot;index::header&quot; 2-3 问题thymeleaf找不到页面的问题注意@Controller配置@Slf4jhttps://www.jianshu.com/p/6e137ee836a1","categories":[{"name":"项目","slug":"项目","permalink":"https://shadowbynl.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"ls树相关","slug":"ls-tree","date":"2021-09-20T16:12:54.000Z","updated":"2021-10-07T08:16:13.462Z","comments":true,"path":"2021/09/21/ls-tree/","link":"","permalink":"https://shadowbynl.github.io/2021/09/21/ls-tree/","excerpt":"","text":"","categories":[{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"SQL相关","slug":"sql-00","date":"2021-09-20T14:51:34.000Z","updated":"2021-10-07T08:17:50.652Z","comments":true,"path":"2021/09/20/sql-00/","link":"","permalink":"https://shadowbynl.github.io/2021/09/20/sql-00/","excerpt":"sql相关的问题与练习","text":"sql相关的问题与练习 环境 环境本机mysql配置初始化密码遗失的解决方案 https://blog.csdn.net/m0_46278037/article/details/113923726","categories":[{"name":"面试","slug":"面试","permalink":"https://shadowbynl.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"儒猿面试之一","slug":"ry-00","date":"2021-09-20T14:34:49.000Z","updated":"2021-10-07T08:17:26.399Z","comments":true,"path":"2021/09/20/ry-00/","link":"","permalink":"https://shadowbynl.github.io/2021/09/20/ry-00/","excerpt":"中华石杉面试专题 高频考题篇","text":"中华石杉面试专题 高频考题篇 一 概述 二 集合 1 HashMap相关 2 一 概述二 集合1 HashMap相关 2","categories":[{"name":"面试","slug":"面试","permalink":"https://shadowbynl.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"测试问题","slug":"test-qa","date":"2021-09-15T08:17:23.000Z","updated":"2021-10-07T08:37:48.209Z","comments":true,"path":"2021/09/15/test-qa/","link":"","permalink":"https://shadowbynl.github.io/2021/09/15/test-qa/","excerpt":"占位","text":"占位 mysql 计算机网络 项目 mysqlNavicat运行SQL文件出错https://zhidao.baidu.com/question/525156367906044565.html 计算机网络TCP中的seq 什么意思https://zhidao.baidu.com/question/346839619.htmlhttps://www.cnblogs.com/vvull/p/10597881.html 项目创建springboot项目不成功的问题（网络连接） 网络换成热点（不一定） 创建不成功 https://blog.csdn.net/qq_26071319/article/details/106209405http://start.aliyun.com 代理 pom报红https://blog.csdn.net/feifeiwuxian/article/details/1093341011234567&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; https://blog.csdn.net/qq_41205651/article/details/114854831File -&gt; Invalidate Caches / Restart... -&gt; Invalidate and Restart","categories":[{"name":"随机","slug":"随机","permalink":"https://shadowbynl.github.io/categories/%E9%9A%8F%E6%9C%BA/"}],"tags":[]},{"title":"jf","slug":"jf","date":"2021-09-13T13:10:02.000Z","updated":"2021-10-07T08:15:58.778Z","comments":true,"path":"2021/09/13/jf/","link":"","permalink":"https://shadowbynl.github.io/2021/09/13/jf/","excerpt":"java框架的基本概念与使用相关 ssm springboot等","text":"java框架的基本概念与使用相关 ssm springboot等 mybatis spring springmvc mybatis配置解析映射文件和注解动态sql复杂实体关系缓存 spring控制反转 依赖注入代理模式 AOP整合声明式事务 springmvcdispatcherServlet原理 restful 请求参数 返回 乱码 json","categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"}],"tags":[]},{"title":"javaweb","slug":"javaweb","date":"2021-09-13T07:55:30.000Z","updated":"2021-10-07T08:36:50.636Z","comments":true,"path":"2021/09/13/javaweb/","link":"","permalink":"https://shadowbynl.github.io/2021/09/13/javaweb/","excerpt":"占位","text":"占位 jdbc smbms jdbcsmbms","categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"}],"tags":[]},{"title":"关于编程学习的问题","slug":"abstj","date":"2021-09-10T16:08:33.000Z","updated":"2021-10-07T08:13:08.957Z","comments":true,"path":"2021/09/11/abstj/","link":"","permalink":"https://shadowbynl.github.io/2021/09/11/abstj/","excerpt":"夏令营结束后的八月，心还是有些浮的，一直想回家回不成，所谓准备实习，但实际每天花在准备上的工夫很少，不够专注，效果很差。到九月初回顾自己的技术体系，发现有很多漏洞和模糊的地方，这时候认识到对于找这样的后端开发的工作来说，不专注地学习其基础的方方面面再去看面经总结，而是直接被动接收一些很粗略的知识，是绝对不能应付找工作的要求的。如果以后想干开发，在现在这么卷的情况下，不沉下心来学习准备，而是抱着一个“顺便”的态度，很难会有什么作为。近来先后找过同样学习后端开发的同学聊过两次（已有腾讯网易），对我有些启发，在这篇中简单总结下，同时后续关于总体学习的反思也在此记述。","text":"夏令营结束后的八月，心还是有些浮的，一直想回家回不成，所谓准备实习，但实际每天花在准备上的工夫很少，不够专注，效果很差。到九月初回顾自己的技术体系，发现有很多漏洞和模糊的地方，这时候认识到对于找这样的后端开发的工作来说，不专注地学习其基础的方方面面再去看面经总结，而是直接被动接收一些很粗略的知识，是绝对不能应付找工作的要求的。如果以后想干开发，在现在这么卷的情况下，不沉下心来学习准备，而是抱着一个“顺便”的态度，很难会有什么作为。近来先后找过同样学习后端开发的同学聊过两次（已有腾讯网易），对我有些启发，在这篇中简单总结下，同时后续关于总体学习的反思也在此记述。 一、一个专注的态度和学习方法 二、差异是如何造成的 三、方法 具体 书 一、一个专注的态度和学习方法其实回顾我过去这二十年，很难说我真正学会了什么技能，很多事浅尝辄止，很多事勉强应付。到现在能通过保研拿到这么一个打黑工的机会已经算是我牺牲比别人多几倍的时间（浪费）而争取到的一个并不怎么样的结果。未来靠什么才能生存，需要真正学会什么，我一直都很清楚，但态度和做法实际并不坚定。长久以来，我习惯看视频教程草草学习，看别人怎么做，但自己很少有练习思考，也很少有总结。往往事情一多起来，我就会中断技术的学习，很多东西一直反复，导致目前很难说掌握了什么技术。这种轻慢的应对技术学习的态度，导致的虚浮的技术水平，进而使我本人内心各方面其实都相当不自信。到现在这个阶段，今年的冬天我就要22周岁了，身体素质差，眼下较不抵触的路就是之后两年去南软外包公司去挣4k的月薪，而选择这条意味着未来我将走死开发这条路了。一个电子信息的硕士，学不到新的研究生阶段才能学到的知识，也不会有曾经渴望的导师的引导，有的只是在用身体换钱一条路走到黑的未来，对于我来说其实也算是较适合的了。不太想科研，也欠缺交际的能力，选择了计算机专业的话还是走开发较好，在这种意义上南软是个尚可的选择，算是有了title也有了一个缓冲学习的机会。如果我做了这样的选择，我未来三年内将完全以java开发为主了。和本科前三年的学习完全不同，前三年是在水绩点、竞赛等的同时自学编程，有一段没一段的，总会为完成课内的很多事而中断技术学习很长时间。而未来三年，在完全就业导向下，java这条线就是我主修的，学用、做项目就是我必须投入的。为了在研一的暑假能找到一份尚可不那么累的工作，我必须从现在开始，投入进去，可能这个学期的实习不太好找，但一定要开始打基础，奠定随时能找面试找工作的知识基础，本科毕业前，必须去尝试找实习找工作，至少得参加几十次面试积累经验，这样过渡到研究生再做一年开发后，才算好做一些。因此，我现在要做的是，明确该如何继续学习下去，需要看什么如何做，应该持有一个怎样的态度。 二、差异是如何造成的一年前的暑假基本算是我后端开发技能最熟练的时候了，那时候为完成课设和竞赛等差不多自己完整写过四五个web系统或桌面程序，到暑假给学院开发科研信息系统时我也是搭建基础环境框架、编写原始文档的主力，我的同学那时候刚接触web开发，还有很多问题需要问我。到大三以后，纠结于考研保研中很多时间不知不觉挥霍，结果保研考研没准备，项目也没怎么做，很多是在原来写的系统上修修改改，很多方面变得生疏了。而我的同学从今年年初开始准备面试和实习，每天花相当多的时间看书做笔记写算法题，逐一攻克java基础的各方面，稳扎稳打，其实半年左右，已经足够对javase、并发编程、虚拟机、框架等各方面有一个深入的认知了，同时做做项目，在校招中已经足够获得不错的offer了。可以说，一年过后，我现在不管从理论还是实操上都差了不少了。很大程度上是我过去半年的重心不在就业准备上面，但更重要的其实是我学习的方法和态度、认知不正确。我不管学什么，总是先找很多参考的资料，选择很长时间，再开始，但往往坚持不长时间就因其他事情而放弃，最终收效甚微。我可是太喜欢反思总结，而不去切实学习了。学而不思则罔，思而不学则殆。眼下最重要的就是调整认知，走入java技术体系的一个正常的学习路线。 三、方法通过与同学的交流，我认识到，对校招而言（暂时不谈社招），基础很重要，开发相关的理论也很多。 java相关的知识体系 javase 十几个方面 juc并发编程 netty rpc jvm 数据库 中间件 设计模式 计算机基础 而对于这样的基础理论的学习与实践，之前我的认知是视频教程+面经，可能很多人也是这么做的，但我确实这样做了之后感觉吸收不多，不踏实，可能是不够专注，但我同时也一直都清楚看书去学习技术，看文档才是搞开发最正的路线，再多的视频等也是给你提炼知识的，而且学习效果可能会比较差，所以这些基础理论的学习必须看书细过+实践。 考查的重心 微服务从来不是基础考核的重心，因此与其关注复杂的微服务项目，不如先学好基础的理论和做做基本全面的项目。 牛客的用处 算法题目 面经 项目 关键是什么 看的多，全面，关键是思想 具体123java这个ks路线还得走完框架，然后基础还得那么过但有些书得开始计划看了，初步决定在平板上看，博客做笔记，同时实践（需要先整下平板里以前的笔记） 书 java核心技术卷一/卷二 深入理解java虚拟机 第三版 java并发编程的艺术 java并发编程实战 网络 图解http 图解tcp 自顶向下 谢希仁 计算机基础 深入理解计算机系统 春风 1忽然意识到cs科班生应该沉下心研读些cs体系的东西","categories":[{"name":"规划","slug":"规划","permalink":"https://shadowbynl.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"java相关问题","slug":"java-qa","date":"2021-09-05T15:12:24.000Z","updated":"2021-10-07T08:36:43.273Z","comments":true,"path":"2021/09/05/java-qa/","link":"","permalink":"https://shadowbynl.github.io/2021/09/05/java-qa/","excerpt":"占位","text":"占位 可重入锁虚假唤醒COWcas compareandset","categories":[{"name":"随记","slug":"随记","permalink":"https://shadowbynl.github.io/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[]},{"title":"wsl相关配置","slug":"env-wsl","date":"2021-09-03T02:35:30.000Z","updated":"2021-10-07T08:12:15.236Z","comments":true,"path":"2021/09/03/env-wsl/","link":"","permalink":"https://shadowbynl.github.io/2021/09/03/env-wsl/","excerpt":"为允许大四上人工神经网络的程序，需要配置wsl2上的cuda相关环境，现记述一下相关过程与参考","text":"为允许大四上人工神经网络的程序，需要配置wsl2上的cuda相关环境，现记述一下相关过程与参考 1 介绍 2 本机cuda相关配置 3 关于wsl2的测试 win10虚拟机的问题 修改用户密码 安装图形界面 安装MySql8.0 文件传送 备份 4 wsl2 cuda配置 4.1 官网文档（校园网打不开） 4.2 cuda相关 安装好没有自动配置环境变量，手动配置 阿里云cuda镜像 卸载现有驱动/cuda 几种方案，但没有参考价值（都更新太快了） 各种报错 ubuntu卸载 比较有价值的参考方案，但还是失败了，和官网错误类似 4.3 综上 4.4 其他方案 1 介绍https://docs.microsoft.com/zh-cn/windows/wsl/abouthttps://docs.microsoft.com/zh-cn/windows/wsl/install-win10本机在2021.4.30时安装过wsl2 ubuntu2 2 本机cuda相关配置本机目前环境为cuda11.0 gpu为rtx3060 3 关于wsl2的测试win10虚拟机的问题 这里先提一下之前在win10上安装vmware后没法开启虚拟机的问题 这里进行详细记述，简单说就是win10本身的虚拟机功能和vmware冲突参考 https://www.chenkaihua.com/2019/09/23/hyper-off/ 12345安装virtualbox后发现开启不了虚拟机，根据网上资料得知，是因为微软默认开启了hyper-v,即便是在启用或关闭Windows功能里不启用Hyper-V,也不能解决问题，需要解决的话就需要彻底关闭hyper-v功能。从知乎问题上(Windows 10 下如何彻底关闭 Hyper-V 服务？ - 张林军的回答 - 知乎)找到了最简单的解决办法。快捷键win+x,使用管理员权限打开Windows Powershell关闭：bcdedit /set hypervisorlaunchtype off开启: bcdedit /set hypervisorlaunchtype auto 修改用户密码123456789win10中WSL登录是不用密码的，当需要使用用户权限但是忘记密码的时候，可以使用如下办法以root身份登录WSL并重置密码1、以管理员身份打开 PowerShell ;2、输入命令 wsl.exe --user root ;3、命令 passwd root 修改 root 用户密码。忘记其他用户密码supasswd 用户名 参考https://www.cnblogs.com/my-blogs-for-everone/articles/13973872.htmlhttps://blog.csdn.net/qq_28120227/article/details/100677167 安装图形界面https://www.bilibili.com/video/BV1LA411n7BK?spm_id_from=333.999.0.0 12345678910sudo apt update &amp;&amp; apt upgradesudo apt install xrdpsudo apt install xfce4 xfce4-goodiessudo vim /etc/xrdp/xrdp.iniecho xfce4-session &gt; ~/.xsessionsudo vim /etc/xrdp/startwm.shsudo /etc/init.d/xrdp startip asudo apt install firefox 安装MySql8.01234567891011121314151617181920212223安装mysqlsudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev查看默认密码sudo cat /etc/mysql/debian.cnf默认方式登陆mysql -u debian-sys-maint -p // 用户名以自己的配置文件为准更改密码mysql&gt;use mysql;mysql&gt;flush privileges;mysql&gt;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;你的密码&#x27;;mysql&gt;flush privileges;重启服务sudo service mysql restart开启端口vim /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉 bind-address = 127.0.0.1允许访问use mysql;select host from user where user = &#x27;root&#x27;;update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;flush privileges; 参考https://www.jianshu.com/p/99c4baca1983https://www.cnblogs.com/xiaozhounandu/p/14497835.htmlhttps://www.cnblogs.com/patrickding/p/6435459.htmlhttps://blog.csdn.net/iiiiiilikangshuai/article/details/100905996补充vimhttps://blog.csdn.net/yang1393214887/article/details/106233991https://blog.csdn.net/weixin_40853073/article/details/81707177 文件传送https://blog.csdn.net/x356982611/article/details/80077085 备份4 wsl2 cuda配置 先说结论：总体上完成配置的要求有1 硬件2 驱动3 wsl上的专用cuda4 dev通道的windows先后参照一个去年的视频教程、多篇博客、官网文档，在20.04 18.04等上先后安了三个版本的cuda，均测试失败，暂认为是没有安装dev预览版windows所致，但若进入dev通道升级为win11，对本机系统的稳定性有影响，也不容易回退，所以暂时放弃这个方案。下面记述一下过程及参考 4.1 官网文档（校园网打不开）https://docs.nvidia.com/cuda/wsl-user-guide/index.html#rel-460-15本机安装驱动和dev通道情况下，执行以下命令 1234567$ wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin$ sudo mv cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600$ wget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda-repo-wsl-ubuntu-11-4-local_11.4.0-1_amd64.deb$ sudo dpkg -i cuda-repo-wsl-ubuntu-11-4-local_11.4.0-1_amd64.deb$ sudo apt-key add /var/cuda-repo-wsl-ubuntu-11-4-local/7fa2af80.pub$ sudo apt-get update$ sudo apt-get -y install cuda 测试 123$ cd /usr/local/cuda-11.4/samples/4_Finance/BlackScholes$ make BlackScholes$ ./BlackScholes 在本机上，测试失败，提示大意为找不到驱动/gpuCUDA error at ../../common/inc/helper_cuda.h:779 code=35(cudaErrorInsufficientDriver) &quot;cudaGetDevicehttps://developer.nvidia.com/cuda/wsl/download 4.2 cuda相关安装好没有自动配置环境变量，手动配置https://blog.csdn.net/yinxian9019/article/details/106756280/ 阿里云cuda镜像https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/https://mirrors.aliyun.com/nvidia-cuda/ubuntu2004/x86_64/ 卸载现有驱动/cuda1234$ sudo apt-get remove --purge nvidia-* $ sudo apt-get autoremovedpkg -l | grep -i nvidia https://blog.csdn.net/weixin_32820767/article/details/83818885https://qastack.cn/ubuntu/206283/how-can-i-uninstall-a-nvidia-driver-completely 几种方案，但没有参考价值（都更新太快了）https://www.bilibili.com/video/BV1FZ4y1p7Qp?spm_id_from=333.999.0.0https://blog.csdn.net/qq_20291997/article/details/106897324https://blog.csdn.net/weixin_36815313/article/details/107641262https://zhuanlan.zhihu.com/p/152533150https://zhuanlan.zhihu.com/p/122286055 各种报错NVIDIA-SMI has failed because it couldn&#39;t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.https://zhuanlan.zhihu.com/p/89714824https://blog.csdn.net/weixin_42084747/article/details/84371079?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link ubuntu卸载https://blog.csdn.net/weixin_33711641/article/details/90386490?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.control&amp;spm=1001.2101.3001.4242https://blog.csdn.net/qq_38410428/article/details/82930814 比较有价值的参考方案，但还是失败了，和官网错误类似https://blog.csdn.net/u010953692/article/details/113830046 123456wget https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/cuda-ubuntu1804.pinsudo mv cuda-ubuntu1804.pin /etc/apt/preferences.d/cuda-repository-pin-600sudo apt-key adv --fetch-keys https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/7fa2af80.pubsudo add-apt-repository &quot;deb https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/ /&quot;sudo apt-get updatesudo apt-get -y install cuda 4.3 综上基本可以判断是没有用dev通道的问题，参考一篇博客的评论（五月左右）提到切换到dev通道按官网方式就成功了，但这样风险有些大，所以不再尝试。https://zhuanlan.zhihu.com/p/386362341 极不容易回退，也不稳定 4.4 其他方案1.本机上是有完整可用的cuda+opencv的环境的，就看代码怎么改了。。2.先下数据集，数据集官方的下载速度很慢（校园网），一般找不到其他的就得耗流量了。。 hmdb51https://www.pianshen.com/article/1325689931/https://serre-lab.clps.brown.edu/resource/hmdb-a-large-human-motion-database/ucf101https://blog.csdn.net/weixin_40162095/article/details/111870161 其他https://blog.csdn.net/alec1987/article/details/69388699?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.no_search_link","categories":[{"name":"环境","slug":"环境","permalink":"https://shadowbynl.github.io/categories/%E7%8E%AF%E5%A2%83/"}],"tags":[]},{"title":"输入输出","slug":"dsa-io","date":"2021-09-01T09:52:41.000Z","updated":"2021-10-07T08:35:22.028Z","comments":true,"path":"2021/09/01/dsa-io/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/dsa-io/","excerpt":"占位","text":"占位 c++ java c++https://www.cnblogs.com/Mary-Sue/p/8678462.html java","categories":[{"name":"语法","slug":"语法","permalink":"https://shadowbynl.github.io/categories/%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"信息检索系统","slug":"ds-xxjsxt","date":"2021-09-01T06:00:27.000Z","updated":"2021-10-07T08:12:49.740Z","comments":true,"path":"2021/09/01/ds-xxjsxt/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/ds-xxjsxt/","excerpt":"该篇是为完成大四上信息检索系统作业，对其基础理论和相关参考进行学习的一个随记，并记录完成作业的思路过程。","text":"该篇是为完成大四上信息检索系统作业，对其基础理论和相关参考进行学习的一个随记，并记录完成作业的思路过程。 理论部分 jdnlp的课件：信息检索及倒排技术 现代信息检索 信息检索：实现和评价搜索引擎 实现部分 lzw报告理解复现 其他参考程序 实现 一些问题与参考 java解析处理相关 相关资源 理论部分jdnlp的课件：信息检索及倒排技术 信息检索 Information Retrieval(IR)：从大规模非结构化数据（通常是文本）的集合（通常保存在计算机上）中找出满足用户信息需求的资料（通常是文档） 的过程。作为一门学科，是研究信息的获取(acquisition)、表示(representation)、 存储(storage)、组织(organization)和访问(access)的一门学问。 信息检索的历史 123456789101112131415# 计算机出现以前目录--索引（从词和概念指向相关信息或文档的指针）手工方式建立索引：如词典的拼音检字 部首笔画检字# 1948第一次出现信息检索的术语# 60s-70s为文献摘要建立文本检索系统产生了布尔模型、向量空间模型和概率检索模型的概念# 80s商用较大规模数据库检索系统# 90s网络搜索工具 web搜索引擎# 2000信息抽取 问答系统 演化出了很多nlp任务，不仅仅是搜索引擎 信息检索例子 倒排索引 布尔检索模型 现代信息检索信息检索：实现和评价搜索引擎相较上本书，这本书更直接地介绍了基本概念 实现部分 由于是作业驱动，没有必要先把概念全部先看一遍，不理解的地方回看即可 lzw报告理解复现两段程序都比较清晰容易理解，算法并不复杂，繁琐的还是文件处理1 tf-idf 英文的话实现很简单 但中文就要考虑分词了，所以会更加负责2 倒排索引 需要自己实现b+树/前缀树 因此如果使用java实现的话，首先是要解决文本处理的问题 其他参考程序1 拼写检查功能只实现了一半2 中文分词3 commonsio maven项目中绝对路径4 中文分词 实现 10.4 下午六点 基本把三份代码完成了 完成情况 tf-idf 1234561.完成了中文和英文两种计算2.对中文2.1 前缀树存储词库2.2 分词工具类：前缀树初始化 文本预处理 分词2.3 测试类 计算父类 中文处理子类3.对英文 倒排索引 121.主要是修改了前缀树的数据结构 改动不多2.只实现了对英文单文本的 逐行处理 记录一个单词在一个文本中的行号，列好 不处理行尾一个单词未结束的情况 爬虫 12341.为方便1测试，写个简单的爬取中文文本的方法2.原定计划是中文+英文 但没必要就不写了3.搜过一些xpath解析的方法 dom4j jsoupxpath等等 但都不能利用xpath表达式最后还是老老实实用jsoup解析 + 连接池 问题 12程序1中的中文处理中无论如何无法去掉部分词语的空格，多处处理无法过滤，暂时留着这个问题程序2中仅限处理约定的情况 一些问题与参考java解析处理相关1.java去除空格符的方法https://blog.csdn.net/weixin_33851177/article/details/92001703 12345678910111213141516JAVA中去掉空格 1. String.trim() trim()是去掉首尾空格 2.str.replaceAll(&quot; &quot;, &quot;&quot;); 去掉所有空格，包括首尾、中间 String str = &quot; hell o &quot;; String str2 = str.replaceAll(&quot; &quot;, &quot;&quot;); System.out.println(str2); 3.或者replaceAll(&quot; +&quot;,&quot;&quot;); 去掉所有空格 4.str = .replaceAll(&quot;\\\\s*&quot;, &quot;&quot;); 可以替换大部分空白字符， 不限于空格 \\s 可以匹配空格、制表符、换页符等空白字符的其中任意一个 2.notepad++查看所有字符（没用）https://jingyan.baidu.com/article/ce4366494960083773afd32e.html3 java xpath解析方法https://blog.csdn.net/weixin_42022555/article/details/82775916https://www.cnblogs.com/wanghaomiao/p/4899355.htmlhttps://blog.csdn.net/baidu_36336788/article/details/89875926?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link4 java格式化输出方法https://blog.csdn.net/qq_44111805/article/details/1128505505 TreeMap按照value进行排序https://blog.csdn.net/liuxiao723846/article/details/50454622 1234567891011121314151617181920public static void sortByValue() &#123; Map&lt;String,String&gt; map = new TreeMap&lt;String,String&gt;(); map.put(&quot;a&quot;, &quot;dddd&quot;); map.put(&quot;d&quot;, &quot;aaaa&quot;); map.put(&quot;b&quot;, &quot;cccc&quot;); map.put(&quot;c&quot;, &quot;bbbb&quot;); List&lt;Entry&lt;String, String&gt;&gt; list = new ArrayList&lt;Entry&lt;String, String&gt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() &#123; //升序排序 public int compare(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2) &#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for (Entry&lt;String, String&gt; e: list) &#123; System.out.println(e.getKey()+&quot;:&quot;+e.getValue()); &#125; &#125; 6 Java遍历Map的4种方式https://blog.csdn.net/chpllp/article/details/109073224 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; // 循环遍历Map的4中方法 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(1, 2); // 1. entrySet遍历，在键和值都需要时使用（最常用） for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key = &quot; + entry.getKey() + &quot;, value = &quot; + entry.getValue()); &#125; // 2. 通过keySet或values来实现遍历,性能略低于第一种方式 // 遍历map中的键 for (Integer key : map.keySet()) &#123; System.out.println(&quot;key = &quot; + key); &#125; // 遍历map中的值 for (Integer value : map.values()) &#123; System.out.println(&quot;key = &quot; + value); &#125; // 3. 使用Iterator遍历 Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(&quot;key = &quot; + entry.getKey() + &quot;, value = &quot; + entry.getValue()); &#125; // 4. java8 Lambda // java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value， // 不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式 map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot;:&quot; + value); &#125;); &#125; 7 java列出目录文件https://blog.csdn.net/hlanting/article/details/92854033?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link 12345678910111213141516package com.jn.test; import java.io.File; public class ListFile2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub File file=new File(&quot;E:\\\\&quot;); for(File temp:file.listFiles())&#123; if(temp.isDirectory())&#123; System.out.println(temp.toString()); &#125; &#125; &#125;&#125; 8 commons-io的常用方法https://blog.csdn.net/backbug/article/details/99572931?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_linkhttps://blog.csdn.net/weixin_44035017/article/details/102526767https://blog.csdn.net/weixin_44035017/article/details/1025267679 Java之StringUtils的常用方法https://blog.csdn.net/weixin_42290280/article/details/8259116110 java正则https://www.runoob.com/java/java-regular-expressions.html11 Java删除/清除/过滤标点（所有中英文标点）的正则表达式https://blog.csdn.net/yuan882696yan/article/details/52276210 123(1) s.replaceAll( &quot;\\\\p&#123;Punct&#125;&quot;, &quot;&quot; ); (2) s.replaceAll(&quot;\\\\pP&quot; , &quot;&quot;); (3) s.replaceAll(&quot;\\\\p&#123;P&#125;&quot; , &quot;&quot;); 12 commons-lang 常用apishttps://max.book118.com/html/2017/0325/96858094.shtm13 中文分词方法https://blog.csdn.net/weixin_42242538/article/details/84754491 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697中文分词通俗来讲，中文分词是指将一句中文句子中的所有中文词汇相互分隔开来。它是文本挖掘的基础，有着十分广阔的应用前景。下面，我们来看一看对于这个技术的简单实现。算法对于中文分词技术的实现，有许多算法可以完成，目前大致可以把算法分为三大类：基于字符串匹配的分词方法；基于理解的分词方法；基于统计的分词方法。其中，基于字符串匹配的分词方法是把中文句子按照一定的策略将待分析的汉字串与已知且足够大的中文词典库进行比对，从而达到分词效果。而我们通常使用最多的分词策略，大致有三类，正向最大匹配法，逆向最大匹配法和最少切分法。基于理解的分词方法是指让计算机模拟人对句子的理解进行分词。基于统计的分词方法是指找出上下文中出现较多的汉字组合，将这些组合视为词汇，代入到原文中进行分词。在这里，我们就使用字符串匹配的分词方法，利用逆向最大匹配的策略，对中文句子进行简单的分词。算法思路逆向最大匹配法大致思想为：将整个字符串作为一个“词组”带入到词典中进行比对，若不成功，删除第一个字符，继续进行如此操作，直到成功或者只剩下最后一个字，再把结果放入一个字符串的数组中，最后删除原句中的结果，继续上面的操作。下面我将用一个例子解释这个操作：原句：今晚月亮真漂亮啊词典：“今晚”，“月亮”，“漂亮”第一次代入：今晚月亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）删除首字符：晚月亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）删除首字符：月亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）删除首字符：亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）…删除首字符：啊（在词典中没有该词汇，只剩下一个字，放入结果数组，并删除位于句尾的最后这个字，进行第二次代入）第二次代入：今晚月亮真漂亮（在词典中没有该词汇，删除首字符继续比对）…删除首字符：漂亮（在词典中找到词汇“漂亮”，放入结果数组，并删除位于句尾的结果“漂亮”，进行第三次代入）…————————————————版权声明：本文为CSDN博主「birches」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_42242538/article/details/84754491public class secondwork &#123; public static void main(String args[]) &#123; String[] cs = &#123;&quot;你好&quot;,&quot;请问&quot;,&quot;什么&quot;,&quot;名字&quot;&#125;;//词典 String a = &quot;你好！请问你叫什么名字？&quot;; System.out.print(&quot;原句：&quot;); System.out.print(a + &#x27;\\n&#x27;); System.out.print(&quot;拆分后为：&quot;); String[] cs2 = new String[100]; //结果数组 int jud=0;//找到匹配字符串与否的标志 int j=0; String temp=null;//初始化临时字符串 for(;a.length()&gt;0;) &#123; for(int i = 0;i&lt;a.length();i++) &#123; temp = a.substring(i);//每次截取掉首个字符 if(isin(cs,temp) == true)//如果目标字符串在数组中 &#123; cs2[j] = temp; jud = 1; int number = temp.length(); a = a.substring(0,a.length()-number); &#125; &#125; if(jud == 0)//没有找到匹配字符串 &#123; cs2[j] = a.substring(a.length()-1,a.length());//将最后一个元素放在cs2里面 a = a.substring(0, a.length()-1);//截掉最后一个元素继续循环。 &#125; jud = 0; j++; &#125; for(;j &gt;= 0;j--) &#123; if(cs2[j] != null) System.out.print(cs2[j]+&quot; &quot;); &#125; &#125; /* * 下面为判断字符串是否在词典中的函数方法 */ static public boolean isin(String[] cs,String temp)//判断目标字符串是否在对比字符串数组中 &#123; int i; for(i = 0;i&lt;cs.length;) &#123; if(temp.equals(cs[i])) i = cs.length+1; else i++; &#125; if(i == cs.length+1) return true; else return false; &#125;&#125; 相关资源1 英文文本http://www.enread.com/news/life/114823.htmlhttp://www.enread.com/2 小说https://www.tycqxs.com/57_57672/21597158.html3 python splithttps://www.jb51.net/article/63592.htm4 敏感词过滤方法https://blog.csdn.net/qq_42956993/article/details/1094915565 用于存储中文字符的字典树https://blog.csdn.net/ccwlisha/article/details/895254556 maven项目就别想用相对路径读写文件了7 java实现b+树8 中文分词工具https://search.gitee.com/?q=%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D&amp;skin=rec&amp;type=repository&amp;pageno=2https://blog.csdn.net/qq_41154871/article/details/893755879 中文文本纠错算法实现https://blog.csdn.net/demm868/article/details/107096661","categories":[{"name":"大四","slug":"大四","permalink":"https://shadowbynl.github.io/categories/%E5%A4%A7%E5%9B%9B/"}],"tags":[]},{"title":"网络安全","slug":"ds-net","date":"2021-09-01T01:55:32.000Z","updated":"2021-10-07T08:12:54.881Z","comments":true,"path":"2021/09/01/ds-net/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/ds-net/","excerpt":"大四上学期网络安全选修课课程内容","text":"大四上学期网络安全选修课课程内容 1 概述 2 密码体制与技术 非对称加密技术组合 3 PKI技术 3.1 数字证书 3.2 数字证书安全通信实例 3.3 PKI的组成 3.4 PKI的应用 查看数字证书 国内外CA 数字证书的申请 数字证书应用操作实例 4 VPN技术 4.1 VPN概述 为什么需要VPN–VPN产生的原因 VPN的定义和分类 VPN能做什么–功能 VPN的分类 4.2 VPN原理 实现VPN的关键技术 1 安全隧道技术 1 概述12345678910111213141516171. TCP连接为什么需要三次握手？两次握手是否可以？答：为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。举例表述：防止失效的连接请求报文段被服务端接收，从而产生错误。 首先需要解释失效的连接请求是什么：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是失效的连接请求。假如建立连接只需两次握手，对于客户端来说并没有太大的变化。但仍然需要获得服务端的应答后才进入ESTABLISHED（建立）状态。而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。https://blog.csdn.net/lengxiao1993/article/details/82771768?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.essearch_pc_relevanthttps://blog.csdn.net/AntdonYu/article/details/1037655532. 什么是TCP半开连接？客户端向服务端发送SYN建立连接请求，服务端响应SYN-ACK建立连接，即为TCP半开连接。3. SYN Flood属于哪种攻击？SYN Flood (SYN泛洪) 是种典型的DoS (Denial of Service，拒绝服务) 攻击，效果是服务器TCP连接资源耗尽，停止响应正常的TCP连接请求。https://blog.csdn.net/chenyulancn/article/details/788325974.什么是字典攻击？在破解密码或密钥时，逐一尝试用户自定义词典中的可能密码（单词或短语）的攻击方式。与暴力破解的区别是，暴力破解会逐一尝试所有可能的组合密码，而字典式攻击会使用一个预先定义好的单词列表（可能的密码）。5. ARP欺骗的原理是什么？ARP(Address Resolution Protocol，地址解析协议)是一个位于TCP/IP协议栈中的低层协议，负责将某个IP地址解析成对应的MAC地址。从影响网络连接通畅的方式来看，ARP欺骗分为二种，一种是对路由器ARP表的欺骗;另一种是对内网PC的网关欺骗。第一种ARP欺骗的原理是——截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的路由器途径上网。在PC看来，就是上不了网了，“网络掉线了”。https://www.xuexila.com/luyouqi/120948.htmlhttps://jingyan.baidu.com/article/fea4511a7a2020f7bb91252a.html 2 密码体制与技术12345678910111213141516171.三重DES为什么是加密-解密-加密三重DES(triple-des)是为了增加DES的强度,将DES重复3次所得到的一种密码算法,也称为TDEA(Triple Date Encryption Algorithm),通常缩写为3DES。三重DES并不是进行三次DES加密(加密→加密→加密),而是加密→解密→加密的过程,目的是为了让三重DES能够兼容普通的DES。当三重DES中所有的密钥都相同时,三重DES也就等同于普通的DES了。这是因为在前两步加密→解密之后,得到的就是最初的明文。因此,以前用DES加密的密文,就可以通过这种方式用三重DES来进行解密。也就是说,三重DES对DES具备向下兼容性。2.密钥是不是越长越好密码体制的安全性，其并不是仅仅由密钥的长度决定的，但是在同一个密码体制中，越长的密钥意味着密钥空间越大，敌手通过暴力穷举的方式得到真实密钥的情况更加难以发生，在这种意义上讲，同一种密码体制中，体制的安全性与密钥的长度相关。3.对称密码的优点是什么以及缺点是什么优点算法简单、速度快、适合加密大量数据缺点密钥管理方面如何安全的共享秘密密钥，不可能与你未曾谋面的人通信每对通信者间都需要一个不同的密钥，当用户量增大时密钥空间急剧增大。没有解决不可抵赖问题没有解决不可抵赖问题 参考https://www.cnblogs.com/songwenlong/p/5944139.htmlhttps://www.sohu.com/a/278245376_100245441https://www.zhihu.com/question/365630892 matlab图像置乱参考https://blog.csdn.net/qq_33472557/article/details/79668662https://ww2.mathworks.cn/help/matlab/ref/rgb2gray.htmlhttps://www.cnblogs.com/wxl845235800/p/7216785.htmlhttps://jingyan.baidu.com/article/ed15cb1b3e94da5be269810f.htmlhttps://ww2.mathworks.cn/help/matlab/ref/imread.html matlab 图片相关的问题 imshow image https://tieba.baidu.com/p/6492190181图片分量提取 https://jingyan.baidu.com/article/456c463b41de5f0a5831448e.htmllinux移动文件 https://www.cnblogs.com/aiyr/p/7395738.htmlubuntu创建用户https://blog.csdn.net/taolusi/article/details/81304057“const char *” 类型的实参与 “char *” 类型的形参不兼容错误的解决方法https://blog.csdn.net/qinshiyang/article/details/83213664cvwaitkey未定义标识符https://blog.csdn.net/baidu_38172402/article/details/87982268hhu推免 https://cies.hhu.edu.cn/2020/0924/c4093a213007/page.pspimresizehttps://baike.baidu.com/item/imresize/9948188?fr=aladdinmatlab输入输出https://blog.csdn.net/yewuzhitou/article/details/81906379matlab 技巧 figurehttps://blog.csdn.net/hyz301/article/details/64130405matlab将灰度图转化为彩图https://blog.csdn.net/felix_zhangshou/article/details/88915229?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&amp;spm=1001.2101.3001.4242http://blog.sina.com.cn/s/blog_a5fdbf010101hhyk.html置乱https://blog.csdn.net/qq_25884463/article/details/52463788https://wenku.baidu.com/view/7c3c84f2580102020740be1e650e52ea5418ce81.html?rec_flag=default&amp;fr=Recommend_RelativeDoc-60354,60273,60321,40251-kpdrec_doc_pc_view-203b4e017dd5360cba1aa8114431b90d6d85895a&amp;sxts=1631104444164https://wenku.baidu.com/view/203b4e017dd5360cba1aa8114431b90d6d85895a.htmlhttps://blog.csdn.net/qq_33472557/article/details/79668662 非对称加密技术组合A–B1 会话密钥加密明文2 明文哈希–数字签名–A私钥加密3 B公钥加密会话密钥B–A1 B私钥解密会话密钥2 获取明文3 明文哈希–数字签名+A公钥–比较 3 PKI技术123456中间人攻击数字证书 权威机构CA内容 格式 数字签名 CA的私钥对哈希过的数字证书进行签名根证书通信实例 3.1 数字证书 引入 安全功能：认证 授权 保密性（防偷听） 完整性（防篡改）防抵赖网络通信的四个安全要素如何解决安全要素 12345信任类型 现实世界 数字世界身份认证 身份证、护照、信用卡、驾照 数字证书、数字签名完 整 性 签名、支票、第三方证明 数字签名或MAC保 密 性 保险箱、信封、警卫、密藏 对称加密或公钥加密不可否认性 签名、挂号信、公证、邮戳 数字签名 PKI 公钥基础设施 数字证书 数字证书的提出A需要用B的公钥加密信息，那么在发送前，需要获取B公钥，一种是B发给A，一种是提供一个公共访问地址若有人假冒B的公钥发消息，这样能获得A的信息，中间人攻击 数字证书 用户身份+公钥 权威机构CA证实身份 身份+公钥–证书 数字证书的内容名称 序列号 签发者 发布时间 有效时间 公钥 数字证书格式–标准X.509如何保证数字证书的不可篡改性1 数字签名 对数字证书内容进行哈希后，再用CA的私钥进行数字签名2 CA对证书签名后，大家如何验证这个签名用证书发布机构的公钥3 如何获得CA的公钥CA给自己颁发的证书–根证书–包含CA公钥4 如何获取根证书 系统安装时已有一些默认安装的根证书例 签名算法 sha1RSA 哈希算法 sha1 公钥加密算法 rsa 3.2 数字证书安全通信实例1 客户向服务端发送通信请求2 服务器给客户自己的数字证书 有公钥加密信息 私钥服务器持有3 客户端收到服务端的证书，对其进行验证（是否过期–&gt;根证书（公钥）解密 哈希–&gt;比较–&gt;是否是CA颁发证书，是否是指定通信对象–&gt;取出公钥）4 身份认证 客户给服务端一个随机字符串，让其用私钥加密 服务器把结果返回 客户用公钥解密，说明匹配了5 验证服务器身份后，客户生成一个对称加密算法和密钥，用于后面通信的加密和解密（公钥加密后发送给服务器） 后续双方可以使用对称加密算法来加密解密通信内容问题1：服务器随便加密一个来路不明的字符串是不安全的问题2：黑客可以扰乱通信过程 重发 3.3 PKI的组成组成：证书持有者证书认证机构CA：必须有一个可信机构对一个主体公钥进行公证（签发证书 证书管理 密钥管理 证书状态查询）证书注册机构RA：分担CA的任务证书注册机构RA：辅助证书存储和发布系统：负责证书的分发（证书库：证书的集中存放）证书应用系统：应用接口和基于此的应用服务 证书撤销： 在有效期内由于某些原因需要废除 证书撤销列表CRL 3.4 PKI的应用查看数字证书Internet选项–内容–证书 国内外CA数字证书的申请证书的获得和安装（安装根证书 表格申请 下载数字证书安装） 数字证书应用操作实例添加数字签名 4 VPN技术4.1 VPN概述为什么需要VPN–VPN产生的原因总公司和分公司间有大量的数据要传输1 专线费用高 灵活性差2 若不使用任何技术措施在公共网上传输数据端到端数据安全问题（拨入段 外部段 内部段）风险：（1）拨入段 用户明文到ISP（攻击者和ISP存在问题）（2）因特网上数据泄露的风险（逐段加密也不能防范恶意的ISP，路由器上肯定会解密，且ISP可能伪造网关）（3）安全网关中数据泄露的风险（4）内部网中数据泄露的风险 需要一个综合一致的解决方案，提供端到端的、逐段的数据保护 VPN的定义和分类虚拟专用网VPN 在公共网络中建立的安全网络连接 采用了专有的协议虚拟 不再需要拥有实际的专线专用 VPN能做什么–功能数据机密性、完整性保护、身份认证数据完整性：VPN网关hash后摘要+数据包加密–解密数据包-&gt;hash-&gt;比对摘要数据认证：签名（数据包hash后摘要-&gt;私钥签名DSS，附在数据包后发送–&gt;取出DSS，公钥解密–原始数据包hash–比对 VPN的分类根据网络类型差异，分为两种类型Client-LAN 远程访问 客户端到网关（需要在LAN中加一个VPN设备）LAN-LAN 总部到分支机构 远程办公室（不同的局域网之间，每个LAN中都需要VPN设备） 4.2 VPN原理实现VPN的关键技术1 安全隧道技术一种封装，将一种协议封装在另一种协议中传输隧道协议包括三种：乘客 封装 运载 隧道技术和隧道协议 隧道协议类型 分类依据：被封装的数据在OSI/RM的层次二层隧道协议：封装数据链路层的数据包 构建远程访问型的VPN L2F PPTP L2TP三层隧道协议：网络层协议封装到隧道协议中传输 应用于构建LAN-LAN型的VPN 第二层隧道协议 PPTP 点到点 第一个广泛使用建立VPN的协议 PPP协议的问题 工作在专线上才能保证安全性 但专线贵 希望PPP工作在Internet上而不是专线上，但PPP是点对点的，只是一个链路层协议 PPTP 点对点隧道 还是基于PPP的 接入集中器AC（客户端-因特网间）：封装数据包，加上IP地址等可以路由的部分 乘客PPP 封装GRE 运载IP 第二层隧道协议 L2TP 以PPTP和L2F为基础，结合了两者的优点 工业标准 PPP PPTP L2TP比较 第三层隧道协议 IP–&gt;IPSec 传输模式只加密数据，隧道模式加密整个IP包，安全性更高。隧道模式开销更大 AH协议 ESP协议 认证+加密 IKE协议 安全地交换一套密钥 SA 安全联盟 SA和DH交换算法 DH原理 如何获得一致的密钥 且防止攻击者获得密钥的拷贝 混色原理正向很容易，逆向很难（单向函数）1 相同的初始颜色2 各有一个私有颜色 混合之后给对方 再与私有混合后即可获得相同颜色3 攻击者可能获得两者的混合颜色 但无法获取两者的私有颜色对一个数字过程 找一个单向函数数学原理 IKE密钥交换两个阶段","categories":[{"name":"大四","slug":"大四","permalink":"https://shadowbynl.github.io/categories/%E5%A4%A7%E5%9B%9B/"}],"tags":[]},{"title":"排序","slug":"dsa-sort","date":"2021-09-01T01:05:58.000Z","updated":"2021-10-07T08:13:03.179Z","comments":true,"path":"2021/09/01/dsa-sort/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/dsa-sort/","excerpt":"排序相关算法与问题","text":"排序相关算法与问题 排序算法模板 快速排序 归并排序 排序相关问题 第k个数（快速排序） 排序算法模板快速排序1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int a[100010];void quick_sort(int n[], int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int p = n[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while (i &lt; j) &#123; while(n[++i] &lt; p); while(n[--j] &gt; p); if (i &lt; j) &#123; swap(n[i], n[j]); &#125; &#125; quick_sort(n, l, j); quick_sort(n, j + 1, r);&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; quick_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125; 123456789101112131415161718192021222324252627public class TestSort &#123; public static void main(String[] args) &#123; int[] nums = &#123;22, 34, 1, 2, 0, 44, 553, 2, 3&#125;; quickSort(nums, 0, nums.length - 1); for (int x : nums) &#123; System.out.println(x); &#125; &#125; public static void quickSort(int[] nums, int l, int r) &#123; if (l &gt;= r) return; int xi = (int)(Math.random() * (r - l) + l); int x = nums[xi]; int i = l - 1, j = r + 1; while (i &lt; j) &#123; while (nums[++i] &lt; x); while (nums[--j] &gt; x); if (i &lt; j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125; &#125; quickSort(nums, l, j); quickSort(nums, j + 1, r); &#125;&#125; 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N];int b[N];void merge_sort(int a[], int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int m = l + r &gt;&gt; 1; merge_sort(a, l, m); merge_sort(a, m + 1, r); int k = 0; int i = l, j = m + 1; while (i &lt;= m &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) &#123; b[k++] = a[i++]; &#125; else &#123; b[k++] = a[j++]; &#125; &#125; while (i &lt;= m) &#123; b[k++] = a[i++]; &#125; while (j &lt;= r) &#123; b[k++] = a[j++]; &#125; for (int i = 0; i &lt; k; i++) &#123; a[l + i] = b[i]; &#125;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; merge_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125; 排序相关问题第k个数（快速排序）acwing786 leetcode215https://www.acwing.com/problem/content/788/https://www.acwing.com/solution/content/63587/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 时间复杂度：O(n), 空间复杂度: 递归栈空间O(logn)// y总 代码 没有 随机选取 x , 导致 用时比较长 44ms. 随机后 4ms// 如果 x 每次都选 nums[l] 或 nums[r], 碰到 升序或降序的 极端样例, 时间O(n^2),, 用时会很久// 而且 nums[l] 和 nums[r] 的代码边界不一样, 容易出错, 建议选 nums[l + r &gt;&gt; 1]// 选取 nums[l] 的 用时 在 40ms 左右, 选取 nums[r]需要修改一下边界情况, 没有改, 应该也40ms左右// 选取 nums[l + r &gt;&gt; 1] 跟 随机选取 nums[rand() % (r - l + 1) + l] 时间差不多, 在 4ms 左右class Solution &#123;public: int quick_select(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123; if (l &gt;= r) return nums[l]; // int i = l - 1, j = r + 1, x = nums[l + r &gt;&gt; 1]; // 选取 nums[l], 极端样例 时间会很久 int x = nums[rand() % (r - l + 1) + l], i = l - 1, j = r + 1; // 随机选取 while (i &lt; j) &#123; do i ++ ; while (nums[i] &gt; x); do j -- ; while (nums[j] &lt; x); if (i &lt; j) swap(nums[i], nums[j]); &#125; if (k &lt;= j - l + 1) return quick_select(nums, l, j, k); else return quick_select(nums, j + 1, r, k - (j - l + 1)); &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; srand(time(0)); // 随机种子 return quick_select(nums, 0, nums.size() - 1, k); &#125;作者：yxc链接：https://www.acwing.com/video/1589/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。// 时间复杂度：O(n), 空间复杂度: O(1)// y总 代码 去掉递归栈空间, 用 while 循环, 就不用 递归栈空间 了.// 原来的 递归 只是 相同的代码, 只不过 递归时 递归的参数 区间端点值 l,r 以及 k变了// 这里 while 每次循环 也是 用 相同的代码, 只不过 是 每次循环之后 将 l,r 以及 k 更新class Solution &#123;public: int quick_select(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123; while(true) &#123; if (l == r) return nums[l]; // int i = l - 1, j = r + 1, x = nums[l + r &gt;&gt; 1]; // 选取 nums[l], 极端样例 时间会很久 int x = nums[rand() % (r - l + 1) + l], i = l - 1, j = r + 1; // 随机选取 while (i &lt; j) &#123; do i ++ ; while (nums[i] &gt; x); do j -- ; while (nums[j] &lt; x); if (i &lt; j) swap(nums[i], nums[j]); &#125; // 将 递归 的 参数l,r,k变化 改为 while 循环中 l,r,k 更新, 省去递归栈空间 // if (k &lt;= j - l + 1) return quick_select(nums, l, j, k); if (k &lt;= j - l + 1) r = j; // else return quick_select(nums, j + 1, r, k - (j - l + 1)); else k = k - (j - l + 1), l = j + 1; // 注意 k更新用到 l, 所以 l 更新应该在 k更新之后 &#125; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; srand(time(0)); // 随机种子 return quick_select(nums, 0, nums.size() - 1, k); &#125;&#125;;作者：yxc链接：https://www.acwing.com/video/1589/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 注意 c++的rand()函数https://blog.csdn.net/cmm0401/article/details/54599083 123456789101112131415161718192021222324252627282930313233343536373839404142C++中rand() 函数的用法1、rand()不需要参数，它会返回一个从0到最大随机数的任意整数，最大随机数的大小通常是固定的一个大整数。2、如果你要产生0~99这100个整数中的一个随机整数，可以表达为：int num = rand() % 100; 这样，num的值就是一个0~99中的一个随机数了。3、如果要产生1~100，则是这样：int num = rand() % 100 + 1; 4、总结来说，可以表示为：int num = rand() % n +a; 其中的a是起始值，n-1+a是终止值，n是整数的范围。5、一般性：rand() % (b-a+1)+ a ; 就表示 a~b 之间的一个随机整数。6、若要产生0~1之间的小数，则可以先取得0~10的整数，然后均除以10即可得到“随机到十分位”的10个随机小数。 若要得到“随机到百分位”的随机小数，则需要先得到0~100的10个整数，然后均除以100，其它情况依 此类推。7、通常rand()产生的随机数在每次运行的时候都是与上一次相同的，这样是为了便于程序的调试。 若要产生每次不同的随机数，则可以使用srand( seed )函数进行产生随机化种子，随着seed的不同，就能够产生 不同的随机数。8、还可以包含time.h头文件，然后使用srand(time(0))来使用当前时间使随机数发生器随机化，这样就可以保证每两 次运行时可以得到不同的随机数序列，同时这要求程序的两次运行的间隔超过1秒。9、举例如下：rand（产生随机数）表头文件: #include&lt;stdlib.h&gt;定义函数 :int rand(void)函数说明 :因为rand() 的内部实现是用线性同余法做的，它不是真的随机数，只不过是因为其周期特别长，所以有一定的范围里可看成是随机的，rand() 会返回一随机数值，范围在 0 至 RAND_MAX 间。在调用此函数产生随机数前，必须先利用 srand()设置好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为 1。rand()产生的是假随机数字，每次执行时是相同的。若要不同,以不同的值来初始化它.初始化的函数就是 srand()。返回值:返回 0 至 RAND_MAX 之间的随机整数值，RAND_MAX 的范围最少是在 32767 之间（int），即双字节（16位数）。若用unsigned int 双字节是 65535，四字节是 4294967295 的整数范围。0~RAND_MAX 每个数字被选中的机率是相同的。 java随机数https://www.cnblogs.com/blogxjc/p/9687297.html","categories":[{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"字符串","slug":"dsa-string","date":"2021-08-31T07:13:08.000Z","updated":"2021-10-07T08:12:58.722Z","comments":true,"path":"2021/08/31/dsa-string/","link":"","permalink":"https://shadowbynl.github.io/2021/08/31/dsa-string/","excerpt":"对字符串相关问题进行记录","text":"对字符串相关问题进行记录 字符串匹配 朴素模式匹配 KMP算法 相关题目 leetcode214 字符串匹配朴素模式匹配 KMP算法 相关题目leetcode214https://leetcode-cn.com/problems/shortest-palindrome/ 1234567891011121314151617181920212223242526/*给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。0 &lt;= s.length &lt;= 5 * 10^4s 仅由小写英文字母组成*/class Solution &#123;public: string shortestPalindrome(string s) &#123; string t(s.rbegin(), s.rend()); int n = s.size(); s = s + &#x27;#&#x27; + t; vector&lt;int&gt; ne(n * 2 + 2); ne[0] = -1; int i = 0, k = -1; while (i &lt; s.size()) &#123; while (k &gt;= 0 &amp;&amp; s[i] != s[k]) k = ne[k]; i++; k++; ne[i] = k; //cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ne[i] &lt;&lt; &quot; &quot; &lt;&lt; s[i]&lt;&lt; endl; &#125; int len = ne[2 * n + 1]; string left = s.substr(0, len), right = s.substr(len, n - len); return string(right.rbegin(), right.rend()) + left + right; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"南软服务端开发","slug":"njuse-sever-development","date":"2021-08-30T15:42:34.000Z","updated":"2021-10-07T08:16:27.129Z","comments":true,"path":"2021/08/30/njuse-sever-development/","link":"","permalink":"https://shadowbynl.github.io/2021/08/30/njuse-sever-development/","excerpt":"南大软件本科服务端开发课程笔记","text":"南大软件本科服务端开发课程笔记","categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"}],"tags":[]},{"title":"javase之一","slug":"java-base-00","date":"2021-08-30T08:47:11.000Z","updated":"2021-10-07T08:36:32.200Z","comments":true,"path":"2021/08/30/java-base-00/","link":"","permalink":"https://shadowbynl.github.io/2021/08/30/java-base-00/","excerpt":"占位","text":"占位 为重新巩固java基础，个人决定从javase开始到微服务等过一遍java技术体系。经过几天比对，发现很多培训课程为顾及学生讲的很繁琐，b站ks的视频相对较简洁。虽然可能存在不全、不准确、资料不太够的问题，但也有很大的学习参考价值。因此从本篇开始将按照ks提供的顺序，看视频、敲代码，并在这些文档中做些笔记。https://gitee.com/kuangstudy/kuang_livenote?_from=gitee_search","categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://shadowbynl.github.io/tags/javase/"}]},{"title":"idea学习","slug":"idea-study","date":"2021-08-28T15:01:52.000Z","updated":"2021-10-07T08:12:42.387Z","comments":true,"path":"2021/08/28/idea-study/","link":"","permalink":"https://shadowbynl.github.io/2021/08/28/idea-study/","excerpt":"用了idea也快两年了，在此系统看一下idea专门的教程","text":"用了idea也快两年了，在此系统看一下idea专门的教程 模板 插件 配置 模板参考先前的配置，具体配置方法参考下面的图 使新建类默认有类注释123456/*** @Auther: nlby* @Date: $&#123;DATE&#125; $&#123;TIME&#125; * @Description: $&#123;PACKAGE_NAME&#125;* @version: 1.0*/ 自定义类注释、方法注释模板1234567891011121314151617181920212223/** * * @name $NAME$ * @author nlby * @date $DATE$ */ /** * @author nlby * @description $description$ * @updateTime $date$ $TIME$ $param$ $return$ * @throws $throws$ */ 参数groovyScript(&quot;def result=&#x27;&#x27;; def stop=false; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); if (params.size()==1 &amp;&amp; (params[0]==null || params[0]==&#x27;null&#x27; || params[0]==&#x27;&#x27;)) &#123; stop=true; &#125;; if(!stop) &#123; for(i=0; i &lt; params.size(); i++) &#123;result +=((i==0) ? &#x27;\\\\r\\\\n&#x27; : &#x27;&#x27;) + ((i &lt; params.size() - 1) ? &#x27; * @param: &#x27; + params[i] + &#x27;\\\\r\\\\n&#x27; : &#x27; * @param: &#x27; + params[i] + &#x27;&#x27;)&#125;; &#125;; return result;&quot;, methodParameters())groovyScript(&quot;def result=&#x27;&#x27;; def stop=false; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); if (params.size()==1 &amp;&amp; (params[0]==null || params[0]==&#x27;null&#x27; || params[0]==&#x27;&#x27;)) &#123; stop=true; &#125;; if(!stop) &#123; for(i=0; i &lt; params.size(); i++) &#123;result +=((i==0) ? &#x27;\\\\r\\\\n&#x27; : &#x27;&#x27;) + ((i &lt; params.size() - 1) ? &#x27; * @param: &#x27; + params[i] + &#x27;\\\\r\\\\n&#x27; : &#x27; * @param: &#x27; + params[i] + &#x27;&#x27;)&#125;; &#125;; return result;&quot;, methodParameters())返回值groovyScript(&quot;def result=&#x27;&#x27;; def data=\\&quot;$&#123;_1&#125;\\&quot;; def stop=false; if(data==null || data==&#x27;null&#x27; || data==&#x27;&#x27; || data==&#x27;void&#x27; ) &#123; stop=true; &#125;; if(!stop) &#123; result += &#x27;\\\\r\\\\n&#x27; + &#x27; * @return: &#x27; + data; &#125;; return result;&quot;, methodReturnType())groovyScript(&quot;def result=&#x27;&#x27;; def data=\\&quot;$&#123;_1&#125;\\&quot;; def stop=false; if(data==null || data==&#x27;null&#x27; || data==&#x27;&#x27; || data==&#x27;void&#x27; ) &#123; stop=true; &#125;; if(!stop) &#123; result += &#x27;\\\\r\\\\n&#x27; + &#x27; * @return: &#x27; + data; &#125;; return result;&quot;, methodReturnType()) 注意：123一般步骤：创建模板组、创建模板、指定变量值、指定对某种语言使用上述模板中的方法注释需要在方法中生成注释，否则可能参数等生成有问题，且对返回值为void的情况，还需手动修改 插件https://www.bilibili.com/video/BV1zb4y1U7Fv配置https://www.bilibili.com/video/BV1Tg4y1B7nM11. 创建一个empty project让多个模块在项目空间同级显示（没有默认父模块）","categories":[{"name":"环境","slug":"环境","permalink":"https://shadowbynl.github.io/categories/%E7%8E%AF%E5%A2%83/"}],"tags":[]},{"title":"2021年八月底总结","slug":"202108summary","date":"2021-08-27T16:35:13.000Z","updated":"2021-10-07T08:13:17.608Z","comments":true,"path":"2021/08/28/202108summary/","link":"","permalink":"https://shadowbynl.github.io/2021/08/28/202108summary/","excerpt":"在该站点重新开始维护个人博客。 从2020年2月开始接触hexo博客，其后到2020年11月左右断断续续写了一百多篇博客，但后面由于到大三的一个比较迷茫和紧张的时期就慢慢不再维护博客了，总体上先前的博客分类和标签有些混乱冗余了，同时域名也到期，图床也存在一些失效的风险，于是决定在本人的这第二个github账号下建立仓库重新开始维护一个新的个人博客，计划是长期性的，因此：域名就采用github.io的域名，图片直接存储在本地和仓库中，而先前的文章后续有时间再作整理和迁移。这篇写于2021年8月底，本人大四上学期开始前几天，算是一个大学与未来研究生生活承前启后的一个阶段，因此在该站点的这第一篇文章中打算记述一下前一段时间（保研，简要记述，详细内容以后有时间或者等完全结束再写）和之后的两个月内的一个大致的安排。","text":"在该站点重新开始维护个人博客。 从2020年2月开始接触hexo博客，其后到2020年11月左右断断续续写了一百多篇博客，但后面由于到大三的一个比较迷茫和紧张的时期就慢慢不再维护博客了，总体上先前的博客分类和标签有些混乱冗余了，同时域名也到期，图床也存在一些失效的风险，于是决定在本人的这第二个github账号下建立仓库重新开始维护一个新的个人博客，计划是长期性的，因此：域名就采用github.io的域名，图片直接存储在本地和仓库中，而先前的文章后续有时间再作整理和迁移。这篇写于2021年8月底，本人大四上学期开始前几天，算是一个大学与未来研究生生活承前启后的一个阶段，因此在该站点的这第一篇文章中打算记述一下前一段时间（保研，简要记述，详细内容以后有时间或者等完全结束再写）和之后的两个月内的一个大致的安排。 创建该站点第一篇博客的时间 简单说明一下2021年前八个月的情况 个人的一些情况 先整理下hexo相关的 技术体系重建（主要是java) 计算机基础 java基础 juc并发编程 jvm 框架 web基本技术 前端技术 附 短期安排 创建该站点第一篇博客的时间 简单说明一下2021年前八个月的情况到大三下学期，基本要确定未来的规划安排了，从寒假开始到大三下学期，一直焦虑于能否稳定保研名额，能否保到外校，因为没有经历过、信息源匮乏心态一直有些颓丧，同时还想做做考研和工作的准备，但到现在来看浪费那些时间基本没啥意义。从来没能准备周全，被各种事和人推着走。到6月底，随着计算机保研生的大流投了差不多15个左右的夏令营，毫无准备地同时应对夏令营活动和7月初的期末考试。6月20号左右由于没拿到西交的夏令营资格，使我将对夏令营的期望放到了能入营就是成功的程度上，也因此多投了很多中下游的985。后面半个月左右，是比较消耗精力的，总体上就是一个拼运气和心态的阶段。从6月25日之后，我陆续接到了北交cs、华师se、西工大cs、吉大ai、山大se、东北cs、中南cs、浙大se、南大se、本校、东南cs的入营通知，参加了其中一多半，最终也拿到了5个优营，这个结果对没啥追求的我来说已经算是确定了一些事了。后面这一个多月，总体上过得相当随性，所以即便还是有很多很久以前就想做去解决的事，到现在大四快开始了还没什么进展。纠结于保研与实习之中，在原地徘徊不定，致使现在的处境比较尴尬（hh 本来打算回家学车，结果因为暴雨和疫情一年都回不了家了，在学校每天待着浪费人生）现在也算是再做一次计划人，再做做后续的一些安排，搞搞心理建设。 个人的一些情况大学前三年学的东西太杂不够深入，也很少动手实践，因此实际现在对于编码面试的事还是不太敢尝试。总是想着必须重新建立一下技术体系，但基本没时间，也不敢去费时间去尝试。但现在的情况为今后考虑，不管是纯去做开发，还是搞几年研究，必须先把一门语言学到比较熟悉的程度。对本人来说，学了两年多java，周边技术知道不少，但很难做到随手编程实现和随口讲清相关的概念，基础相当薄弱，实践也不足，而java的相关知识是极多的，我也总是有些抗拒再头像大一时那样看起，总感觉浪法时间。但显然，越看一些概念，我越认识到我的基础到处是窟窿，不去拼一把真的是只能永远处于一个会做点简单应用但实际并不熟悉语言的程度。 先整理下hexo相关的8.27晚，经过测试我确认了： hexo editor可直接将复制的图片拷到本地对应目录下，可以直接在编辑器中显示，但上传时注意补充/images 博客主题更换 使用这位比我小三岁的大佬做的主题 https://nexmoe.com/ 更新hexo版本 参考 https://www.jianshu.com/p/98ac1e253e6e 配置gitalk https://www.cnblogs.com/bigyoung/p/14154060.html 本人第一个github账号的github.io之后作工作展示用 该账号是作日常生活学习记录用 技术体系重建（主要是java)计算机基础408相关 考研材料 面经上的问题背记 几本图解 数据结构的java实现 常用基本算法 leetcode整理 java基础 尚硅谷基础（集合异常等） 面试常考 南大se服务端开发 一入 石杉 juc并发编程 尚硅谷 大厂学院 os原理 jvm 大厂学院 框架 尚硅谷spring相关 spring全家桶 设计模式与框架模式源码解析 大厂学院 web基本技术 数据库 Mysql redis 消息队列 web基本技术 前端技术总体上，应先重点看三个部分： 计算机基础（数据结构与典型算法的多次实现 leetcode整理讲解）几本书+面经+复习资料 java基础回顾 宋+mb+面经 石杉经典问题 后续再针对各专项进入深入学习。 附相关资源 小马哥java https://ke.segmentfault.com/teacher/mercyblitz https://github.com/mercyblitzhttps://www.bilibili.com/video/BV1GT4y1P76R https://github.com/leiguorui/programming-video-tutorials 南大服务端开发 https://github.com/Software-Knowledge/2021-Server-Development 南大se git@github.com:NJU-SE-15-share-review/professional-class.git https://github.com/NJU-SE-15-share-review/professional-class 南大se笔记 https://github.com/stormbroken/SpriCoder-Notes 有配一下as环境的打算 几个南大se本科的up https://space.bilibili.com/349257951/video https://www.bilibili.com/video/BV1fh411U7KR/ taoci https://zhuanlan.zhihu.com/p/172476313 短期安排 文都几本过完 j/c面经过完 dsa稳定实现 dc数据结构整理类型 java基础 面经 + 尚 + mb 石杉","categories":[{"name":"规划","slug":"规划","permalink":"https://shadowbynl.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"android基本概念（六）","slug":"a-study-6","date":"2020-03-25T13:07:46.000Z","updated":"2021-10-07T08:24:47.449Z","comments":true,"path":"2020/03/25/a-study-6/","link":"","permalink":"https://shadowbynl.github.io/2020/03/25/a-study-6/","excerpt":"安卓常用画图类","text":"安卓常用画图类 一、概述 123• Bitmap：相当于我们绘制出来的图像，获取图像文件信息，对图像进行剪切、旋转、缩放，压缩等操作，并可以以指定格式保存图像文件。• Paint：相当于我们绘图所用的画笔，绘制几何，文本，位图的风格与颜色信息。• Canvas：相当于我们绘图所用的画布，调用方法进行图像绘制。 二、BITMAP1.作用 123• Bitmap在Android中指的是一张图片，可以是png，也可以是jpg等其他图片格式。• Bitmap是Android系统中的图像处理中最重要类之一。Bitmap可以获取图像文件信息，对图像进行剪切、旋转、缩放，压缩等操作，并可以以指定格式保存图像文件。• Bitmap是一个final类，因此不能被继承。Bitmap只有一个构造方法，且该构造方法是没有任何访问权限修饰符修饰，也就是说该构造方法是friendly。 2.内部枚举类 123456789101112• Bitmap中有两个内部枚举类：• Config是用来设置颜色配置信息的。• CompressFormat是用来设置压缩方式的。• Bitmap.Config.ALPHA_8：颜色信息只由透明度组成，占8位。• Bitmap.Config.ARGB_4444：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占4位，总共占16位。• Bitmap.Config.ARGB_8888：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置。• Bitmap.Config.RGB_565：颜色信息由R（Red），G（Green），B（Blue）三部分组成，R占5位，G占6位，B占5位，总共占16位。• Bitmap.CompressFormat.JPEG：表示以JPEG压缩算法进行图像压缩，压缩后的格式可以是&quot;.jpg&quot;或者&quot;.jpeg&quot;，是一种有损压缩。• Bitmap.CompressFormat.PNG：表示以PNG压缩算法进行图像压缩，压缩后的格式可以是&quot;.png&quot;，是一种无损压缩。• Bitmap.CompressFormat.WEBP：表示以WebP压缩算法进行图像压缩，压缩后的格式可以是&quot;.webp&quot;，是一种有损压缩，质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。美中不足的是，WebP格式图像的编码时间“比JPEG格式图像长8倍”。 3.构造 123456789101112131415161718• Bitmap的类构造函数是私有的，因此不能直接通过构造方法实例化。• 一般利用Bitmap的静态方法createBitmap()和BitmapFactory的decode系列静态方法创建Bitmap对象。• BitmapFactory类提供了4类方法用来加载Bitmap：• decodeFile()：从文件系统加载。• String sd_patch= “/sdcard/test.png”;• Bitmap bm= BitmapFactory.decodeFile(sd_path);• decodeResource()：以R.drawable.xxx的形式从本地资源中加载。• Bitmap bm = BitmapFactory.decodeResource(this.getContext().getResources(), R.drawable.pop);• decodeStream()：从输入流加载。• FileInputStream = new FileInputStream(“/sdcard/test.png”);• Bitmap bm= BitmapFactory.decodeStream(fis);• decodeByteArray()：从字节数组中加载。• Bitmap bm = BitmapFactory.decodeByteArray(myByte,0,myByte.length); 二、PAINT1.构造 1234567• Paint有3个构造方法，可以通过这3个构造方法创建Paint对象：• Paint()：用默认设置创建一个Paint对象。• Paint(int flags)：用特殊标记创建一个Paint对象：• Paint.FILTER_BITMAP_FLAG：使位图过滤的位掩码标志。• Paint.ANTI_ALIAS_FLAG：使位图抗锯齿的标志。• Paint.DITHER_FLAG：使位图进行有利的抖动的位掩码标志。• Paint(Paint paint)：用指定Paint对象的参数初始化一个新的Paint对象。 2.常用方法 123456789101112131415161718192021• Paint常用方法：• setARGB(int a, int r, int g, int b)：设置画笔颜色。• setAntiAlias(booleanaa)：设置是否抗锯齿。• setColor(int color)：设置画笔颜色。• setAlpha(int a)：设置画笔透明度。• setTextSize(float textSize)：设置字体大小。• setUnderlineText(booleanunderlineText)：设置文本带有下划线效果。• setStrikeThruText(booleanstrikeThruText)：设置文本带删除线效果。• setTextSkewX(float skewX)：设置文本倾斜度。• setTextScaleX(float scaleX)：设置文本缩放大小。• setTextAlign(Paint.Alignalign)：设置文本对齐方式。• setTypeface(Typeface typeface)：设置字体。• setStyle(Paint.Stylestyle)：设置画笔样式，画笔样式有3种：Paint.Style.FILL：默认值，用这种风格绘制的几何图与文本将被填充，它画出来的是实心图• Paint.Style.STROKE：用这种风格绘制的几何图与文本将被画出外边框，它画出来的是空心图• Paint.Style.FILL_AND_STROKE：用这种风格绘制的几何图与文本将被填充并被画出外边框，从表面看它画出来的也是实心图，不过比一般画出来的实心图多了一层外边框。• setStrokeWidth(float width)：设置画笔外边框的宽度，可以想象成画笔“画出线条的宽度”。• setXfermode(Xfermodexfermode)：设置图像重叠时的处理方式。• setShader(Shadershader)：设置着色器。• setPathEffect(PathEffecteffect)：设置或者清除路径效果。 三、CANVAS1.概述 123456• Canvas拥有“绘制”调用，可以调用方法进行图像绘制。• 画图时需要4个基本元素：• 拥有像素的Bitmap。• 可以进行绘制调用的Canvas。• 图元（比如：Rect, Path, text, Bitmap）。• 描述风格与颜色的Paint。 2.构造 123• Canvas有两个构造方法，可以通过这两个构造方法创建Canvas对象：• Canvas()：创建一个空的Canvas对象。• Canvas(Bitmap bitmap)：用指定的位图构造一个Canvas对象。 3.常用方法 12345678910111213141516• drawARGB()：用指定ARGB颜色填充画布上面的位图• drawRGB()：用指定RGB颜色填充画布上面的位图• drawColor()：用指定颜色填充画布上面的位图• drawArc()：画圆弧• drawBitmap()：画位图• drawCircle()：画圆• drawLine()：画直线• drawLines()：画折线• drawOval()：画椭圆• drawRect()：画矩形• drawRoundRect()：画圆角矩形• drawPoint()：画点• drawPoints()：画一组点• drawPath()：画路径• drawText()：画文本 ANIMATION一、概述Android Animation分为两类 12• 传统动画：包括帧动画（Frame Animation）和补间动画（Tween Animation），又称为DrawableAnimation和View Animation。• 属性动画（Property Animation）。 二、传统动画Frame Animation 123• Frame Animation（DrawableAnimation）是最容易实现的一种动画，这种动画更多的依赖于完善的UI资源。• Frame Animation的原理是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果。• 这种动画的实质其实是Drawable，所以这种动画的XML定义方式文件一般放在res/drawable/目录下。 TweenAnimation 12345678910111213141516171819202122232425262728293031323334• TweenAnimation（View Animation）可以在一个视图容器内执行一系列简单变换。譬如，有一个TextView对象，可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。• TweenAnimation 具体有4种形式：alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。• 补间动画通过XML或Android代码定义，建议使用XML文件定义，因为它更具可读性、可重用性。--------------------关于配置anime--------------------相关类名：• AlphaAnimation：渐变透明度动画效果，对应XML中的&lt;alpha&gt;，放置在res/anim/目录。• RotateAnimation：画面转移旋转动画效果，对应XML中的&lt;rotate&gt;，放置在res/anim/目录。• ScaleAnimation：渐变尺寸伸缩动画效果，对应XML中的&lt;scale&gt;，放置在res/anim/目录。• TranslateAnimation：画面转换位置移动动画效果，对应XML中的&lt;translate&gt; 放置在res/anim/目录。• AnimationSet：一个持有其它动画元素alpha、scale、translate、rotate或者其它set元素的容器，对应XML中的&lt;set&gt;，放置在res/anim/目录。Animation属性：• android:detachWallpaper：是否在壁纸上运行，对应setDetachWallpaper(boolean)。• android:duration：动画持续时间，毫秒为单位，对应setDuration(long)。• android:fillAfter：控件动画结束时是否保持动画最后的状态，对应setFillAfter(boolean) 。• android:fillBefore：控件动画结束时是否还原到开始动画前的状态，对应setFillBefore(boolean)。• android:fillEnabled：与android:fillBefore效果相同，对应setFillEnabled(boolean) 。• android:interpolator：设定插值器（指定的动画效果，譬如回弹等），对应setInterpolator(Interpolator)。• android:repeatCount：重复次数，对应setInterpolator(Interpolator)。• android:repeatMode：重复类型有两个值，reverse表示倒序回放，restart表示从头播放，对应setInterpolator(Interpolator) 。• android:startOffset：调用start函数之后等待开始运行的时间，单位为毫秒，对应setStartOffset(long)。• android:zAdjustment：表示被设置动画的内容运行时在Z轴上的位置（top/bottom/normal），默认为normal ，对应setZAdjustment(int)。• Interpolator 主要作用是可以控制动画的变化速率，就是动画进行的快慢节奏：• @android:anim/accelerate_decelerate_interpolator：动画始末速率较慢，中间加速。• @android:anim/accelerate_interpolator：动画开始速率较慢，之后慢慢加速。• AnticipateInterpolator@android:anim/anticipate_interpolator开始的时候从后向前甩。• @android:anim/anticipate_overshoot_interpolator类似上面AnticipateInterpolator。• @android:anim/bounce_interpolator：动画结束时弹起。• @android:anim/cycle_interpolator：循环播放速率改变为正弦曲线。• @android:anim/decelerate_interpolator：动画开始快然后慢。• @android:anim/linear_interpolator：动画匀速改变。• @android:anim/overshoot_interpolator：向前弹出一定值之后回到原来位置。 逐帧动画&amp; 补间动画存在一定的缺点： 123• 作用对象局限。有些情况下的动画效果只是视图的某个属性&amp; 对象而不是整个视图。• 没有改变View的属性，只是改变视觉效果。补间动画只是改变了View的视觉效果，而不会真正去改变View的属性。• 动画效果单一。补间动画只能实现平移、旋转、缩放&amp; 透明度这些简单的动画需求，一旦遇到相对复杂的动画效果，即超出了上述4种动画效果，那么补间动画则无法实现。 三、属性动画（Property Animation） 1234• 为了解决补间动画的缺陷，在Android 3.0（API 11）开始，系统提供了一种全新的动画模式：属性动画（Property Animation）。• 作用对象：任意Java 对象，不再局限于视图View对象。• 实现的动画效果：可自定义各种动画效果，不再局限于4种基本变换：平移、旋转、缩放&amp; 透明度。• 工作原理：在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果。 四、ANIMATION LISTENER 12345678910• anim.setAnimationListener(new AnimationListener() &#123;• @Override• public void onAnimationCancle(Animation animation) &#123;…&#125;• @Override• public void onAnimationStart(Animation animation) &#123;…&#125;• @Override• public void onAnimationRepeat(Animation animation) &#123;…&#125;• @Override• public void onAnimationEnd(Animation animation) &#123;…&#125;• &#125;); MEDIAPLAYER一、功能与设置源 123456789101112• Android可以通过Mediaplayer类提供的API，实现以下音频、视频文件的播放：• 自带resource资源：MediaPlayer.create(this, R.raw.test);• SD卡或其他文件路径下的媒体文件：mp.setDataSource(“/sdcard/test.mp3”);• 网络媒体文件：mp.setDataSource(&quot;http://www.citynorth.cn/music/confucius.mp3&quot;);• setDataSource一共四个方法：• setDataSource(String path) ；//文件系统路径• setDataSource(FileDescriptorfd)；//assets文件• setDataSource(Context context, Uri uri)；//网络虚拟路径• setDataSource(FileDescriptorfd, long offset, long length)；• 若URI中包含网络资源，需在AndroidManifest.xml中申请Internet访问权限：• &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 二、生命周期 123456789101112• Idle 状态：当使用new()方法创建一个MediaPlayer对象或者调用了其reset()方法时，该MediaPlayer对象处于idle状态。这两种方法的一个重要差别就是：如果在这个状态下调用了getDuration()等方法（相当于调用时机不正确），通过reset()方法进入idle状态的话会触发OnErrorListener.onError()，并且MediaPlayer会进入Error状态；如果是新创建的MediaPlayer对象，则并不会触发onError(),也不会进入Error状态。• End 状态：通过release()方法可以进入End状态，只要MediaPlayer对象不再被使用，就应当尽快将其通过release()方法释放掉，以释放相关的软硬件组件资源，这其中有些资源是只有一份的（相当于临界资源）。如果MediaPlayer对象进入了End状态，则不会在进入任何其他状态了。• Initialized 状态：这个状态比较简单，MediaPlayer调用setDataSource()方法就进入Initialized状态，表示此时要播放的文件已经设置好了。• Prepared 状态：初始化完成之后还需要通过调用prepare()或prepareAsync()方法，这两个方法一个是同步的一个是异步的，只有进入Prepared状态，才表明MediaPlayer到目前为止都没有错误，可以进行文件播放。• Preparing 状态：这个状态比较好理解，主要是和prepareAsync()配合，如果异步准备完成，会触发OnPreparedListener.onPrepared()，进而进入Prepared状态。MediaPlayer准备资源调用prepare()时，会执行一段稍长的时间，因为它在解码媒体数据，如果解码时间过长那么会出现主线程阻塞，从而触发ANR异常，导致程序运行很慢，所以框架提供了prepareAsync()异步准备方法并提供资源准备监听，当资源准备完成会触发MediaPlayer.OnPreparedListener的onPrepared()方法。• Stop 状态：Started或者Paused状态下均可调用stop()停止MediaPlayer，而处于Stop状态的MediaPlayer要想重新播放，需要通过prepareAsync()和prepare()回到先前的Prepared状态重新开始才可以。• PlaybackCompleted状态：文件正常播放完毕，而又没有设置循环播放的话就进入该状态，并会触发OnCompletionListener的onCompletion()方法。此时可以调用start()方法重新从头播放文件，也可以stop()停止MediaPlayer，或者也可以seekTo()来重新定位播放位置。• Error状态：如果由于某种原因MediaPlayer出现了错误，会触发OnErrorListener.onError()事件，此时MediaPlayer即进入Error状态，及时捕捉并妥善处理这些错误是很重要的，可以帮助我们及时释放相关的软硬件资源，也可以改善用户体验。• 通过setOnErrorListener(android.media.MediaPlayer.OnErrorListener)可以设置该监听器。如果MediaPlayer进入了Error状态，可以通过调用reset()来恢复，使得MediaPlayer重新返回到Idle状态。 三、常用方法 123456789101112131415161718192021• int getCurrentPosition()：获取当前播放的位置。• int getAudioSessionId()：返回音频的session ID。• int getDuration()：得到文件的时间。• TrackInfo[] getTrackInfo()：返回一个track信息的数组。• booleanisLooping()：是否循环播放。• booleanisPlaying()：是否正在播放。• void pause ()：暂停。• void start ()：开始。• void stop ()：停止。• void prepare()：同步的方式装载流媒体文件。• void prepareAsync()：异步的方式装载流媒体文件。• void reset()：重置MediaPlayer至未初始化状态。• void release ()：回收流媒体资源。• void seekTo(int msec)：指定播放的位置（以毫秒为单位时间）。• void setAudioStreamType(intstreamtype)：指定流媒体类型。• void setLooping(booleanlooping)：设置是否单曲循环。• void setNextMediaPlayer(MediaPlayernext)：当这个MediaPlayer播放完毕后，MediaPlayernext开始播放。• void setWakeMode(Context context, int mode)：设置CPU唤醒的状态。• void setScreenOnWhilePlaying(Boolean screenOn)：播放时是否保持屏幕常亮，是否阻止屏幕自动休眠。 四、展示控件–SurfaceView 1234567• View通过刷新来重绘视图，Android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的时间间隔为16ms。在一些需要频繁刷新，执行很多逻辑操作的时候，超过了16ms，就会导致卡顿.• SurfaceView继承自View，但拥有独立的绘制表面，即它不与其宿主窗口共享同一个绘图表面，可以单独在一个线程进行绘制，并不会占用主线程的资源。这样，绘制就会比较高效，游戏，视频播放，还有最近热门的直播，都可以用SurfaceView。SurfaceView和View的区别：• View主要适用于主动更新的情况下，而SurfaceView主要适用于被动更新，例如频繁地刷新。• View在主线程中对画面进行刷新，而SurfaceView通常会通过一个子线程来进行页面的刷新。• View在绘图时没有使用双缓冲机制，而SufaceView在底层实现机制中就已经实现了双缓冲机制。","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"android基本概念（五）","slug":"a-study-5","date":"2020-03-19T14:20:08.000Z","updated":"2021-10-07T08:24:42.140Z","comments":true,"path":"2020/03/19/a-study-5/","link":"","permalink":"https://shadowbynl.github.io/2020/03/19/a-study-5/","excerpt":"Android网络编程基础","text":"Android网络编程基础 一、基于TCP协议的网络通信1.ServerSocket建立服务端 1234567891011121314151617ServerSocket serverSocket = new ServerSocket(8888);while (true) &#123; try &#123; Socket socket = serverSocket.accept(); System.out.println(&quot;新增连接&quot; + server.getInetAddress() + &quot;:&quot; + socket.getPort()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.客户端程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.Socket;import java.net.SocketTimeoutException;public class Main2Activity extends AppCompatActivity &#123; private Context context; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; textView = (TextView)findViewById(R.id.textView); new Thread() &#123; @Override public void run() &#123; try &#123; Socket socket = new Socket(&quot;192.168.1.49&quot;, 9999); socket.setSoTimeout(3000); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String info = br.readLine(); textView.setText(&quot;Client received: &quot; + info); br.close(); socket.close(); &#125; catch (SocketTimeoutException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125;&#125; 3.服务端程序 12345678910111213141516171819package com.n;import java.io.IOException;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class help1 &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(9999); while (true) &#123; Socket socket = serverSocket.accept(); OutputStream os = socket.getOutputStream(); os.write(&quot;This is Server!&quot;.getBytes(&quot;utf-8&quot;)); os.close(); socket.close(); &#125; &#125;&#125; 二、使用URL访问网络1.访问URL网络资源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.os.Bundle;import android.widget.ImageView;import java.io.IOException;import java.io.InputStream;import java.net.MalformedURLException;import java.net.URL;public class Main3Activity extends AppCompatActivity &#123; private Context context; private ImageView imageView; private Bitmap bitmap; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; imageView = findViewById(R.id.imageView); showPicture(&quot;https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3063886216,124952448&amp;fm=26&amp;gp=0.jpg&quot;); &#125; public void showPicture(String url) &#123; new AsyncTask&lt;String, Void, String&gt;() &#123; @Override protected String doInBackground(String... strings) &#123; try &#123; URL url = new URL(strings[0]); InputStream is = url.openStream(); bitmap = BitmapFactory.decodeStream(is); is.close(); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); imageView.setImageBitmap(bitmap); &#125; &#125;.execute(url); &#125;&#125; 2.URLConnection + TomcatJavaWeb服务器端 123456789101112131415161718192021222324252627package servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class LoginServlet extends HttpServlet&#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html; charset=utf-8&quot;); req.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = resp.getWriter(); String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); if (username.equals(&quot;admin&quot;) &amp;&amp; password.equals(&quot;123&quot;)) &#123; out.print(&quot;登录成功&quot;); &#125; else &#123; out.print(&quot;登录失败&quot;); &#125; out.flush(); out.close(); &#125;&#125; 12345678&lt;servlet&gt; &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; URLConnection客户端（访问不成功） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.AsyncTask;import android.os.Bundle;import android.os.StrictMode;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class Main4Activity extends AppCompatActivity &#123; private Context context; private EditText editText, editText2; private TextView textView; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main4); context = this; editText = findViewById(R.id.editText); editText2 = findViewById(R.id.editText2); textView = findViewById(R.id.textView4); button = findViewById(R.id.button5); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; loginCheck(editText.getText().toString(), editText2.getText().toString()); &#125; &#125;); &#125; private void loginCheck(String username, String password) &#123; final String url = &quot;http://10.0.2.2:8080/servlet&quot;; final String param = &quot;username=&quot; + username + &quot;&amp;&quot; + &quot;password=&quot; + password; new AsyncTask&lt;String, Void, String&gt;() &#123; @Override protected String doInBackground(String... strings) &#123; PrintWriter out = null; BufferedReader in = null; String result = null; try &#123; URL url = new URL(strings[0]); URLConnection conn = url.openConnection(); conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36&quot;); conn.setDoInput(true); conn.setDoOutput(true); out = new PrintWriter(conn.getOutputStream()); out.print(param); in = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override protected void onPostExecute(String s) &#123; if (s != null) &#123; textView.setText(s); &#125; super.onPostExecute(s); &#125; &#125;.execute(url); &#125;&#125; 3.HttpURLConnection客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.AsyncTask;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class Main5Activity extends AppCompatActivity &#123; private Context context; private EditText editText, editText2; private TextView textView; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main5); context = this; editText = findViewById(R.id.editText); editText2 = findViewById(R.id.editText2); textView = findViewById(R.id.textView4); button = findViewById(R.id.button5); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; loginCheck(editText.getText().toString(), editText2.getText().toString()); &#125; &#125;); &#125; private void loginCheck(String username, String password) &#123; final String url = &quot;http://10.0.2.2:8080/servlet&quot;; final String param = &quot;username=&quot; + username + &quot;&amp;&quot; + &quot;password=&quot; + password; new AsyncTask&lt;String, Void, String&gt;() &#123; @Override protected String doInBackground(String... strings) &#123; PrintWriter out = null; BufferedReader in = null; String result = &quot;&quot;; try &#123; URL url = new URL(strings[0]); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36&quot;); conn.setDoInput(true); conn.setDoOutput(true); conn.setRequestMethod(&quot;POST&quot;); conn.setUseCaches(false); out = new PrintWriter(conn.getOutputStream()); out.print(param); out.flush(); out.close(); int responseCode = conn.getResponseCode(); System.out.println(responseCode); if (responseCode == HttpURLConnection.HTTP_OK) &#123; in = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override protected void onPostExecute(String s) &#123; if (s != null) &#123; textView.setText(s); &#125; super.onPostExecute(s); &#125; &#125;.execute(url); &#125;&#125; 4.注意点 123（1）Google在API23之后就不自带HttpClient了，原因是Apache不再维护HttpClient了，官方推荐使用的就是HttpURLConnection。（2）在对Tomcat的servlet进行访问时，暂时发现只有一级路由可以访问到，二级就找不到，原因未明。而且更奇怪的是，通用的路由，URLConnection访问不到，HttpURLConnection可以访问到。（3）Async有警告暂时不处理。 三、WebService 1234浏览器基本功能：地址栏 前进后退刷新 加载本地网页： file:///android_asset/与javascript交互：使用场景为加载本地网页，其中有与系统交互的逻辑网络编程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 private Context context; private WebView wv; private EditText editText; private String url; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main6); context = this; editText = findViewById(R.id.editText); initWeb(); &#125; private void initWeb() &#123; wv = findViewById(R.id.webView); //加载本地网页 wv.loadUrl(&quot;file:///android_asset/templates/all-admin-index.html&quot;); //覆盖默认通过第三方或系统浏览器打开网页的行为，使网页在WebView内打开 wv.setWebViewClient(new CustomWebViewClient()); WebSettings ws = wv.getSettings(); //启用支持JavaScript ws.setJavaScriptEnabled(true); //加载页面优先使用缓存 ws.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //设置可以访问文件 ws.setAllowFileAccess(true); //设置支持缩放 ws.setBuiltInZoomControls(true); &#125; //改写按键--返回的逻辑，实现页面的后退 @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (wv.canGoBack()) &#123; wv.goBack(); return true; &#125; else &#123; finish(); &#125; &#125; return super.onKeyDown(keyCode, event); &#125; //实现地址栏跳转、后退、前进、刷新功能 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button: &#123; url = editText.getText().toString(); editText.setText(&quot;&quot;); if (url != null &amp;&amp; url.length() &gt; 0) &#123; wv.loadUrl(url); &#125; break; &#125; case R.id.button2: &#123; wv.goBack(); break; &#125; case R.id.button3: &#123; wv.goForward(); break; &#125; case R.id.button4: &#123; wv.reload(); break; &#125; &#125; &#125; private class CustomWebViewClient extends WebViewClient &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;// view.loadUrl(url);// //返回为true是在wv中打开，false则使用其他浏览器// return true; if (url.endsWith(&quot;.apk&quot;)) &#123; return true; &#125; else if (url.startsWith(&quot;tel:&quot;)) &#123; return true; &#125; else if (url.startsWith(&quot;mailto:&quot;)) &#123; return true; &#125; else if (url.startsWith(&quot;baidu&quot;)) &#123; return true; &#125; view.loadUrl(url); return true; &#125; &#125;","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"android基本概念（四）","slug":"a-study-4","date":"2020-03-17T13:30:55.000Z","updated":"2021-10-07T08:24:35.823Z","comments":true,"path":"2020/03/17/a-study-4/","link":"","permalink":"https://shadowbynl.github.io/2020/03/17/a-study-4/","excerpt":"CONTENT PROVIDER","text":"CONTENT PROVIDER 一、ContentProvider内容提供者1.概述 123• ContentProvider即内容提供者，是Android四大组件之一。• ContentProvider为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。• Android内置的许多数据都是使用ContentProvider形式，供开发者调用的(如视频，音频，图片，通讯录等)。 123• ContentProvider提供了对底层数据存储方式的抽象。• Android框架中的一些类需要ContentProvider类型数据。• ContentProvider为应用间的数据交互提供了一个安全的环境。 2.方法 1234567• ContentProvider提供以下方法：• query：查询；• insert：插入；• update：更新；• delete：删除；• getType：得到数据类型；• onCreate：创建数据时调用的回调函数。 3.配置属性 123456789• 授权(android:authorities)：用于在系统内标识整个提供程序的符号名称。• 提供程序类名( android:name)：实现ContentProvider的类。• 启动和控制属性：这些属性决定Android 系统如何以及何时启动提供程序、提供程序的进程特性以及其他运行时设置：• android:enabled：允许系统启动提供程序的标志。• android:exported：允许其他应用使用此提供程序的标志。• android:initOrder：此提供程序相对于同一进程中其他提供程序的启动顺序。• android:multiProcess：允许系统在与调用客户端相同的进程中启动提供程序的标志。• android:process：应在其中运行提供程序的进程的名称。• android:syncable：指示提供程序的数据将与服务器上的数据同步的标志。 二、ContentResolver内容解析者1.概述 12• ContentResolver即内容解析器，程序通过ContentResolver可以访问ContentProvider提供的数据。• 使用ContentResolver对ContentProvider进行增、删、改、查的操作，应用程序开发者不需要知道ContentProvider的内部实现，ContentResolver可统一管理与不同ContentProvider间的操作。 2.URI 123• 每个ContentProvider都有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。• Android所提供的ContentProvider都存放在android.provider包当中。• ContentResolver通过URI来区别不同的ContentProvider。 12345• URI（Universal Resource Identifier, 统一资源定位符）代表要操作的数据，Android上可用的每种资源，图像、视频片段等都可以用URI来表示：• 所有联系人的URI ：content://contacts/people • 某个联系人的URI : content://contacts/people/5 • 所有图片URI : content://media/external • 某个图片的URI：content://media/external/images/media/4 三、案例代码1.自定义UserContentProvider，并用ContentResolver增加和获取数据UserContentProvider.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.example.app_data;import android.content.ContentProvider;import android.content.ContentUris;import android.content.ContentValues;import android.content.UriMatcher;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.net.Uri;import android.util.Log;public class UserContentProvider extends ContentProvider &#123; public UserContentProvider() &#123; &#125; //自定义uri private static final String TAG = &quot;UserContentProvider&quot;; static final String PROVIDER_NAME = &quot;com.example.app_data.UserContentProvider&quot;; static final String URL = &quot;content://&quot; + PROVIDER_NAME + &quot;/user&quot;; static final Uri CONTENT_URI = Uri.parse(URL); //定义uri匹配码 private static final UriMatcher MATCHER = new UriMatcher(UriMatcher.NO_MATCH); // 若不匹配采用UriMatcher.NO_MATCH(-1)返回 private static final int CODE_NOPARAM = 1; //无参 // 匹配码 private static final int CODE_PARAM = 2; //带参数 //自定义uri匹配模式 static &#123; // 对等待匹配的URI进行匹配操作，com.example.app_data.UserContentProvider/user格式 // 匹配返回CODE_NOPARAM，不匹配返回-1 无参的情况 MATCHER.addURI(&quot;com.example.app_data.UserContentProvider&quot;, &quot;user&quot;, CODE_NOPARAM); // #表示数字 com.example.app_data.UserContentProvider/user/10 // 匹配返回CODE_PARAM，不匹配返回-1 有参的情况 MATCHER.addURI(&quot;com.example.app_data.UserContentProvider&quot;, &quot;user/#&quot;, CODE_PARAM); &#125; //UserSQLiteOpenHelper中预先建好user表 private UserSQLiteOpenHelper helper; //操作数据库 private final String user_TABLE = &quot;user&quot;; //所用表名 @Override public boolean onCreate() &#123; // TODO Auto-generated method stub helper = new UserSQLiteOpenHelper(getContext(), &quot;userdb&quot;); //以上下文 和 所用数据库名为参数，此处写死了 return true; &#125; @Override public Uri insert(Uri uri, ContentValues cv) &#123; // TODO Auto-generated method stub Log.i(TAG, &quot;insert()&quot;); SQLiteDatabase db = helper.getWritableDatabase(); switch (MATCHER.match(uri)) &#123; //插入的uri无参才是正确情况 case CODE_NOPARAM: //调用sqlite的插入方法 long id = db.insert(user_TABLE, null, cv); //若主键是自增的，则返回主键值；否则为行号 Uri insertUri = ContentUris.withAppendedId(uri, id); return insertUri; default: throw new IllegalArgumentException(&quot;This is unknow uri: &quot; + uri); &#125; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub Log.i(TAG, &quot;delete()&quot;); SQLiteDatabase db = helper.getWritableDatabase(); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: //无参删除所有记录 return db.delete(user_TABLE, selection, selectionArgs); //删除所有记录 case CODE_PARAM: //有参删除uri指明的记录 long id = ContentUris.parseId(uri); //取得Uri后面的数字 String where = &quot;_id = &quot; + id; if(null != selection &amp;&amp; !(selection.trim()).equals(&quot;&quot;))&#123; where += &quot;and &quot; + selection; &#125; return db.delete(user_TABLE, where, selectionArgs); default: throw new IllegalArgumentException(&quot;This is unknow uri: &quot; + uri); &#125; &#125; @Override public int update(Uri uri, ContentValues cv, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub Log.i(TAG, &quot;update()&quot;); SQLiteDatabase db = helper.getWritableDatabase(); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: return db.update(user_TABLE, cv, selection, selectionArgs); //更新所有记录 case CODE_PARAM: long id = ContentUris.parseId(uri); //取得Uri后面的数字 String where = &quot;_id = &quot; + id; if(null != selection &amp;&amp; !(selection.trim()).equals(&quot;&quot;))&#123; where += &quot; and &quot; + selection; &#125; return db.update(user_TABLE, cv, where, selectionArgs); default: throw new IllegalArgumentException(&quot;This is unknow uri: &quot; + uri); &#125; &#125; /** * 返回对应的内容类型 * 如果返回集合的内容类型，必须以com.example.android.cursor.dir开头 * 如果是单个元素，必须以com.example.android.cursor.item开头 */ @Override public String getType(Uri uri) &#123; // TODO Auto-generated method stub Log.i(TAG, &quot;getType()&quot;); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: return &quot;com.example.android.cursor.dir/user&quot;; case CODE_PARAM: return &quot;com.example.android.cursor.item/user&quot;; default: throw new IllegalArgumentException(&quot;This is unknow uri: &quot; + uri); &#125; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String orderBy) &#123; // TODO Auto-generated method stub Log.i(TAG, &quot;query()&quot;); SQLiteDatabase db = helper.getReadableDatabase(); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: return db.query(user_TABLE, projection, selection, selectionArgs, null, null, orderBy); case CODE_PARAM: long id = ContentUris.parseId(uri); //取得Uri后面的数字 String where = &quot;_id = &quot; + id; if(null != selection &amp;&amp; !(selection.trim()).equals(&quot;&quot;))&#123; where += &quot;and &quot; + selection; &#125; return db.query(user_TABLE, projection, where, selectionArgs, null, null, orderBy); default: throw new IllegalArgumentException(&quot;This is unknow uri: &quot; + uri); &#125; &#125;&#125; UserSQLiteOpenHelper.java 123456789101112131415161718192021222324252627package com.example.app_data;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import androidx.annotation.Nullable;public class UserSQLiteOpenHelper extends SQLiteOpenHelper &#123; public UserSQLiteOpenHelper(Context context, String name) &#123; super(context, name, null, 1); &#125; public UserSQLiteOpenHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; @Override //首次创建数据库时调用，一般可写建表建库的操作 public void onCreate(SQLiteDatabase sqLiteDatabase) &#123; sqLiteDatabase.execSQL(&quot;create table if not exists user (_id integer primary key autoincrement, name text not null, password text not null)&quot;); &#125; @Override //当数据库的版本发生变化时，会自动执行 public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) &#123; &#125;&#125; Activity文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.app_data;import androidx.appcompat.app.AppCompatActivity;import android.content.ContentValues;import android.database.Cursor;import android.net.Uri;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.EditText;import android.widget.Toast;public class Main2Activity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); &#125; //增加用户 public void onClickAddUser(View view) &#123; ContentValues values = new ContentValues(); //以下的字段名是自定义表中写死的字段名，而系统提供的是static final String 需要通过相关provider调用（在里面定义） values.put(&quot;name&quot;, ((EditText)findViewById(R.id.editText)).getText().toString()); values.put(&quot;password&quot;, ((EditText)findViewById(R.id.editText2)).getText().toString()); //当前上下文的内容提供者通过uri与指定的provider建立联系 Uri uri = getContentResolver().insert(UserContentProvider.CONTENT_URI, values); Toast.makeText(getBaseContext(), uri.toString(), Toast.LENGTH_LONG * 3).show(); &#125; //获取用户信息 public void onClickRetrieveUser(View view) &#123; Cursor cursor = getContentResolver().query(UserContentProvider.CONTENT_URI , new String[]&#123;&quot;name&quot;, &quot;password&quot;&#125;, null, null, null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123;// Log.i(&quot;info&quot;, &quot;_id:&quot; + cursor.getInt(cursor.getColumnIndex(&quot;_id&quot;))); 此处绝对不能多写id 因为上面的projection就没写id字段，返回结果也不会有 Log.i(&quot;info&quot;, &quot;name:&quot; + cursor.getString(cursor.getColumnIndex(&quot;name&quot;))); Log.i(&quot;info&quot;, &quot;password:&quot; + cursor.getString(cursor.getColumnIndex(&quot;password&quot;))); &#125; cursor.close(); &#125; &#125;&#125; 2.动态获取权限 SharedPreferences一、概述 12• SharedPreferences对象指向包含键值对的文件并提供读写这些文件的简单方法。每个SharedPreferences文件由框架进行管理并且可以专用或共享。• SharedPreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/&lt;package name&gt;/shared_prefs目录下。 二、保存key-value对 步骤123• 使用Activity类的getSharedPreferences方法获取到SharedPreferences对象，指定文件名和访问权限。• 获得SharedPreferences.Editor对象，并使用该对象的putXXX方法保存key-value对。• 通过SharedPreferences.Editor的commit方法保存（提交）key-value对。 getSharedPreferences(String name, int mode)使用getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例，该方法第一个参数为实例名称（不带后缀），第二个参数为操作模式，共四种：1234• Context.MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中。可以使用Context.MODE_APPEND• Context.MODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。• MODE_WORLD_READABLE：表示当前文件可以被其他应用读取；• MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。 SharedPreferences.Editor1234567891011121314151617• 获取SharedPreferences实例之后，需要创建SharedPreferences.Editor以实现修改功能：• SharedPreferencespref = getSharedPreferences(&quot;myPref&quot;, MODE_PRIVATE);• SharedPreferences.Editoreditor = pref.edit();• 在SharedPreferences.Editor中使用putXXX方法存储键值对，并使用commit方法提交数据：• editor.putString(“name”, “刘全有&quot;);• editor.putInt(&quot;age&quot;, 25);• editor.putLong(&quot;time&quot;, System.currentTimeMillis());• editor.putBoolean(&quot;default&quot;, true);• …• editor.commit();• 使用remove方法删除SharedPreferences实例中某个键值对：• SharedPreferencespref = getSharedPreferences(&quot;myPref&quot;, MODE_PRIVATE);• SharedPreferences.Editoreditor = pref.edit();• Editor.remove(“name”);• editor.commit(); File一、Android系统文件路径说明Android应用可能访问以下文件系统路径 12345678910111213• /data/app：该文件夹存放着系统中安装的第三方应用的apk文件。Android 中应用的安装就是将应用的安装包原封不动地拷贝到/data/app 目录下，• 每个应用安装包本质上就是一个zip 格式的压缩文件。为了提升应用的启动效率，Android 会将解压出来的dex格式的应用代码文件解析提取后，缓存在/data/dalvik-cache 目录下。• /data/data：该文件夹存放存储包私有数据，对于设备中每一个安装的App，系统都会在内部存储空间的data/data 目录下以应用包名为名字自动创建与之对应的文件夹。• 用户卸载App 时，系统自动删除data/data 目录下对应包名的文件夹及其内容。• /system：通过Environment.getRootDirectory() 访问，该目录下也有一个app 目录，存放的是系统应用的apk文件。• /system/app 和/data/app 的区别为：• /system/app 里的软件获取了所有权限。• /system/app 只能root 后删除。• /system/app 文件夹有大小限制，卸载/system/app 目录下的文件并不会增加系统空间，即可用ROM 空间。• /mnt：这个目录专门用来当作挂载点挂在外部设备，如SD 卡，将会被系统视作一个文件夹，这个文件夹将会被系统嵌入到文件系统的mnt目录中，所以在/mnt目录下也会看到一个sdcard的快捷方式： 二、apk组成1.在Android APK中，除了被编译的代码以外，还可以允许存储两种资源文件： 123res：文件会被映射到R.java文件中，访问的时候直接通过资源ID即可访问，而且不能有目录结构，即不能再创建文件夹。assets：不会映射到R.java文件中，通过AssetManager来访问，能有目录结构，即可以自行创建文件夹。注意：res和assets只能读取，不能修改，每个文件大小不能超过1MB。 2.读文件 123456• 读res资源文件：• InputStreamis = getResources().openRawResource(R.drawable.pop);• 读assets资源文件：• AssetManageram = getAssets(); • InputStreamis = am.open(&quot;filename&quot;); 三、data/data 目录对于设备中每一个安装的App，系统都会在内部存储空间的data/data 目录下以应用包名为名字自动创建与之对应的文件夹。 123456789101112用户卸载App 时，系统自动删除data/data 目录下对应包名的文件夹及其内容。该目录下又把存储内容进行了分类：• data/data/包名/cache：存放的APP 的缓存信息。• data/data/包名/databases：存放APP 的数据库信息。• data/data/包名/files：存放APP 的文件信息。• data/data/包名/shared_prefs：存放APP内的SharedPreferences。• 若需要访问内部存储器data/data/包名/路径上的资源文件，可使用FileOutputStream和FileInputStream。• 若需要访问SD卡存储空间，需要先获取READ_EXTERNAL_STORAGE 或WRITE_EXTERNAL_STORAGE系统权限。• 外部存储在Android 文件系统中是sdcard目录，这里只是一个快捷方式，真正的目录是/storage/emulated/legacy 文件夹。• 仅能对data/data/包名/路径上的资源文件使用openFileOutput和openFileInput两个方法，不可进行其他操作。• 在AndroidMainfset.xml中获取SD卡文件写入、创建与删除权限： 四、上下文API 1234567891011121314151617181920212223242526272829303132333435Environment 常用方法：• getDataDirectory()：获取Android 数据目录。• getDownloadCacheDirectory()：获取Android 下载/缓存内容目录。• getExternalStorageDirectory()：获取外部存储目录即SDCard。• getExternalStorageState()：获取外部存储设备的当前状态。• getRootDirectory()：获取Android 的根目录。getExternalStorageState()：获取SD卡存储状态，返回值可能为以下一种：• MEDIA_BAD_REMOVAL：在没有挂载前存储媒体已经被移除。• MEDIA_CHECKING：正在检查存储媒体。• MEDIA_MOUNTED：存储媒体已经挂载，并且挂载点可读/写。• MEDIA_MOUNTED_READ_ONLY：存储媒体已经挂载，挂载点只读。• MEDIA_NOFS：存储媒体是空白或是不支持的文件系统。• MEDIA_REMOVED：存储媒体被移除。• MEDIA_SHARED：存储媒体正在通过USB共享。• MEDIA_UNMOUNTABLE：存储媒体无法挂载。• MEDIA_UNMOUNTED：存储媒体没有挂载。getExternalStoragePublicDirectory(String type)：提供十个公共目录用来存储相对应的文件，返回值如下：• DIRECTORY_MUSIC：/storage/emulated/0/Music• DIRECTORY_PODCASTS：/storage/emulated/0/Podcasts• DIRECTORY_RINGTONES：/storage/emulated/0/Ringtones• DIRECTORY_ALARMS：/storage/emulated/0/Alarms• DIRECTORY_NOTIFICATIONS：/storage/emulated/0/Notifications• DIRECTORY_PICTURES：/storage/emulated/0/Pictures• DIRECTORY_MOVIES：/storage/emulated/0/Movies• DIRECTORY_DOWNLOADS：/storage/emulated/0/Downloads• DIRECTORY_DCIM：/storage/emulated/0/Dcim• DIRECTORY_DOCUMENTS：/storage/emulated/0/DocumentsAndroid2.2 引入了基于扩展存储器的应用缓存目录，该目录指向大容量的扩展存储器。与应用的内存私有目录一样，缓存目录会随着应用的卸载一并删除。• 和内部存储一样，会在SD 卡的Android/data 目录下生成对应包名的文件夹：• getExternalFilesDir(type)：返回/storage/emulated/0/Android/data/包名/files。• getExternalCacheDir()：返回/storage/emulated/0/Android/data/应用包名/cache。• getObbDir()：返回/storage/emulated/0/Android/obb/包名。 五、文件API 1234567891011121314151617181920212223242526272829303132333435363738394041424344对象实例化：• File file= new File (&quot;/mnt/sdcard/test.txt&quot;);• File file= new File(&quot;/mnt/sdcard/temp&quot;, &quot;test.txt&quot;);判断文件是否存在：• file.exists();删除文件：• file.delete();创建文件夹：• file=new File(&quot;/mnt/sdcard/temp&quot;);• file.mkdir();创建文件：• File file= new File (&quot;/mnt/sdcard/temp/test.txt&quot;);• file.createNewFile();• booleanisDirectory() ：测试此File对象表示的文件是否是目录。• booleanmkdirs() ：创建包括父目录的目录。• String getAbsolutePath()：返回此对象表示的文件的绝对路径名。• String getName() ：返回此对象表示的文件的名称。• String getParent() ：返回此File对象的路径名的上一级,若路径名没有上一级，则返回null。• openFileOutput(String name,intmode);打开应用程序私有目录下的指定私有文件以写入数据，返回一个FileOutputStream对象，如果文件不存在就创建这个文件。• openFileInput(String fileName); 打开应用程序私有目录下的指定私有文件以读入数据，返回一个FileInputStream对象。openFileOutput()方法的第一参数用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。openFileOutput()方法的第二参数用于指定操作模式，有四种模式：• Context.MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。• Context.MODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。• MODE_WORLD_READABLE：表示当前文件可以被其他应用读取。• MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。• MODE_WORLD_READABLE+MODE_WORLD_WRITEABLE：既可以读又可以写。写文件：• FileOutputStreamfos = openFileOutput(fileName,MODE_PRIVATE);• byte[] bytes = message.getBytes();• fos.write(bytes);• fos.close();读文件：• FileInputStreamfin = openFileInput(fileName);• int length = fin.available();• byte[] buffer = new byte[length];• fin.read(buffer);• result = EncodingUtils.getString(buffer,ENCODING);• fin.close();","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 使用（五）","slug":"as-use-5","date":"2020-03-15T08:05:36.000Z","updated":"2021-10-07T08:25:31.012Z","comments":true,"path":"2020/03/15/as-use-5/","link":"","permalink":"https://shadowbynl.github.io/2020/03/15/as-use-5/","excerpt":"代码","text":"代码 （0）测试专用布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面4&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面3&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.1&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.25&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.4&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面1&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面2&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline17&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.55&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline18&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.7&quot; /&gt; &lt;Button android:id=&quot;@+id/button7&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面5&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.483&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button8&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面6&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button9&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面7&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.677&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt; &lt;Button android:id=&quot;@+id/button10&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面8&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （1）ScollView 滚动文本视图（未解决排版问题）布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main5Activity&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.92&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;ScrollView android:id=&quot;@+id/scrollView&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:scrollbars=&quot;none&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline5&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:singleLine=&quot;false&quot; /&gt; &lt;/ScrollView&gt; &lt;Button android:id=&quot;@+id/button5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;up&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline6&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline5&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;down&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline6&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline5&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; java 注意onTouchListner需要加注解压警告 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.annotation.SuppressLint;import android.content.Context;import android.os.Bundle;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.widget.Button;import android.widget.ScrollView;import android.widget.Scroller;import android.widget.TextView;@SuppressLint(&quot;ClickableViewAccessibility&quot;)public class Main5Activity extends AppCompatActivity implements View.OnTouchListener &#123; private Context context; private TextView tv1; private ScrollView sv1; private Button bt1; private Button bt2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main5); context = this; tv1 = findViewById(R.id.textView); tv1.setText(R.string.textView_text); sv1 = findViewById(R.id.scrollView); sv1.setOnTouchListener(this); bt1 = findViewById(R.id.button5); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sv1.scrollBy(0, -30); &#125; &#125;); bt2 = findViewById(R.id.button6); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sv1.scrollBy(0, 30); &#125; &#125;); &#125; @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; switch (motionEvent.getAction()) &#123; case MotionEvent.ACTION_MOVE: &#123; if (sv1.getScrollY() &lt;= 0) &#123; Log.i(&quot;Main&quot;, &quot;顶部状态&quot;); &#125; if (sv1.getChildAt(0).getMeasuredHeight() &lt;= sv1.getHeight() + sv1.getScrollY()) &#123; Log.i(&quot;Main&quot;, &quot;底部状态&quot;); tv1.append(getString(R.string.textView_text)); &#125; break; &#125; &#125; return false; &#125;&#125; （2）Gallery 缩略图 + ImageSwitcher 大图浏览布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main6Activity&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline7&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.18&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline8&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.52&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline9&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.02&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline10&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.86&quot; /&gt; &lt;Gallery android:id=&quot;@+id/gallery&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline7&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline9&quot; /&gt; &lt;ImageSwitcher android:id=&quot;@+id/imageSwitcher&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline8&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline7&quot; /&gt; &lt;ImageSwitcher android:id=&quot;@+id/imageSwitcher2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline10&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageSwitcher&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.view.View;import android.view.animation.AnimationUtils;import android.widget.AdapterView;import android.widget.Gallery;import android.widget.ImageSwitcher;import android.widget.ImageView;import android.widget.ViewSwitcher;import com.example.app_z.custom.ImageAdapter;public class Main6Activity extends AppCompatActivity implements ViewSwitcher.ViewFactory &#123; private Context context; private Gallery gallery; private ImageAdapter adapter; private ImageSwitcher imageSwitcher1; private ImageSwitcher imageSwitcher2; private int[] res = &#123;R.drawable.h1, R.drawable.h2, R.drawable.h3, R.drawable.h4&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main6); context = this; gallery = findViewById(R.id.gallery); adapter = new ImageAdapter(res, context); gallery.setAdapter(adapter); imageSwitcher1 = findViewById(R.id.imageSwitcher); imageSwitcher2 = findViewById(R.id.imageSwitcher2); imageSwitcher1.setFactory(this); imageSwitcher2.setFactory(this); imageSwitcher1.setInAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_in)); imageSwitcher1.setOutAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_out)); imageSwitcher2.setOutAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_in)); imageSwitcher2.setOutAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_out)); gallery.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; imageSwitcher1.setBackgroundResource(res[i % Integer.MAX_VALUE]); imageSwitcher2.setBackgroundResource(res[res.length - 1 - (i % Integer.MAX_VALUE)]); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) &#123; &#125; &#125;); &#125; @Override public View makeView() &#123; ImageView imageView = new ImageView(context); imageView.setScaleType(ImageView.ScaleType.FIT_CENTER); return imageView; &#125;&#125; （3）Log输出类型，确认/单选/复选/列表/自定义对话框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import androidx.constraintlayout.widget.ConstraintLayout;import android.app.AlertDialog;import android.content.Context;import android.content.DialogInterface;import android.os.Bundle;import android.text.Layout;import android.util.Log;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.Toast;public class Main7Activity extends AppCompatActivity &#123; private Context context; private Button button1; private Button button2; private Button button3; private Button button4; private Button button5; private Button button6; private Button button7; private Button button8; private String[] single_dialog = &#123;&quot;金星&quot;, &quot;木星&quot;, &quot;火星&quot;, &quot;水星&quot;, &quot;土星&quot;&#125;; private String[] muti_dialog = &#123;&quot;saber&quot;, &quot;violet&quot;, &quot;mikasa&quot;, &quot;yui&quot;&#125;; private String[] item_dialog = &#123;&quot;paworks&quot;, &quot;bone&quot;, &quot;whitefox&quot;, &quot;京都&quot;, &quot;madhouse&quot;&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main7); context = this; button1 = findViewById(R.id.button); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //最后日志输出结果说明，颜色并没有那么多，而且还有一种assert Log.v(&quot;tag&quot;, &quot;verbose模式，打印最详细的日志 黑色&quot;); Log.d(&quot;tag&quot;, &quot;debug级别 蓝色&quot;); Log.i(&quot;tag&quot;, &quot;info级别 绿色&quot;); Log.w(&quot;tag&quot;, &quot;warn级别 橙色&quot;); Log.e(&quot;tag&quot;, &quot;error级别 红色&quot;); &#125; &#125;); button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast toast = Toast.makeText(context, &quot;显示一条消息&quot;, Toast.LENGTH_LONG * 6); toast.setGravity(Gravity.CENTER, 0, 100); //自定义位置 LinearLayout toast_layout = (LinearLayout)toast.getView(); //设置图片 ImageView imageView = new ImageView(context); imageView.setBackgroundResource(R.drawable.v1); toast_layout.addView(imageView); toast.show(); &#125; &#125;); button3 = findViewById(R.id.button3); button3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //自定义Toast布局，事实证明约束布局无法显示 Toast toast = Toast.makeText(context, &quot;显示一条消息&quot;, Toast.LENGTH_LONG * 6); LayoutInflater inflater = LayoutInflater.from(context); View toast_layout = inflater.inflate(R.layout.toast_layout, null); toast.setView(toast_layout); toast.show(); &#125; &#125;); button4 = findViewById(R.id.button4); button4.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(&quot;确认对话框&quot;); builder.setIcon(R.drawable.v1); builder.setMessage(&quot;确认对话框提示内容&quot;); builder.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, &quot;点击了确认按钮&quot;, Toast.LENGTH_LONG * 10).show(); &#125; &#125;); builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, &quot;点击了取消按钮&quot;, Toast.LENGTH_LONG * 10).show(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button5 = findViewById(R.id.button7); button5.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //注意只有确认对话框可以设置message 其他若设置会影响项的显示 AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(&quot;单选对话框&quot;); builder.setIcon(R.drawable.v1); //builder.setMessage(&quot;单选对话框提示内容&quot;); builder.setSingleChoiceItems(single_dialog, 0, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, &quot;选择了&quot; + single_dialog[i], Toast.LENGTH_LONG * 10).show(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button6 = findViewById(R.id.button8); button6.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(&quot;多选对话框&quot;); builder.setIcon(R.drawable.v1); builder.setMultiChoiceItems(muti_dialog, null, new DialogInterface.OnMultiChoiceClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i, boolean b) &#123; if (b) &#123; Toast.makeText(context, &quot;选择了&quot; + muti_dialog[i], Toast.LENGTH_LONG * 3).show(); &#125; else &#123; Toast.makeText(context, &quot;取消选择了&quot; + muti_dialog[i], Toast.LENGTH_LONG * 3).show(); &#125; &#125; &#125;); builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; dialogInterface.dismiss(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button7 = findViewById(R.id.button9); button7.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(&quot;多选对话框&quot;); builder.setIcon(R.drawable.v1); builder.setItems(item_dialog, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, &quot;选择了&quot; + item_dialog[i], Toast.LENGTH_LONG * 3).show(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button8 = findViewById(R.id.button10); button8.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(&quot;自定义对话框&quot;); builder.setIcon(R.drawable.v1); LayoutInflater inflater = LayoutInflater.from(context); View dialog_lagout = inflater.inflate(R.layout.toast_layout, null); builder.setView(dialog_lagout); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); &#125;&#125; （4）notification状态栏 选项菜单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.Toast;import java.util.Locale;public class Main8Activity extends AppCompatActivity &#123; private Context context; private Button button1; private Button button2; private Button button3; private Button button4; private Button button5; private Button button6; private Button button7; private Button button8; private NotificationManager notificationManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main8); context = this; notificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE); button1 = findViewById(R.id.button); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0); Notification.Builder builder = new Notification.Builder(context); builder.setSmallIcon(R.drawable.v1); //设置图标 builder.setTicker(&quot;状态栏的提示&quot;); builder.setWhen(System.currentTimeMillis()); //设置时间 builder.setContentTitle(&quot;状态栏标题&quot;); builder.setContentText(&quot;状态栏通知内容&quot;); builder.setContentIntent(pendingIntent); //点击后的意图// builder.setDefaults(Notification.DEFAULT_LIGHTS); //设置指示灯// builder.setDefaults(Notification.DEFAULT_SOUND); //设置提示声音// builder.setDefaults(Notification.DEFAULT_LIGHTS); //设置振动 builder.setDefaults(Notification.DEFAULT_ALL); Notification notification = builder.build(); notificationManager.notify(1, notification); &#125; &#125;); button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() &#123; @Override //通过自定义的通知id即可取消通知 public void onClick(View view) &#123; notificationManager.cancel(1); &#125; &#125;); &#125; /* 创建选项菜单 */ @Override public boolean onCreateOptionsMenu(Menu menu) &#123; menu.add(0, 100, 1, &quot;菜单项一&quot;); //参数依次表示：分组序号、自定义id、优先级、项内容 menu.add(0, 101, 1, &quot;菜单项二&quot;); menu.add(0, 102, 1, &quot;菜单项三&quot;); return true; &#125; /* 给选项菜单列表项添加点击事件 */ @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case 100: &#123; Toast.makeText(context, &quot;点击了菜单项一&quot;, Toast.LENGTH_LONG * 3).show(); break; &#125; case 101: &#123; Toast.makeText(context, &quot;点击了菜单项二&quot;, Toast.LENGTH_LONG * 3).show(); break; &#125; case 102: &#123; Toast.makeText(context, &quot;点击了菜单项三&quot;, Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; return true; &#125;&#125; （5）上下文菜单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.ContextMenu;import android.view.MenuItem;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.Toast;import com.example.app_z.Data;public class Main9Activity extends AppCompatActivity &#123; private Context context; private ListView listView; private ArrayAdapter&lt;String&gt; adapter; private String[] vname = Data.vname; private String selected; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main9); context = this; listView = findViewById(R.id.listView); adapter = new ArrayAdapter&lt;&gt;(context, android.R.layout.simple_list_item_1, vname); listView.setAdapter(adapter); this.registerForContextMenu(listView); //注册 listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; selected = vname[i]; &#125; &#125;); &#125; @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; super.onCreateContextMenu(menu, v, menuInfo); menu.setHeaderTitle(&quot;上下文菜单&quot;); menu.setHeaderIcon(R.drawable.v1); menu.add(1, 1, 1, &quot;百度百科&quot;); menu.add(1, 2, 1, &quot;bangumi&quot;); &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case 1: &#123; Intent intent = new Intent(context, Main2Activity.class); intent.putExtra(&quot;url&quot;, &quot;https://baike.baidu.com/item/&quot; + selected); startActivity(intent); break; &#125; case 2: &#123; Toast.makeText(context, &quot;通过利用全局变量实现菜单和上下文的关联&quot;, Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; return true; &#125;&#125; （6）子菜单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.SubMenu;import android.widget.Toast;import javax.security.auth.Subject;public class Main10Activity extends AppCompatActivity &#123; private Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main10); context = this; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; SubMenu file = menu.addSubMenu(&quot;文件&quot;); SubMenu edit = menu.addSubMenu(&quot;编辑&quot;); file.setHeaderTitle(&quot;文件操作&quot;); file.setIcon(R.drawable.v1); file.add(1, 1, 1, &quot;新建&quot;); file.add(1, 2, 1, &quot;打开&quot;); file.add(1, 3, 1, &quot;保存&quot;); edit.setHeaderTitle(&quot;文本操作&quot;); edit.setIcon(R.drawable.v2); edit.add(2, 1, 1, &quot;复制&quot;); edit.add(2, 2, 1, &quot;粘贴&quot;); edit.add(2, 3, 1, &quot;剪切&quot;); return true; &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; if (item.getGroupId() == 1) &#123; switch (item.getItemId()) &#123; case 1: &#123; Toast.makeText(context, &quot;item.getTitle()不能用&quot;, Toast.LENGTH_LONG * 3).show(); break; &#125; case 2: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; case 3: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; &#125; else &#123; switch (item.getItemId()) &#123; case 1: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; case 2: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; case 3: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"android基本概念（三）","slug":"a-study-3","date":"2020-03-15T07:38:41.000Z","updated":"2021-10-07T08:24:30.065Z","comments":true,"path":"2020/03/15/a-study-3/","link":"","permalink":"https://shadowbynl.github.io/2020/03/15/a-study-3/","excerpt":"Activity生命周期","text":"Activity生命周期 一、Activity与状态改变 123456• Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件或查看地图等操作。• 每个Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。• 一个应用通常由多个彼此松散联系的Activity 组成。一般会指定应用中的某个Activity 为“主”Activity，即首次启动应用时呈现给用户的那个Activity。而且每个Activity 均可启动另一个Activity，以便执行不同的操作。每次新Activity 启动时，前一Activity 便会停止，但系统会在堆栈（“返回栈”）中保留该Activity。• 当新Activity 启动时，系统会将其推送到返回栈上，并取得用户焦点。返回栈遵循基本的“后进先出”堆栈机制，因此，当用户完成当前Activity 并按“返回”按钮时，系统会从堆栈中将其弹出（并销毁），然后恢复前一Activity。• 当一个Activity 因某个新Activity 启动而停止时，系统会通过该Activity 的生命周期回调方法通知其这一状态变化。• Activity 因状态变化—系统是创建Activity、停止Activity、恢复Activity 还是销毁Activity—而收到的回调方法可能有若干种，每一种回调都会为您提供执行与该状态变化相应的特定操作的机会。例如，停止时，您的Activity 应释放任何大型对象，例如网络或数据库连接。当Activity 恢复时，您可以重新获取所需资源，并恢复执行中断的操作。这些状态转变都是Activity 生命周期的一部分。 状态 1234567• onCreate：Activity创建时调用。• onStart：可见未获取焦点，无法与之交互。• onResume：可见已获取焦点，可与之交互。• onPause：可见，失去焦点。• onStop：不可见。• onRestart：Activity重启。• onDestory：Activity被销毁。 二、生命周期 123456789• Activity 的整个生命周期发生在onCreate() 调用与onDestroy() 调用之间。• 您的Activity 应在onCreate() 中执行“全局”状态设置（例如定义布局），并释放onDestroy() 中的所有其余资源。• 例如，如果您的Activity 有一个在后台运行的线程，用于从网络上下载数据，它可能会在onCreate() 中创建该线程，然后在onDestroy() 中停止该线程。• Activity 的可见生命周期发生在onStart() 调用与onStop() 调用之间。• 在这段时间，用户可以在屏幕上看到Activity 并与其交互。例如，当一个新Activity 启动，并且此Activity 不再可见时，系统会调用onStop()。您可以在调用这两个方法之间保留向用户显示Activity 所需的资源。• 例如，您可以在onStart() 中注册一个BroadcastReceiver以监控影响UI 的变化，并在用户无法再看到您显示的内容时在onStop() 中将其取消注册。在Activity 的整个生命周期，当Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用onStart() 和onStop()。• Activity 的前台生命周期发生在onResume() 调用与onPause() 调用之间。• 在这段时间，Activity 位于屏幕上的所有其他Activity 之前，并具有用户输入焦点。Activity 可频繁转入和转出前台—例如，当设备转入休眠状态或出现对话框时，系统会调用onPause()。• 由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待。 三、注意点常见行为与调用方法 事件处理一、概述 123456• 在Android 系统中，从用户与应用的交互中截获事件的方法不止一种。如考虑截获用户界面内的事件，则可从用户与之交互的特定视图对象中捕获事件。为此，View 类提供了多种方法。• 在您将用于构建布局的各种View 类中，您可能会注意到几种看起来适用于UI 事件的公共回调方法。当该对象上发生相应的操作时，Android 框架会调用这些方法。• 例如，在触摸一个视图对象（例如“按钮”）时，对该对象调用onTouchEvent() 方法。不过，为了截获此事件，您必须扩展View 类并重写该方法。然而，为了处理此类事件而扩展每个视图对象并不现实。• 正因如此，View 类还包含一系列嵌套接口以及您可以更加轻松定义的回调。这些接口称为事件侦听器，是您捕获用户与UI 之间交互的票证。• 尽管您通常会使用事件侦听器来侦听用户交互，但有时您确实需要扩展View 类以构建自定义组件。也许，您想扩展Button 类来丰富某些内容的样式。在这种情况下，您将能够使用该类的事件处理程序为类定义默认事件行为。• 事件侦听器是View 类中包含一个回调方法的接口。当用户与UI 项目之间的交互触发已注册此视图的侦听器时，Android 框架将调用这些方法。 二、Android事件侦听器的回调方法 1234567891011• onClick()：在View.OnClickListener中。当用户触摸项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，将调用此方法。• onLongClick()：在View.OnLongClickListener中。当用户触摸并按住项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按住适用的“Enter”键或按住轨迹球（持续一秒钟）时，将调用此方法。• onFocusChange()：在View.OnFocusChangeListener中。当用户使用导航键或轨迹球导航到或远离项目时，将调用此方法。• onKey()：在View.OnKeyListener中。当用户聚焦于项目并按下或释放设备上的硬按键时，将调用此方法。• onTouch()：在View.OnTouchListener中。当用户执行可视为触摸事件的操作时，其中包括按下、释放或屏幕上的任何移动手势（在项目边界内），将调用此方法。• onCreateContextMenu()：在View.OnCreateContextMenuListener中。当（因持续“长按”而）生成上下文菜单时，将调用此方法。请参见菜单开发者指南中有关上下文菜单的阐述。• onClick() 回调没有返回值，但是其他某些事件侦听器方法必须返回布尔值。具体原因取决于事件。• 对于这几个事件侦听器，必须返回布尔值的原因如下：• onLongClick()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。也就是说，返回true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何点击侦听器，则返回false。• onKey()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。也就是说，返回true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何按键侦听器，则返回false。• onTouch()：此方法返回一个布尔值，表示侦听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。因此，如果在收到关闭操作事件时返回false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。因此，您无需执行事件内的任何其他操作，如手势或最终操作事件。 三、事件侦听实现的三种方式 1234• 使用匿名类需要编写额外代码，安全性最高。• 使用Activity 类更为方便，可以避免加载额外的类和分配对象，但需要对View的ID进行识别，可能引入安全风险。• 使用布局文件最为简单，但无法实现比较复杂的功能。• 需要根据项目实际情况进行选择。","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"android基本概念（二）","slug":"a-study-2","date":"2020-03-15T04:09:57.000Z","updated":"2021-10-07T08:24:24.919Z","comments":true,"path":"2020/03/15/a-study-2/","link":"","permalink":"https://shadowbynl.github.io/2020/03/15/a-study-2/","excerpt":"Service","text":"Service 一、概述 可见不可交互：Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。 服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信(IPC)。例如，服务可以处理网络事务、播放音乐，执行文件I/O或与内容提供程序交互，而所有这一切均可在后台进行。 二、服务的两种状态与生命周期 两种状态 Started启动当应用组件（如Activity）通过调用startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。操作完成后，服务会自行停止运行。 Bound绑定当应用组件通过调用bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信(IPC) 跨进程执行这些操作。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 回调方法 onStartCommand()：当另一个组件（如Activity）通过调用startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。如果您实现此方法，则在服务工作完成后，需要由您通过调用stopSelf() 或stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。） onBind()：当另一个组件想通过调用bindService() 与服务绑定（例如执行RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回IBinder提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回null。 onUnbind()：当组件中断所有与服务绑定的连接时，系统调用该方法。 onRebind()：当新的组件与服务绑定，且此前它已经通过onUnbind(Intent)通知断开连接时，系统调用该方法。 onCreate()：首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用onStartCommand() 或onBind() 之前）。如果服务已在运行，则不会调用此方法。 生命周期12341.服务的整个生命周期从调用onCreate() 开始起，到onDestroy() 返回时结束。与Activity 类似，服务也在onCreate() 中完成初始设置，并在onDestroy() 中释放所有剩余资源。例如，音乐播放服务可以在onCreate() 中创建用于播放音乐的线程，然后在onDestroy() 中停止该线程。2.无论服务是通过startService() 还是bindService() 创建，都会为所有服务调用onCreate() 和onDestroy() 方法。3.服务的有效生命周期从调用onStartCommand() 或onBind() 方法开始。每种方法均有&#123;Intent 对象，该对象分别传递到startService() 或bindService()。4.对于启动服务，有效生命周期与整个生命周期同时结束（即便是在onStartCommand() 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在onUnbind() 返回时结束。 三、代码（1）布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.1&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.25&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.4&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;StartService&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;StopService&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;Button android:id=&quot;@+id/button4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;UnBindService&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;BindService&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline17&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.55&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline18&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.7&quot; /&gt; &lt;Button android:id=&quot;@+id/button5&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;播放&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.483&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;暂停&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button7&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;上一首&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.677&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt; &lt;Button android:id=&quot;@+id/button8&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;下一首&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （2）Activity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.example.app_service;import androidx.appcompat.app.AppCompatActivity;import android.app.Service;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Binder;import android.os.Bundle;import android.os.IBinder;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Context context; private Intent intent1; private Intent intent2; private ServiceConnection serviceConnection; private CustomBindService service; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; service = ((CustomBindService.CustomBinder) iBinder).getService(); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125;; &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button: &#123; intent1 = new Intent(context, CustomStartService.class); startService(intent1); break; &#125; case R.id.button2: &#123; stopService(intent1); break; &#125; case R.id.button3: &#123; intent2 = new Intent(context, CustomBindService.class); bindService(intent2, serviceConnection, Service.BIND_AUTO_CREATE); break; &#125; case R.id.button4: &#123; unbindService(serviceConnection); break; &#125; case R.id.button5: &#123; service.play(); break; &#125; case R.id.button6: &#123; service.pause(); break; &#125; case R.id.button7: &#123; service.previous(); break; &#125; case R.id.button8: &#123; service.next(); break; &#125; &#125; &#125; @Override protected void onDestroy() &#123; stopService(intent1); unbindService(serviceConnection); super.onDestroy(); &#125;&#125; （3）CustomStartService 12345678910111213141516171819202122232425262728293031323334353637package com.example.app_service;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.util.Log;public class CustomStartService extends Service &#123; public CustomStartService() &#123; &#125; @Override public void onCreate() &#123; Log.i(&quot;service&quot;, &quot;执行onCreate&quot;); super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i(&quot;service&quot;, &quot;执行onStartCommand&quot;); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; Log.i(&quot;service&quot;, &quot;执行onDestroy&quot;); super.onDestroy(); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.i(&quot;service&quot;, &quot;执行onBind&quot;); // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); &#125;&#125; （4）CustomBindService 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.app_service;import android.app.Service;import android.content.Intent;import android.content.ServiceConnection;import android.os.Binder;import android.os.IBinder;import android.util.Log;public class CustomBindService extends Service &#123; public CustomBindService() &#123; &#125; public class CustomBinder extends Binder &#123; public CustomBindService getService() &#123; return CustomBindService.this; &#125; &#125; @Override public void onCreate() &#123; Log.i(&quot;service&quot;, &quot;执行onCreate&quot;); super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.i(&quot;service&quot;, &quot;执行onBind&quot;); return new CustomBinder(); &#125; @Override public void unbindService(ServiceConnection conn) &#123; Log.i(&quot;service&quot;, &quot;执行unbindService&quot;); super.unbindService(conn); &#125; @Override public void onDestroy() &#123; Log.i(&quot;service&quot;, &quot;执行onDestroy&quot;); super.onDestroy(); &#125; public void play() &#123; Log.i(&quot;music&quot;, &quot;执行play&quot;); &#125; public void pause() &#123; Log.i(&quot;music&quot;, &quot;执行pause&quot;); &#125; public void previous() &#123; Log.i(&quot;music&quot;, &quot;执行previous&quot;); &#125; public void next() &#123; Log.i(&quot;music&quot;, &quot;执行next&quot;); &#125;&#125; BroadCast Receiver一、概述 Broadcast Receiver本质上是一个全局的监听器，属于Android四大组件之一。 Android广播分为两个方面：广播发送者、广播接收者（BroadcastReceiver） Broadcast Receiver用于监听（接收）应用发出的广播消息，并做出响应。 不同组件之间通信（包括应用内/ 不同应用之间），Android系统在特定情况下与App之间的消息通信，多线程通信。 二、实现原理 12345678• 自定义广播接收者BroadcastReceiver子类，并复写onRecvice（）方法；• 通过Binder机制向AMS（Activity Manager Service）进行注册；• 广播发送者通过Binder机制向AMS发送广播；• AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；• 消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。• 广播接收器接收到相应广播后，会自动回调onReceive()方法。• 一般情况下，onReceive方法会涉及与其他组件之间的交互，如发送Notification、启动service等。• 默认情况下，广播接收器运行在UI线程，因此，onReceive方法不能行耗时操作，否则将导致ANR（Application Not Responding）。 三、两种注册方式 静态注册：在AndroidManifest.xml里通过标签声明。 动态注册：动态注册，在代码中通过调用Context的registerReceiver（）方法进行动态注册BroadcastReceiver。 注意：Android Oreo已限制App在后台接收Intent广播信息，需要修改build.gradle中targetSdkVersion的值，使其小于等于25。 动态广播的注册销毁的时机12345• 动态广播最好在Activity的onResume()注册、onPause()注销。• 在onResume()注册、onPause()注销是因为onPause()在App死亡前一定会被执行，从而保证广播在App死亡前一定会被注销，从而防止内存泄露。• 不在onCreate() &amp; onDestory() 或onStart() &amp; onStop()注册、注销是因为：当系统因为内存不足要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。• 假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。• 但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。 两种方式的比较 四、系统广播与接收 系统广播123• Android中内置了多个系统广播（System Broadcast），只要涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播。• 当使用系统广播时，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播。• 每个广播都有特定的Intent -Filter（包括具体的action），Android系统广播action如下： 静态注册系统广播接收器 动态注册系统广播接收器 五、应用间广播和应用内广播 应用间广播的问题123• Android中的广播可以跨App直接通信（exported对于有intent-filter情况下默认值为true）。可能出现的问题：• 其他App针对性发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收广播并处理；• 其他App注册与当前App一致的intent-filter用于接收广播，获取广播具体信息。 App应用内广播（Local Broadcast）12• App应用内广播可理解为一种局部广播，广播的发送者和接收者都同属于一个App。• 相比于全局广播（普通广播），App应用内广播优势体现在：安全性高、效率高。 123• 注册广播时将exported属性设置为false，使得非本App内部发出的此广播不被接收；• 在广播发送和接收时，增设相应权限permission，用于权限验证；• 发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。 12• 使用封装好的LocalBroadcastManager类：• 使用方式上与全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将参数的context变成了LocalBroadcastManager的单一实例。 六、注意事项 对于不同注册方式的广播接收器回调OnReceive（Context context，Intent intent）中的context返回值是不一样的：1234• 对于静态注册（全局+应用内广播），回调onReceive(context, intent)中的context返回值是：ReceiverRestrictedContext；• 对于全局广播的动态注册，回调onReceive(context, intent)中的context返回值是：Activity Context；• 对于应用内广播的动态注册（LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Application Context；• 对于应用内广播的动态注册（非LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Activity Context。 其他参考（关于广播类型与特点）12345678910111213# 普通广播 同级别收到先后随机 指定优先级 是在 intent filter 里指定 android: priority 范围是-1000到1000指定优先级后，数值大的先收到截断广播（不能）也不能处理静态注册 在清单文件中 是全局有效的动态注册 优先级高于静态 缺点是 只有当前Activity在运行时才生效# 有序广播 同级别随机先收到的可以截断处理 可以传输数据之类# 异步广播 可以先发送 后注册接收者 需要加权限 七、代码（1）Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.example.app_bcr;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.content.IntentFilter;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private MyReceiver3 myReceiver3; private MyReceiver6 myReceiver6; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //动态注册与注销 @Override protected void onResume() &#123; super.onResume(); IntentFilter intentFilter = new IntentFilter(&quot;com.example.app_bcr&quot;); myReceiver3 = new MyReceiver3(); registerReceiver(myReceiver3, intentFilter); &#125; @Override protected void onPause() &#123; super.onPause(); unregisterReceiver(myReceiver3); unregisterReceiver(myReceiver6); &#125; //静态注册在清单文件中 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button: &#123; Intent intent = new Intent(); intent.putExtra(&quot;msg&quot;, &quot;这是一条普通广播&quot;); intent.setAction(&quot;com.example.app_bcr&quot;); sendBroadcast(intent); break; &#125; case R.id.button2: &#123; Intent intent = new Intent(); intent.putExtra(&quot;msg&quot;, &quot;这是一条有序广播&quot;); intent.setAction(&quot;com.example.app_bcr_o&quot;); sendOrderedBroadcast(intent, null); break; &#125; case R.id.button3: &#123; Intent intent = new Intent(); intent.putExtra(&quot;msg&quot;, &quot;这是一条异步广播&quot;); intent.setAction(&quot;com.example.app_bcr_a&quot;); sendStickyBroadcast(intent); IntentFilter intentFilter = new IntentFilter(&quot;com.example.app_bcr_a&quot;); myReceiver6 = new MyReceiver6(); registerReceiver(myReceiver6, intentFilter); break; &#125; &#125; &#125;&#125;// MyReceiver MyReceiver2 MyReceiver3接收的是 普通广播// 前两个输出的先后体现了优先级设置的作用，第三个和前两个比较体现了动态注册优先级高于静态// MyReceiver4 MyReceiver5接收的是 有序广播 在设置了优先级之后，可以实现广播的有序处理和传播// MyReceiver6接收的是 异步广播 可以看出已经不推荐使用 它能够先发送广播再注册// 注意动态注册与注销分别在onResume 和 onPause中进行// 至于系统广播，应用内广播可直接参考写 （2）清单文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.app_bcr&quot;&gt;&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot;/&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;receiver android:name=&quot;.MyReceiver6&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt;&lt;/receiver&gt; &lt;receiver android:name=&quot;.MyReceiver5&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;100&quot;&gt; &lt;action android:name=&quot;com.example.app_bcr_o&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;.MyReceiver4&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;200&quot;&gt; &lt;action android:name=&quot;com.example.app_bcr_o&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;.MyReceiver3&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; /&gt; &lt;receiver android:name=&quot;.MyReceiver2&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;100&quot;&gt; &lt;action android:name=&quot;com.example.app_bcr&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;.MyReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;200&quot;&gt; &lt;action android:name=&quot;com.example.app_bcr&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"android基本概念（一）","slug":"a-study-1","date":"2020-03-05T08:21:35.000Z","updated":"2021-10-07T08:24:16.953Z","comments":true,"path":"2020/03/05/a-study-1/","link":"","permalink":"https://shadowbynl.github.io/2020/03/05/a-study-1/","excerpt":"一、概述","text":"一、概述 （1）概述：Intent的中文意思是“意图，意向”，在Android中提供了Intent机制来协助应用间的交互与通讯，Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将Intent传递给调用的组件，并完成组件的调用。Intent不仅可用于应用程序之间，也可用于应用程序内部的Activity/Service之间的交互。因此，可以将Intent理解为不同组件之间通信的“媒介”专门提供组件互相调用的相关信息。（2）功能：Intent 是一个将要执行的动作的抽象的描述，一般来说是作为参数来使用，由Intent来协助完成android各个组件之间的通讯。比如说调用startActivity()来启动一个activity,或者由broadcaseIntent()来传递给所有感兴趣的broadcastReceiver, 再或者由startService()/bindservice()来启动一个后台的service。Intent可以启动一个Activity，也可以启动一个Service，还可以发起一个广播Broadcast。二、属性和方法: 12345678910111213141516171819202122 • component(组件) ：目的组件。 • action （动作）：用来表现意图的行动。 • category （类别）：用来表现动作的类别。 • data （数据）：表示与动作要操纵的数据。 • type （数据类型）：对于data范例的描写。 • extras （扩展信息）：扩展信息。 • Flags （标志位）：期望这个意图的运行模式。 • setClass(Context packageContext,Classcls)：设置该Intent将要启动的组件对应的类。• setClassName(Context packageContext,StringclassName)：设置该Intent将要启动的组件对应的类。• setClassName(String packageContext,StringclassName)：设置该Intent将要启动的组件对应的类。 （1）Component属性： 123456789101112131415• Component属性明确指定Intent的目标组件的类名称。 • ComponentName对象包含的构造器 ： • ComponentName(String pkg,String cls) ：创建在pkg所在包下的 cls类所对应的组件 • ComponentName(Context pkg,String cls) ：创建在pkg所在包下的 cls类所对应的组件 • ComponentName(Context pkg,Class cls)创建在pkg所在包下的cls 类所对应的组件 • 一个ComponentName需要指定包名和类名，这就可以唯一确定一 个组件类。 （2）Action属性： Action 是一个用户定义的普通字符串，代表该Intent索要完成的一个抽象“动作”。用于描述一个Android 应用程序组件，一个Intent Filter 可以包含多个Action。在AndroidManifest.xml 的Activity 定义时，可以在其节点指定一个Action列表用于标识Activity 所能接受的“动作”。 Action要完成的只是一个抽象的动作，这个动作具体由哪个组件(Activity,Service,BroadcastReceiver)来完成，Action这个字符不管。比如Android提供的标准Action：Intent.ACTION_VIEW，它只表示一个抽象的查看动作，但具体什么，启动哪个Activity来看，Intent.ACTION_VIEW并不知道—这取决于Activity的配置，只要某个Activity的配置中包含了该ACTION_VIEW，该Activity就有可能被启动。 常见的ActivityAction： 常见的Broadcast Action：（3）Category属性： Category是要执行动作的目标所具有的特质或行为归类，在Intent对象中可添加任意多个category。 常见的category（4）Data和Type: Data，也就是执行动作要操作的数据。Android中采用指向数据的一个URI来表示，如在联系人应用中，一个指向某联系人的URI可能为：content://contacts/1。 Type，即数据类型，显式指定Intent的数据类型（MIME）。一般Intent的数据类型能够根据数据本身进行判定，但是通过设置这个属性，可以强制采用显式指定的类型而不再进行推导。 在AndroidManifest.xml的标签中包含了以下几种子元素，他们定义了url的匹配规则：12345678910111213141516• android:scheme：匹配url中的前缀，除了“http”、“https”、“tel”...之外，我们可以定义自己的前缀。• android:host：匹配url中的主机名部分，如“google.com”，如果定义为“*”则表示任意主机名。• android:port：匹配url中的端口。• android:path：匹配url中的路径。&lt;activity android:name=&quot;.TargetActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.scott.intent.action.TARGET&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:scheme=&quot;scott&quot; android:host=&quot;com.scott.intent.data&quot; android:port=&quot;7788&quot; android:path=&quot;/target&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; Intent的Action和Data组合例子：（5）Extras属性 Extras属性主要用于传递目标组件所需要的额外的数据。通过putExtras()方法设置。 常用值如下所示：1234567EXTRA_BCC：存放邮件密送人地址的字符串数组。EXTRA_CC：存放邮件抄送人地址的字符串数组。EXTRA_EMAIL：存放邮件地址的字符串数组。EXTRA_SUBJECT：存放邮件主题字符串。EXTRA_TEXT：存放邮件内容。EXTRA_KEY_EVENT：以KeyEvent对象方式存放触发Intent的按键。EXTRA_PHONE_NUMBER：存放调用ACTION_CALL时的电话号码。 （6）Flag（标记） Flag（标记）用于为Intent添加额外控制标记。 常用值如下所示：123456789• FLAG_ACTIVITY_BROUGHT_TO_FRONT：这个标志一般不是由程序代码设置的，如在launchMode中设置singleTask模式时系统帮你设定。• FLAG_ACTIVITY_CLEAR_TOP：如果目标Activity已经运行于当前的Task中，则关闭Activity Stack中在此Activity上方的所有Activity，然后将此Intent传递到该Activity实例内。• FLAG_ACTIVITY_NEW_TASK：将使Activity成为一个新Task的开始。• FLAG_ACTIVITY_NO_ANIMATION：这个标志将阻止系统进入下一个Activity时应用Acitivity迁移动画。• FLAG_ACTIVITY_NO_HISTORY：新的Activity将不再历史stack中保留。一旦离开，此Activity就关闭了。 三、显式INTENT和隐式Intent 显式：直接指明Intent的接收者，可以利用Bundle传输多对数据。（Bundle bundle = getIntent().getExtras();） 隐式：不指定接收者，指定Action + Data等，因未指定接收者，其意图需要经过过滤，即需要配置INTENT FILTER来确定Intent的接收者（其实这样实现了一个Intent多个接受者，只要满足条件） INTENT FILTER：在清单文件中的接收组件中注册&emsp;（0）概述：未指定接收者的隐式Intent，需要经过Action,Category,Data三种过滤联合筛选出可以接收意图的应用或组件。接收者是其他的应用，那么配置都用android提供的应该即可，但要指定自己应用中的组件接收，则需要通过自定义Action等来具体指定注意一定是完全匹配才可接收。&emsp;（1）意图过滤器 IntentFilter翻译成中文就是“意图过滤器”，主要用来过滤隐式意图。当用户进行一项操作的时候，Android系统会根据配置的“意图过滤器”来寻找可以响应该操作的组件，服务。 例如当用户点击PDF文件的时候，Android系统就会通过设定好的意图过滤器，进行匹配测试。找到能够打开PDF文件的APP程序。（2）三重过滤 Android系统会根据我们配置的Intent Filter（意图过滤器），来进行匹配测试。匹配的时候，只会考虑三个方面：动作、数据（URI以及数据类型）和类别。 也就是说Android系统会进行“动作测试”，“数据测试”，“类别测试”，来寻找可以响应隐式意图的组件或服务。 另外，当对其他App程序开放组件和服务的时候也需要配置IntentFilter（意图过滤器），一个Activity可以配置多个。（3）具体规则:123456789101112131415161718192021对应&lt;intent-filter&gt;中的&lt;action/&gt;标签1.如果&lt;intent-filter&gt;标签中有多个&lt;action/&gt;，那么Intent请求的Action，只要匹配其中的一条&lt;action/&gt;就可以通过了这条&lt;intent-filter&gt;的动作测试。 2.如果&lt;intent-filter&gt;中没有包含任何&lt;action/&gt;，那么无论什么Intent请求都无法和这条&lt;intent-filter&gt;匹配。3.如果Intent请求中没有设定Action(动作)，那么这个Intent请求就将顺利地通过&lt;intent-filter&gt;的动作测试（前提是&lt;intent-filter&gt;中必须包含有&lt;action/&gt;，否则与第二条冲突）。对应&lt;intent-filter&gt;中的&lt;category /&gt;标签1.Intent中的类别必须全部匹配&lt;intent-filter&gt;中的&lt;category /&gt;，但是&lt;intent-filter&gt;中多余的&lt;category /&gt;将不会导致匹配失败。例如：Intent中有3个类别，而意图过滤器中定义了5个，如果Intent中的3个类别都与过滤器中的匹配，那么过滤器中的另外2个，将不会导致类别测试失败。2.注意有一个例外，Android把所有传给startActivity()的隐式意图当作他们包含至少一个类别：&quot;android.intent.category.DEFAULT&quot; （CATEGORY_DEFAULT常量）。因此，想要接收隐式意图的活动必须在它们的意图过滤器中包含&quot;android.intent.category.DEFAULT&quot;。对应&lt;intent-filter&gt;中的&lt;data&gt;标签1. &lt;data&gt;元素指定了可以接受的Intent传过来的数据URI和数据类型，当一个意图对象中的URI被用来和一个过滤器中的URI比较时，比较的是URI的各个组成部分。2. 例如：如果过滤器仅指定了一个scheme，所有该scheme的URIs都能够和这个过滤器相匹配；如果过滤器指定了一个scheme、主机名但没有路经部分，所有具有相同scheme和主机名的URIs都可以和这个过滤器相匹配，而不管它们的路经；如果过滤器指定了一个scheme、主机名和路经，只有具有相同scheme、主机名和路经的URIs才可以和这个过滤器相匹配。3. 当然，一个过滤器中的路径规格可以包含通配符，这样只需要部分匹配即可。 四、注意点经过后期编写代码，发现需要注意的几个点： action、data这些可以在构造intent时直接作为参数传入，也可以在后面用intent的相关set方法设置。 action的值除了android默认定义好的与系统有关的行为外，如果是涉及要发送intent交给对应的自定义的Activity或Service或Broadcast Receiver处理，那么一般的值应该定义成目标组件所在的包的完整的包名。 data，就目前来看，其值的指定是通过Uri.parse(uri)。 发送请求的action有一条和过滤器中的匹配即可（其实是接收的可以写多个action 但发送的只有一种action），请求时定义的category对应的接收者过滤器中必须全都有（注意DEFAULT） 例","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 使用（四）","slug":"as-use-4","date":"2020-03-04T12:34:55.000Z","updated":"2021-10-07T08:25:13.353Z","comments":true,"path":"2020/03/04/as-use-4/","link":"","permalink":"https://shadowbynl.github.io/2020/03/04/as-use-4/","excerpt":"一、代码","text":"一、代码 （1）测试专用布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面4&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面3&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.1&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.25&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.4&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面1&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面2&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline17&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.55&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline18&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.7&quot; /&gt; &lt;Button android:id=&quot;@+id/button7&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面5&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.483&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button8&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面6&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button9&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面7&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.677&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt; &lt;Button android:id=&quot;@+id/button10&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面8&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （2）ListView相关ListView主布局和列表项布局 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main2Activity&quot;&gt; &lt;ListView android:id=&quot;@+id/listView&quot; android:layout_width=&quot;409dp&quot; android:layout_height=&quot;729dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; &gt; &lt;/ListView&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;190dp&quot; android:layout_weight=&quot;1&quot; android:scaleType=&quot;centerCrop&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;130dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;TextView&quot; /&gt;&lt;/LinearLayout&gt; Activity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.SimpleAdapter;import com.example.app_e.Test;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class Main2Activity extends AppCompatActivity &#123; private Context context; private ListView lv1; private ArrayAdapter adapter1; private SimpleAdapter adapter2; private List&lt;Map&lt;String, Object&gt;&gt; dataList = new ArrayList&lt;&gt;(); private String[] texts = Test.s; private int[] pics = Test.i; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; lv1 = findViewById(R.id.listView); String[] objects = &#123;&quot;栉枝实乃梨&quot;,&quot;山田妖精&quot;,&quot;谷川柑菜&quot;,&quot;青山七海&quot;,&quot;五更琉璃（黑猫）&quot;,&quot;莓&quot;,&quot;英梨梨&quot;,&quot;空银子&quot;,&quot;尼娅&quot;,&quot;狛井莲季&quot;,&quot;小宫惠那&quot;,&quot;石动乃绘&quot;,&quot;小野寺小咲&quot;,&quot;练白龙&quot;,&quot;泰蕾莎&quot;,&quot;潮留美海&quot;,&quot;七宫智音&quot;,&quot;由比滨结衣&quot;,&quot;鲇川天理&quot;,&quot;菱川六花&quot;,&quot;桂雏菊&quot;,&quot;柏崎星奈&quot;,&quot;小豆梓&quot;,&quot;森宫苍乃&quot;,&quot;兰花·李&quot;,&quot;高宫丽娜&quot;,&quot;驹鸟莲华&quot;,&quot;婕希卡&quot;,&quot;羽川翼&quot;,&quot;一色彩羽&quot;,&quot;凉水玉青&quot;,&quot;相麻堇&quot;,&quot;冢本八云&quot;,&quot;苏茜亚&quot;,&quot;冰无小雪&quot;,&quot;三宅日向&quot;,&quot;流木野咲&quot;,&quot;法提娜&quot;,&quot;山田亚由美&quot;,&quot;科户濑伊札那&quot;,&quot;东云皐月&quot;,&quot;李莓玲&quot;,&quot;吉田一美&quot;,&quot;速水玲香&quot;,&quot;芙蓉枫&quot;,&quot;林明美&quot;,&quot;仓岛千百合&quot;,&quot;米拉洁&quot;&#125;; //adapter1 = new ArrayAdapter&lt;String&gt;(context, android.R.layout.simple_list_item_1, objects); //lv1.setAdapter(adapter1); adapter2 = new SimpleAdapter(context, getData(), R.layout.list_simple_item, new String[]&#123;&quot;pic&quot;, &quot;text&quot;&#125;, new int[]&#123;R.id.imageView, R.id.textView&#125;); lv1.setAdapter(adapter2); &#125; private List&lt;Map&lt;String, Object&gt;&gt; getData() &#123; for (int i = 0; i &lt; 48; i++) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;pic&quot;, pics[i]); map.put(&quot;text&quot;, texts[i]); dataList.add(map); &#125; return dataList; &#125;&#125; （3）GridView相关GridView主布局和列表项布局 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main3Activity&quot;&gt; &lt;GridView android:id=&quot;@+id/gridView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;1dp&quot; android:layout_marginTop=&quot;1dp&quot; android:layout_marginEnd=&quot;1dp&quot; android:layout_marginBottom=&quot;1dp&quot; android:horizontalSpacing=&quot;10dp&quot; android:verticalSpacing=&quot;10dp&quot; android:numColumns=&quot;3&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/h1&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; /&gt;&lt;/LinearLayout&gt; Activity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.EditText;import android.widget.GridView;import android.widget.ImageView;import android.widget.ListView;import android.widget.SimpleAdapter;import android.widget.TextView;import android.widget.Toast;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import com.example.app_e.Test;public class Main3Activity extends AppCompatActivity&#123; private int[] imgs = Test.i; private String[] texts = Test.s; private Context context; private GridView gv1; private SimpleAdapter adapter1; private String[] names = &#123;&quot;栉枝实乃梨&quot;,&quot;山田妖精&quot;,&quot;谷川柑菜&quot;,&quot;青山七海&quot;,&quot;五更琉璃（黑猫）&quot;,&quot;莓&quot;,&quot;英梨梨&quot;,&quot;空银子&quot;,&quot;尼娅&quot;,&quot;狛井莲季&quot;,&quot;小宫惠那&quot;,&quot;石动乃绘&quot;,&quot;小野寺小咲&quot;,&quot;练白龙&quot;,&quot;泰蕾莎&quot;,&quot;潮留美海&quot;,&quot;七宫智音&quot;,&quot;由比滨结衣&quot;&#125;; private int[] pics = &#123;R.drawable.h1,R.drawable.h2,R.drawable.h3,R.drawable.h4,R.drawable.h5,R.drawable.h6,R.drawable.h7,R.drawable.h8,R.drawable.h9,R.drawable.h10,R.drawable.h11,R.drawable.h12,R.drawable.h13,R.drawable.h14,R.drawable.h15,R.drawable.h16,R.drawable.h17,R.drawable.h18&#125;; private List&lt;Map&lt;String, Object&gt;&gt; dataList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; gv1 = findViewById(R.id.gridView); adapter1 = new SimpleAdapter(context, getData(), R.layout.grid_simple_item , new String[]&#123;&quot;pic&quot;, &quot;name&quot;&#125;, new int[]&#123;R.id.imageView3, R.id.textView2&#125;); gv1.setAdapter(adapter1); gv1.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;// ImageView iv1 = findViewById(R.id.imageView4);// TextView tv1 = findViewById(R.id.textView3);// iv1.setImageResource(imgs[i]);// tv1.setText(texts[i]); Intent intent = new Intent(context, Main4Activity.class); intent.putExtra(&quot;index&quot;, i); startActivity(intent); &#125; &#125;); &#125; private List&lt;Map&lt;String, Object&gt;&gt; getData() &#123; for (int i = 0; i &lt; 18; i++) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;pic&quot;, pics[i]); map.put(&quot;name&quot;, names[i]); dataList.add(map); &#125; return dataList; &#125;&#125; （4）Spinner 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ImageView;import android.widget.Spinner;import com.example.app_e.Test;public class Main5Activity extends AppCompatActivity &#123; private Context context; private ImageView iv1; private Spinner sp1; private ArrayAdapter adapter1; private int selected; //数据源 private int[] pics = Test.i; private String[] items = Test.objects; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main5); context = this; //实例化 iv1 = findViewById(R.id.imageView2); sp1 = findViewById(R.id.spinner); //适配器 adapter1 = new ArrayAdapter&lt;String&gt;(context, android.R.layout.simple_spinner_item, items); adapter1.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); //设置 sp1.setAdapter(adapter1); //选择项方法 sp1.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; iv1.setImageResource(pics[i]); selected = i; iv1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String url = &quot;https://baike.baidu.com/item/&quot; + items[selected]; Intent intent = new Intent(context, Main7Activity.class); intent.putExtra(&quot;url&quot;, url); startActivity(intent); &#125; &#125;); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) &#123; &#125; &#125;); &#125;&#125; （5）DatePicker和TimePicker 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import java.util.Calendar;import android.app.DatePickerDialog;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.DatePicker;import android.widget.TextView;import android.widget.TimePicker;public class Main6Activity extends AppCompatActivity &#123; private Context context; private DatePicker dp1; private TimePicker tp1; private DatePickerDialog dpd1; private TextView tv1; private Button bt1; private Calendar cal; private int year; private int month; private int day; private int hour; private int minute; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main6); context = this; cal = Calendar.getInstance(); year = cal.get(Calendar.YEAR); month = cal.get(Calendar.MONTH) + 1; day = cal.get(Calendar.DAY_OF_MONTH); hour = cal.get(Calendar.HOUR); minute = cal.get(Calendar.MINUTE); String date = year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;; setTitle(date); dp1 = findViewById(R.id.datePicker); tp1 = findViewById(R.id.timePicker); tv1 = findViewById(R.id.textView4); bt1 = findViewById(R.id.button6); dp1.init(year, month - 1, day, new DatePicker.OnDateChangedListener() &#123; @Override public void onDateChanged(DatePicker datePicker, int i, int i1, int i2) &#123; year = i; month = i1 + 1; day = i2; String date = year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;; tv1.setText(date); &#125; &#125;); tp1.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() &#123; @Override public void onTimeChanged(TimePicker timePicker, int i, int i1) &#123; hour = i; minute = i1; String time = year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot; + hour + &quot;时&quot; + minute + &quot;分&quot;; tv1.setText(time); &#125; &#125;); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, MainActivity.class); startActivity(intent); &#125; &#125;); &#125;&#125; 布局文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main6Activity&quot;&gt; &lt;TimePicker android:id=&quot;@+id/timePicker&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:headerBackground=&quot;#000000&quot; android:calendarViewShown=&quot;false&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline14&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline13&quot; /&gt; &lt;DatePicker android:id=&quot;@+id/datePicker&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:headerBackground=&quot;#000000&quot; android:calendarViewShown=&quot;false&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline13&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.493&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@id/guideline12&quot; app:layout_constraintVertical_bias=&quot;0.114&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline12&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.02&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline13&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.46&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline14&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.9&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline15&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.98&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline16&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.7&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline15&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline16&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline14&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;返回&quot; android:textSize=&quot;20sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline15&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toEndOf=&quot;@+id/textView4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline14&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （6）WebView清单文件开启权限 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; Activity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.KeyEvent;import android.webkit.WebResourceRequest;import android.webkit.WebSettings;import android.webkit.WebView;import android.webkit.WebViewClient;public class Main7Activity extends AppCompatActivity &#123; private Context context; private WebView wv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main7); context = this; init(); &#125; private void init() &#123; Intent intent = getIntent(); String url = intent.getStringExtra(&quot;url&quot;); wv = findViewById(R.id.webView); wv.loadUrl(url); //覆盖默认通过第三方或系统浏览器打开网页的行为，使网页在WebView内打开 wv.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); //返回为true是在wv中打开，false则使用其他浏览器 return true; &#125; &#125;); WebSettings ws = wv.getSettings(); //启用支持JavaScript ws.setJavaScriptEnabled(true); //加载页面优先使用缓存 ws.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); &#125; //改写按键--返回的逻辑，实现页面的后退 @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (wv.canGoBack()) &#123; wv.goBack(); return true; &#125; else &#123; finish(); &#125; &#125; return super.onKeyDown(keyCode, event); &#125;&#125; （7）ProgressBar布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main8Activity&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline19&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.02&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline20&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.1&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline21&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.18&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline25&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.26&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline22&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.25&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline23&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline24&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.75&quot; /&gt; &lt;Button android:id=&quot;@+id/button11&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;增加&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline21&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline22&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline20&quot; /&gt; &lt;Button android:id=&quot;@+id/button12&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;4dp&quot; android:layout_marginEnd=&quot;6dp&quot; android:text=&quot;减少&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline21&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline23&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline22&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline20&quot; /&gt; &lt;Button android:id=&quot;@+id/button13&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;7dp&quot; android:layout_marginTop=&quot;4dp&quot; android:text=&quot;重置&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline21&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline24&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline23&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline20&quot; /&gt; &lt;Button android:id=&quot;@+id/button14&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;3dp&quot; android:layout_marginEnd=&quot;6dp&quot; android:text=&quot;返回&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline21&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline24&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline20&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline20&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline19&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView5&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline25&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline21&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; Activity代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ProgressBar;import android.widget.TextView;public class Main8Activity extends AppCompatActivity implements View.OnClickListener &#123; private Context context; private ProgressBar pb1; private TextView tv1; private Button bt1; private Button bt2; private Button bt3; private Button bt4; private int first; private int second; private int max; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main8); context = this; init(); &#125; private void init() &#123; pb1 = findViewById(R.id.progressBar); tv1 = findViewById(R.id.textView5); bt1 = findViewById(R.id.button11); bt2 = findViewById(R.id.button12); bt3 = findViewById(R.id.button13); bt4 = findViewById(R.id.button14); first = pb1.getProgress(); second = pb1.getSecondaryProgress(); max = pb1.getMax(); tv1.setText(&quot;第一进度条百分比为&quot; + (int)((float)first/max * 100) + &quot;% 第二进度条百分比为&quot; + (int)((float)second/max * 100) + &quot;%&quot;); bt1.setOnClickListener(this); bt2.setOnClickListener(this); bt3.setOnClickListener(this); bt4.setOnClickListener(this); &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button11: &#123; pb1.incrementProgressBy(10); pb1.incrementSecondaryProgressBy(10); break; &#125; case R.id.button12: &#123; pb1.incrementProgressBy(-10); pb1.incrementSecondaryProgressBy(-10); break; &#125; case R.id.button13: &#123; pb1.setProgress(0); pb1.setSecondaryProgress(10); break; &#125; case R.id.button14: &#123; Intent intent = new Intent(context, MainActivity.class); startActivity(intent); break; &#125; &#125; first = pb1.getProgress(); second = pb1.getSecondaryProgress(); max = pb1.getMax(); tv1.setText(&quot;第一进度条百分比为&quot; + (int)((float)first/max * 100) + &quot;% 第二进度条百分比为&quot; + (int)((float)second/max * 100) + &quot;%&quot;); &#125;&#125; （8）ViewPager子视图布局v1.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.2&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.02&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; android:textSize=&quot;30sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 主视图代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.example.app_s;import androidx.appcompat.app.AppCompatActivity;import androidx.viewpager.widget.PagerTabStrip;import androidx.viewpager.widget.ViewPager;import android.content.Context;import android.content.Intent;import android.graphics.Color;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.Toast;import com.example.app_s.custom.CustomPagerAdapter;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private Context context; private List&lt;View&gt; viewList; private List&lt;String&gt; titleList; private ViewPager vp; private PagerTabStrip tag; private Button bt1; private Button bt2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; //获得视图对象，加入视图列表，标题加入标题列表 viewList = new ArrayList&lt;&gt;(); titleList = new ArrayList&lt;&gt;(); View v1 = View.inflate(context, R.layout.v1, null); View v2 = View.inflate(context, R.layout.v2, null); viewList.add(v1); viewList.add(v2); titleList.add(&quot;页面一&quot;); titleList.add(&quot;页面二&quot;); //针对各个视图获取控件实例，编写逻辑实现代码 bt1 = v1.findViewById(R.id.button); bt2 = v2.findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, Main2Activity.class); startActivity(intent); &#125; &#125;); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Log.i(&quot;tag&quot;, &quot;测试无误&quot;); //Toast.makeText(context, &quot;测试无误&quot;, Toast.LENGTH_LONG); &#125; &#125;); //创建设置适配器 vp = findViewById(R.id.viewPager); CustomPagerAdapter customPagerAdapter = new CustomPagerAdapter(viewList, titleList); vp.setAdapter(customPagerAdapter); //设置页面标题的属性，虽然此处报错，但可以生效 tag = findViewById(R.id.tag);// tag = (PagerTabStrip)vp.getTag(); tag.setBackgroundColor(Color.BLACK); tag.setTextColor(Color.WHITE); tag.setDrawFullUnderline(false); tag.setTabIndicatorColor(Color.YELLOW); &#125;&#125; 自定义PagerAdapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.example.app_s.custom;import android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.viewpager.widget.PagerAdapter;import java.util.List;public class CustomPagerAdapter extends PagerAdapter &#123; private List&lt;View&gt; viewList; private List&lt;String&gt; titleList; public CustomPagerAdapter(List&lt;View&gt; viewList, List&lt;String&gt; titleList) &#123; this.viewList = viewList; this.titleList = titleList; &#125; /* 返回的是页卡的数量 */ @Override public int getCount() &#123; return viewList.size(); &#125; /* 判断页卡是否来自对象 */ @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) &#123; return view == object; &#125; /* 实例化一个页卡 */ @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) &#123; container.addView(viewList.get(position)); return viewList.get(position); &#125; /* 销毁一个页卡 */ @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; container.removeView(viewList.get(position)); &#125; /* 给每个视图添加标题 */ @Nullable @Override public CharSequence getPageTitle(int position) &#123; return titleList.get(position); &#125;&#125; （9）图片轮播ViewFlipper主布局 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main3Activity&quot;&gt; &lt;ViewFlipper android:id=&quot;@+id/viewFlipper&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 进出效果（anim文件夹下）left_in.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;2000&quot; android:fromXDelta=&quot;-100%p&quot; android:toXDelta=&quot;0&quot;/&gt; &lt;alpha android:fromAlpha=&quot;0.5&quot; android:toAlpha=&quot;1&quot; android:duration=&quot;2000&quot;/&gt;&lt;/set&gt; left_out.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;2000&quot; android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;100%p&quot;/&gt; &lt;alpha android:fromAlpha=&quot;1&quot; android:toAlpha=&quot;0.5&quot; android:duration=&quot;2000&quot;/&gt;&lt;/set&gt; Activity代码 1234567891011121314151617181920212223242526272829303132333435package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.widget.ImageView;import android.widget.ViewFlipper;public class Main3Activity extends AppCompatActivity &#123; private Context context; private ViewFlipper vf; private int[] pic = &#123;R.drawable.h1, R.drawable.h2, R.drawable.h3, R.drawable.h4&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; vf = findViewById(R.id.viewFlipper); for (int i = 0; i &lt; pic.length; i++) &#123; vf.addView(getImageView(pic[i])); &#125; vf.setInAnimation(context, R.anim.left_in); vf.setOutAnimation(context, R.anim.left_out); vf.setFlipInterval(3000); vf.startFlipping(); &#125; private ImageView getImageView(int p) &#123; ImageView imageView = new ImageView(context); imageView.setImageResource(p); return imageView; &#125;&#125; （10）Fragment静态加载fragment_blank.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;占位&quot; android:textSize=&quot;30sp&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;跳转&quot; android:textSize=&quot;30sp&quot;/&gt;&lt;/LinearLayout&gt; BlankFragment.java 1234567891011121314151617181920212223package com.example.app_n;import android.content.Context;import android.net.Uri;import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;public class BlankFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_blank, container, false); &#125;&#125; Main2Activity.java 1234567891011121314151617181920212223242526272829303132package com.example.app_n;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class Main2Activity extends AppCompatActivity &#123; private Context context; private Button bt1; private TextView tv1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; bt1 = findViewById(R.id.button6); tv1 = findViewById(R.id.textView2); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; tv1.setText(&quot;fragment静态加载&quot;); &#125; &#125;); &#125;&#125; （11）Fragment动态加载fragment_blank_fragment2.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;占位&quot; android:textSize=&quot;30sp&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;跳转&quot; android:textSize=&quot;30sp&quot;/&gt;&lt;/LinearLayout&gt; BlankFragment2.java 1234567891011121314151617181920212223242526272829303132333435package com.example.app_n;import android.content.Context;import android.net.Uri;import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.TextView;public class BlankFragment2 extends Fragment &#123; private Button bt1; private TextView tv1; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment View view = inflater.inflate(R.layout.fragment_blank_fragment2, container, false); tv1 = view.findViewById(R.id.textView2); bt1 = view.findViewById(R.id.button6); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; tv1.setText(&quot;fragment动态加载&quot;); &#125; &#125;); return view; &#125;&#125; Main3Activity.java 1234567891011121314151617181920212223package com.example.app_n;import androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentTransaction;import android.os.Bundle;public class Main3Activity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); BlankFragment2 blankFragment = new BlankFragment2(); FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); //注意这个R.id.frame表示的是放置fragment的布局控件 fragmentTransaction.add(R.id.frame, blankFragment); fragmentTransaction.commit(); &#125;&#125; （12）音乐播放将音频文件放在资源文件夹raw下 1234private MediaPlayer mp = new MediaPlayer();mp = MediaPlayer.create(this, R.raw.h);mp.start(); （13）无标题栏主题配置 1android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot; 参考：https://blog.csdn.net/lvxiangan/article/details/82783667 二、说明 经实践，以上代码均可较容易地重用。 存在问题，ListView和GridView的列表项无法用约束布局，导致显示效果有问题；Fragment主布局和自身布局均无法使用约束布局；DatePickerDialog和TimePickerDialog存在api版本问题报错，因而未进行完整测试，ProgressBarDialog同理；DatePicker和TimePicker的大小调整和日历显示存在问题。 学习项目：引导动画和过渡动画，自定义适配器等。 关于上篇RecycleListView的说明：事实上，RecycleView才是一种视图控件，而RecycleListView与其无关，不应使用和混淆，参考： https://blog.csdn.net/github_37130188/article/details/89648136https://blog.csdn.net/yuan1244487110/article/details/90401874https://blog.csdn.net/allen315410/article/details/40379159?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 使用（三）","slug":"as-use-3","date":"2020-03-01T02:43:06.000Z","updated":"2021-10-07T08:25:06.566Z","comments":true,"path":"2020/03/01/as-use-3/","link":"","permalink":"https://shadowbynl.github.io/2020/03/01/as-use-3/","excerpt":"一、AndroidManifest","text":"一、AndroidManifest 二、数据源–适配器–视图（使用默认适配器，视图ListView GridView）#### 三、案例实现 四、后续学习 全局配置 gradle模块此部分配置是放在build.gradle中，包括sdk版本等 组件配置四种组件的功能–注册–必要的标签利用intent-filter(可视为组件名片)实现组件间通信的方法 权限配置申请权限：https://www.cnblogs.com/AAAI/p/10899381.html权限参考：http://www.bejson.com/doc/AndroidManifest/自定义权限： 可以实现不同应用间组件的通信或阻止通信保护组件 二、数据源–适配器–视图（使用默认适配器，视图ListView GridView）#### 必要步骤layout 将ListView/GridView脱入主布局（约束布局）activity中 建立控件私有变量 并一定要先在onCreate中实例化 创建数据源分两类：a.格式单一的数据，由数组、集合等存储，常用的就是ArrayAdapter所用的字符串数组b.格式复杂的数据，由特定泛型的集合存储List&lt;Map&lt;Object,Object&gt;&gt;，一个Map表示一项（可包含文字图片）b类数据源涉及：定义私有数据源dataList 重写方法getData来给dataList添加数据并返回 定义适配器及设置数据源与SimpleAdapter的列表项布局准备根据两类数据源，分别对应两类适配器（常用情况下如此，但实际上还有重写适配器等实现方法，后面会记述）a.ArrayAdapter（数据源一般为字符串数组）b.SimpleAdapter（数据源一般为map列表） 特别注意参数（1） ArrayAdapter(上下文this,默认列表项布局(ID),数据源)常用的列表项布局是simple_list_item_1；android.R.layout中全部布局的效果参考：https://blog.csdn.net/qq_36408196/article/details/82819024 ，这些布局都是只有一个TextView，因此数据源只能是字符串数组；当然也可以自定义列表项布局，可能能实现展现其他形式数据的目的，也可以使用重写适配器的方法，这些以后再进行实践验证。总之，一般的ArrayAdapter使用就使用simple_list_item_1展示字符串。（2） SimpleAdapter(上下文this,数据源getData(),自定义列表项布局（ID),自定义数据源dataList中Map所有键的数组String[] from,对应Map每个键的列表项布局中控件的id组成的数组int[] to)后两个参数实现了定义数据源的map的键和布局文件中控件id的映射； 由参数可知，定义SimpleAdapter前，需先布局好列表项的形式和数据源形式（定义getData()方法）；SimpleAdapter必须自定义列表项布局，列表项如何布局与使用为ListView/GridView有关自定义列表项布局（1）应选择线性布局（2）ListView 案例布局参考：list_simple_item.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;190dp&quot; android:layout_weight=&quot;1&quot; android:scaleType=&quot;centerCrop&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;130dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;TextView&quot; /&gt;&lt;/LinearLayout&gt; （3）GridView 案例布局参考：grid_simple_item.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/h1&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; /&gt;&lt;/LinearLayout&gt; 关键是android:gravity=”center”为使GridView生效，还应该在主布局中加上三个属性设置： 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main3Activity&quot;&gt; &lt;GridView android:id=&quot;@+id/gridView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;1dp&quot; android:layout_marginTop=&quot;1dp&quot; android:layout_marginEnd=&quot;1dp&quot; android:layout_marginBottom=&quot;1dp&quot; android:horizontalSpacing=&quot;10dp&quot; &lt;!--需加--&gt; android:verticalSpacing=&quot;10dp&quot; &lt;!--需加--&gt; android:numColumns=&quot;3&quot; &lt;!--自定义列数--&gt; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （4）就以上两种布局，均存在无法自适应，显示有问题的缺陷，需要以后实践改善重写适配器（1）参考：https://blog.csdn.net/qq_33399371/article/details/76285726https://blog.csdn.net/whycmpx/article/details/80580913https://www.cnblogs.com/penghuster/p/5001161.html（2）后续实践3. 给视图实例对象添加适配器4. 实现点击列表项事件方法，滚动方法（1）列表项从零计数 倒数第二个参数是点击的标号position（2）滚动事件 可实现动态增加数据源 三、案例实现（1）使用urlib爬取图片和描述，并用正则处理文本图片 123456789101112131415161718192021from urllib.request import urlopenfrom urllib.request import Requestimport requestsfrom lxml import etreeurl = &quot;https://baijiahao.baidu.com/s?id=1597344111243871701&amp;wfr=spider&amp;for=pc&quot;request = Request(url)response = urlopen(request)html = response.read()s = str(html, encoding=&quot;utf-8&quot;)# l = re.findall(&#x27;&lt;img class=&quot;large&quot; data-loadfunc=0 src=&quot;(.+)&quot; data-loaded=0&#x27;, s)exml = etree.HTML(s)links = exml.xpath(&quot;//img[@class=&#x27;large&#x27;]/@src&quot;)count = 1for l in links[1:]: request = Request(l) response = urlopen(request) path = &quot;p&quot; + str(count) + &quot;.jpg&quot; with open(path, &quot;wb&quot;) as f: f.write(response.read()) f.flush() count = count + 1 描述 12345678910111213141516from urllib.request import urlopenfrom urllib.request import Requestimport requestsfrom lxml import etreeurl = &quot;https://baijiahao.baidu.com/s?id=1597344111243871701&amp;wfr=spider&amp;for=pc&quot;request = Request(url)response = urlopen(request)html = response.read()s = str(html, encoding=&quot;utf-8&quot;)# l = re.findall(&#x27;&lt;img class=&quot;large&quot; data-loadfunc=0 src=&quot;(.+)&quot; data-loaded=0&#x27;, s)exml = etree.HTML(s)ss = exml.xpath(&quot;//div[@class=&#x27;article-content&#x27;]//span[@class=&#x27;bjh-p&#x27;]//text()&quot;)with open(&quot;2.txt&quot;, &quot;a&quot;) as f: for s in ss: f.write(s + &quot;\\n&quot;) f.flush() （2） 跳转页面时实现传输数据参考：https://jingyan.baidu.com/article/d621e8da20c67f2865913fe6.html 1234567//发送Intent intent = new Intent(context, target.class);intent.putExtra(key, value);startActivity(intent);//接收Intent intent = getIntent();//再由intent调用具体getExtra()方法获取 四、后续学习RecycleListView参考：https://blog.csdn.net/gongch0604/article/details/89025024https://blog.csdn.net/morgerton/article/details/78983976https://www.jianshu.com/p/b4bb52cdbeb7https://www.jianshu.com/p/4f9591291365重写适配器参考：https://blog.csdn.net/qq_33399371/article/details/76285726https://blog.csdn.net/whycmpx/article/details/80580913https://www.cnblogs.com/penghuster/p/5001161.html","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 使用（二）","slug":"as-use-2","date":"2020-02-27T08:18:48.000Z","updated":"2021-10-07T08:25:00.544Z","comments":true,"path":"2020/02/27/as-use-2/","link":"","permalink":"https://shadowbynl.github.io/2020/02/27/as-use-2/","excerpt":"基本控件练习","text":"基本控件练习 一、Activity Andoid四大组件：ActicityServiceBroadcastReceiverContent Provider Activity是一个应用程序组件，提供用户与程序交互的界面 Activity创建与注册：继承与自动生成的MainActivity相同的父类，在清单文件中注册。12345678910&lt;!-- 新建模块时自动生成的Activity --&gt;&lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;!-- 表示应用程序的首启动项 --&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;!-- 新创建的第二个Activity 会自动注册 --&gt;&lt;activity android:name=&quot;.Main2Activity&quot;&gt;&lt;/activity&gt; Activity生命周期 二、页面跳转 Intent可以理解为信使（意图），由其来协助完成Android各个组件间的通讯。 两种跳转方式：第一个Activity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.app_t;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private Button bt1; private Button bt2; private TextView tv1; private Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; //第一种跳转方式 简单的跳转到另一个页面 bt1 = findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //第一个参数为上下文对象，因匿名内部类无法直接取到外部类this，因此事先定义并赋this //第二个参数是目标Activity的类对象 Intent intent = new Intent(context, Main2Activity.class); startActivity(intent); &#125; &#125;); //第二种跳转方式 会携带请求码，与重写的onActivity方法接收的响应码共同决定一个指定操作，可获得返回数据 bt2 = findViewById(R.id.button2); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, Main2Activity.class); startActivityForResult(intent, 1); &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == 1 &amp;&amp; resultCode == 2) &#123; String content = data.getStringExtra(&quot;data&quot;); tv1 = findViewById(R.id.textView); tv1.setText(content); &#125; &#125;&#125; 第二个Activity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.app_t;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class Main2Activity extends AppCompatActivity &#123; private Button bt1; private Button bt2; private TextView tv1; private Context context; private String content = &quot;第二种跳转方法返回&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; //第一种跳转返回 bt1 = findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, MainActivity.class); startActivity(intent); &#125; &#125;); //第二种跳转返回 bt2 = findViewById(R.id.button2); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent data = new Intent(); //设置响应数据 data.putExtra(&quot;data&quot;, content); setResult(2, data); //此处必须有finish finish(); &#125; &#125;); &#125;&#125; 三、实践细节 现在Empty Activity继承的是AppCompatActivity而非Activity，其区别可参考：https://blog.csdn.net/today_work/article/details/79300181https://blog.csdn.net/u012602304/article/details/90756655 现在获取控件实例不需类型转换 四、基本控件练习（部分） 做了一个小案例，结合了TextView，EditText，ImageView，Button，ImageButton，ToggleButton，CheckBox，RadioGroup，RadioButton，CalendarView控件，基本上熟悉了基本界面的绘制和事件的设置。 问题与细节（1）绘制布局首先要用guideline划分好区域，并在xml文件中手动修改百分比为可控值，这是保证布局在真机上显示正常（完整不重叠）的先决条件，实践证明guideline非常重要且极有作用。参考： https://www.jianshu.com/p/862caaceccb1https://www.jianshu.com/p/a4a5f8c91fdehttps://www.jianshu.com/p/2ab12ba05dc8（2）关于控件属性设置的经验：显示文本的控件切忌高度要wrap， 不能充满约束，否则很可能显示不出来文本；显示图像和日历的控件水平垂直均充满约束；其他按钮等若要显示文本的，高度也是wrap。（3）关于继承父类的问题：在实现跑马灯效果时，发现as推荐继承的是AppCompatTextView，这个不影响什么， 但属性里关于focus的两个属性必须去掉，否则无法生效。参考： https://www.cnblogs.com/merbn/p/11351459.htmlhttps://blog.csdn.net/zhangphil/article/details/81388186https://www.jianshu.com/p/6e232196c511（4）关于如何在app里添加音乐： https://blog.csdn.net/pythontojava/article/details/48058087 https://blog.csdn.net/qq_31939617/article/details/79969796（5）连接逍遥模拟器的命令： adb connect 127.0.0.1:21503（6）关于ImageView 的 ScaleType 属性： https://www.jianshu.com/p/e046b4201289https://www.jianshu.com/p/b8e75430f3dchttps://blog.csdn.net/qq_34902522/article/details/76682293（7）关于android的文档：https://www.runoob.com/android/android-resources.htmlhttps://blog.csdn.net/whitenebula/article/details/81171095https://developer.android.google.cn/reference/android/widget/TextView?hl=enhttps://developer.android.google.cn/guide/topics/ui/declaring-layouthttps://www.jianshu.com/p/a567c5cf8e1ahttps://blog.csdn.net/carson_ho/category_5959547.html（8）需要特别注意的一点是，as设计页面可能不会显示部分控件，如本机的DatePicker、TimePicker等，既然无法直接拖动放置，那么就只能手动在xml文件中输入，自然会出现。（9）关于CalendarView：https://www.jianshu.com/p/0c06f71d0be8 主要代码MainActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example.app_f;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.ToggleButton;public class MainActivity extends AppCompatActivity &#123; private MediaPlayer mp = new MediaPlayer(); private Button bt1; private Context context; private ToggleButton tbt1; private ToggleButton tbt2; private ImageView iv1; private ImageView iv2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mp =MediaPlayer.create(this, R.raw.h); mp.start(); context = this; // Button 添加点击事件，跳转至第二页面 bt1 = findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mp.stop(); Intent intent = new Intent(context, Main2Activity.class); startActivity(intent); &#125; &#125;); //ToggleButton 和 ImageView结合使用，切换图片 tbt1 = findViewById(R.id.toggleButton3); iv1 = findViewById(R.id.imageView); tbt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (tbt1.getText().equals(getString(R.string.button3_text))) &#123; iv1.setImageResource(R.drawable.yml); &#125; else &#123; iv1.setImageResource(R.drawable.lrd); &#125; &#125; &#125;); tbt2 = findViewById(R.id.toggleButton4); iv2 = findViewById(R.id.imageView3); tbt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (tbt2.getText().equals(getString(R.string.button4_text))) &#123; iv2.setImageResource(R.drawable.gn); &#125; else &#123; iv2.setImageResource(R.drawable.st); &#125; &#125; &#125;); &#125;&#125; Main2Activity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.example.app_f;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.ImageButton;import android.widget.RadioButton;import android.widget.RadioGroup;import android.widget.TextView;import android.widget.Toast;public class Main2Activity extends AppCompatActivity &#123; private MediaPlayer mp = new MediaPlayer(); private ImageButton ibt1; private Context context; private TextView tv1; private TextView tv2; private RadioGroup rg1; private RadioButton rb1; private Button bt1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); mp = MediaPlayer.create(this, R.raw.z); mp.start(); context = this; //ImageButton 添加点击事件 跳回第一页面 ibt1 = findViewById(R.id.imageButton); ibt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mp.stop(); Intent intent = new Intent(context, MainActivity.class); startActivity(intent); &#125; &#125;); //为文字添加点击方法，以第二种形式跳转至第三页面 tv1 = findViewById(R.id.textView2); tv1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, Main3Activity.class); startActivityForResult(intent, 2); &#125; &#125;); tv2 = findViewById(R.id.textView3); //为最后的选择提供跳转 rg1 = findViewById(R.id.radioGroup); bt1 = findViewById(R.id.button3); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (tv2.getText().length() &gt; 0) &#123; int selected = rg1.getCheckedRadioButtonId(); if (selected == R.id.radioButton2) &#123; mp.stop(); Intent intent = new Intent(context, Main4Activity.class); startActivity(intent); &#125; else &#123; mp.stop(); Intent intent = new Intent(context, Main5Activity.class); startActivity(intent); &#125; &#125; if (tv2.getText() == null) &#123; Toast.makeText(context, &quot;为实现你的目的，请点击下方红字&quot;, Toast.LENGTH_LONG * 3); &#125; &#125; &#125;); &#125; //显示第三页面返回的结果 @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == 2 &amp;&amp; resultCode == 3) &#123; String content = data.getStringExtra(&quot;content&quot;); tv2.setText(content); &#125; &#125;&#125; Main3Activity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.example.app_f;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.CalendarView;import android.widget.CheckBox;import android.widget.EditText;import android.widget.Toast;public class Main3Activity extends AppCompatActivity &#123; private EditText et1; private EditText et2; private CalendarView cv1; private CheckBox cb1; private CheckBox cb2; private CheckBox cb3; private CheckBox cb4; private Button bt1; private String content; private Context context; private String date = &quot;&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; et1 = findViewById(R.id.editText); et2 = findViewById(R.id.editText2); cv1 = findViewById(R.id.calendarView); cb1 = findViewById(R.id.checkBox); cb2 = findViewById(R.id.checkBox2); cb3 = findViewById(R.id.checkBox3); cb4 = findViewById(R.id.checkBox4); bt1 = findViewById(R.id.button2); //拼凑结果 bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent data = new Intent(); StringBuffer sb = new StringBuffer(); if (et1.getText().length() &gt; 0) &#123; sb.append(&quot;你最怨恨的事是：&quot;); sb.append(et1.getText()); &#125; else &#123; Toast.makeText(context, &quot;输入不完整，重新输入&quot;, Toast.LENGTH_LONG * 3).show(); &#125; if (et2.getText().length() &gt; 0) &#123; sb.append(&quot;\\n&quot;); sb.append(&quot;你最怨恨的人是：&quot;); sb.append(et2.getText()); &#125; else &#123; Toast.makeText(context, &quot;输入不完整，重新输入&quot;, Toast.LENGTH_LONG * 3).show(); &#125; sb.append(&quot;\\n你选择的执行时间是&quot;); sb.append(date); sb.append(&quot;\\n你选择的本司员工为：&quot;); if (cb1.isChecked()) &#123; sb.append(cb1.getText() + &quot; &quot;); &#125; if (cb2.isChecked()) &#123; sb.append(cb2.getText() + &quot; &quot;); &#125; if (cb3.isChecked()) &#123; sb.append(cb3.getText() + &quot; &quot;); &#125; if (cb4.isChecked()) &#123; sb.append(cb4.getText() + &quot; &quot;); &#125; //Log.i(&quot;tag&quot;, date); //设置响应数据 content = sb.toString(); data.putExtra(&quot;content&quot;, content); setResult(3, data); finish(); &#125; &#125;); //获取选择的日期 cv1.setOnDateChangeListener(new CalendarView.OnDateChangeListener() &#123; @Override public void onSelectedDayChange(@NonNull CalendarView calendarView, int i, int i1, int i2) &#123; date = i + &quot;年&quot; + i1 + &quot;月&quot; + i2 + &quot;日&quot;; &#125; &#125;); &#125;&#125;","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 使用（一）","slug":"as-use-1","date":"2020-02-26T14:38:14.000Z","updated":"2021-10-07T08:24:53.556Z","comments":true,"path":"2020/02/26/as-use-1/","link":"","permalink":"https://shadowbynl.github.io/2020/02/26/as-use-1/","excerpt":"as使用：问题与解决参考（2020.2.25-2.26）","text":"as使用：问题与解决参考（2020.2.25-2.26） 一、消除清单文件的黄色警告 参考：https://blog.csdn.net/LJX_ahut/article/details/89711478&emsp;https://blog.csdn.net/qq_35003588/article/details/104192062 两种方法，我采用的是修改gradle文件,在module的build.gradle 的android {}下添加: 123lintOptions &#123; disable &#x27;GoogleAppIndexingWarning&#x27; &#125; 二、解决新增控件时布局xml文件中的报错 问题：This view is not constrained, it only has designtime positions；原因是默认约束布局，需要给控件添加约束，可以自己添加，也可以自动添加。 自动添加参考：2.x版本：https://www.jianshu.com/p/dcb76b24bbe9 https://www.jianshu.com/p/723811aa4dfe 3.x版本：https://blog.csdn.net/qunqunstyle99/article/details/81209031 https://blog.csdn.net/bssynhdjzmh/article/details/79728625 三、关于约束布局的使用（重点） 重点参考：csdn guolin：https://blog.csdn.net/guolin_blog/article/details/53122387 https://www.jianshu.com/p/6c9950d1789b 其他：https://www.jianshu.com/p/ac450f6386ee https://blog.csdn.net/guolin_blog https://www.jianshu.com/p/eff62726ea84 https://www.jianshu.com/p/81f85d761aa9 https://www.jianshu.com/p/6c9950d1789b 说明：约束布局因有发挥可视化开发优势、效率等优势（具体见上链接），而较为推荐使用，有很大的灵活性，可以自由根据自己想法调整空间具体位置、大小。要想继续学习控件，首先要知道约束布局下怎样给控件添加约束。 蓝图视图可以帮助你更清晰地查看约束和 guidelines (辅助线)，而不会被内容或背景分散注意力。 控件间垂直对齐是指控件竖直的中心线在同一条竖线上，将两控件的左右两边对应连起来或者连到相同的地方即可；水平对齐指控件水平方向的中心线在同一条横线上，将两控件上下两边对应相连或者连到相同的地方即可。 为使文字显示完全，垂直方向应用wrap，和约束没有关系。 四、关于基本控件 TextView和EditView ImageView 实际和预览不一致的可能性较大，最好将其作为组件而非背景。 Button和ImageButton：onClick事件 监听器 OnClickListner接口 R文件在生成文件夹中，不可改变，存放各控件和资源文件对应的id java文件中获取控件 返回的是View类型，需要类型转换 监听事件的三种写法：（1）匿名内部类： 是监听接口的实现类，每个控件可以实现自己独立的动作（2）外部类： 可以执行外部父类和内部匿名子类两种动作,适用于多个控件有共同动作和自己独立动作的情况 （3）接口方式实现：当前Activity实现监听器接口，需要绑定监听事件的实例调用set监听器方法，参数为this 给控件绑定监听事件的一般流程：（1）实例化控件（私有属性、类型转换、id）；（2）按照三种方法实现监听事件，注意set监听器的方法是监听器的实例。 属性：关于控件的相关尺寸，用dp，文字用sp AutoCompleteTextView和MultiAutoCompleteTextView均有自动匹配输入的功能：（1）AutoCompleteTextView均有属性completionThreshold=”n”，即设置输入n个字符时开始匹配，匹配产生的内容是自定义的；实现方法：由id获得控件实例，创建一个适配器，创建数据源并交给适配器，将适配器与控件实例绑定；（2）MultiAutoCompleteTextView与前者的区别在于支持一次输入的多关键词匹配，每次匹配的是分隔符之后的内容，需要指定分隔符；实现方法：前几步与前者同，此外还需要设置分隔符。 多状态按钮ToggleButton：实现通过更改ToggleButton状态来切换图片。实现方法：获取按钮和图片实例，给按钮设置监听器setOnCheckedChangedListner，实现监听方法切换图片源。 复选框CheckBox实现多选效果：CheckBox可单独使用，可多个共同使用；具有checked属性，默认为false;设置监听器setOnCheckedChangedListner RadioGroup与RadioButton：RadioButton不能单独使用；RadioGroup是RadioButton的集合，提供多选一的机制，可由orientation属性决定水平还是竖直排布；设置RadioGroup的监听器setOnCheckedChangedListner（注意是RadioGroup包下的） 五、一些效果的实现 使用TextView实现跑马灯效果:（1）修改布局文件控件属性的方法仅对单个TextView有效；（2）采 用自定义TextView的方法，重载isFocused方法，并在布局文件中指明；（3）注：所谓跑马灯实现，一个是内容当行单行显示+内容隐藏；一个是保持焦点，后者只有通过自定义控件类的方法才可使多个控件能同时具有焦点，从而实现效果。","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"https://shadowbynl.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"数据","slug":"数据","permalink":"https://shadowbynl.github.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"规划","slug":"规划","permalink":"https://shadowbynl.github.io/categories/%E8%A7%84%E5%88%92/"},{"name":"环境","slug":"环境","permalink":"https://shadowbynl.github.io/categories/%E7%8E%AF%E5%A2%83/"},{"name":"项目","slug":"项目","permalink":"https://shadowbynl.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"https://shadowbynl.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"随机","slug":"随机","permalink":"https://shadowbynl.github.io/categories/%E9%9A%8F%E6%9C%BA/"},{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"},{"name":"随记","slug":"随记","permalink":"https://shadowbynl.github.io/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"语法","slug":"语法","permalink":"https://shadowbynl.github.io/categories/%E8%AF%AD%E6%B3%95/"},{"name":"大四","slug":"大四","permalink":"https://shadowbynl.github.io/categories/%E5%A4%A7%E5%9B%9B/"},{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://shadowbynl.github.io/tags/javase/"},{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]}