{"meta":{"title":"Memory","subtitle":"永远相信美好的事情即将发生","description":null,"author":"nlby","url":"https://shadowbynl.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2021-08-28T04:29:51.390Z","updated":"2021-08-28T04:22:33.454Z","comments":true,"path":"archive.html","permalink":"https://shadowbynl.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"工具之一：一个爬虫小demo","slug":"tool-00","date":"2021-10-04T12:27:12.000Z","updated":"2021-10-07T08:19:00.362Z","comments":true,"path":"2021/10/04/tool-00/","link":"","permalink":"https://shadowbynl.github.io/2021/10/04/tool-00/","excerpt":"2021.10.04 恰逢绿群换届，加入绿群半年多了，深感绿群给我认识上的帮助还是不小的，为表纪念，编程实现一下把两个绿群当前的群成员信息（为了以后还能留在里面，得每天早上打卡了，）","text":"2021.10.04 恰逢绿群换届，加入绿群半年多了，深感绿群给我认识上的帮助还是不小的，为表纪念，编程实现一下把两个绿群当前的群成员信息（为了以后还能留在里面，得每天早上打卡了，） 先前的工作 实现 问题与参考 总结 先前的工作根据前两三天的测试，发现只能通过网页版群管理网站访问自己加入群的信息，且初始群成员仅显示几十条，随手动刷新变化，因此 121 需要登录信息cookie2 需要调整访问参数或者自己创建客户端 后面用chrome + postman进行了接口测试发现仿照chrome对接口https://qun.qq.com/cgi-bin/qun_mgr/search_group_members 的请求，自己填写请求头和cookie很难访问成功，后通过postman的拦截器，拦截到请求（主要是headers），再手动设置cookie，可以请求到数据，但现在两天后已经失效了，需要重新考虑，并且经过测试一次请求的数据最多为40条 那么 1 手动调整参数2 编程实现 1决定还是用python实现，有python脚本且python写爬虫和操作数据库简单多了 实现在用复杂方法实现之前，先试试能不能用xpath抓到不能 以下为成功实现（json数据存储在文本中，解析后的数据存入数据库） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import requestsimport jsonimport datetimeimport pymysqldef get_data(st, end): url = &quot;https://qun.qq.com/cgi-bin/qun_mgr/search_group_members&quot; payload=&#x27;bkn=17&amp;end=%d&amp;gc=60&amp;sort=0&amp;st=%d&#x27; % (end, st) print(payload) headers = &#123; &#x27;sec-ch-ua&#x27;: &#x27;&quot;Google Chrome&quot;;v=&quot;93&quot;, &quot; Not;A Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;93&quot;&#x27;, &#x27;Accept&#x27;: &#x27;application/json, text/javascript, */*; q=0.01&#x27;, &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;, &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;, &#x27;sec-ch-ua-mobile&#x27;: &#x27;?0&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36&#x27;, &#x27;sec-ch-ua-platform&#x27;: &#x27;&quot;Windows&quot;&#x27;, &#x27;Sec-Fetch-Site&#x27;: &#x27;same-origin&#x27;, &#x27;Sec-Fetch-Mode&#x27;: &#x27;cors&#x27;, &#x27;Sec-Fetch-Dest&#x27;: &#x27;empty&#x27;, &#x27;cookie&#x27;: &#x27;pgv_pvid=4807424512; RK=CnitUqaOzk; ptcz=2bff5fa480b335df4dea5136dd81406309b8f15f73ff199cd4a10aab809851c6; ptui_loginuin=1029253541@qq.com; o_cookie=1029253541; pac_uid=1_1029253541; pt_sms_phone=152******68; tvfe_boss_uuid=64df391d6a4d651e; luin=o1029253541; lskey=000100000e1cf2eae4b33b52500045ff70be94a0d1970a5bef9d1b131ed869f75fa730c46612f21ab51145fd; pgv_info=ssid=s7817371752; rv2=8071853B4A6553C74DF68DE54D4BA72CAE91A028BB765C5D46; property20=A93EDBD10D788C397EE1080CE04FEC49CCE5ED74FAD10405A78EB5850B3C3DFDDFD043AC9328A585; uin=o3347893023; _qpsvr_localtk=0.05728061992185873; p_uin=o3347893023; traceid=4260966dcc; midas_openid=F7D08CE2D8B70939D1A41C59F768CFD3; midas_openkey=BF1126A37F21BE7734072884A99E4C88; skey=@rLW4zF2XC; pt4_token=dFtpDgb38HJDsbh-LofFjunN7VgVFhV-nb62YQdGqDo_; p_skey=C9bpnITdlIJZ2w2697GG4yD4w*v*ccsw76wzZN6J-qA_; traceid=3bf6119017&#x27; &#125; response = requests.request(&quot;POST&quot;, url, headers=headers, data=payload) content = response.text # print(response.text) return contentdef parse(content, file): with open(file, &quot;a&quot;, encoding=&#x27;utf-8&#x27;) as f: f.write(content + &quot;\\n&quot;) # 转换为python对象 data = json.loads(content) mems = data[&quot;mems&quot;] conn = pymysql.connect(host=&quot;ip&quot;, port=3306, user=&quot;root&quot;, password=&quot;pwd&quot;, database=&quot;ggu&quot;, charset=&quot;utf8mb4&quot;) for mem in mems: qq_id = mem[&quot;uin&quot;] qq_name = mem[&quot;nick&quot;] print(qq_name) qq_card = mem[&quot;card&quot;] qq_age = str(mem[&quot;qage&quot;]) qq_join_time = mem[&quot;join_time&quot;] dateArray = datetime.datetime.utcfromtimestamp(qq_join_time) qq_join_time = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) qq_speak_time = mem[&quot;last_speak_time&quot;] dateArray = datetime.datetime.utcfromtimestamp(qq_speak_time) qq_speak_time = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) cursor = conn.cursor() sql = &quot;INSERT INTO membera(qq_id, qq_name, qq_card, qq_age, qq_join_time, qq_speak_time) VALUES (%s, %s, %s, %s, %s, %s);&quot; cursor.execute(sql, [qq_id, qq_name, qq_card, qq_age, qq_join_time, qq_speak_time]) conn.commit() cursor.close()# timeStamp = 1591780240# dateArray = datetime.datetime.utcfromtimestamp(timeStamp)# otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)# print(otherStyleTime)if __name__ == &#x27;__main__&#x27;: for st in range(0, 2800, 40): content = get_data(st, st + 40) parse(content, file=&quot;membera.txt&quot;) 问题与参考 python时间戳转换日期格式 https://www.runoob.com/python3/python-timstamp-str.html 123456import datetime timeStamp = 1557502800dateArray = datetime.datetime.utcfromtimestamp(timeStamp)otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)print(otherStyleTime) python json解析 https://www.runoob.com/python/python-json.html python格式化字符串 https://www.cnblogs.com/wilber2013/p/4641616.html python循环 https://www.cnblogs.com/anyview/p/5569016.html utf8编码和utf8mb4编码的差别 存数据库时报错 Incorrect string value: &#39;\\\\xF0\\\\x9F\\\\x92\\\\xAD\\\\xF0\\\\x9F... 经查是字段编码导致（原为utf8三字节存不下，需要换成utf8mb4四字节，注意必须在字段设计上换，单纯更改数据库编码不行）https://blog.csdn.net/qq_36090463/article/details/82353327https://blog.csdn.net/qq_17555933/article/details/101445526 总结 利用postman捕获分析请求有助于获取一般难以爬取的信息，且提供了多种语言的脚本，可以说作用很大了 utf8和utf8mb4的区别","categories":[{"name":"工具","slug":"工具","permalink":"https://shadowbynl.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"java爬虫相关","slug":"jaspider","date":"2021-10-01T13:36:45.000Z","updated":"2021-10-07T08:36:12.445Z","comments":true,"path":"2021/10/01/jaspider/","link":"","permalink":"https://shadowbynl.github.io/2021/10/01/jaspider/","excerpt":"占位","text":"占位 爬虫：采集–处理–存储用途：实现搜索引擎 获取更多的数据源 进行搜索引擎优化","categories":[{"name":"数据","slug":"数据","permalink":"https://shadowbynl.github.io/categories/%E6%95%B0%E6%8D%AE/"}],"tags":[]},{"title":"2021年9月保研结束后总结","slug":"202109summary","date":"2021-09-28T14:48:19.000Z","updated":"2021-10-07T08:35:05.694Z","comments":true,"path":"2021/09/28/202109summary/","link":"","permalink":"https://shadowbynl.github.io/2021/09/28/202109summary/","excerpt":"占位","text":"占位 目标 10.8 前 不多说了，勉强上个学，夏令营后两个月基本没有做保研相关的准备，拿到现在的结果也算是将就吧，之后的路就全看自己把握了。充足的写代码时间，自学时间，和短期的与长期的找工作的目标，将是我未来三年内的主题。未来的半年内，实习，毕设，写代码，学英语，深化对计算机知识的理解，尝试一些事，为研究生打工做准备，锻炼身体。。所有一切需要足够的自律和坚定的信念。这是一个新的起点，与我竞争的不单单是同校同专业的同学，更是全国千千万万学历或高或低经验或多或少的相关从业者。在这行立足，并做久，需要我持续慎重思考并践行。总会有遗憾，但要努力让自己以后不要做会让未来后悔的事。现在我的路已经很明确了。 目标10.8 前1 步入正轨 按920的安排进行2 做简历，准备投递（目标，了解）3 了解之后研究生的规划安排/情况（小概率考虑其他导师）","categories":[{"name":"规划","slug":"规划","permalink":"https://shadowbynl.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"npm相关环境","slug":"env-npm","date":"2021-09-22T01:42:20.000Z","updated":"2021-10-07T08:35:49.810Z","comments":true,"path":"2021/09/22/env-npm/","link":"","permalink":"https://shadowbynl.github.io/2021/09/22/env-npm/","excerpt":"占位","text":"占位 npm查看全局安装过的包npm list -g –depth 0https://www.cnblogs.com/zhou-135/articles/11816745.html","categories":[{"name":"环境","slug":"环境","permalink":"https://shadowbynl.github.io/categories/%E7%8E%AF%E5%A2%83/"}],"tags":[]},{"title":"nk社区","slug":"pro-00","date":"2021-09-21T12:21:15.000Z","updated":"2021-10-07T11:07:51.522Z","comments":true,"path":"2021/09/21/pro-00/","link":"","permalink":"https://shadowbynl.github.io/2021/09/21/pro-00/","excerpt":"占位","text":"占位 nk社区 1 首页 2 登录模块 2-1 发送邮件 2-2 开发注册功能 代码 2-3 会话管理 代码 2-4 生成验证码 代码 2-5 开发登录、退出功能 代码 2-6 显示登录信息 代码 2-7 账号设置 代码 2-8 检查登录状态 代码 3 核心功能 3-1 过滤敏感词 代码 3-2 发布帖子 3-3 帖子详情 3-4 事务管理 3-5 显示评论 3-6 添加评论 3-7 私信列表 3-8 发送私信 3-9 统一处理异常 3-10 统一处理日志（针对业务组件） 四 Redis缓存 4.1 Redis入门 4.2 spring整合redis 4.3 点赞（获取赞信息） 4.4 我收到的赞 4.5 关注、取消关注 4.6 关注列表、粉丝列表 4.7 优化登录模块 五 Kafka消息队列 5.1 阻塞队列 5.2 Kafka入门 5.3 Spring整合Kafka 测试 5.4 发送系统通知 5.5 显示系统通知 六 搜索 6.1 Elasticsearch入门 nk社区（编写） 0 框架与环境 0-1 框架 0-2 数据库 1 基本环境 1-1 用户实体相关 1-2 基本环境配置 1-3 帖子实体与分页实现 2 登录模块 2-1 邮件功能 2-2 注册 2-3 问题 nk社区1 首页123456789101112131415161718192021222324252627用户实体帖子实体帖子mapper1 （分页）查询帖子（用户id）2 查询帖子数量关于帖子关联的用户名的问题，采用得到帖子后，再查询的方式，不在mapper中统一关联查询，因此需要提供查询用户（id)的方法静态资源 static模板文件 templatesHomeController返回帖子-用户的键值列表首页渲染 帖子列表分页功能分页实体 方法 使用page实体 处理逻辑首页 分页实现项目调试技巧f8 7 9 日志默认logbacklogback-spring.xml 2 登录模块2-1 发送邮件12345678• 邮箱设置- 启用客户端SMTP服务• Spring Email- 导入 jar 包- 邮箱参数配置- 使用 JavaMailSender 发送邮件• 模板引擎- 使用 Thymeleaf 发送 HTML 邮件 2-2 开发注册功能12345678• 访问注册页面- 点击顶部区域内的链接，打开注册页面。• 提交注册数据- 通过表单提交数据。- 服务端验证账号是否已存在、邮箱是否已注册。- 服务端发送激活邮件。• 激活注册账号- 点击邮件中的链接，访问服务端的激活服务 拆解为三次请求 1234567首页跳转至注册页 首部的复用两个工具类 生成uuid md加盐加密注册业务 判空 验证账号 验证邮箱 注册用户 激活邮件注册controller 成功后到执行成功页注册页面 注册失败后跳回还需要留存信息th:value激活注册账号（邮箱链接）三种结果--常量类 激活业务激活controller 登录模板 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279# 首页跳转至注册页 首部的复用@GetMapping(&quot;/register&quot;)public String getRegisterPage() &#123; return &quot;/site/register&quot;;&#125;th:fragment=&quot;header&quot;th:href=&quot;@&#123;/index&#125;&quot;th:replace=&quot;index::header&quot;# 两个工具类 生成uuid md加盐加密&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;// 生成随机字符串public static String generateUUID() &#123; return UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);&#125;// MD5加密// hello -&gt; abc123def456// hello + 3e4a8 -&gt; abc123def456abcpublic static String md5(String key) &#123; if (StringUtils.isBlank(key)) &#123; return null; &#125; return DigestUtils.md5DigestAsHex(key.getBytes());&#125;# 注册业务 判空 验证账号 验证邮箱 注册用户 激活邮件@Servicepublic class UserService implements CommunityConstant &#123; @Autowired private UserMapper userMapper; @Autowired private MailClient mailClient; @Autowired private TemplateEngine templateEngine; @Value(&quot;$&#123;community.path.domain&#125;&quot;) private String domain; @Value(&quot;$&#123;server.servlet.context-path&#125;&quot;) private String contextPath; public User findUserById(int id) &#123; return userMapper.selectById(id); &#125; public Map&lt;String, Object&gt; register(User user) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 空值处理 if (user == null) &#123; throw new IllegalArgumentException(&quot;参数不能为空!&quot;); &#125; if (StringUtils.isBlank(user.getUsername())) &#123; map.put(&quot;usernameMsg&quot;, &quot;账号不能为空!&quot;); return map; &#125; if (StringUtils.isBlank(user.getPassword())) &#123; map.put(&quot;passwordMsg&quot;, &quot;密码不能为空!&quot;); return map; &#125; if (StringUtils.isBlank(user.getEmail())) &#123; map.put(&quot;emailMsg&quot;, &quot;邮箱不能为空!&quot;); return map; &#125; // 验证账号 User u = userMapper.selectByName(user.getUsername()); if (u != null) &#123; map.put(&quot;usernameMsg&quot;, &quot;该账号已存在!&quot;); return map; &#125; // 验证邮箱 u = userMapper.selectByEmail(user.getEmail()); if (u != null) &#123; map.put(&quot;emailMsg&quot;, &quot;该邮箱已被注册!&quot;); return map; &#125; // 注册用户 user.setSalt(CommunityUtil.generateUUID().substring(0, 5)); user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt())); user.setType(0); user.setStatus(0); user.setActivationCode(CommunityUtil.generateUUID()); user.setHeaderUrl(String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;, new Random().nextInt(1000))); user.setCreateTime(new Date()); userMapper.insertUser(user); // 激活邮件 Context context = new Context(); context.setVariable(&quot;email&quot;, user.getEmail()); // http://localhost:8080/community/activation/101/code String url = domain + contextPath + &quot;/activation/&quot; + user.getId() + &quot;/&quot; + user.getActivationCode(); context.setVariable(&quot;url&quot;, url); String content = templateEngine.process(&quot;/mail/activation&quot;, context); mailClient.sendMail(user.getEmail(), &quot;激活账号&quot;, content); return map; &#125; public int activation(int userId, String code) &#123; User user = userMapper.selectById(userId); if (user.getStatus() == 1) &#123; return ACTIVATION_REPEAT; &#125; else if (user.getActivationCode().equals(code)) &#123; userMapper.updateStatus(userId, 1); return ACTIVATION_SUCCESS; &#125; else &#123; return ACTIVATION_FAILURE; &#125; &#125;&#125;# 注册controller 成功后到执行成功页@Controllerpublic class LoginController implements CommunityConstant &#123; @Autowired private UserService userService; @RequestMapping(path = &quot;/register&quot;, method = RequestMethod.GET) public String getRegisterPage() &#123; return &quot;/site/register&quot;; &#125; @RequestMapping(path = &quot;/login&quot;, method = RequestMethod.GET) public String getLoginPage() &#123; return &quot;/site/login&quot;; &#125; @RequestMapping(path = &quot;/register&quot;, method = RequestMethod.POST) public String register(Model model, User user) &#123; Map&lt;String, Object&gt; map = userService.register(user); if (map == null || map.isEmpty()) &#123; model.addAttribute(&quot;msg&quot;, &quot;注册成功,我们已经向您的邮箱发送了一封激活邮件,请尽快激活!&quot;); model.addAttribute(&quot;target&quot;, &quot;/index&quot;); return &quot;/site/operate-result&quot;; &#125; else &#123; model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;)); model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;)); model.addAttribute(&quot;emailMsg&quot;, map.get(&quot;emailMsg&quot;)); return &quot;/site/register&quot;; &#125; &#125; // http://localhost:8080/community/activation/101/code @RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET) public String activation(Model model, @PathVariable(&quot;userId&quot;) int userId, @PathVariable(&quot;code&quot;) String code) &#123; int result = userService.activation(userId, code); if (result == ACTIVATION_SUCCESS) &#123; model.addAttribute(&quot;msg&quot;, &quot;激活成功,您的账号已经可以正常使用了!&quot;); model.addAttribute(&quot;target&quot;, &quot;/login&quot;); &#125; else if (result == ACTIVATION_REPEAT) &#123; model.addAttribute(&quot;msg&quot;, &quot;无效操作,该账号已经激活过了!&quot;); model.addAttribute(&quot;target&quot;, &quot;/index&quot;); &#125; else &#123; model.addAttribute(&quot;msg&quot;, &quot;激活失败,您提供的激活码不正确!&quot;); model.addAttribute(&quot;target&quot;, &quot;/index&quot;); &#125; return &quot;/site/operate-result&quot;; &#125;&#125;# 注册页面 注册失败后跳回还需要留存信息th:value&lt;!-- 内容 --&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3&quot;&gt; &lt;h3 class=&quot;text-center text-info border-bottom pb-3&quot;&gt;注&amp;nbsp;&amp;nbsp;册&lt;/h3&gt; &lt;form class=&quot;mt-5&quot; method=&quot;post&quot; th:action=&quot;@&#123;/register&#125;&quot;&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;username&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;账号:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; th:class=&quot;|form-control $&#123;usernameMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;user!=null?user.username:&#x27;&#x27;&#125;&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;usernameMsg&#125;&quot;&gt; 该账号已存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; th:class=&quot;|form-control $&#123;passwordMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;user!=null?user.password:&#x27;&#x27;&#125;&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入您的密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;passwordMsg&#125;&quot;&gt; 密码长度不能小于8位! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;confirm-password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;确认密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; th:value=&quot;$&#123;user!=null?user.password:&#x27;&#x27;&#125;&quot; id=&quot;confirm-password&quot; placeholder=&quot;请再次输入密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 两次输入的密码不一致! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;email&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;邮箱:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;email&quot; th:class=&quot;|form-control $&#123;emailMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;user!=null?user.email:&#x27;&#x27;&#125;&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;请输入您的邮箱!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;emailMsg&#125;&quot;&gt; 该邮箱已注册! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即注册&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;# 激活注册账号（邮箱链接）三种结果--常量类 激活业务public interface CommunityConstant &#123; /** * 激活成功 */ int ACTIVATION_SUCCESS = 0; /** * 重复激活 */ int ACTIVATION_REPEAT = 1; /** * 激活失败 */ int ACTIVATION_FAILURE = 2;&#125;# 激活controller 登录模板&lt;!doctype html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;https://static.nowcoder.com/images/logo_87_87.png&quot;/&gt; &lt;title&gt;牛客网-激活账号&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;b th:text=&quot;$&#123;email&#125;&quot;&gt;xxx@xxx.com&lt;/b&gt;, 您好! &lt;/p&gt; &lt;p&gt; 您正在注册牛客网, 这是一封激活邮件, 请点击 &lt;a th:href=&quot;$&#123;url&#125;&quot;&gt;此链接&lt;/a&gt;, 激活您的牛客账号! &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2-3 会话管理12345678910• HTTP的基本性质- HTTP是简单的- HTTP是可扩展的- HTTP是无状态的，有会话的• Cookie- 是服务器发送到浏览器，并保存在浏览器端的一小块数据。- 浏览器下次访问该服务器时，会自动携带块该数据，将其发送给服务器。• Session- 是JavaEE的标准，用于在服务端记录客户端信息。- 数据存放在服务端更加安全，但是也会增加服务端的内存压力。 12cookie测试session测试 多服务器情况 粘性session 同步session session服务器 会话数据存储 数据库（非关系） 代码1234567891011121314151617181920212223242526272829303132333435// cookie示例@RequestMapping(path = &quot;/cookie/set&quot;, method = RequestMethod.GET)@ResponseBodypublic String setCookie(HttpServletResponse response) &#123; // 创建cookie Cookie cookie = new Cookie(&quot;code&quot;, CommunityUtil.generateUUID()); // 设置cookie生效的范围 cookie.setPath(&quot;/community/alpha&quot;); // 设置cookie的生存时间 cookie.setMaxAge(60 * 10); // 发送cookie response.addCookie(cookie); return &quot;set cookie&quot;;&#125;@RequestMapping(path = &quot;/cookie/get&quot;, method = RequestMethod.GET)@ResponseBodypublic String getCookie(@CookieValue(&quot;code&quot;) String code) &#123; System.out.println(code); return &quot;get cookie&quot;;&#125;// session示例@RequestMapping(path = &quot;/session/set&quot;, method = RequestMethod.GET)@ResponseBodypublic String setSession(HttpSession session) &#123; session.setAttribute(&quot;id&quot;, 1); session.setAttribute(&quot;name&quot;, &quot;Test&quot;); return &quot;set session&quot;;&#125;@RequestMapping(path = &quot;/session/get&quot;, method = RequestMethod.GET)@ResponseBodypublic String getSession(HttpSession session) &#123; System.out.println(session.getAttribute(&quot;id&quot;)); System.out.println(session.getAttribute(&quot;name&quot;)); return &quot;get session&quot;;&#125; 2-4 生成验证码1234Kaptcha- 导入 jar 包- 编写 Kaptcha 配置类- 生成随机字符、生成图片 生成验证码的配置类 controller login图片 js 统一路径 随机参数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# 导入 jar 包&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt;# 编写 Kaptcha 配置类@Configurationpublic class KaptchaConfig &#123; @Bean public Producer kaptchaProducer() &#123; Properties properties = new Properties(); properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;100&quot;); properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;40&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;32&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;0,0,0&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYAZ&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;); properties.setProperty(&quot;kaptcha.noise.impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;); DefaultKaptcha kaptcha = new DefaultKaptcha(); Config config = new Config(properties); kaptcha.setConfig(config); return kaptcha; &#125;&#125;# 生成随机字符、生成图片@RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET)public void getKaptcha(HttpServletResponse response, HttpSession session) &#123; // 生成验证码 String text = kaptchaProducer.createText(); BufferedImage image = kaptchaProducer.createImage(text); // 将验证码存入session session.setAttribute(&quot;kaptcha&quot;, text); // 将突图片输出给浏览器 response.setContentType(&quot;image/png&quot;); try &#123; OutputStream os = response.getOutputStream(); ImageIO.write(image, &quot;png&quot;, os); &#125; catch (IOException e) &#123; logger.error(&quot;响应验证码失败:&quot; + e.getMessage()); &#125;&#125;# 前端&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3&quot;&gt; &lt;h3 class=&quot;text-center text-info border-bottom pb-3&quot;&gt;登&amp;nbsp;&amp;nbsp;录&lt;/h3&gt; &lt;form class=&quot;mt-5&quot;&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;username&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;账号:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control is-invalid&quot; id=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 该账号不存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control is-invalid&quot; id=&quot;password&quot; placeholder=&quot;请输入您的密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 密码长度不能小于8位! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;verifycode&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;验证码:&lt;/label&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control is-invalid&quot; id=&quot;verifycode&quot; placeholder=&quot;请输入验证码!&quot;&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 验证码不正确! &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;img th:src=&quot;@&#123;/kaptcha&#125;&quot; id=&quot;kaptcha&quot; style=&quot;width:100px;height:40px;&quot; class=&quot;mr-2&quot;/&gt; &lt;a href=&quot;javascript:refresh_kaptcha();&quot; class=&quot;font-size-12 align-bottom&quot;&gt;刷新验证码&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;remember-me&quot; checked=&quot;checked&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;remember-me&quot;&gt;记住我&lt;/label&gt; &lt;a href=&quot;forget.html&quot; class=&quot;text-danger float-right&quot;&gt;忘记密码?&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;var CONTEXT_PATH = &quot;/community&quot;;&lt;script th:src=&quot;@&#123;/js/global.js&#125;&quot;&gt;&lt;/script&gt;&lt;script&gt; function refresh_kaptcha() &#123; var path = CONTEXT_PATH + &quot;/kaptcha?p=&quot; + Math.random(); $(&quot;#kaptcha&quot;).attr(&quot;src&quot;, path); &#125;&lt;/script&gt; 2-5 开发登录、退出功能123456789• 访问登录页面- 点击顶部区域内的链接，打开登录页面。• 登录- 验证账号、密码、验证码。- 成功时，生成登录凭证，发放给客户端。- 失败时，跳转回登录页。• 退出- 将登录凭证修改为失效状态。- 跳转至网站首页。 登录凭证实体登录业务（空值处理 验证账号|是否存在/是否激活 验证密码 生成登录凭证）controller（检查验证码 登录凭证超时时间设置 检查账号密码登录页 表单 请求参数（输入回显 提示文本）退出功能（凭证失效 重定向到登录页 退出链接） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155# 登录凭证public class LoginTicket &#123; private int id; private int userId; private String ticket; private int status; private Date expired;&#125;# 实体# 登录业务（空值处理 验证账号|是否存在/是否激活 验证密码 生成登录凭证）public Map&lt;String, Object&gt; login(String username, String password, int expiredSeconds) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 空值处理 if (StringUtils.isBlank(username)) &#123; map.put(&quot;usernameMsg&quot;, &quot;账号不能为空!&quot;); return map; &#125; if (StringUtils.isBlank(password)) &#123; map.put(&quot;passwordMsg&quot;, &quot;密码不能为空!&quot;); return map; &#125; // 验证账号 User user = userMapper.selectByName(username); if (user == null) &#123; map.put(&quot;usernameMsg&quot;, &quot;该账号不存在!&quot;); return map; &#125; // 验证状态 if (user.getStatus() == 0) &#123; map.put(&quot;usernameMsg&quot;, &quot;该账号未激活!&quot;); return map; &#125; // 验证密码 password = CommunityUtil.md5(password + user.getSalt()); if (!user.getPassword().equals(password)) &#123; map.put(&quot;passwordMsg&quot;, &quot;密码不正确!&quot;); return map; &#125; // 生成登录凭证 LoginTicket loginTicket = new LoginTicket(); loginTicket.setUserId(user.getId()); loginTicket.setTicket(CommunityUtil.generateUUID()); loginTicket.setStatus(0); loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000)); loginTicketMapper.insertLoginTicket(loginTicket); map.put(&quot;ticket&quot;, loginTicket.getTicket()); return map;&#125;# controller（检查验证码 登录凭证超时时间设置 检查账号密码@RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST)public String login(String username, String password, String code, boolean rememberme, Model model, HttpSession session, HttpServletResponse response) &#123; // 检查验证码 String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;); if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) &#123; model.addAttribute(&quot;codeMsg&quot;, &quot;验证码不正确!&quot;); return &quot;/site/login&quot;; &#125; // 检查账号,密码 int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS; Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds); if (map.containsKey(&quot;ticket&quot;)) &#123; Cookie cookie = new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString()); cookie.setPath(contextPath); cookie.setMaxAge(expiredSeconds); response.addCookie(cookie); return &quot;redirect:/index&quot;; &#125; else &#123; model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;)); model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;)); return &quot;/site/login&quot;; &#125;&#125;/** * 默认状态的登录凭证的超时时间 */int DEFAULT_EXPIRED_SECONDS = 3600 * 12;/** * 记住状态的登录凭证超时时间 */int REMEMBER_EXPIRED_SECONDS = 3600 * 24 * 100;# 登录页 表单 请求参数（输入回显 提示文本）&lt;!-- 内容 --&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3&quot;&gt; &lt;h3 class=&quot;text-center text-info border-bottom pb-3&quot;&gt;登&amp;nbsp;&amp;nbsp;录&lt;/h3&gt; &lt;form class=&quot;mt-5&quot; method=&quot;post&quot; th:action=&quot;@&#123;/login&#125;&quot;&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;username&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;账号:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; th:class=&quot;|form-control $&#123;usernameMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;param.username&#125;&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;usernameMsg&#125;&quot;&gt; 该账号不存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; th:class=&quot;|form-control $&#123;passwordMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;param.password&#125;&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入您的密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;passwordMsg&#125;&quot;&gt; 密码长度不能小于8位! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;verifycode&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;验证码:&lt;/label&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &lt;input type=&quot;text&quot; th:class=&quot;|form-control $&#123;codeMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; id=&quot;verifycode&quot; name=&quot;code&quot; placeholder=&quot;请输入验证码!&quot;&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;codeMsg&#125;&quot;&gt; 验证码不正确! &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;img th:src=&quot;@&#123;/kaptcha&#125;&quot; id=&quot;kaptcha&quot; style=&quot;width:100px;height:40px;&quot; class=&quot;mr-2&quot;/&gt; &lt;a href=&quot;javascript:refresh_kaptcha();&quot; class=&quot;font-size-12 align-bottom&quot;&gt;刷新验证码&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;remember-me&quot; name=&quot;rememberme&quot; th:checked=&quot;$&#123;param.rememberme&#125;&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;remember-me&quot;&gt;记住我&lt;/label&gt; &lt;a href=&quot;forget.html&quot; class=&quot;text-danger float-right&quot;&gt;忘记密码?&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;# 退出功能（凭证失效 重定向到登录页 退出链接）public void logout(String ticket) &#123; loginTicketMapper.updateStatus(ticket, 1);&#125;@RequestMapping(path = &quot;/logout&quot;, method = RequestMethod.GET)public String logout(@CookieValue(&quot;ticket&quot;) String ticket) &#123; userService.logout(ticket); return &quot;redirect:/login&quot;;&#125; 2-6 显示登录信息12345678• 拦截器示例- 定义拦截器，实现HandlerInterceptor- 配置拦截器，为它指定拦截、排除的路径• 拦截器应用- 在请求开始时查询登录用户- 在本次请求中持有用户数据- 在模板视图上显示用户数据- 在请求结束时清理用户数据 12345拦截器测试 interceptor mvc配置利用cookie获取凭证-用户实体获取cookie的工具类LoginTicketInterceptor（获取凭证 获取用户--持有用户信息的工具类 ThreadLocal）页面th:if 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# 拦截器测试 interceptor mvc配置@Componentpublic class AlphaInterceptor implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(AlphaInterceptor.class); // 在Controller之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug(&quot;preHandle: &quot; + handler.toString()); return true; &#125; // 在Controller之后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; logger.debug(&quot;postHandle: &quot; + handler.toString()); &#125; // 在TemplateEngine之后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; logger.debug(&quot;afterCompletion: &quot; + handler.toString()); &#125;&#125;@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Autowired private AlphaInterceptor alphaInterceptor; @Autowired private LoginTicketInterceptor loginTicketInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(alphaInterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;) .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;); registry.addInterceptor(loginTicketInterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); &#125;&#125;# 利用cookie获取凭证-用户实体# 获取cookie的工具类public class CookieUtil &#123; public static String getValue(HttpServletRequest request, String name) &#123; if (request == null || name == null) &#123; throw new IllegalArgumentException(&quot;参数为空!&quot;); &#125; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(name)) &#123; return cookie.getValue(); &#125; &#125; &#125; return null; &#125;&#125;# LoginTicketInterceptor（获取凭证 获取用户--持有用户信息的工具类 ThreadLocal）/** * 持有用户信息,用于代替session对象. */@Componentpublic class HostHolder &#123; private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;&gt;(); public void setUser(User user) &#123; users.set(user); &#125; public User getUser() &#123; return users.get(); &#125; public void clear() &#123; users.remove(); &#125;&#125;@Componentpublic class LoginTicketInterceptor implements HandlerInterceptor &#123; @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 从cookie中获取凭证 String ticket = CookieUtil.getValue(request, &quot;ticket&quot;); if (ticket != null) &#123; // 查询凭证 LoginTicket loginTicket = userService.findLoginTicket(ticket); // 检查凭证是否有效 if (loginTicket != null &amp;&amp; loginTicket.getStatus() == 0 &amp;&amp; loginTicket.getExpired().after(new Date())) &#123; // 根据凭证查询用户 User user = userService.findUserById(loginTicket.getUserId()); // 在本次请求中持有用户 hostHolder.setUser(user); &#125; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; User user = hostHolder.getUser(); if (user != null &amp;&amp; modelAndView != null) &#123; modelAndView.addObject(&quot;loginUser&quot;, user); &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; hostHolder.clear(); &#125;&#125;# 页面th:if&lt;!-- 头部 --&gt;&lt;header class=&quot;bg-dark sticky-top&quot; th:fragment=&quot;header&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 导航 --&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark&quot;&gt; &lt;!-- logo --&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;!-- 功能 --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt; &lt;ul class=&quot;navbar-nav mr-auto&quot;&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot;&gt; &lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/index&#125;&quot;&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot; th:if=&quot;$&#123;loginUser!=null&#125;&quot;&gt; &lt;a class=&quot;nav-link position-relative&quot; href=&quot;site/letter.html&quot;&gt;消息&lt;span class=&quot;badge badge-danger&quot;&gt;12&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot; th:if=&quot;$&#123;loginUser==null&#125;&quot;&gt; &lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/register&#125;&quot;&gt;注册&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot; th:if=&quot;$&#123;loginUser==null&#125;&quot;&gt; &lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical dropdown&quot; th:if=&quot;$&#123;loginUser!=null&#125;&quot;&gt; &lt;a class=&quot;nav-link dropdown-toggle&quot; href=&quot;#&quot; id=&quot;navbarDropdown&quot; role=&quot;button&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; &lt;img th:src=&quot;$&#123;loginUser.headerUrl&#125;&quot; class=&quot;rounded-circle&quot; style=&quot;width:30px;&quot;/&gt; &lt;/a&gt; &lt;div class=&quot;dropdown-menu&quot; aria-labelledby=&quot;navbarDropdown&quot;&gt; &lt;a class=&quot;dropdown-item text-center&quot; href=&quot;site/profile.html&quot;&gt;个人主页&lt;/a&gt; &lt;a class=&quot;dropdown-item text-center&quot; href=&quot;site/setting.html&quot;&gt;账号设置&lt;/a&gt; &lt;a class=&quot;dropdown-item text-center&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;退出登录&lt;/a&gt; &lt;div class=&quot;dropdown-divider&quot;&gt;&lt;/div&gt; &lt;span class=&quot;dropdown-item text-center text-secondary&quot; th:utext=&quot;$&#123;loginUser.username&#125;&quot;&gt;nowcoder&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 搜索 --&gt; &lt;form class=&quot;form-inline my-2 my-lg-0&quot; action=&quot;site/search.html&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;search&quot; aria-label=&quot;Search&quot; /&gt; &lt;button class=&quot;btn btn-outline-light my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/header&gt; 2-7 账号设置12345678• 上传文件- 请求：必须是POST请求- 表单：enctype=“multipart/form-data”- Spring MVC：通过 MultipartFile 处理上传文件• 开发步骤- 访问账号设置页面- 上传头像- 获取头像 1234设置页配置上传路径上传controller方法（model返回提示信息）获取头像 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# 设置页&lt;!-- 上传头像 --&gt;&lt;h6 class=&quot;text-left text-info border-bottom pb-2&quot;&gt;上传头像&lt;/h6&gt;&lt;form class=&quot;mt-5&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; th:action=&quot;@&#123;/user/upload&#125;&quot;&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;head-image&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;选择头像:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;div class=&quot;custom-file&quot;&gt; &lt;input type=&quot;file&quot; th:class=&quot;|custom-file-input $&#123;error!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; id=&quot;head-image&quot; name=&quot;headerImage&quot; lang=&quot;es&quot; required=&quot;&quot;&gt; &lt;label class=&quot;custom-file-label&quot; for=&quot;head-image&quot; data-browse=&quot;文件&quot;&gt;选择一张图片&lt;/label&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;error&#125;&quot;&gt; 该账号不存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即上传&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;# 配置上传路径community.path.domain=http://localhost:8080community.path.upload=d:/work/data/upload# 上传controller方法（model返回提示信息）@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; private static final Logger logger = LoggerFactory.getLogger(UserController.class); @Value(&quot;$&#123;community.path.upload&#125;&quot;) private String uploadPath; @Value(&quot;$&#123;community.path.domain&#125;&quot;) private String domain; @Value(&quot;$&#123;server.servlet.context-path&#125;&quot;) private String contextPath; @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET) public String getSettingPage() &#123; return &quot;/site/setting&quot;; &#125; @RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST) public String uploadHeader(MultipartFile headerImage, Model model) &#123; if (headerImage == null) &#123; model.addAttribute(&quot;error&quot;, &quot;您还没有选择图片!&quot;); return &quot;/site/setting&quot;; &#125; String fileName = headerImage.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); if (StringUtils.isBlank(suffix)) &#123; model.addAttribute(&quot;error&quot;, &quot;文件的格式不正确!&quot;); return &quot;/site/setting&quot;; &#125; // 生成随机文件名 fileName = CommunityUtil.generateUUID() + suffix; // 确定文件存放的路径 File dest = new File(uploadPath + &quot;/&quot; + fileName); try &#123; // 存储文件 headerImage.transferTo(dest); &#125; catch (IOException e) &#123; logger.error(&quot;上传文件失败: &quot; + e.getMessage()); throw new RuntimeException(&quot;上传文件失败,服务器发生异常!&quot;, e); &#125; // 更新当前用户的头像的路径(web访问路径) // http://localhost:8080/community/user/header/xxx.png User user = hostHolder.getUser(); String headerUrl = domain + contextPath + &quot;/user/header/&quot; + fileName; userService.updateHeader(user.getId(), headerUrl); return &quot;redirect:/index&quot;; &#125; @RequestMapping(path = &quot;/header/&#123;fileName&#125;&quot;, method = RequestMethod.GET) public void getHeader(@PathVariable(&quot;fileName&quot;) String fileName, HttpServletResponse response) &#123; // 服务器存放路径 fileName = uploadPath + &quot;/&quot; + fileName; // 文件后缀 String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); // 响应图片 response.setContentType(&quot;image/&quot; + suffix); try ( FileInputStream fis = new FileInputStream(fileName); OutputStream os = response.getOutputStream(); ) &#123; byte[] buffer = new byte[1024]; int b = 0; while ((b = fis.read(buffer)) != -1) &#123; os.write(buffer, 0, b); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;读取头像失败: &quot; + e.getMessage()); &#125; &#125;&#125;# 获取头像 2-8 检查登录状态123456789• 使用拦截器- 在方法前标注自定义注解- 拦截所有请求，只处理带有该注解的方法• 自定义注解- 常用的元注解：@Target、@Retention、@Document、@Inherited- 如何读取注解：Method.getDeclaredAnnotations​()Method.getAnnotation​(Class&lt;T&gt; annotationClass) 12自定义注解拦截器 代码1234567891011121314151617181920212223242526272829# 自定义注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LoginRequired &#123;&#125;# 拦截器@Componentpublic class LoginRequiredInterceptor implements HandlerInterceptor &#123; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (handler instanceof HandlerMethod) &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); LoginRequired loginRequired = method.getAnnotation(LoginRequired.class); if (loginRequired != null &amp;&amp; hostHolder.getUser() == null) &#123; response.sendRedirect(request.getContextPath() + &quot;/login&quot;); return false; &#125; &#125; return true; &#125;&#125;registry.addInterceptor(loginRequiredInterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); 3 核心功能3-1 过滤敏感词12345678• 前缀树- 名称：Trie、字典树、查找树- 特点：查找效率高，消耗内存大- 应用：字符串检索、词频统计、字符串排序等• 敏感词过滤器- 定义前缀树- 根据敏感词，初始化前缀树- 编写过滤敏感词的方法 12345678910111213141516如果使用jdk的字符串替换api 性能太差 用自己实现的前缀树进行过滤# 思想讲解1 定义敏感词 abc,bf,be 2 由敏感词构造前缀树（根节点空 标记）3 输入字符串 三个指针（两个指针指定一个单词，一个指针扫前缀树）4 示例过程 20min（以字符为单位，任意语言都可以）# 实现1 用文本记录敏感词2 工具类（敏感词过滤器）2.1 前缀树节点类（关键词结束标识 子节点--字符到节点的map 添加子节点方法 获取子节点方法2.2 初始化前缀树 根节点-替换符 init（字节流--字符缓冲流 遍历每个敏感词加入到前缀树）添加方法（传入敏感词 遍历每个字符）2.3 过滤方法（传入文本 判空 三个指针 判断是否为普通字符 逻辑）3 测试 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152@Componentpublic class SensitiveFilter &#123; private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class); // 替换符 private static final String REPLACEMENT = &quot;***&quot;; // 根节点 private TrieNode rootNode = new TrieNode(); @PostConstruct public void init() &#123; try ( InputStream is = this.getClass().getClassLoader().getResourceAsStream(&quot;sensitive-words.txt&quot;); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); ) &#123; String keyword; while ((keyword = reader.readLine()) != null) &#123; // 添加到前缀树 this.addKeyword(keyword); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;加载敏感词文件失败: &quot; + e.getMessage()); &#125; &#125; // 将一个敏感词添加到前缀树中 private void addKeyword(String keyword) &#123; TrieNode tempNode = rootNode; for (int i = 0; i &lt; keyword.length(); i++) &#123; char c = keyword.charAt(i); TrieNode subNode = tempNode.getSubNode(c); if (subNode == null) &#123; // 初始化子节点 subNode = new TrieNode(); tempNode.addSubNode(c, subNode); &#125; // 指向子节点,进入下一轮循环 tempNode = subNode; // 设置结束标识 if (i == keyword.length() - 1) &#123; tempNode.setKeywordEnd(true); &#125; &#125; &#125; /** * 过滤敏感词 * * @param text 待过滤的文本 * @return 过滤后的文本 */ public String filter(String text) &#123; if (StringUtils.isBlank(text)) &#123; return null; &#125; // 指针1 TrieNode tempNode = rootNode; // 指针2 int begin = 0; // 指针3 int position = 0; // 结果 StringBuilder sb = new StringBuilder(); while (position &lt; text.length()) &#123; char c = text.charAt(position); // 跳过符号 if (isSymbol(c)) &#123; // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步 if (tempNode == rootNode) &#123; sb.append(c); begin++; &#125; // 无论符号在开头或中间,指针3都向下走一步 position++; continue; &#125; // 检查下级节点 tempNode = tempNode.getSubNode(c); if (tempNode == null) &#123; // 以begin开头的字符串不是敏感词 sb.append(text.charAt(begin)); // 进入下一个位置 position = ++begin; // 重新指向根节点 tempNode = rootNode; &#125; else if (tempNode.isKeywordEnd()) &#123; // 发现敏感词,将begin~position字符串替换掉 sb.append(REPLACEMENT); // 进入下一个位置 begin = ++position; // 重新指向根节点 tempNode = rootNode; &#125; else &#123; // 检查下一个字符 position++; &#125; &#125; // 将最后一批字符计入结果 sb.append(text.substring(begin)); return sb.toString(); &#125; // 判断是否为符号 private boolean isSymbol(Character c) &#123; // 0x2E80~0x9FFF 是东亚文字范围 return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c &gt; 0x9FFF); &#125; // 前缀树 private class TrieNode &#123; // 关键词结束标识 private boolean isKeywordEnd = false; // 子节点(key是下级字符,value是下级节点) private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); public boolean isKeywordEnd() &#123; return isKeywordEnd; &#125; public void setKeywordEnd(boolean keywordEnd) &#123; isKeywordEnd = keywordEnd; &#125; // 添加子节点 public void addSubNode(Character c, TrieNode node) &#123; subNodes.put(c, node); &#125; // 获取子节点 public TrieNode getSubNode(Character c) &#123; return subNodes.get(c); &#125; &#125;&#125; 3-2 发布帖子12345678910• AJAX- Asynchronous JavaScript and XML- 异步的JavaScript与XML，不是一门新技术，只是一个新的术语。- 使用AJAX，网页能够将增量更新呈现在页面上，而不需要刷新整个页面。- 虽然X代表XML，但目前JSON的使用比XML更加普遍。- https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX• 示例- 使用jQuery发送AJAX请求。• 实践- 采用AJAX请求，实现发布帖子的功能。 123456789101112131415161718192021# json处理--ajax1 引入 fastjson2 在CommunityUtil中编写json对象转换为字符串的方法（重载）3 AlphaController ajax示例 static/html/ajax-demo.html# 实现发布帖子功能1 discusspostmapper 增加帖子方法 xml中加上一个insert语句 2 帖子业务中 addDiscussPost2.1 判空2.2 对标题、内容进行转义处理（处理含有Html标签的内容）2.3 对标题、内容进行过滤敏感词处理 3 帖子Controller问题 为什么hostHolder能取代session的作用 作为存储当前用户的对象3.1 检查用户3.2 新增帖子4 页面4.1 index 弹出框 70多行 对发布按钮进行登录用户判定4.2 static/js/index.js publish方法4.2.1 弹出框隐藏4.2.2 获取标题和内容4.2.3 发布异步请求（显示返回消息 提示 刷新页面） 3-3 帖子详情123456789101112131415161718192021• DiscussPostMapper根据id查询的方法 mapper• DiscussPostServicefindxxx 根据id查询• DiscussPostControllergetxxx 根据id查询 id参数 model返回携带信息注意，一个帖子需要关联用户信息，此处如何处理？（1）效率更好的方法是 sql中关联查询 效率高 但可能会造成业务冗余（2）在controller中单独再查询 效率低 后续可用缓存优化根据帖子的用户id查到用户，也需返回此处先不处理帖子的评论回复相关• index.html- 在帖子标题上增加访问详情页面的链接在帖子列表的超链接上进行修改• discuss-detail.html- 处理静态资源的访问路径- 复用index.html的header区域- 显示标题、作者、发布时间、帖子正文等内容帖子详情 3-4 事务管理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364回顾• 什么是事务- 事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行。• 事务的特性（ACID）- 原子性（Atomicity）：事务是应用中不可再分的最小执行体。- 一致性（Consistency）：事务执行的结果，须使数据从一个一致性状态，变为另一个一致性状态。- 隔离性（Isolation）：各个事务的执行互不干扰，任何事务的内部操作对其他的事务都是隔离的。- 持久性（Durability）：事务一旦提交，对数据所做的任何改变都要记录到永久存储器中。事务的隔离性• 常见的并发异常- 第一类丢失更新、第二类丢失更新。- 脏读、不可重复读、幻读。• 常见的隔离级别- Read Uncommitted：读取未提交的数据。- Read Committed：读取已提交的数据。- Repeatable Read：可重复读。- Serializable：串行化。第一类丢失更新某一个事务的回滚，导致另外一个事务已更新的数据丢失了。第二类丢失更新某一个事务的提交，导致另外一个事务已更新的数据丢失了。脏读某一个事务，读取了另外一个事务未提交的数据。不可重复读某一个事务，对同一个数据前后读取的结果不一致。幻读某一个事务，对同一个表前后查询到的行数不一致。事务隔离级别隔离级别 第一类丢失更新 脏读 第二类丢失更新 不可重复读 幻读Read Uncommitted Y Y Y Y YRead Committed N N Y Y YRepeatable Read N N N N YSerializable N N N N N实现机制• 悲观锁（数据库）- 共享锁（S锁）事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。- 排他锁（X锁）事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。• 乐观锁（自定义）- 版本号、时间戳等在更新数据前，检查版本号是否发生变化。若变化则取消本次更新，否则就更新数据（版本号+1）。Spring事务管理• 声明式事务- 通过XML配置，声明某方法的事务特征。- 通过注解，声明某方法的事务特征。• 编程式事务- 通过 TransactionTemplate 管理事务，并通过它执行数据库的操作。 123456789多线程环境下，多个环境下同时访问同一数据隔离级别一般选中间两种# Spring事务测试Alpha业务中 save1 新增用户 新增帖子 注解：隔离机制 传播机制（业务方法相互调用）事务测试类 完整回滚编程式事务 save2 3-5 显示评论123456789• 数据层- 根据实体查询一页评论数据。- 根据实体查询评论的数量。• 业务层- 处理查询评论的业务。处理查询评论数量的业务。• 表现层- 显示帖子详情数据时，同时显示该帖子所有的评论数据。 1234567891011121314151617181920212218# 评论表可以对帖子评论 可以对评论评论1 设计一个entity_type 对应评论的对象 entity_id target_id是在回复某个回复时要指明针对的对象# 实体类 Mapper1 实体类2 方法：根据评论的对象查询评论、数量（分页辅助） 3 xml # 业务 控制器1 业务 两个方法2 控制器 getDiscussPost 获取评论分页信息+ 每个帖子有一个字段评论数量 实体类型 + 对每个评论，需要和用户关联 再逐一查询 和index帖子列表类似+ 评论的评论（回复）查所有 回复列表 对其也要设置一个Vo列表 比较特殊的是有一个指向性，回复的目标，普通的回复即回复评论target_id=0，特殊的是回复回复的回复，那么需要一个目标用户，vo里还需加一个键值对+ 帖子有评论数量字段 但评论的回复数量就需要单独查了# 页面1 index.html 帖子列表 回帖数2 帖子详情页 内容--回帖部分 回帖数量-回帖列表 基本--回复列表 特殊处理目标用户--回复回复的回复的情况 id3 复用分页 3-6 添加评论123456789• 数据层- 增加评论数据。- 修改帖子的评论数量。• 业务层- 处理添加评论的业务：先增加评论、再更新帖子的评论数量。• 表现层- 处理添加评论数据的请求。- 设置添加评论的表单 123456789101112131415191 comment mapper xml insert方法2 帖子 mapper xml 更新评论数量方法 帖子 service 更新评论数量方法3 评论 业务 增加评论方法（包含事务管理）3.1 参数判空3.2 评论 转义 敏感词过滤3.3 存入数据库3.4 更新评论数量（需要判断是帖子的评论，即需要判断entity_type，然后查到对应的帖子实体，调用帖子的更新评论数量业务方法进行更新）4 评论 controller 新增方法5 页面评论详情页5.1 回帖输入部分（表单 method action 文本域 隐藏域/两个entity_xxx）5.2 回复输入框（和5.1同 区别是针对的对象是评论/回复 还需要携带targetId 提示回复给xxx） 3-7 私信列表1234567• 私信列表- 查询当前用户的会话列表，每个会话只显示一条最新的私信。- 支持分页显示。• 私信详情- 查询某个会话所包含的私信。- 支持分页显示。 123456789101112131415161718192021222324252627282920# 表 messagefrom_id to_id 会话id（规则，小id_大id）# 实现1 Message实体2 MessageMapper（5个方法）xml（1）查询用户会话列表（分页）（2）会话数量（3）查询某个会话包含的私信列表（4）查询某个会话包含的私信数量（5）查询未读的私信的数量xml1/查询时status=2表删除 from_id=1表系统通知3 Mapper测试4 业务message 55 controller 私信列表 私信详情 注意逻辑6 页面6.1 index.html 消息链接6.2 letter.html引入css js 首部选项卡部分（链接 未读消息）私信列表-------------letter.html 详情链接6.3 私信详情页面目标用户私信列表返回和js方法 3-8 发送私信123456• 发送私信- 采用异步的方式发送私信。- 发送成功后刷新私信列表。• 设置已读- 访问私信详情时，将显示的私信设置为已读状态。 1234567891011121321# 两个地方可以发起私信# 进入私信详情，修改私信状态# 实现1 mapper 新增消息 修改消息状态2 业务 需要过滤 add read3 controller 异步send 用户业务补充一个根据用户名查询用户的方法 修改状态3.1 根据用户名查到发送的用户对象3.2 构造私信对象 from to 会话4 页面4.1 letter.js里send_letter方法4.2 私信详情页处理 3-9 统一处理异常12345678910• @ControllerAdvice- 用于修饰类，表示该类是Controller的全局配置类。- 在此类中，可以对Controller进行如下三种全局配置：异常处理方案、绑定数据方案、绑定参数方案。• @ExceptionHandler- 用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。• @ModelAttribute- 用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。• @DataBinder- 用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。 1231 错误页面模板 templates/error 自动跳转2 HomeController/getErrorPage3 异常处理类 区分处理异步请求和普通请求 3-10 统一处理日志（针对业务组件）12345678910111213141516171819202122AOP的概念• Aspect Oriented Programing，即面向方面（切面）编程。• AOP是一种编程思想，是对OOP的补充，可以进一步提高编程的效率。AOP的实现• AspectJ- AspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法。- AspectJ在编译期织入代码，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。• Spring AOP- Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器。- Spring AOP在运行时通过代理的方式织入代码，只支持方法类型的连接点。- Spring支持对AspectJ的集成。Spring AOP• JDK动态代理- Java提供的动态代理技术，可以在运行时创建接口的代理实例。- Spring AOP默认采用此种方式，在接口的代理实例中织入代码。• CGLib动态代理- 采用底层的字节码技术，在运行时创建子类代理实例。- 当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码。 1234567拦截器等和上述方法是针对controller的对于业务组件来说，不应该把记录日志的代码在每个地方都明写出来（硬编码）目标对象 joinpoint 切面组件两个类 四 Redis缓存4.1 Redis入门12345• Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。• Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人。同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性。• Redis典型的应用场景包括：缓存、排行榜、计数器、社交网络、消息队列等。 12345678910111213141516171819202122232425262728293031323334353637381 快照存储 完全存储 不能实时2 日志存储AOF 实时命令 追加3 主要是 数据结构--对应命令--------常用命令select nflushdb&gt; stringset test:count 1get test:countincr test:countdecr test:counthset test:user id 1hset test:user username zshget test:user idlpush test:ids 101 102 103 列表左进右出 索引左到右递增llen test:idslindex test:ids 0lindex test:ids 2lrange test:ids 0 2rpop test:idssadd test:teachers aaa bbb cc dd eeescard test:teachersspop test:teacherssmembers test:teacherszadd test:students 10 aaa 20 bbb 30 ccc 40 dddzcard test:studentszscore test:students ccczrank test:studentszrange test:students 0 2keys *keys test*type test:userexists keydel key 4.2 spring整合redis1234567891011• 引入依赖- spring-boot-starter-data-redis• 配置Redis- 配置数据库参数- 编写配置类，构造RedisTemplate• 访问Redis- redisTemplate.opsForValue()- redisTemplate.opsForHash()- redisTemplate.opsForList()- redisTemplate.opsForSet()- redisTemplate.opsForZSet() 123456724RedisTemplate默认的key是object类型 用的不方便 需要重新配置1 依赖不写版本 默认用的父pom中规定的版本2 配置：数据库 主机 端口配置类：配置RedisTemplate（返回泛型 连接工厂 设置key 普通value hash的key value的序列化方式 生效）3 测试方法 4.3 点赞（获取赞信息）12345678• 点赞- 支持对帖子、评论点赞。- 第1次点赞，第2次取消点赞。• 首页点赞数量- 统计帖子的点赞数量。• 详情页点赞数量- 统计点赞数量。- 显示点赞状态。 12345678910111213141516171819202122# 说明点赞可能同时很多人进行 存到内存里提升性能两处支持点赞 帖子 评论存到redis中 数据访问层就省去了 # 实现 1 工具类 RedisKeyUtil 获取key 2 点赞业务 likeservice 点赞方法 查询某实体点赞的数量 查询某人对某实体的点赞状态 3 表现层 异步请求 likecontroller 4 页面 4.1 discuss-detail 1赞（帖子） 80多行 2赞（评论） 100多行 3赞（回复）160多行 此处是点赞操作 请求的是likecontroller 4.2 创建一个discuss.js like方法 ---------------- 1 HomeController 补充逻辑 返回帖子的赞 2 修改首页 赞相关 3 帖子详情页面 帖子Controller 补充点赞相关的信息（帖子 评论 回复） 4 详情页面 获取赞的信息 三处 4.4 我收到的赞12345• 重构点赞功能- 以用户为key，记录点赞数量- increment(key)，decrement(key)• 开发个人主页- 以用户为key，查询点赞数量 1234567891011121314151626# 实现1 在RedisKeyUtil中增加一个方法 以用户名为键 统计其获赞数量2 在点赞的业务方法中 修改实体赞的数量的同时，也需要修改用户的赞的数量，涉及到事务，redis需要使用编程式事务 multi-exec3 点赞业务 查询有个用户获赞的数量4 likecontroller 参数5 帖子详情页 三处 需要对请求调用处修改 补充参数6 discuss.js 修改方法--------------------# 个人主页不仅查看自己的，而且可以查看别人的 传入userId1 UserControllergetProfilePage(userId) （用户 点赞数量）2 index.html 个人主页 43行 帖子列表-用户头像-超链接-1223 profile.html 4.5 关注、取消关注123456• 需求- 开发关注、取消关注功能。- 统计用户的关注数、粉丝数。• 关键- 若A关注了B，则A是B的Follower（粉丝），B是A的Followee（目标）。- 关注的目标可以是用户、帖子、题目等，在实现时将这些目标抽象为实体。 1234567891011121314151617181920212223242526272829# 说明A和B关注目标--用户帖子--实体存到redis里 所以还是从key开始# 实现1 RedisKeyUtil 两个键 followee 关注的目标集合 follower 关注者集合关注的实体 zsets 实体id 由关注时间为分数useid-实体类型 为键某个实体拥有的粉丝 zset2 FollowService&gt; 关注方法（用户id 实体类型 实体id）编程式事务（要操作两个zset）&gt; 取关方法移除3 FollowController 异步请求关注 取关3 profile.html 关注取关--profile.js 发送异步请求profile.html 隐藏框携带用户id-----------还需处理关注数量的回显 和 改变关注状态1 service中 方法：查询关注的实体的数量（目标）zcard查询实体的粉丝的数量 查询当前用户是否已关注该实体2 修改usercontroller中的个人主页的方法 返回关注相关（关注数量 粉丝数量 是否已关注）3 页面 profile.html 关注操作还需处理非自己时才显示 关注/取关按钮的样式还需动态拼接 4.6 关注列表、粉丝列表123456• 业务层- 查询某个用户关注的人，支持分页。- 查询某个用户的粉丝，支持分页。• 表现层- 处理“查询关注的人”、“查询粉丝”请求。- 编写“查询关注的人”、“查询粉丝”模板。 123456789101112131428# 实现1 Follow业务查询某用户关注的人（倒序 分页--关注的id列表 需要再进行遍历 根据id查到对应实体和分数/关注时间）查询某用户的粉丝2 Controller 分页查询关注 followee查询粉丝 follower为什么controller里还需要判断一遍是不是已关注？粉丝列表可能还需要该信息 但关注列表里不都是已关注吗解答：查看的是别人的关注列表时，不一定是已关注的3 profile.html 链接 关注 粉丝followee.html 标签连接 返回 关注列表（头像 用户主页链接 关注时间 分页 关注他--按钮样式--非自己--字）follower.html 类似 4.7 优化登录模块12345678• 使用Redis存储验证码- 验证码需要频繁的访问与刷新，对性能要求较高。- 验证码不需永久保存，通常在很短的时间后就会失效。- 分布式部署时，存在Session共享的问题。• 使用Redis存储登录凭证- 处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。• 使用Redis缓存用户信息- 处理每次请求时，都要根据凭证查询用户信息，访问的频率非常高。 12345678910111213141516171819202122232425262728293031323334# 说明1 验证码先前存在session里 redis可解决共享问题 设置过期时间2 登录凭证 先前每次都要查用户凭证3 缓存用户信息# 验证码1 RedisKeyUtilkaptcha获取验证码的方法2 重构LoginController中的getKaptcha存入session-&gt;存入redis-&gt;键规定为“归属”，一个临时字符串，存入cookie，设置其过期时间登录login方法取验证码：设置一个参数从cookie中取值（之前存的时候生成的随机字符串-&gt;取到之后到redis中取验证码# 登录凭证1 RedisKeyUtil键和方法（传入ticket）后续可以用redis存凭证代替之前的登录凭证表2 设置原来的登录凭证Mapper为@Deprecated 不推荐使用3 三处重构3.1 UserService 登录处 修改为将登录凭证对象序列化后存入redis 3.2 登出时，将登录凭证取出，修改状态，再存3.3 查询凭证 到redis里查# 缓存用户信息1 RedisKeyUtil2 重构UserService中的findUserById方法+ 查的时候优先从缓存查+ 取不到时初始化+ 数据变更时清楚缓存数据三个方法重写findUserById 调用上面的方法修改User的地方 + 激活的时候修改了用户状态+ 更新头像 五 Kafka消息队列Kafka性能最好的消息队列系统通知 日志 性能问题 5.1 阻塞队列1234567891011121314151617181920• BlockingQueue- 解决线程通信的问题。- 阻塞方法：put、take。• 生产者消费者模式- 生产者：产生数据的线程。- 消费者：使用数据的线程。• 实现类- ArrayBlockingQueue- LinkedBlockingQueue- PriorityBlockingQueue、SynchronousQueue、DelayQueue等。```````markdown30阻塞队列：一组接口，解决线程通信的问题线程1put 生产者 线程2take 消费者 阻塞队列--缓冲区域 线程阻塞不占用CPU资源实现类# 测试BlockingQueueTests生产者线程 消费者线程 缓冲区 5.2 Kafka入门123456789• Kafka简介- Kafka是一个分布式的流媒体平台。- 应用：消息系统、日志收集、用户行为追踪、流式处理。• Kafka特点- 高吞吐量、消息持久化、高可靠性、高扩展性。• Kafka术语- Broker、Zookeeper- Topic、Partition、Offset- Leader Replica 、Follower Replica 1234567891011121314151617181920212223242526272829303132# 简介分布式流媒体平台 消息 日志 特点：高吞吐量消息持久化（存储海量数据的前提）# 术语消息队列两种实现方式：点对点 发布-订阅方式（kafka采用）服务器Brokerzookeeper管理集群Topic主题（存放消息的位置）Partition 对主题的分区Offset 消息在分区内存放的索引Replica 副本 每个分区会有多个副本 Leader响应 Follower# 安装官网下载 解压缩配置 config/zookeeper.properties datadir config/server.properties logdir启动 bin/windows先启动zookeeperbin\\windows\\zookeeper-server-start.bat config\\zookeeper.properties再启动kafkabin\\windows\\kafka-server-start.bat config\\server.properties使用kafka的命令工具+ 创建主题 kafka-topics.bat --create --bootstrap-server localhost:9092（默认端口）--replication-factor 1（1个副本）--partitions 1 --topic test+ 列举所有主题 kafka-topics.bat --list --bootstrap-server localhost:9092+ 生产者发消息 kafka-console-produce.bat --broker-list localhost:9092 --topic test 指定服务器和主题 一个回车一个消息+ 消费者查看 kafka-console-consumer.bat --broker-list localhost:9092 --topic test --from-beginning 从头开始读消息 5.3 Spring整合Kafka12345678910• 引入依赖- spring-kafka• 配置Kafka- 配置server、consumer• 访问Kafka- 生产者kafkaTemplate.send(topic, data);- 消费者@KafkaListener(topics = &#123;&quot;test&quot;&#125;)public void handleMessage(ConsumerRecord record) &#123;&#125; 123依赖配置测试类 生产者 消费者 测试在windows上测试不要使用最新版的kafka 配置路径用/或\\参考 https://blog.csdn.net/yinianxx/article/details/106283443https://stackoverflow.com/questions/67317088/kafka-error-failed-to-write-meta-properties-due-to-kafka-server-brokermetadat 5.4 发送系统通知12345678• 触发事件- 评论后，发布通知- 点赞后，发布通知- 关注后，发布通知• 处理事件- 封装事件对象- 开发事件的生产者- 开发事件的消费者 1234567891011121314151617181920212223242526272829303132333435# 说明发布通知非常频繁 为了保证性能 使用消息队列定义三种主题 异步技术：kafka 业务：事件驱动1 封装事件对象# 实现1 实体 Event+ 属性 topic 用户id 实体类型id 实体所属的用户id 额外数据集data+ getset set返回 setData2 event包2.1 EventProducer将消息发到指定主题2.2 EventConsumer一个方法处理三种主题定义三个常量步骤：判空 获取event数据 构造message（from_id=1系统常量 to_id data存入content 通知对象区分处理）生产者生产3 controller3.1 评论 addComment（触发评论事件 补充一个根据id查commentid的方法（mapper service）3.2 点赞 likeController 在触发点赞事件时才进行（取消不通知） 需要获取帖子id来跳转3.2 关注 follow方法 触发关注事件（当前只有关注用户功能） 4 页面处理4.1 帖子详情 点赞请求处多一个帖子id参数（三处）discuss.js方法补充参数5 注意kafka windows客户端容易崩溃 一般linux下比较稳定6 调试由于消费者service没有请求 导致统一日志切面产生空指针异常ServiceLogAspect 5.5 显示系统通知123456• 通知列表- 显示评论、点赞、关注三种类型的通知• 通知详情- 分页显示某一类主题所包含的通知• 未读消息- 在页面头部显示所有的未读消息数量 1234567891011121314151617181933# 列表实现1 MessageMapper查询某个主题下最新的通知（用户id，主题)查询某个主题所包含的通知数量查询未读的通知数量2 service三个方法getNoticeList 三类通知 letterUnreadCount&amp;noticeUnreadCount 3 页面 letter.html 选项-系统通知notice.html # 详情实现1 MessageMapper查询某个主题包含的通知列表 用户id 主题 分页2 Service3 controller4 notice详情5 Message拦截器 每个请求都要显示未读消息的数量 需要加入mvc config 12后端的四个文件+letter notice notice详情 index消息处修改 拦截器+mvc配置注意私信+通知是必须查到返回才修改状态 分页的话后面的没查状态改不了的 六 搜索6.1 Elasticsearch入门12345678• Elasticsearch简介- 一个分布式的、Restful风格的搜索引擎。- 支持对各种类型的数据的检索。- 搜索速度快，可以提供实时的搜索服务。- 便于水平扩展，每秒可以处理PB级海量数据。• Elasticsearch术语- 索引、类型、文档、字段。- 集群、节点、分片、副本。 1 nk社区（编写） 2021.9.22开始做这个社区项目，后面几天就以此为主要任务，做完为止。一个典型的crud的单体应用。 0 框架与环境0-1 框架装载beanspringmvc注解 0-2 数据库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `password` varchar(50) DEFAULT NULL, `salt` varchar(50) DEFAULT NULL, `email` varchar(100) DEFAULT NULL, `type` int(11) DEFAULT NULL COMMENT &#x27;0-普通用户; 1-超级管理员; 2-版主;&#x27;, `status` int(11) DEFAULT NULL COMMENT &#x27;0-未激活; 1-已激活;&#x27;, `activation_code` varchar(100) DEFAULT NULL, `header_url` varchar(200) DEFAULT NULL, `create_time` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_username` (`username`(20)), KEY `index_email` (`email`(20))) ENGINE=InnoDB AUTO_INCREMENT=101 DEFAULT CHARSET=utf8;CREATE TABLE `discuss_post` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` varchar(45) DEFAULT NULL, `title` varchar(100) DEFAULT NULL, `content` text, `type` int(11) DEFAULT NULL COMMENT &#x27;0-普通; 1-置顶;&#x27;, `status` int(11) DEFAULT NULL COMMENT &#x27;0-正常; 1-精华; 2-拉黑;&#x27;, `create_time` timestamp NULL DEFAULT NULL, `comment_count` int(11) DEFAULT NULL, `score` double DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_user_id` (`user_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `message` ( `id` int(11) NOT NULL AUTO_INCREMENT, `from_id` int(11) DEFAULT NULL, `to_id` int(11) DEFAULT NULL, `conversation_id` varchar(45) NOT NULL, `content` text, `status` int(11) DEFAULT NULL COMMENT &#x27;0-未读;1-已读;2-删除;&#x27;, `create_time` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_from_id` (`from_id`), KEY `index_to_id` (`to_id`), KEY `index_conversation_id` (`conversation_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `comment` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) DEFAULT NULL, `entity_type` int(11) DEFAULT NULL, `entity_id` int(11) DEFAULT NULL, `target_id` int(11) DEFAULT NULL, `content` text, `status` int(11) DEFAULT NULL, `create_time` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_user_id` (`user_id`) /*!80000 INVISIBLE */, KEY `index_entity_id` (`entity_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `login_ticket` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL, `ticket` varchar(45) NOT NULL, `status` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;0-有效; 1-无效;&#x27;, `expired` timestamp NOT NULL, PRIMARY KEY (`id`), KEY `index_ticket` (`ticket`(20))) ENGINE=InnoDB DEFAULT CHARSET=utf8; 12345678UserMapper selectById selectByName selectByEmail insertUser updateStatus updateHeader updatePassword 1 基本环境1-1 用户实体相关先看着敲一遍，然后自己写一遍，再对照，在此前先熟悉下数据库 123456789101112131415create table `user` ( `id` int(11) not null auto_increment, `username` varchar(50) default null, `password` varchar(50) default null, `salt` varchar(50) default null, `email` varchar(100) default null, `type` int(11) default null, `status` int(11) default null, `activation_code` varchar(100) default null, `header_url` varchar(200) default null, `create_time` timestamp null default null, primary key(`id`), key `index_username`(`username`(20)), key `index_email`(`email`(20))) engine = innodb auto_increment=101 default charset=utf8; 编写测试完用户实体的总结 12345678流程依赖：数据库驱动+mybatis配置：数据源 连接池配置实体mapper 测试crud注意测试，用到容器中的bean 须用@SpringBootTest 1-2 基本环境配置 原始网页素材已经没有了，初始是配置好分页相关的 thymeleaf语法 https://fanlychie.github.io/post/thymeleaf.html 日志默认 logback-spring.xml 1-3 帖子实体与分页实现帖子实体 mapper分页实体 thymeleaf 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 帖子列表 --&gt;&lt;ul class=&quot;list-unstyled&quot;&gt; &lt;li class=&quot;media pb-3 pt-3 mb-3 border-bottom&quot; th:each=&quot;map:$&#123;discussPosts&#125;&quot;&gt; &lt;a href=&quot;site/profile.html&quot;&gt; &lt;img th:src=&quot;$&#123;map.user.headerUrl&#125;&quot; class=&quot;mr-4 rounded-circle&quot; alt=&quot;用户头像&quot; style=&quot;width:50px;height:50px;&quot;&gt; &lt;/a&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h6 class=&quot;mt-0 mb-3&quot;&gt; &lt;a href=&quot;#&quot; th:utext=&quot;$&#123;map.post.title&#125;&quot;&gt;备战春招，面试刷题跟他复习，一个月全搞定！&lt;/a&gt; &lt;span class=&quot;badge badge-secondary bg-primary&quot; th:if=&quot;$&#123;map.post.type==1&#125;&quot;&gt;置顶&lt;/span&gt; &lt;span class=&quot;badge badge-secondary bg-danger&quot; th:if=&quot;$&#123;map.post.status==1&#125;&quot;&gt;精华&lt;/span&gt; &lt;/h6&gt; &lt;div class=&quot;text-muted font-size-12&quot;&gt; &lt;u class=&quot;mr-3&quot; th:utext=&quot;$&#123;map.user.username&#125;&quot;&gt;寒江雪&lt;/u&gt; 发布于 &lt;b th:text=&quot;$&#123;#dates.format(map.post.createTime,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;2019-04-15 15:32:18&lt;/b&gt; &lt;ul class=&quot;d-inline float-right&quot;&gt; &lt;li class=&quot;d-inline ml-2&quot;&gt;赞 11&lt;/li&gt; &lt;li class=&quot;d-inline ml-2&quot;&gt;|&lt;/li&gt; &lt;li class=&quot;d-inline ml-2&quot;&gt;回帖 7&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 分页 --&gt;&lt;nav class=&quot;mt-5&quot; th:if=&quot;$&#123;page.rows&gt;0&#125;&quot;&gt; &lt;ul class=&quot;pagination justify-content-center&quot;&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=1)&#125;&quot;&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;|page-item $&#123;page.current==1?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current-1&#125;)&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li th:class=&quot;|page-item $&#123;i==page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;|&quot; th:each=&quot;i:$&#123;#numbers.sequence(page.from,page.to)&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;i&#125;)&#125;&quot; th:text=&quot;$&#123;i&#125;&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;|page-item $&#123;page.current==page.total?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current+1&#125;)&#125;&quot;&gt;下一页&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.total&#125;)&#125;&quot;&gt;末页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 12345涉及到对象及运算的都用$&#123;&#125;th:href=@&#123;$&#123;&#125;()&#125;th:class=&quot;||&quot;th:each=&quot;map:$&#123;&#125;&quot;th:text=&quot;&quot; 分页测试报错 There is no getter for property named ‘userId’ in ‘class java.lang.Integer’https://blog.csdn.net/qq_30604989/article/details/81297400 2 登录模块2-1 邮件功能注意测试时有延迟，可能需要几分钟才能发送成功参考 https://blog.csdn.net/breakaway_01/article/details/111474564 2-2 注册123th:fragment=&quot;header&quot;th:href=&quot;@&#123;/index&#125;&quot;th:replace=&quot;index::header&quot; 2-3 问题thymeleaf找不到页面的问题注意@Controller配置@Slf4jhttps://www.jianshu.com/p/6e137ee836a1","categories":[{"name":"项目","slug":"项目","permalink":"https://shadowbynl.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"ls树相关","slug":"ls-tree","date":"2021-09-20T16:12:54.000Z","updated":"2021-10-07T08:16:13.462Z","comments":true,"path":"2021/09/21/ls-tree/","link":"","permalink":"https://shadowbynl.github.io/2021/09/21/ls-tree/","excerpt":"","text":"","categories":[{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"SQL相关","slug":"sql-00","date":"2021-09-20T14:51:34.000Z","updated":"2021-10-07T08:17:50.652Z","comments":true,"path":"2021/09/20/sql-00/","link":"","permalink":"https://shadowbynl.github.io/2021/09/20/sql-00/","excerpt":"sql相关的问题与练习","text":"sql相关的问题与练习 环境 环境本机mysql配置初始化密码遗失的解决方案 https://blog.csdn.net/m0_46278037/article/details/113923726","categories":[{"name":"面试","slug":"面试","permalink":"https://shadowbynl.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"儒猿面试之一","slug":"ry-00","date":"2021-09-20T14:34:49.000Z","updated":"2021-10-07T08:17:26.399Z","comments":true,"path":"2021/09/20/ry-00/","link":"","permalink":"https://shadowbynl.github.io/2021/09/20/ry-00/","excerpt":"中华石杉面试专题 高频考题篇","text":"中华石杉面试专题 高频考题篇 一 概述 二 集合 1 HashMap相关 2 一 概述二 集合1 HashMap相关 2","categories":[{"name":"面试","slug":"面试","permalink":"https://shadowbynl.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"测试问题","slug":"test-qa","date":"2021-09-15T08:17:23.000Z","updated":"2021-10-07T08:37:48.209Z","comments":true,"path":"2021/09/15/test-qa/","link":"","permalink":"https://shadowbynl.github.io/2021/09/15/test-qa/","excerpt":"占位","text":"占位 mysql 计算机网络 项目 mysqlNavicat运行SQL文件出错https://zhidao.baidu.com/question/525156367906044565.html 计算机网络TCP中的seq 什么意思https://zhidao.baidu.com/question/346839619.htmlhttps://www.cnblogs.com/vvull/p/10597881.html 项目创建springboot项目不成功的问题（网络连接） 网络换成热点（不一定） 创建不成功 https://blog.csdn.net/qq_26071319/article/details/106209405http://start.aliyun.com 代理 pom报红https://blog.csdn.net/feifeiwuxian/article/details/1093341011234567&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; https://blog.csdn.net/qq_41205651/article/details/114854831File -&gt; Invalidate Caches / Restart... -&gt; Invalidate and Restart","categories":[{"name":"随机","slug":"随机","permalink":"https://shadowbynl.github.io/categories/%E9%9A%8F%E6%9C%BA/"}],"tags":[]},{"title":"jf","slug":"jf","date":"2021-09-13T13:10:02.000Z","updated":"2021-10-07T08:15:58.778Z","comments":true,"path":"2021/09/13/jf/","link":"","permalink":"https://shadowbynl.github.io/2021/09/13/jf/","excerpt":"java框架的基本概念与使用相关 ssm springboot等","text":"java框架的基本概念与使用相关 ssm springboot等 mybatis spring springmvc mybatis配置解析映射文件和注解动态sql复杂实体关系缓存 spring控制反转 依赖注入代理模式 AOP整合声明式事务 springmvcdispatcherServlet原理 restful 请求参数 返回 乱码 json","categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"}],"tags":[]},{"title":"javaweb","slug":"javaweb","date":"2021-09-13T07:55:30.000Z","updated":"2021-10-07T08:36:50.636Z","comments":true,"path":"2021/09/13/javaweb/","link":"","permalink":"https://shadowbynl.github.io/2021/09/13/javaweb/","excerpt":"占位","text":"占位 jdbc smbms jdbcsmbms","categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"}],"tags":[]},{"title":"关于编程学习的问题","slug":"abstj","date":"2021-09-10T16:08:33.000Z","updated":"2021-10-07T08:13:08.957Z","comments":true,"path":"2021/09/11/abstj/","link":"","permalink":"https://shadowbynl.github.io/2021/09/11/abstj/","excerpt":"夏令营结束后的八月，心还是有些浮的，一直想回家回不成，所谓准备实习，但实际每天花在准备上的工夫很少，不够专注，效果很差。到九月初回顾自己的技术体系，发现有很多漏洞和模糊的地方，这时候认识到对于找这样的后端开发的工作来说，不专注地学习其基础的方方面面再去看面经总结，而是直接被动接收一些很粗略的知识，是绝对不能应付找工作的要求的。如果以后想干开发，在现在这么卷的情况下，不沉下心来学习准备，而是抱着一个“顺便”的态度，很难会有什么作为。近来先后找过同样学习后端开发的同学聊过两次（已有腾讯网易），对我有些启发，在这篇中简单总结下，同时后续关于总体学习的反思也在此记述。","text":"夏令营结束后的八月，心还是有些浮的，一直想回家回不成，所谓准备实习，但实际每天花在准备上的工夫很少，不够专注，效果很差。到九月初回顾自己的技术体系，发现有很多漏洞和模糊的地方，这时候认识到对于找这样的后端开发的工作来说，不专注地学习其基础的方方面面再去看面经总结，而是直接被动接收一些很粗略的知识，是绝对不能应付找工作的要求的。如果以后想干开发，在现在这么卷的情况下，不沉下心来学习准备，而是抱着一个“顺便”的态度，很难会有什么作为。近来先后找过同样学习后端开发的同学聊过两次（已有腾讯网易），对我有些启发，在这篇中简单总结下，同时后续关于总体学习的反思也在此记述。 一、一个专注的态度和学习方法 二、差异是如何造成的 三、方法 具体 书 一、一个专注的态度和学习方法其实回顾我过去这二十年，很难说我真正学会了什么技能，很多事浅尝辄止，很多事勉强应付。到现在能通过保研拿到这么一个打黑工的机会已经算是我牺牲比别人多几倍的时间（浪费）而争取到的一个并不怎么样的结果。未来靠什么才能生存，需要真正学会什么，我一直都很清楚，但态度和做法实际并不坚定。长久以来，我习惯看视频教程草草学习，看别人怎么做，但自己很少有练习思考，也很少有总结。往往事情一多起来，我就会中断技术的学习，很多东西一直反复，导致目前很难说掌握了什么技术。这种轻慢的应对技术学习的态度，导致的虚浮的技术水平，进而使我本人内心各方面其实都相当不自信。到现在这个阶段，今年的冬天我就要22周岁了，身体素质差，眼下较不抵触的路就是之后两年去南软外包公司去挣4k的月薪，而选择这条意味着未来我将走死开发这条路了。一个电子信息的硕士，学不到新的研究生阶段才能学到的知识，也不会有曾经渴望的导师的引导，有的只是在用身体换钱一条路走到黑的未来，对于我来说其实也算是较适合的了。不太想科研，也欠缺交际的能力，选择了计算机专业的话还是走开发较好，在这种意义上南软是个尚可的选择，算是有了title也有了一个缓冲学习的机会。如果我做了这样的选择，我未来三年内将完全以java开发为主了。和本科前三年的学习完全不同，前三年是在水绩点、竞赛等的同时自学编程，有一段没一段的，总会为完成课内的很多事而中断技术学习很长时间。而未来三年，在完全就业导向下，java这条线就是我主修的，学用、做项目就是我必须投入的。为了在研一的暑假能找到一份尚可不那么累的工作，我必须从现在开始，投入进去，可能这个学期的实习不太好找，但一定要开始打基础，奠定随时能找面试找工作的知识基础，本科毕业前，必须去尝试找实习找工作，至少得参加几十次面试积累经验，这样过渡到研究生再做一年开发后，才算好做一些。因此，我现在要做的是，明确该如何继续学习下去，需要看什么如何做，应该持有一个怎样的态度。 二、差异是如何造成的一年前的暑假基本算是我后端开发技能最熟练的时候了，那时候为完成课设和竞赛等差不多自己完整写过四五个web系统或桌面程序，到暑假给学院开发科研信息系统时我也是搭建基础环境框架、编写原始文档的主力，我的同学那时候刚接触web开发，还有很多问题需要问我。到大三以后，纠结于考研保研中很多时间不知不觉挥霍，结果保研考研没准备，项目也没怎么做，很多是在原来写的系统上修修改改，很多方面变得生疏了。而我的同学从今年年初开始准备面试和实习，每天花相当多的时间看书做笔记写算法题，逐一攻克java基础的各方面，稳扎稳打，其实半年左右，已经足够对javase、并发编程、虚拟机、框架等各方面有一个深入的认知了，同时做做项目，在校招中已经足够获得不错的offer了。可以说，一年过后，我现在不管从理论还是实操上都差了不少了。很大程度上是我过去半年的重心不在就业准备上面，但更重要的其实是我学习的方法和态度、认知不正确。我不管学什么，总是先找很多参考的资料，选择很长时间，再开始，但往往坚持不长时间就因其他事情而放弃，最终收效甚微。我可是太喜欢反思总结，而不去切实学习了。学而不思则罔，思而不学则殆。眼下最重要的就是调整认知，走入java技术体系的一个正常的学习路线。 三、方法通过与同学的交流，我认识到，对校招而言（暂时不谈社招），基础很重要，开发相关的理论也很多。 java相关的知识体系 javase 十几个方面 juc并发编程 netty rpc jvm 数据库 中间件 设计模式 计算机基础 而对于这样的基础理论的学习与实践，之前我的认知是视频教程+面经，可能很多人也是这么做的，但我确实这样做了之后感觉吸收不多，不踏实，可能是不够专注，但我同时也一直都清楚看书去学习技术，看文档才是搞开发最正的路线，再多的视频等也是给你提炼知识的，而且学习效果可能会比较差，所以这些基础理论的学习必须看书细过+实践。 考查的重心 微服务从来不是基础考核的重心，因此与其关注复杂的微服务项目，不如先学好基础的理论和做做基本全面的项目。 牛客的用处 算法题目 面经 项目 关键是什么 看的多，全面，关键是思想 具体123java这个ks路线还得走完框架，然后基础还得那么过但有些书得开始计划看了，初步决定在平板上看，博客做笔记，同时实践（需要先整下平板里以前的笔记） 书 java核心技术卷一/卷二 深入理解java虚拟机 第三版 java并发编程的艺术 java并发编程实战 网络 图解http 图解tcp 自顶向下 谢希仁 计算机基础 深入理解计算机系统 春风 1忽然意识到cs科班生应该沉下心研读些cs体系的东西","categories":[{"name":"规划","slug":"规划","permalink":"https://shadowbynl.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"java相关问题","slug":"java-qa","date":"2021-09-05T15:12:24.000Z","updated":"2021-10-07T08:36:43.273Z","comments":true,"path":"2021/09/05/java-qa/","link":"","permalink":"https://shadowbynl.github.io/2021/09/05/java-qa/","excerpt":"占位","text":"占位 可重入锁虚假唤醒COWcas compareandset","categories":[{"name":"随记","slug":"随记","permalink":"https://shadowbynl.github.io/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[]},{"title":"wsl相关配置","slug":"env-wsl","date":"2021-09-03T02:35:30.000Z","updated":"2021-10-07T08:12:15.236Z","comments":true,"path":"2021/09/03/env-wsl/","link":"","permalink":"https://shadowbynl.github.io/2021/09/03/env-wsl/","excerpt":"为允许大四上人工神经网络的程序，需要配置wsl2上的cuda相关环境，现记述一下相关过程与参考","text":"为允许大四上人工神经网络的程序，需要配置wsl2上的cuda相关环境，现记述一下相关过程与参考 1 介绍 2 本机cuda相关配置 3 关于wsl2的测试 win10虚拟机的问题 修改用户密码 安装图形界面 安装MySql8.0 文件传送 备份 4 wsl2 cuda配置 4.1 官网文档（校园网打不开） 4.2 cuda相关 安装好没有自动配置环境变量，手动配置 阿里云cuda镜像 卸载现有驱动/cuda 几种方案，但没有参考价值（都更新太快了） 各种报错 ubuntu卸载 比较有价值的参考方案，但还是失败了，和官网错误类似 4.3 综上 4.4 其他方案 1 介绍https://docs.microsoft.com/zh-cn/windows/wsl/abouthttps://docs.microsoft.com/zh-cn/windows/wsl/install-win10本机在2021.4.30时安装过wsl2 ubuntu2 2 本机cuda相关配置本机目前环境为cuda11.0 gpu为rtx3060 3 关于wsl2的测试win10虚拟机的问题 这里先提一下之前在win10上安装vmware后没法开启虚拟机的问题 这里进行详细记述，简单说就是win10本身的虚拟机功能和vmware冲突参考 https://www.chenkaihua.com/2019/09/23/hyper-off/ 12345安装virtualbox后发现开启不了虚拟机，根据网上资料得知，是因为微软默认开启了hyper-v,即便是在启用或关闭Windows功能里不启用Hyper-V,也不能解决问题，需要解决的话就需要彻底关闭hyper-v功能。从知乎问题上(Windows 10 下如何彻底关闭 Hyper-V 服务？ - 张林军的回答 - 知乎)找到了最简单的解决办法。快捷键win+x,使用管理员权限打开Windows Powershell关闭：bcdedit /set hypervisorlaunchtype off开启: bcdedit /set hypervisorlaunchtype auto 修改用户密码123456789win10中WSL登录是不用密码的，当需要使用用户权限但是忘记密码的时候，可以使用如下办法以root身份登录WSL并重置密码1、以管理员身份打开 PowerShell ;2、输入命令 wsl.exe --user root ;3、命令 passwd root 修改 root 用户密码。忘记其他用户密码supasswd 用户名 参考https://www.cnblogs.com/my-blogs-for-everone/articles/13973872.htmlhttps://blog.csdn.net/qq_28120227/article/details/100677167 安装图形界面https://www.bilibili.com/video/BV1LA411n7BK?spm_id_from=333.999.0.0 12345678910sudo apt update &amp;&amp; apt upgradesudo apt install xrdpsudo apt install xfce4 xfce4-goodiessudo vim /etc/xrdp/xrdp.iniecho xfce4-session &gt; ~/.xsessionsudo vim /etc/xrdp/startwm.shsudo /etc/init.d/xrdp startip asudo apt install firefox 安装MySql8.01234567891011121314151617181920212223安装mysqlsudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev查看默认密码sudo cat /etc/mysql/debian.cnf默认方式登陆mysql -u debian-sys-maint -p // 用户名以自己的配置文件为准更改密码mysql&gt;use mysql;mysql&gt;flush privileges;mysql&gt;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;你的密码&#x27;;mysql&gt;flush privileges;重启服务sudo service mysql restart开启端口vim /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉 bind-address = 127.0.0.1允许访问use mysql;select host from user where user = &#x27;root&#x27;;update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;flush privileges; 参考https://www.jianshu.com/p/99c4baca1983https://www.cnblogs.com/xiaozhounandu/p/14497835.htmlhttps://www.cnblogs.com/patrickding/p/6435459.htmlhttps://blog.csdn.net/iiiiiilikangshuai/article/details/100905996补充vimhttps://blog.csdn.net/yang1393214887/article/details/106233991https://blog.csdn.net/weixin_40853073/article/details/81707177 文件传送https://blog.csdn.net/x356982611/article/details/80077085 备份4 wsl2 cuda配置 先说结论：总体上完成配置的要求有1 硬件2 驱动3 wsl上的专用cuda4 dev通道的windows先后参照一个去年的视频教程、多篇博客、官网文档，在20.04 18.04等上先后安了三个版本的cuda，均测试失败，暂认为是没有安装dev预览版windows所致，但若进入dev通道升级为win11，对本机系统的稳定性有影响，也不容易回退，所以暂时放弃这个方案。下面记述一下过程及参考 4.1 官网文档（校园网打不开）https://docs.nvidia.com/cuda/wsl-user-guide/index.html#rel-460-15本机安装驱动和dev通道情况下，执行以下命令 1234567$ wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin$ sudo mv cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600$ wget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda-repo-wsl-ubuntu-11-4-local_11.4.0-1_amd64.deb$ sudo dpkg -i cuda-repo-wsl-ubuntu-11-4-local_11.4.0-1_amd64.deb$ sudo apt-key add /var/cuda-repo-wsl-ubuntu-11-4-local/7fa2af80.pub$ sudo apt-get update$ sudo apt-get -y install cuda 测试 123$ cd /usr/local/cuda-11.4/samples/4_Finance/BlackScholes$ make BlackScholes$ ./BlackScholes 在本机上，测试失败，提示大意为找不到驱动/gpuCUDA error at ../../common/inc/helper_cuda.h:779 code=35(cudaErrorInsufficientDriver) &quot;cudaGetDevicehttps://developer.nvidia.com/cuda/wsl/download 4.2 cuda相关安装好没有自动配置环境变量，手动配置https://blog.csdn.net/yinxian9019/article/details/106756280/ 阿里云cuda镜像https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/https://mirrors.aliyun.com/nvidia-cuda/ubuntu2004/x86_64/ 卸载现有驱动/cuda1234$ sudo apt-get remove --purge nvidia-* $ sudo apt-get autoremovedpkg -l | grep -i nvidia https://blog.csdn.net/weixin_32820767/article/details/83818885https://qastack.cn/ubuntu/206283/how-can-i-uninstall-a-nvidia-driver-completely 几种方案，但没有参考价值（都更新太快了）https://www.bilibili.com/video/BV1FZ4y1p7Qp?spm_id_from=333.999.0.0https://blog.csdn.net/qq_20291997/article/details/106897324https://blog.csdn.net/weixin_36815313/article/details/107641262https://zhuanlan.zhihu.com/p/152533150https://zhuanlan.zhihu.com/p/122286055 各种报错NVIDIA-SMI has failed because it couldn&#39;t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.https://zhuanlan.zhihu.com/p/89714824https://blog.csdn.net/weixin_42084747/article/details/84371079?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link ubuntu卸载https://blog.csdn.net/weixin_33711641/article/details/90386490?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.control&amp;spm=1001.2101.3001.4242https://blog.csdn.net/qq_38410428/article/details/82930814 比较有价值的参考方案，但还是失败了，和官网错误类似https://blog.csdn.net/u010953692/article/details/113830046 123456wget https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/cuda-ubuntu1804.pinsudo mv cuda-ubuntu1804.pin /etc/apt/preferences.d/cuda-repository-pin-600sudo apt-key adv --fetch-keys https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/7fa2af80.pubsudo add-apt-repository &quot;deb https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/ /&quot;sudo apt-get updatesudo apt-get -y install cuda 4.3 综上基本可以判断是没有用dev通道的问题，参考一篇博客的评论（五月左右）提到切换到dev通道按官网方式就成功了，但这样风险有些大，所以不再尝试。https://zhuanlan.zhihu.com/p/386362341 极不容易回退，也不稳定 4.4 其他方案1.本机上是有完整可用的cuda+opencv的环境的，就看代码怎么改了。。2.先下数据集，数据集官方的下载速度很慢（校园网），一般找不到其他的就得耗流量了。。 hmdb51https://www.pianshen.com/article/1325689931/https://serre-lab.clps.brown.edu/resource/hmdb-a-large-human-motion-database/ucf101https://blog.csdn.net/weixin_40162095/article/details/111870161 其他https://blog.csdn.net/alec1987/article/details/69388699?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.no_search_link","categories":[{"name":"环境","slug":"环境","permalink":"https://shadowbynl.github.io/categories/%E7%8E%AF%E5%A2%83/"}],"tags":[]},{"title":"输入输出","slug":"dsa-io","date":"2021-09-01T09:52:41.000Z","updated":"2021-10-07T08:35:22.028Z","comments":true,"path":"2021/09/01/dsa-io/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/dsa-io/","excerpt":"占位","text":"占位 c++ java c++https://www.cnblogs.com/Mary-Sue/p/8678462.html java","categories":[{"name":"语法","slug":"语法","permalink":"https://shadowbynl.github.io/categories/%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"信息检索系统","slug":"ds-xxjsxt","date":"2021-09-01T06:00:27.000Z","updated":"2021-10-07T08:12:49.740Z","comments":true,"path":"2021/09/01/ds-xxjsxt/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/ds-xxjsxt/","excerpt":"该篇是为完成大四上信息检索系统作业，对其基础理论和相关参考进行学习的一个随记，并记录完成作业的思路过程。","text":"该篇是为完成大四上信息检索系统作业，对其基础理论和相关参考进行学习的一个随记，并记录完成作业的思路过程。 理论部分 jdnlp的课件：信息检索及倒排技术 现代信息检索 信息检索：实现和评价搜索引擎 实现部分 lzw报告理解复现 其他参考程序 实现 一些问题与参考 java解析处理相关 相关资源 理论部分jdnlp的课件：信息检索及倒排技术 信息检索 Information Retrieval(IR)：从大规模非结构化数据（通常是文本）的集合（通常保存在计算机上）中找出满足用户信息需求的资料（通常是文档） 的过程。作为一门学科，是研究信息的获取(acquisition)、表示(representation)、 存储(storage)、组织(organization)和访问(access)的一门学问。 信息检索的历史 123456789101112131415# 计算机出现以前目录--索引（从词和概念指向相关信息或文档的指针）手工方式建立索引：如词典的拼音检字 部首笔画检字# 1948第一次出现信息检索的术语# 60s-70s为文献摘要建立文本检索系统产生了布尔模型、向量空间模型和概率检索模型的概念# 80s商用较大规模数据库检索系统# 90s网络搜索工具 web搜索引擎# 2000信息抽取 问答系统 演化出了很多nlp任务，不仅仅是搜索引擎 信息检索例子 倒排索引 布尔检索模型 现代信息检索信息检索：实现和评价搜索引擎相较上本书，这本书更直接地介绍了基本概念 实现部分 由于是作业驱动，没有必要先把概念全部先看一遍，不理解的地方回看即可 lzw报告理解复现两段程序都比较清晰容易理解，算法并不复杂，繁琐的还是文件处理1 tf-idf 英文的话实现很简单 但中文就要考虑分词了，所以会更加负责2 倒排索引 需要自己实现b+树/前缀树 因此如果使用java实现的话，首先是要解决文本处理的问题 其他参考程序1 拼写检查功能只实现了一半2 中文分词3 commonsio maven项目中绝对路径4 中文分词 实现 10.4 下午六点 基本把三份代码完成了 完成情况 tf-idf 1234561.完成了中文和英文两种计算2.对中文2.1 前缀树存储词库2.2 分词工具类：前缀树初始化 文本预处理 分词2.3 测试类 计算父类 中文处理子类3.对英文 倒排索引 121.主要是修改了前缀树的数据结构 改动不多2.只实现了对英文单文本的 逐行处理 记录一个单词在一个文本中的行号，列好 不处理行尾一个单词未结束的情况 爬虫 12341.为方便1测试，写个简单的爬取中文文本的方法2.原定计划是中文+英文 但没必要就不写了3.搜过一些xpath解析的方法 dom4j jsoupxpath等等 但都不能利用xpath表达式最后还是老老实实用jsoup解析 + 连接池 问题 12程序1中的中文处理中无论如何无法去掉部分词语的空格，多处处理无法过滤，暂时留着这个问题程序2中仅限处理约定的情况 一些问题与参考java解析处理相关1.java去除空格符的方法https://blog.csdn.net/weixin_33851177/article/details/92001703 12345678910111213141516JAVA中去掉空格 1. String.trim() trim()是去掉首尾空格 2.str.replaceAll(&quot; &quot;, &quot;&quot;); 去掉所有空格，包括首尾、中间 String str = &quot; hell o &quot;; String str2 = str.replaceAll(&quot; &quot;, &quot;&quot;); System.out.println(str2); 3.或者replaceAll(&quot; +&quot;,&quot;&quot;); 去掉所有空格 4.str = .replaceAll(&quot;\\\\s*&quot;, &quot;&quot;); 可以替换大部分空白字符， 不限于空格 \\s 可以匹配空格、制表符、换页符等空白字符的其中任意一个 2.notepad++查看所有字符（没用）https://jingyan.baidu.com/article/ce4366494960083773afd32e.html3 java xpath解析方法https://blog.csdn.net/weixin_42022555/article/details/82775916https://www.cnblogs.com/wanghaomiao/p/4899355.htmlhttps://blog.csdn.net/baidu_36336788/article/details/89875926?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link4 java格式化输出方法https://blog.csdn.net/qq_44111805/article/details/1128505505 TreeMap按照value进行排序https://blog.csdn.net/liuxiao723846/article/details/50454622 1234567891011121314151617181920public static void sortByValue() &#123; Map&lt;String,String&gt; map = new TreeMap&lt;String,String&gt;(); map.put(&quot;a&quot;, &quot;dddd&quot;); map.put(&quot;d&quot;, &quot;aaaa&quot;); map.put(&quot;b&quot;, &quot;cccc&quot;); map.put(&quot;c&quot;, &quot;bbbb&quot;); List&lt;Entry&lt;String, String&gt;&gt; list = new ArrayList&lt;Entry&lt;String, String&gt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() &#123; //升序排序 public int compare(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2) &#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for (Entry&lt;String, String&gt; e: list) &#123; System.out.println(e.getKey()+&quot;:&quot;+e.getValue()); &#125; &#125; 6 Java遍历Map的4种方式https://blog.csdn.net/chpllp/article/details/109073224 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; // 循环遍历Map的4中方法 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(1, 2); // 1. entrySet遍历，在键和值都需要时使用（最常用） for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key = &quot; + entry.getKey() + &quot;, value = &quot; + entry.getValue()); &#125; // 2. 通过keySet或values来实现遍历,性能略低于第一种方式 // 遍历map中的键 for (Integer key : map.keySet()) &#123; System.out.println(&quot;key = &quot; + key); &#125; // 遍历map中的值 for (Integer value : map.values()) &#123; System.out.println(&quot;key = &quot; + value); &#125; // 3. 使用Iterator遍历 Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(&quot;key = &quot; + entry.getKey() + &quot;, value = &quot; + entry.getValue()); &#125; // 4. java8 Lambda // java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value， // 不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式 map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot;:&quot; + value); &#125;); &#125; 7 java列出目录文件https://blog.csdn.net/hlanting/article/details/92854033?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link 12345678910111213141516package com.jn.test; import java.io.File; public class ListFile2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub File file=new File(&quot;E:\\\\&quot;); for(File temp:file.listFiles())&#123; if(temp.isDirectory())&#123; System.out.println(temp.toString()); &#125; &#125; &#125;&#125; 8 commons-io的常用方法https://blog.csdn.net/backbug/article/details/99572931?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_linkhttps://blog.csdn.net/weixin_44035017/article/details/102526767https://blog.csdn.net/weixin_44035017/article/details/1025267679 Java之StringUtils的常用方法https://blog.csdn.net/weixin_42290280/article/details/8259116110 java正则https://www.runoob.com/java/java-regular-expressions.html11 Java删除/清除/过滤标点（所有中英文标点）的正则表达式https://blog.csdn.net/yuan882696yan/article/details/52276210 123(1) s.replaceAll( &quot;\\\\p&#123;Punct&#125;&quot;, &quot;&quot; ); (2) s.replaceAll(&quot;\\\\pP&quot; , &quot;&quot;); (3) s.replaceAll(&quot;\\\\p&#123;P&#125;&quot; , &quot;&quot;); 12 commons-lang 常用apishttps://max.book118.com/html/2017/0325/96858094.shtm13 中文分词方法https://blog.csdn.net/weixin_42242538/article/details/84754491 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697中文分词通俗来讲，中文分词是指将一句中文句子中的所有中文词汇相互分隔开来。它是文本挖掘的基础，有着十分广阔的应用前景。下面，我们来看一看对于这个技术的简单实现。算法对于中文分词技术的实现，有许多算法可以完成，目前大致可以把算法分为三大类：基于字符串匹配的分词方法；基于理解的分词方法；基于统计的分词方法。其中，基于字符串匹配的分词方法是把中文句子按照一定的策略将待分析的汉字串与已知且足够大的中文词典库进行比对，从而达到分词效果。而我们通常使用最多的分词策略，大致有三类，正向最大匹配法，逆向最大匹配法和最少切分法。基于理解的分词方法是指让计算机模拟人对句子的理解进行分词。基于统计的分词方法是指找出上下文中出现较多的汉字组合，将这些组合视为词汇，代入到原文中进行分词。在这里，我们就使用字符串匹配的分词方法，利用逆向最大匹配的策略，对中文句子进行简单的分词。算法思路逆向最大匹配法大致思想为：将整个字符串作为一个“词组”带入到词典中进行比对，若不成功，删除第一个字符，继续进行如此操作，直到成功或者只剩下最后一个字，再把结果放入一个字符串的数组中，最后删除原句中的结果，继续上面的操作。下面我将用一个例子解释这个操作：原句：今晚月亮真漂亮啊词典：“今晚”，“月亮”，“漂亮”第一次代入：今晚月亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）删除首字符：晚月亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）删除首字符：月亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）删除首字符：亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）…删除首字符：啊（在词典中没有该词汇，只剩下一个字，放入结果数组，并删除位于句尾的最后这个字，进行第二次代入）第二次代入：今晚月亮真漂亮（在词典中没有该词汇，删除首字符继续比对）…删除首字符：漂亮（在词典中找到词汇“漂亮”，放入结果数组，并删除位于句尾的结果“漂亮”，进行第三次代入）…————————————————版权声明：本文为CSDN博主「birches」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_42242538/article/details/84754491public class secondwork &#123; public static void main(String args[]) &#123; String[] cs = &#123;&quot;你好&quot;,&quot;请问&quot;,&quot;什么&quot;,&quot;名字&quot;&#125;;//词典 String a = &quot;你好！请问你叫什么名字？&quot;; System.out.print(&quot;原句：&quot;); System.out.print(a + &#x27;\\n&#x27;); System.out.print(&quot;拆分后为：&quot;); String[] cs2 = new String[100]; //结果数组 int jud=0;//找到匹配字符串与否的标志 int j=0; String temp=null;//初始化临时字符串 for(;a.length()&gt;0;) &#123; for(int i = 0;i&lt;a.length();i++) &#123; temp = a.substring(i);//每次截取掉首个字符 if(isin(cs,temp) == true)//如果目标字符串在数组中 &#123; cs2[j] = temp; jud = 1; int number = temp.length(); a = a.substring(0,a.length()-number); &#125; &#125; if(jud == 0)//没有找到匹配字符串 &#123; cs2[j] = a.substring(a.length()-1,a.length());//将最后一个元素放在cs2里面 a = a.substring(0, a.length()-1);//截掉最后一个元素继续循环。 &#125; jud = 0; j++; &#125; for(;j &gt;= 0;j--) &#123; if(cs2[j] != null) System.out.print(cs2[j]+&quot; &quot;); &#125; &#125; /* * 下面为判断字符串是否在词典中的函数方法 */ static public boolean isin(String[] cs,String temp)//判断目标字符串是否在对比字符串数组中 &#123; int i; for(i = 0;i&lt;cs.length;) &#123; if(temp.equals(cs[i])) i = cs.length+1; else i++; &#125; if(i == cs.length+1) return true; else return false; &#125;&#125; 相关资源1 英文文本http://www.enread.com/news/life/114823.htmlhttp://www.enread.com/2 小说https://www.tycqxs.com/57_57672/21597158.html3 python splithttps://www.jb51.net/article/63592.htm4 敏感词过滤方法https://blog.csdn.net/qq_42956993/article/details/1094915565 用于存储中文字符的字典树https://blog.csdn.net/ccwlisha/article/details/895254556 maven项目就别想用相对路径读写文件了7 java实现b+树8 中文分词工具https://search.gitee.com/?q=%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D&amp;skin=rec&amp;type=repository&amp;pageno=2https://blog.csdn.net/qq_41154871/article/details/893755879 中文文本纠错算法实现https://blog.csdn.net/demm868/article/details/107096661","categories":[{"name":"大四","slug":"大四","permalink":"https://shadowbynl.github.io/categories/%E5%A4%A7%E5%9B%9B/"}],"tags":[]},{"title":"网络安全","slug":"ds-net","date":"2021-09-01T01:55:32.000Z","updated":"2021-10-07T08:12:54.881Z","comments":true,"path":"2021/09/01/ds-net/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/ds-net/","excerpt":"大四上学期网络安全选修课课程内容","text":"大四上学期网络安全选修课课程内容 1 概述 2 密码体制与技术 非对称加密技术组合 3 PKI技术 3.1 数字证书 3.2 数字证书安全通信实例 3.3 PKI的组成 3.4 PKI的应用 查看数字证书 国内外CA 数字证书的申请 数字证书应用操作实例 4 VPN技术 4.1 VPN概述 为什么需要VPN–VPN产生的原因 VPN的定义和分类 VPN能做什么–功能 VPN的分类 4.2 VPN原理 实现VPN的关键技术 1 安全隧道技术 1 概述12345678910111213141516171. TCP连接为什么需要三次握手？两次握手是否可以？答：为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。举例表述：防止失效的连接请求报文段被服务端接收，从而产生错误。 首先需要解释失效的连接请求是什么：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是失效的连接请求。假如建立连接只需两次握手，对于客户端来说并没有太大的变化。但仍然需要获得服务端的应答后才进入ESTABLISHED（建立）状态。而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。https://blog.csdn.net/lengxiao1993/article/details/82771768?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.essearch_pc_relevanthttps://blog.csdn.net/AntdonYu/article/details/1037655532. 什么是TCP半开连接？客户端向服务端发送SYN建立连接请求，服务端响应SYN-ACK建立连接，即为TCP半开连接。3. SYN Flood属于哪种攻击？SYN Flood (SYN泛洪) 是种典型的DoS (Denial of Service，拒绝服务) 攻击，效果是服务器TCP连接资源耗尽，停止响应正常的TCP连接请求。https://blog.csdn.net/chenyulancn/article/details/788325974.什么是字典攻击？在破解密码或密钥时，逐一尝试用户自定义词典中的可能密码（单词或短语）的攻击方式。与暴力破解的区别是，暴力破解会逐一尝试所有可能的组合密码，而字典式攻击会使用一个预先定义好的单词列表（可能的密码）。5. ARP欺骗的原理是什么？ARP(Address Resolution Protocol，地址解析协议)是一个位于TCP/IP协议栈中的低层协议，负责将某个IP地址解析成对应的MAC地址。从影响网络连接通畅的方式来看，ARP欺骗分为二种，一种是对路由器ARP表的欺骗;另一种是对内网PC的网关欺骗。第一种ARP欺骗的原理是——截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的路由器途径上网。在PC看来，就是上不了网了，“网络掉线了”。https://www.xuexila.com/luyouqi/120948.htmlhttps://jingyan.baidu.com/article/fea4511a7a2020f7bb91252a.html 2 密码体制与技术12345678910111213141516171.三重DES为什么是加密-解密-加密三重DES(triple-des)是为了增加DES的强度,将DES重复3次所得到的一种密码算法,也称为TDEA(Triple Date Encryption Algorithm),通常缩写为3DES。三重DES并不是进行三次DES加密(加密→加密→加密),而是加密→解密→加密的过程,目的是为了让三重DES能够兼容普通的DES。当三重DES中所有的密钥都相同时,三重DES也就等同于普通的DES了。这是因为在前两步加密→解密之后,得到的就是最初的明文。因此,以前用DES加密的密文,就可以通过这种方式用三重DES来进行解密。也就是说,三重DES对DES具备向下兼容性。2.密钥是不是越长越好密码体制的安全性，其并不是仅仅由密钥的长度决定的，但是在同一个密码体制中，越长的密钥意味着密钥空间越大，敌手通过暴力穷举的方式得到真实密钥的情况更加难以发生，在这种意义上讲，同一种密码体制中，体制的安全性与密钥的长度相关。3.对称密码的优点是什么以及缺点是什么优点算法简单、速度快、适合加密大量数据缺点密钥管理方面如何安全的共享秘密密钥，不可能与你未曾谋面的人通信每对通信者间都需要一个不同的密钥，当用户量增大时密钥空间急剧增大。没有解决不可抵赖问题没有解决不可抵赖问题 参考https://www.cnblogs.com/songwenlong/p/5944139.htmlhttps://www.sohu.com/a/278245376_100245441https://www.zhihu.com/question/365630892 matlab图像置乱参考https://blog.csdn.net/qq_33472557/article/details/79668662https://ww2.mathworks.cn/help/matlab/ref/rgb2gray.htmlhttps://www.cnblogs.com/wxl845235800/p/7216785.htmlhttps://jingyan.baidu.com/article/ed15cb1b3e94da5be269810f.htmlhttps://ww2.mathworks.cn/help/matlab/ref/imread.html matlab 图片相关的问题 imshow image https://tieba.baidu.com/p/6492190181图片分量提取 https://jingyan.baidu.com/article/456c463b41de5f0a5831448e.htmllinux移动文件 https://www.cnblogs.com/aiyr/p/7395738.htmlubuntu创建用户https://blog.csdn.net/taolusi/article/details/81304057“const char *” 类型的实参与 “char *” 类型的形参不兼容错误的解决方法https://blog.csdn.net/qinshiyang/article/details/83213664cvwaitkey未定义标识符https://blog.csdn.net/baidu_38172402/article/details/87982268hhu推免 https://cies.hhu.edu.cn/2020/0924/c4093a213007/page.pspimresizehttps://baike.baidu.com/item/imresize/9948188?fr=aladdinmatlab输入输出https://blog.csdn.net/yewuzhitou/article/details/81906379matlab 技巧 figurehttps://blog.csdn.net/hyz301/article/details/64130405matlab将灰度图转化为彩图https://blog.csdn.net/felix_zhangshou/article/details/88915229?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&amp;spm=1001.2101.3001.4242http://blog.sina.com.cn/s/blog_a5fdbf010101hhyk.html置乱https://blog.csdn.net/qq_25884463/article/details/52463788https://wenku.baidu.com/view/7c3c84f2580102020740be1e650e52ea5418ce81.html?rec_flag=default&amp;fr=Recommend_RelativeDoc-60354,60273,60321,40251-kpdrec_doc_pc_view-203b4e017dd5360cba1aa8114431b90d6d85895a&amp;sxts=1631104444164https://wenku.baidu.com/view/203b4e017dd5360cba1aa8114431b90d6d85895a.htmlhttps://blog.csdn.net/qq_33472557/article/details/79668662 非对称加密技术组合A–B1 会话密钥加密明文2 明文哈希–数字签名–A私钥加密3 B公钥加密会话密钥B–A1 B私钥解密会话密钥2 获取明文3 明文哈希–数字签名+A公钥–比较 3 PKI技术123456中间人攻击数字证书 权威机构CA内容 格式 数字签名 CA的私钥对哈希过的数字证书进行签名根证书通信实例 3.1 数字证书 引入 安全功能：认证 授权 保密性（防偷听） 完整性（防篡改）防抵赖网络通信的四个安全要素如何解决安全要素 12345信任类型 现实世界 数字世界身份认证 身份证、护照、信用卡、驾照 数字证书、数字签名完 整 性 签名、支票、第三方证明 数字签名或MAC保 密 性 保险箱、信封、警卫、密藏 对称加密或公钥加密不可否认性 签名、挂号信、公证、邮戳 数字签名 PKI 公钥基础设施 数字证书 数字证书的提出A需要用B的公钥加密信息，那么在发送前，需要获取B公钥，一种是B发给A，一种是提供一个公共访问地址若有人假冒B的公钥发消息，这样能获得A的信息，中间人攻击 数字证书 用户身份+公钥 权威机构CA证实身份 身份+公钥–证书 数字证书的内容名称 序列号 签发者 发布时间 有效时间 公钥 数字证书格式–标准X.509如何保证数字证书的不可篡改性1 数字签名 对数字证书内容进行哈希后，再用CA的私钥进行数字签名2 CA对证书签名后，大家如何验证这个签名用证书发布机构的公钥3 如何获得CA的公钥CA给自己颁发的证书–根证书–包含CA公钥4 如何获取根证书 系统安装时已有一些默认安装的根证书例 签名算法 sha1RSA 哈希算法 sha1 公钥加密算法 rsa 3.2 数字证书安全通信实例1 客户向服务端发送通信请求2 服务器给客户自己的数字证书 有公钥加密信息 私钥服务器持有3 客户端收到服务端的证书，对其进行验证（是否过期–&gt;根证书（公钥）解密 哈希–&gt;比较–&gt;是否是CA颁发证书，是否是指定通信对象–&gt;取出公钥）4 身份认证 客户给服务端一个随机字符串，让其用私钥加密 服务器把结果返回 客户用公钥解密，说明匹配了5 验证服务器身份后，客户生成一个对称加密算法和密钥，用于后面通信的加密和解密（公钥加密后发送给服务器） 后续双方可以使用对称加密算法来加密解密通信内容问题1：服务器随便加密一个来路不明的字符串是不安全的问题2：黑客可以扰乱通信过程 重发 3.3 PKI的组成组成：证书持有者证书认证机构CA：必须有一个可信机构对一个主体公钥进行公证（签发证书 证书管理 密钥管理 证书状态查询）证书注册机构RA：分担CA的任务证书注册机构RA：辅助证书存储和发布系统：负责证书的分发（证书库：证书的集中存放）证书应用系统：应用接口和基于此的应用服务 证书撤销： 在有效期内由于某些原因需要废除 证书撤销列表CRL 3.4 PKI的应用查看数字证书Internet选项–内容–证书 国内外CA数字证书的申请证书的获得和安装（安装根证书 表格申请 下载数字证书安装） 数字证书应用操作实例添加数字签名 4 VPN技术4.1 VPN概述为什么需要VPN–VPN产生的原因总公司和分公司间有大量的数据要传输1 专线费用高 灵活性差2 若不使用任何技术措施在公共网上传输数据端到端数据安全问题（拨入段 外部段 内部段）风险：（1）拨入段 用户明文到ISP（攻击者和ISP存在问题）（2）因特网上数据泄露的风险（逐段加密也不能防范恶意的ISP，路由器上肯定会解密，且ISP可能伪造网关）（3）安全网关中数据泄露的风险（4）内部网中数据泄露的风险 需要一个综合一致的解决方案，提供端到端的、逐段的数据保护 VPN的定义和分类虚拟专用网VPN 在公共网络中建立的安全网络连接 采用了专有的协议虚拟 不再需要拥有实际的专线专用 VPN能做什么–功能数据机密性、完整性保护、身份认证数据完整性：VPN网关hash后摘要+数据包加密–解密数据包-&gt;hash-&gt;比对摘要数据认证：签名（数据包hash后摘要-&gt;私钥签名DSS，附在数据包后发送–&gt;取出DSS，公钥解密–原始数据包hash–比对 VPN的分类根据网络类型差异，分为两种类型Client-LAN 远程访问 客户端到网关（需要在LAN中加一个VPN设备）LAN-LAN 总部到分支机构 远程办公室（不同的局域网之间，每个LAN中都需要VPN设备） 4.2 VPN原理实现VPN的关键技术1 安全隧道技术一种封装，将一种协议封装在另一种协议中传输隧道协议包括三种：乘客 封装 运载 隧道技术和隧道协议 隧道协议类型 分类依据：被封装的数据在OSI/RM的层次二层隧道协议：封装数据链路层的数据包 构建远程访问型的VPN L2F PPTP L2TP三层隧道协议：网络层协议封装到隧道协议中传输 应用于构建LAN-LAN型的VPN 第二层隧道协议 PPTP 点到点 第一个广泛使用建立VPN的协议 PPP协议的问题 工作在专线上才能保证安全性 但专线贵 希望PPP工作在Internet上而不是专线上，但PPP是点对点的，只是一个链路层协议 PPTP 点对点隧道 还是基于PPP的 接入集中器AC（客户端-因特网间）：封装数据包，加上IP地址等可以路由的部分 乘客PPP 封装GRE 运载IP 第二层隧道协议 L2TP 以PPTP和L2F为基础，结合了两者的优点 工业标准 PPP PPTP L2TP比较 第三层隧道协议 IP–&gt;IPSec 传输模式只加密数据，隧道模式加密整个IP包，安全性更高。隧道模式开销更大 AH协议 ESP协议 认证+加密 IKE协议 安全地交换一套密钥 SA 安全联盟 SA和DH交换算法 DH原理 如何获得一致的密钥 且防止攻击者获得密钥的拷贝 混色原理正向很容易，逆向很难（单向函数）1 相同的初始颜色2 各有一个私有颜色 混合之后给对方 再与私有混合后即可获得相同颜色3 攻击者可能获得两者的混合颜色 但无法获取两者的私有颜色对一个数字过程 找一个单向函数数学原理 IKE密钥交换两个阶段","categories":[{"name":"大四","slug":"大四","permalink":"https://shadowbynl.github.io/categories/%E5%A4%A7%E5%9B%9B/"}],"tags":[]},{"title":"排序","slug":"dsa-sort","date":"2021-09-01T01:05:58.000Z","updated":"2021-10-07T08:13:03.179Z","comments":true,"path":"2021/09/01/dsa-sort/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/dsa-sort/","excerpt":"排序相关算法与问题","text":"排序相关算法与问题 排序算法模板 快速排序 归并排序 排序相关问题 第k个数（快速排序） 排序算法模板快速排序1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int a[100010];void quick_sort(int n[], int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int p = n[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while (i &lt; j) &#123; while(n[++i] &lt; p); while(n[--j] &gt; p); if (i &lt; j) &#123; swap(n[i], n[j]); &#125; &#125; quick_sort(n, l, j); quick_sort(n, j + 1, r);&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; quick_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125; 123456789101112131415161718192021222324252627public class TestSort &#123; public static void main(String[] args) &#123; int[] nums = &#123;22, 34, 1, 2, 0, 44, 553, 2, 3&#125;; quickSort(nums, 0, nums.length - 1); for (int x : nums) &#123; System.out.println(x); &#125; &#125; public static void quickSort(int[] nums, int l, int r) &#123; if (l &gt;= r) return; int xi = (int)(Math.random() * (r - l) + l); int x = nums[xi]; int i = l - 1, j = r + 1; while (i &lt; j) &#123; while (nums[++i] &lt; x); while (nums[--j] &gt; x); if (i &lt; j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125; &#125; quickSort(nums, l, j); quickSort(nums, j + 1, r); &#125;&#125; 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N];int b[N];void merge_sort(int a[], int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int m = l + r &gt;&gt; 1; merge_sort(a, l, m); merge_sort(a, m + 1, r); int k = 0; int i = l, j = m + 1; while (i &lt;= m &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) &#123; b[k++] = a[i++]; &#125; else &#123; b[k++] = a[j++]; &#125; &#125; while (i &lt;= m) &#123; b[k++] = a[i++]; &#125; while (j &lt;= r) &#123; b[k++] = a[j++]; &#125; for (int i = 0; i &lt; k; i++) &#123; a[l + i] = b[i]; &#125;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; merge_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125; 排序相关问题第k个数（快速排序）acwing786 leetcode215https://www.acwing.com/problem/content/788/https://www.acwing.com/solution/content/63587/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 时间复杂度：O(n), 空间复杂度: 递归栈空间O(logn)// y总 代码 没有 随机选取 x , 导致 用时比较长 44ms. 随机后 4ms// 如果 x 每次都选 nums[l] 或 nums[r], 碰到 升序或降序的 极端样例, 时间O(n^2),, 用时会很久// 而且 nums[l] 和 nums[r] 的代码边界不一样, 容易出错, 建议选 nums[l + r &gt;&gt; 1]// 选取 nums[l] 的 用时 在 40ms 左右, 选取 nums[r]需要修改一下边界情况, 没有改, 应该也40ms左右// 选取 nums[l + r &gt;&gt; 1] 跟 随机选取 nums[rand() % (r - l + 1) + l] 时间差不多, 在 4ms 左右class Solution &#123;public: int quick_select(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123; if (l &gt;= r) return nums[l]; // int i = l - 1, j = r + 1, x = nums[l + r &gt;&gt; 1]; // 选取 nums[l], 极端样例 时间会很久 int x = nums[rand() % (r - l + 1) + l], i = l - 1, j = r + 1; // 随机选取 while (i &lt; j) &#123; do i ++ ; while (nums[i] &gt; x); do j -- ; while (nums[j] &lt; x); if (i &lt; j) swap(nums[i], nums[j]); &#125; if (k &lt;= j - l + 1) return quick_select(nums, l, j, k); else return quick_select(nums, j + 1, r, k - (j - l + 1)); &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; srand(time(0)); // 随机种子 return quick_select(nums, 0, nums.size() - 1, k); &#125;作者：yxc链接：https://www.acwing.com/video/1589/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。// 时间复杂度：O(n), 空间复杂度: O(1)// y总 代码 去掉递归栈空间, 用 while 循环, 就不用 递归栈空间 了.// 原来的 递归 只是 相同的代码, 只不过 递归时 递归的参数 区间端点值 l,r 以及 k变了// 这里 while 每次循环 也是 用 相同的代码, 只不过 是 每次循环之后 将 l,r 以及 k 更新class Solution &#123;public: int quick_select(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123; while(true) &#123; if (l == r) return nums[l]; // int i = l - 1, j = r + 1, x = nums[l + r &gt;&gt; 1]; // 选取 nums[l], 极端样例 时间会很久 int x = nums[rand() % (r - l + 1) + l], i = l - 1, j = r + 1; // 随机选取 while (i &lt; j) &#123; do i ++ ; while (nums[i] &gt; x); do j -- ; while (nums[j] &lt; x); if (i &lt; j) swap(nums[i], nums[j]); &#125; // 将 递归 的 参数l,r,k变化 改为 while 循环中 l,r,k 更新, 省去递归栈空间 // if (k &lt;= j - l + 1) return quick_select(nums, l, j, k); if (k &lt;= j - l + 1) r = j; // else return quick_select(nums, j + 1, r, k - (j - l + 1)); else k = k - (j - l + 1), l = j + 1; // 注意 k更新用到 l, 所以 l 更新应该在 k更新之后 &#125; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; srand(time(0)); // 随机种子 return quick_select(nums, 0, nums.size() - 1, k); &#125;&#125;;作者：yxc链接：https://www.acwing.com/video/1589/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 注意 c++的rand()函数https://blog.csdn.net/cmm0401/article/details/54599083 123456789101112131415161718192021222324252627282930313233343536373839404142C++中rand() 函数的用法1、rand()不需要参数，它会返回一个从0到最大随机数的任意整数，最大随机数的大小通常是固定的一个大整数。2、如果你要产生0~99这100个整数中的一个随机整数，可以表达为：int num = rand() % 100; 这样，num的值就是一个0~99中的一个随机数了。3、如果要产生1~100，则是这样：int num = rand() % 100 + 1; 4、总结来说，可以表示为：int num = rand() % n +a; 其中的a是起始值，n-1+a是终止值，n是整数的范围。5、一般性：rand() % (b-a+1)+ a ; 就表示 a~b 之间的一个随机整数。6、若要产生0~1之间的小数，则可以先取得0~10的整数，然后均除以10即可得到“随机到十分位”的10个随机小数。 若要得到“随机到百分位”的随机小数，则需要先得到0~100的10个整数，然后均除以100，其它情况依 此类推。7、通常rand()产生的随机数在每次运行的时候都是与上一次相同的，这样是为了便于程序的调试。 若要产生每次不同的随机数，则可以使用srand( seed )函数进行产生随机化种子，随着seed的不同，就能够产生 不同的随机数。8、还可以包含time.h头文件，然后使用srand(time(0))来使用当前时间使随机数发生器随机化，这样就可以保证每两 次运行时可以得到不同的随机数序列，同时这要求程序的两次运行的间隔超过1秒。9、举例如下：rand（产生随机数）表头文件: #include&lt;stdlib.h&gt;定义函数 :int rand(void)函数说明 :因为rand() 的内部实现是用线性同余法做的，它不是真的随机数，只不过是因为其周期特别长，所以有一定的范围里可看成是随机的，rand() 会返回一随机数值，范围在 0 至 RAND_MAX 间。在调用此函数产生随机数前，必须先利用 srand()设置好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为 1。rand()产生的是假随机数字，每次执行时是相同的。若要不同,以不同的值来初始化它.初始化的函数就是 srand()。返回值:返回 0 至 RAND_MAX 之间的随机整数值，RAND_MAX 的范围最少是在 32767 之间（int），即双字节（16位数）。若用unsigned int 双字节是 65535，四字节是 4294967295 的整数范围。0~RAND_MAX 每个数字被选中的机率是相同的。 java随机数https://www.cnblogs.com/blogxjc/p/9687297.html","categories":[{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"字符串","slug":"dsa-string","date":"2021-08-31T07:13:08.000Z","updated":"2021-10-07T08:12:58.722Z","comments":true,"path":"2021/08/31/dsa-string/","link":"","permalink":"https://shadowbynl.github.io/2021/08/31/dsa-string/","excerpt":"对字符串相关问题进行记录","text":"对字符串相关问题进行记录 字符串匹配 朴素模式匹配 KMP算法 相关题目 leetcode214 字符串匹配朴素模式匹配 KMP算法 相关题目leetcode214https://leetcode-cn.com/problems/shortest-palindrome/ 1234567891011121314151617181920212223242526/*给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。0 &lt;= s.length &lt;= 5 * 10^4s 仅由小写英文字母组成*/class Solution &#123;public: string shortestPalindrome(string s) &#123; string t(s.rbegin(), s.rend()); int n = s.size(); s = s + &#x27;#&#x27; + t; vector&lt;int&gt; ne(n * 2 + 2); ne[0] = -1; int i = 0, k = -1; while (i &lt; s.size()) &#123; while (k &gt;= 0 &amp;&amp; s[i] != s[k]) k = ne[k]; i++; k++; ne[i] = k; //cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ne[i] &lt;&lt; &quot; &quot; &lt;&lt; s[i]&lt;&lt; endl; &#125; int len = ne[2 * n + 1]; string left = s.substr(0, len), right = s.substr(len, n - len); return string(right.rbegin(), right.rend()) + left + right; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"南软服务端开发","slug":"njuse-sever-development","date":"2021-08-30T15:42:34.000Z","updated":"2021-10-07T08:16:27.129Z","comments":true,"path":"2021/08/30/njuse-sever-development/","link":"","permalink":"https://shadowbynl.github.io/2021/08/30/njuse-sever-development/","excerpt":"南大软件本科服务端开发课程笔记","text":"南大软件本科服务端开发课程笔记","categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"}],"tags":[]},{"title":"javase之一","slug":"java-base-00","date":"2021-08-30T08:47:11.000Z","updated":"2021-10-07T08:36:32.200Z","comments":true,"path":"2021/08/30/java-base-00/","link":"","permalink":"https://shadowbynl.github.io/2021/08/30/java-base-00/","excerpt":"占位","text":"占位 为重新巩固java基础，个人决定从javase开始到微服务等过一遍java技术体系。经过几天比对，发现很多培训课程为顾及学生讲的很繁琐，b站ks的视频相对较简洁。虽然可能存在不全、不准确、资料不太够的问题，但也有很大的学习参考价值。因此从本篇开始将按照ks提供的顺序，看视频、敲代码，并在这些文档中做些笔记。https://gitee.com/kuangstudy/kuang_livenote?_from=gitee_search","categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://shadowbynl.github.io/tags/javase/"}]},{"title":"idea学习","slug":"idea-study","date":"2021-08-28T15:01:52.000Z","updated":"2021-10-07T08:12:42.387Z","comments":true,"path":"2021/08/28/idea-study/","link":"","permalink":"https://shadowbynl.github.io/2021/08/28/idea-study/","excerpt":"用了idea也快两年了，在此系统看一下idea专门的教程","text":"用了idea也快两年了，在此系统看一下idea专门的教程 模板 插件 配置 模板参考先前的配置，具体配置方法参考下面的图 使新建类默认有类注释123456/*** @Auther: nlby* @Date: $&#123;DATE&#125; $&#123;TIME&#125; * @Description: $&#123;PACKAGE_NAME&#125;* @version: 1.0*/ 自定义类注释、方法注释模板1234567891011121314151617181920212223/** * * @name $NAME$ * @author nlby * @date $DATE$ */ /** * @author nlby * @description $description$ * @updateTime $date$ $TIME$ $param$ $return$ * @throws $throws$ */ 参数groovyScript(&quot;def result=&#x27;&#x27;; def stop=false; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); if (params.size()==1 &amp;&amp; (params[0]==null || params[0]==&#x27;null&#x27; || params[0]==&#x27;&#x27;)) &#123; stop=true; &#125;; if(!stop) &#123; for(i=0; i &lt; params.size(); i++) &#123;result +=((i==0) ? &#x27;\\\\r\\\\n&#x27; : &#x27;&#x27;) + ((i &lt; params.size() - 1) ? &#x27; * @param: &#x27; + params[i] + &#x27;\\\\r\\\\n&#x27; : &#x27; * @param: &#x27; + params[i] + &#x27;&#x27;)&#125;; &#125;; return result;&quot;, methodParameters())groovyScript(&quot;def result=&#x27;&#x27;; def stop=false; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); if (params.size()==1 &amp;&amp; (params[0]==null || params[0]==&#x27;null&#x27; || params[0]==&#x27;&#x27;)) &#123; stop=true; &#125;; if(!stop) &#123; for(i=0; i &lt; params.size(); i++) &#123;result +=((i==0) ? &#x27;\\\\r\\\\n&#x27; : &#x27;&#x27;) + ((i &lt; params.size() - 1) ? &#x27; * @param: &#x27; + params[i] + &#x27;\\\\r\\\\n&#x27; : &#x27; * @param: &#x27; + params[i] + &#x27;&#x27;)&#125;; &#125;; return result;&quot;, methodParameters())返回值groovyScript(&quot;def result=&#x27;&#x27;; def data=\\&quot;$&#123;_1&#125;\\&quot;; def stop=false; if(data==null || data==&#x27;null&#x27; || data==&#x27;&#x27; || data==&#x27;void&#x27; ) &#123; stop=true; &#125;; if(!stop) &#123; result += &#x27;\\\\r\\\\n&#x27; + &#x27; * @return: &#x27; + data; &#125;; return result;&quot;, methodReturnType())groovyScript(&quot;def result=&#x27;&#x27;; def data=\\&quot;$&#123;_1&#125;\\&quot;; def stop=false; if(data==null || data==&#x27;null&#x27; || data==&#x27;&#x27; || data==&#x27;void&#x27; ) &#123; stop=true; &#125;; if(!stop) &#123; result += &#x27;\\\\r\\\\n&#x27; + &#x27; * @return: &#x27; + data; &#125;; return result;&quot;, methodReturnType()) 注意：123一般步骤：创建模板组、创建模板、指定变量值、指定对某种语言使用上述模板中的方法注释需要在方法中生成注释，否则可能参数等生成有问题，且对返回值为void的情况，还需手动修改 插件https://www.bilibili.com/video/BV1zb4y1U7Fv配置https://www.bilibili.com/video/BV1Tg4y1B7nM11. 创建一个empty project让多个模块在项目空间同级显示（没有默认父模块）","categories":[{"name":"环境","slug":"环境","permalink":"https://shadowbynl.github.io/categories/%E7%8E%AF%E5%A2%83/"}],"tags":[]},{"title":"2021年八月底总结","slug":"202108summary","date":"2021-08-27T16:35:13.000Z","updated":"2021-10-07T08:13:17.608Z","comments":true,"path":"2021/08/28/202108summary/","link":"","permalink":"https://shadowbynl.github.io/2021/08/28/202108summary/","excerpt":"在该站点重新开始维护个人博客。 从2020年2月开始接触hexo博客，其后到2020年11月左右断断续续写了一百多篇博客，但后面由于到大三的一个比较迷茫和紧张的时期就慢慢不再维护博客了，总体上先前的博客分类和标签有些混乱冗余了，同时域名也到期，图床也存在一些失效的风险，于是决定在本人的这第二个github账号下建立仓库重新开始维护一个新的个人博客，计划是长期性的，因此：域名就采用github.io的域名，图片直接存储在本地和仓库中，而先前的文章后续有时间再作整理和迁移。这篇写于2021年8月底，本人大四上学期开始前几天，算是一个大学与未来研究生生活承前启后的一个阶段，因此在该站点的这第一篇文章中打算记述一下前一段时间（保研，简要记述，详细内容以后有时间或者等完全结束再写）和之后的两个月内的一个大致的安排。","text":"在该站点重新开始维护个人博客。 从2020年2月开始接触hexo博客，其后到2020年11月左右断断续续写了一百多篇博客，但后面由于到大三的一个比较迷茫和紧张的时期就慢慢不再维护博客了，总体上先前的博客分类和标签有些混乱冗余了，同时域名也到期，图床也存在一些失效的风险，于是决定在本人的这第二个github账号下建立仓库重新开始维护一个新的个人博客，计划是长期性的，因此：域名就采用github.io的域名，图片直接存储在本地和仓库中，而先前的文章后续有时间再作整理和迁移。这篇写于2021年8月底，本人大四上学期开始前几天，算是一个大学与未来研究生生活承前启后的一个阶段，因此在该站点的这第一篇文章中打算记述一下前一段时间（保研，简要记述，详细内容以后有时间或者等完全结束再写）和之后的两个月内的一个大致的安排。 创建该站点第一篇博客的时间 简单说明一下2021年前八个月的情况 个人的一些情况 先整理下hexo相关的 技术体系重建（主要是java) 计算机基础 java基础 juc并发编程 jvm 框架 web基本技术 前端技术 附 短期安排 创建该站点第一篇博客的时间 简单说明一下2021年前八个月的情况到大三下学期，基本要确定未来的规划安排了，从寒假开始到大三下学期，一直焦虑于能否稳定保研名额，能否保到外校，因为没有经历过、信息源匮乏心态一直有些颓丧，同时还想做做考研和工作的准备，但到现在来看浪费那些时间基本没啥意义。从来没能准备周全，被各种事和人推着走。到6月底，随着计算机保研生的大流投了差不多15个左右的夏令营，毫无准备地同时应对夏令营活动和7月初的期末考试。6月20号左右由于没拿到西交的夏令营资格，使我将对夏令营的期望放到了能入营就是成功的程度上，也因此多投了很多中下游的985。后面半个月左右，是比较消耗精力的，总体上就是一个拼运气和心态的阶段。从6月25日之后，我陆续接到了北交cs、华师se、西工大cs、吉大ai、山大se、东北cs、中南cs、浙大se、南大se、本校、东南cs的入营通知，参加了其中一多半，最终也拿到了5个优营，这个结果对没啥追求的我来说已经算是确定了一些事了。后面这一个多月，总体上过得相当随性，所以即便还是有很多很久以前就想做去解决的事，到现在大四快开始了还没什么进展。纠结于保研与实习之中，在原地徘徊不定，致使现在的处境比较尴尬（hh 本来打算回家学车，结果因为暴雨和疫情一年都回不了家了，在学校每天待着浪费人生）现在也算是再做一次计划人，再做做后续的一些安排，搞搞心理建设。 个人的一些情况大学前三年学的东西太杂不够深入，也很少动手实践，因此实际现在对于编码面试的事还是不太敢尝试。总是想着必须重新建立一下技术体系，但基本没时间，也不敢去费时间去尝试。但现在的情况为今后考虑，不管是纯去做开发，还是搞几年研究，必须先把一门语言学到比较熟悉的程度。对本人来说，学了两年多java，周边技术知道不少，但很难做到随手编程实现和随口讲清相关的概念，基础相当薄弱，实践也不足，而java的相关知识是极多的，我也总是有些抗拒再头像大一时那样看起，总感觉浪法时间。但显然，越看一些概念，我越认识到我的基础到处是窟窿，不去拼一把真的是只能永远处于一个会做点简单应用但实际并不熟悉语言的程度。 先整理下hexo相关的8.27晚，经过测试我确认了： hexo editor可直接将复制的图片拷到本地对应目录下，可以直接在编辑器中显示，但上传时注意补充/images 博客主题更换 使用这位比我小三岁的大佬做的主题 https://nexmoe.com/ 更新hexo版本 参考 https://www.jianshu.com/p/98ac1e253e6e 配置gitalk https://www.cnblogs.com/bigyoung/p/14154060.html 本人第一个github账号的github.io之后作工作展示用 该账号是作日常生活学习记录用 技术体系重建（主要是java)计算机基础408相关 考研材料 面经上的问题背记 几本图解 数据结构的java实现 常用基本算法 leetcode整理 java基础 尚硅谷基础（集合异常等） 面试常考 南大se服务端开发 一入 石杉 juc并发编程 尚硅谷 大厂学院 os原理 jvm 大厂学院 框架 尚硅谷spring相关 spring全家桶 设计模式与框架模式源码解析 大厂学院 web基本技术 数据库 Mysql redis 消息队列 web基本技术 前端技术总体上，应先重点看三个部分： 计算机基础（数据结构与典型算法的多次实现 leetcode整理讲解）几本书+面经+复习资料 java基础回顾 宋+mb+面经 石杉经典问题 后续再针对各专项进入深入学习。 附相关资源 小马哥java https://ke.segmentfault.com/teacher/mercyblitz https://github.com/mercyblitzhttps://www.bilibili.com/video/BV1GT4y1P76R https://github.com/leiguorui/programming-video-tutorials 南大服务端开发 https://github.com/Software-Knowledge/2021-Server-Development 南大se git@github.com:NJU-SE-15-share-review/professional-class.git https://github.com/NJU-SE-15-share-review/professional-class 南大se笔记 https://github.com/stormbroken/SpriCoder-Notes 有配一下as环境的打算 几个南大se本科的up https://space.bilibili.com/349257951/video https://www.bilibili.com/video/BV1fh411U7KR/ taoci https://zhuanlan.zhihu.com/p/172476313 短期安排 文都几本过完 j/c面经过完 dsa稳定实现 dc数据结构整理类型 java基础 面经 + 尚 + mb 石杉","categories":[{"name":"规划","slug":"规划","permalink":"https://shadowbynl.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"汇编程序功能实现说明","slug":"汇编程序功能实现说明","date":"2020-10-31T15:58:55.000Z","updated":"2020-11-01T03:53:48.264Z","comments":true,"path":"2020/10/31/汇编程序功能实现说明/","link":"","permalink":"https://shadowbynl.github.io/2020/10/31/%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E8%AF%B4%E6%98%8E/","excerpt":"","text":"该篇对汇编中一些基本功能的实现方法进行记述和说明。 INT 21h 转载自 http://blog.eonew.cn/archives/41 INT 21h常用功能号AH = 01h出口参数：AL=ASCII子符功能说明：键但输入一个字符。如果AL=00h.应再次调用该功能获取扩展ASClI字初代码。本功能将在屏称上显示输入的内容（有回显）。调用该功能如果没有按键输入，则一直循环等待直到按键才结束功能调用，此时控制返回调用程序 AH=02h入口参数：DL=欲显示的ASCIl字符功能说明：在屏幕当前光标的位置显示一个字符 AH=06h入口参数：DL=FFh（对应输入功能），DL=欲显示的ASCII得（对应输出功能）出口参数：AL=ASCII字符 功能说明：对应入口参数DL=FFh，是一个键盘输入功能调用，调用该功能不论是否有按键输入，都将结束功能调用，标志ZF反映是否按键：条件转移指令的为零条件Z（ZF=1）表示无按键；不为零条件NZ（ZF=0）表示有按键，AL返回输入字符的ASCII码。如果AL=00h，应再次调用该功能获取扩展ASCII字符代码。本功能不在屏幕上显示输入的内容（无回显） 对应入口参数DL=ASCIl字符，是一个显示输出功能调用，与02h功能调用一样 AH=09h入口参数：DS:DX=欲显示的字符中逻辑地址（段地址:偏移地址）功能说明：将指定的字符中在当前光标位置开始显示。字符串可以是任何长度，还可以包含控制字符（例如回车0Dh，换行0Ah），但必须以“$”（其ASCII码为24h）字符结尾 AH=0Ah入口参数：DS:DX=键盘输入缓冲区逻辑地址（段地址:偏移地址）功能说明：读取从键盘输入的一个字符串（有回显），直到按下回车键，键盘输入缓冲区的第一个字节是缓冲区字节大小（最大为255）.第2个字节在调用结束时被功能调用填进输入的字符个数，第3个字节开始存放输入字符的ASClI码，最后是回车字符（ODh） AH=4Ch 生成随机数并显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192DATA SEGMENT PLN DB 0DH, 0AH, &#x27;$&#x27; SEED10 DB 10 DUP(0) SEED80 DB 80 DUP(0)DATA ENDSSTACK SEGMENT DB 100 DUP(0)STACK ENDS CODE SEGMENT ASSUME CS:CODE, DS:DATA, SS:STACKSTART: MOV AX, DATA MOV DS, AX MOV ES, AX MOV AX, STACK MOV SS, AX CALL SEED ;生成80个随机数种子 ;显示80个随机数 LEA DI, SEED80 MOV CX, 80LOP100: MOV BX, 80 SUB BX, CX MOV AX, [DI+BX] CALL DISHEX LOOP LOP100 MOV AH, 4CH INT 21H ;;此子程序为获取种子程序,其中用到了随机数生成器;产生80个种子数的随机数,存储在SEED80中;SEED PROC PUSH CX PUSH DX PUSH AX PUSH BX PUSH SI PUSH DI LEA SI, SEED10LOP0: STI MOV AH, 0 ;读时钟计数器值 INT 1AH MOV AX, DX ;第一步:得到第一号一个种子DX,将DX复制给AX MOV CH, 0 ;CH用来防止多次循环无解LOP1: MOV CL, 4 INC CH CMP CH, 5 JZ LOP0 ROR AX, CL ;第二步:将AX循环右移4位,得到二号种子两个AH和AL CMP AH, AL JZ LOP1 ;确保AH与AL不等 MOV [SI], AH ;将AH放入SEED10中 MOV [SI+1], AL ;将AL放入SEED10中LOP2: MUL AH ;循环超过4个或者第一次,AH与AL相乘 MOV CH, 0 ;CH清零 LOP3: MOV CL, 4 INC CH CMP CH, 5 JZ LOP2 ROR AX, CL ;第三步:AH与AL相乘之后，再将AX循环右移4位,得到新的AH和AL CMP AH, AL ;确保AH、AL、[SI]、[SI+1]四个数不等 JZ LOP3 CMP AH, [SI] JZ LOP3 CMP AH, [SI+1] JZ LOP3 CMP AL, [SI] JZ LOP3 CMP AL, [SI+1] JZ LOP3 MOV [SI+2], AH ;将AH放入SEED10中 MOV [SI+3], AL ;将AL放入SEED10中,第二步完成,得到三号种子SEED10中的4个 MOV AX, [SI] ;三号种子相互异或,得到四号种子SEED10中的10个 XOR AX, [SI+1] MOV [SI+4], AX MOV AX, [SI] XOR AX, [SI+2] MOV [SI+5], AX MOV AX, [SI] XOR AX, [SI+3] MOV [SI+6], AX MOV AX, [SI+1] XOR AX, [SI+2] MOV [SI+7], AX MOV AX, [SI+1] XOR AX, [SI+3] MOV [SI+8], AX MOV AX, [SI+2] XOR AX, [SI+3] MOV [SI+9], AX LEA DI, SEED80 ;第四步:三号种子的10个种子分别循环右移一位8次，得到四号种子SEED80中的80个 MOV CH, 0 MOV BH, 0LOP10: ;此时套用两层循环,第一层循环(外层)为循环三号种子中的10个种子 MOV BL, CH ;CH为第一层循环(外层)计数(10),代表10个种子 MOV CL, 0 ;CL为第二层循环(内层)计数(8) MOV AX, [SI+BX] ;每个第二层循环处理的种子为[SI+CH],暂存至AX做处理LOP11: ;第二层循环(内层)为三号种子中每个种子做循环右移一位处理8次 PUSH AX ;将AX暂存至DX MOV AL, CL ;此处开始计算四号种子中种子的存放位置,存放位置公式为[DI+CH+CL*10] MOV DL, 10 MUL DL MOV BL, CH ADD BX, AX POP AX ;还原AX MOV [DI+BX], AX ;计算种子存放位置结束 PUSH CX MOV CL, 3 ROR AX, CL POP CX INC CL CMP CL, 8 JNZ LOP11 INC CH CMP CH, 10 JNZ LOP10 POP DI POP SI POP BX POP AX POP DX POP CX RETSEED ENDP ;;此子程序为将一个数以十六进制数输出;DEBUG用的;DISHEX PROC NEAR PUSH AX PUSH CX PUSH DX MOV CX, 0404HDIS1: ROL AX, CL MOV DX, AX AND DL, 0FH CALL DISCHAR DEC CH ;; 控制循环4次 因为低两位才表示随机数值 考虑如何跳过前两个循环 JNZ DIS1 MOV DL, &#x27;H&#x27; ;十六进制数后面加上H MOV AH, 2 INT 21H POP DX POP CX POP AX RETDISHEX ENDPDISCHAR PROC NEAR PUSH AX CMP CH, 03H ;; 如果CH的值大于等于03H 即前两个高位值 则直接跳过 JGE P2 CMP DL, 0AH ;判断DL中低四位为数字还是为字母 JL PRINT1 ;DL中低四位为数字,跳转 ADD DL, 7 ;DL中低四位为字母,0AH+7=11H,所以下面就从11H+30H=41H开始算PRINT1: ADD DL, 30H ;30H为0的ASCLL码,41H为A的ASCLL码,61H为A的ASCLL码 MOV AH, 2 ;输出DL中的对应的ASCLL码字符 INT 21H ;; 说明一下 要打印的值在DL里面 此处给AH=2 就是为了在中断时调用相应的功能 参数位置在DL中 POP AX RET P2: POP AX RETDISCHAR ENDPCODE ENDS END START","categories":[{"name":"知识点总结","slug":"知识点总结","permalink":"https://shadowbynl.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"https://shadowbynl.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"app数据抓取策略","slug":"app数据抓取策略","date":"2020-10-23T11:32:25.000Z","updated":"2020-11-01T04:03:12.288Z","comments":true,"path":"2020/10/23/app数据抓取策略/","link":"","permalink":"https://shadowbynl.github.io/2020/10/23/app%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96%E7%AD%96%E7%95%A5/","excerpt":"","text":"写在前面 获取web端靠八爪鱼够用（比较简单的） 至于移动端的，花了那么多时间 发现没有一个稳定的方法 1025测试发现平行空间证书可行，1031就又不行了。用夜神最开始抖音极速版可搜索，隔一天又不行了。其实用各种抓包工具+夜神的话还好，但非要搞抖音还是直播的真是折磨人，就不太明白为啥非要这个数据，明说了有几年经验的爬虫工程师处理这个一直变动的情况都有难度，ty你可真是个人。不过还好抖音之外的app还是好获取数据的，关键是很多app也是有web端的。 过程记录搜集资料阶段直接就爬取app的方法进行搜索，粗略地看到很多博客、视频教程，但短时间内不能确定一个可行的过程是怎样的。这些资料的相同点是基本都用了抓包工具，但有不少相关的问题： 为什么用抓包工具，爬取数据和抓包有什么关系 appium selenium这些和爬取数据有什么关系 基本的爬取app数据的流程、使用的工具方法是怎样的 由于这些相关内容不少且杂，相关性其实不高，故先从抓包工具fiddler工具相关的视频看起。 具体看的阶段抓包工具fiddler在b站上找了很多相关的视频，有的是基本的使用抓包工具测试的教程；有的是介绍相关使用的短视频。先找了一个小视频想入手，https://www.bilibili.com/video/BV1dz411b7Ei，看了之后发现有专门的抓包app HttpCanary小黄鸟，于是在模拟器上按照教程安了，设置了证书，并进行了b视频的获取，参考https://www.bilibili.com/video/bv1pC4y1x79N/。但对于抓包的方法，如何分析有效数据还不甚了解。于是又看相关的短视频：Fiddler之移动端APP抓包教程 https://www.bilibili.com/video/BV13t4y1X7uN，实现了抓取模拟器上http和https的包 抓包app HttpCanary见上，付费，可抓包 知乎的一些文章测试了fiddler抓模拟器的包后，10.23中午看了几篇知乎的文章，里面有一些有参考价值的。下面具体记述。 fiddler根据https://www.bilibili.com/video/BV13t4y1X7uN实现了抓逍遥模拟器上app的http https的包。 需要注意以下方面： 版本选取 本地fiddler启动时，自动设置系统代理失败，不必在意，与模拟器无关 对于http的，直接设置工具-选项-连接-允许远程计算机连接（模拟器已和PC在同一网络下），代理服务器fiddler在8888端口上监听模拟器的请求 模拟器上 网络的高级设置 手动设置代理 注意又ipconfig获取的ip 选哪个，本机是192.168.56.1 以上两步后http可抓 对于https的，需访问http://192.168.56.1:8888/下载安装证书，即可抓取 后续fiddler的具体使用，参考https://www.bilibili.com/video/BV1c4411c7zH?p=3 设置系统代理，可以在chrome的设置-高级-系统代理设置中进行设置。 http canary参考 https://www.bilibili.com/video/bv1pC4y1x79N/ https://www.bilibili.com/video/BV1pz411B7tf/?spm_id_from=333.788.videocard.0 抓了app中的视频。通过看教程和自行操作，有以下问题需要注意： 该app目前免费版功能阉割，加密等功能付费高级版才有 用户证书 系统证书 root 安卓版本等问题 理论上 在模拟器上抓的话，不需要考虑太多证书 版本的问题（安卓版本5.1.1），但确实太吃内存了 知乎看了上面的内容后，还是停留在一个对抓包工具的粗浅了解上，这和爬取数据以及很多文章中提到的appium有什么关系还不可知。于是在10.23中午看了几篇知乎上的文章和回答。 夜神模拟器+mitdump爬取抖音作品https://zhuanlan.zhihu.com/p/57091195?utm_source=qq&amp;utm_medium=social&amp;utm_oi=1009522323552051200 实现：输入一个抖音号，获取所有视频 摘要： 使用 charles 抓包工具进行接口分析，使用mitdump编写脚本爬取。 可以看出，抓包工具主要进行的是一个接口分析的工作，确定如何获取目标数据，使用一些语言编写的脚本就可利用分析结果进行爬取。而这样的实现，需要在app上手动操作后才能抓包，appium实现的就是这一过程的自动化。 评论中有几个github接口，但应该都失效了。。 张小鸡2019-04-13 直接走我的接口就好，何必这么麻烦：https://github.com/hacksman/spi fireantzhang2019-05-13 你这个爬取方式还是不太方便，我推荐一个直接跑脚本就行的，亲自测试过还是挺好用的：https://github.com/loadchange/a 问答：App中的数据可以用网络爬虫抓取么？https://www.zhihu.com/question/53094297 八爪鱼平台的最近半年，我们八爪鱼陆续接到好几个APP数据采集的项目需求，我在群里面，偶尔也看到有些用户在问，有没有APP数据采集的工具。鉴于我们做过的几个APP数据采集项目的经验，我可以告诉大家，现在APP数据采集，市面上还没有通用的工具。我们八爪鱼内部是有一套工具，但由于使用的难度较高，需要编写脚本，所以不对普通用户公开，我们仅接受项目定制。 虽然不对外公开，但并不妨碍我们将技术分享出来，APP数据采集，一般走以下两种方式：1、抓包；2、HOOK 1、抓包 有代码经验或APP开发的同学都很容易理解，其实很多APP，走的都是*webservice*通讯协议的方式，并且由于是公开数据，而且大部分是无加密的。所以只要对网络端口进行监测，对APP进行模拟操作，即可知道APP里面的数据是如何获取的。 我们只需要写代码模拟其请求，无论POST还是GET，即可得到该请求所返回的信息。再通过对返回的信息结构化解析，即可得到我们想要的数据。 2、HOOK技术 HOOK技术是一种走操作系统内核的技术，由于安卓系统是开源的，所以可以借助一些框架修改内核，从而实现你要的功能。HOOK的形式，我们走的是Xposed框架。Xposed是一款可以在不修改任何其他开发者开发的应用（包括系统服务）的情况下，改变程序运行的一个开源框架服务。基于它可以制作出许多功能强大的模块，以此来达到应用程序按照你的意愿运行的目的。 如果把安卓手机看做一座城堡，那Xposed可以让你拥有一个上帝视角，城里的运作细节尽收你眼底，还能让你插一手改变城堡的运作规律。 什么意思呢？简单的说就是你可以通过他，自动化的控制你的APP。如果将我们的APP开在模拟器上，我们可以通过编码，通过他告诉APP这一步干什么，下一步干什么。你把它理解成类似按健精灵或游戏打怪外挂就可以了。 而他每走一步，APP与服务端交互的数据，均可获取下来。这种方式广泛用于一些成熟的APP。比如某信采集。 3、这些年走过的坑 聊完APP采集的思路，我们跟大家分享一些遇过的坑吧，让大家乐一乐 坑一：签名算法 以某信的文章列表页及某信息页为例，对其http访问进行抓包，会发现其url的一个核心参数是我们无法知道如何生成的，这就导致，我们不可能直接用该url进行信息爬取；签名算法如果无法破解，HTTP这条路就是死路了。 坑二：http爬取回来的信息和页面显示不一致 以某信的某信息页为例，对比直接访问某信页面及http爬取的信息，可明显发现http爬取到的信息较少。造成得两种方式都用，才能既照顾速度又照顾完整性。 坑三：模拟器中的坑 APP自动识别你的运行环境进行屏蔽，最厉害的还是某信，连你是用模拟器打开还是真机打开，是什么内核的，全部进行限制。曾经见过牛人，找某手机厂商专门定做真机来配合。 坑四：帐号的坑 这个坑就有点大了，要找号、养号，都不是件容易的事情，更惨的是封号，真真让你一夜回到解放前。 最后附上八爪鱼的下载链接： 免费下载 - 八爪鱼采集器www.bazhuayu.com 一个有经验者 第三个 第四个作者：li crifan 简答：可以。 但前提是你能成功抓包分析出逻辑和api请求，然后才轮到写代码模拟请求去爬取数据 而这个前提，往往不是很容易做到 越是大厂的app，往往反扒、反破解难度越高 最后你发现，其实爬取这些app工作量和难度算100，可能破解占了30%甚至90% 详解： 如果app本身没加密和反扒难度低 简单用抓包工具，比如Charles，去分析网络请求，多数为REST的api，加上合适的header和参数，就可以写代码去爬到数据了 如果app本身的请求是https加了密的 那么先要破解https，往往是找工具和技术去绕过https，才能看到明文 相关工具：Charles+XPosed(+插件：JustTrustMe）+Android虚拟机（Nox夜神模拟器） 如何操作：详见完整教程 已root的安卓+XPosed+JustTrustMe破解ssl pinning 如果app本身的发送和接收的数据虽然是明文但都是加了密看似乱码，则要找到加密和解密逻辑才可能破解和模拟请求爬取数据 就又涉及到 app的加固和去壳方面的技术了 如何操作：详见独立教程 安卓应用的安全和破解 比如稍微复杂一点的，典型分3步： 三步: app-&gt;dex-&gt;jar-&gt;java 总结： 爬取app数据的工作量和难度： 平均来说= 60%的破解 + 10%的抓包分析 + 30%的写爬虫代码 -》你只是要爬取app数据，往往变成 先要破解app 才能爬取其数据 与爬虫相关： 其实写爬虫，要先去搞懂核心逻辑，即 下载 提取 保存 然后才是搞清楚，一般写爬虫有哪些典型实现方式： 裸写爬虫代码 用第三方库写爬虫代码 用爬虫框架 其次才是，搞清楚常见哪些编程语言，每种编程语言有哪些框架 最后才是选用合适语言，合适的方式 如果选框架的话，再选合适的框架，去写你的爬虫 比如选用Python写爬虫，用PySpider或Scrapy等去爬取你要的数据。 总结若要达到获取app数据的目的，有三个方法可选取 利用已有平台，需测试 https://www.bazhuayu.com/?utm_campaign=baidu&amp;utm_medium=pc15182&amp;utm_source=YTPC2&amp;utm_content=%e7%88%ac%e8%99%ab&amp;utm_term=app%e7%88%ac%e8%99%ab&amp;bd_vid=7135645974450989106 在PC上 用fiddler等抓包工具 模拟器 移动端上 用 httpcanary这种 有版本限制 若是采用PC+抓包+模拟器+爬虫的方法 抓模拟器已经可行 fiddler的使用分析还需进一步了解 需要有一个简单接口的测试，然后才能对复杂接口进行分析 使用python或java写爬虫都可以 自动化是在手动实现后才需要考虑的问题 分隔线 以上为10.24 以下为10.251025概述主要工作 对fiddler相关原理、界面、功能进行学习，进行了相关测试 对知乎和b站上使用mitmproxy进行数据爬取的方法进行测试 问题 在模拟器上测试，会因硬件限制等问题导致崩溃 真机抓不到https协议的包，安装的证书不管是来自fiddler的还是mitm的都无效，一直都是443 主要过程fiddler学习http基本相关内容fiddler工具使用 界面功能 与模拟器/真机的连接测试对于测试过程中的现象和注意点详细记述一下： 模拟器 逍遥模拟器5.1.1版本 首先，保证安卓版本在7以下，否则在代理情况下是打不开app的 原因是7及以上版本用户证书不再被信任 为有更好的硬件条件，在两台电脑上均进行测试，但效果都差不多，不怎么理想。表现为：在抖音上可以打开短视频、直播，但再刷会卡或崩溃，搜索无结果，b站打开崩溃。 配置方法：fiddler启动后，常规配置，监听https。模拟器网络设置代理，访问相应Ip端口下载安装证书。 真机 小米note3 由于在模拟器上过卡，选择在真机上测试。注意以下几点： 设置代理的ip和模拟器设置的一般是不同的，若不能联网则换成其他进行测试 下载安装证书同样的方法 但与模拟器很明显的差别是，浏览器打开不加载样式，其他app也无法打开，fiddler显示443，但在测试时没有意识到问题所在，而是选择进行其他方法的测试（实际上是证书无效）。 mitmproxy（参考知乎和b视频测试）参考 https://mp.weixin.qq.com/s/Yldl8oOLvX5Zq7FuHH17Gg 数据平台初试（技术篇）——抖音数据采集（初级版） https://www.bilibili.com/video/BV1Kt411q7tQ 安装使用过程中的问题 pip install mitmproxy时出现的几个问题：（1）Cannot uninstall ‘certifi’. It is a distutils installed project and thus we 直接在anaconda依赖包下的对应文件夹和文件删去了，注意是一个文件夹和一个文件 （2）importError: cannot import name ‘PyAsn1UnicodeDecodeErr 参考 https://www.jianshu.com/p/ed99e9d2bced 卸了重装 windows下是无法使用mitmproxy命令的，可以使用mitmdump或mitmweb 首先参考 https://www.cnblogs.com/shenhf/p/9783174.html 使用mitmweb，给真机安装证书（ https://download.csdn.net/download/gjbfyhbfg/12249162 证书直接无法下载）后发现一直无法正常连接 报很多错误 tls什么的 443.。换成dump也不行。开始以为是缺少一个脚本，参考 http://h3blog.com/article/mitmproxy-app-errors/ 添加脚本后，还是一样的一大堆443。然后app虽然可以正常打开，但什么都抓不到。。 总结 mitmproxy作为python的一个库，有抓包分析和根据脚本爬取的功能。单抓包来说，其提供的展示分析功能没有fiddler等充分好看，但最大的优势是可以直接利用其写python爬取的脚本。 综上这些，都没法很好地对app进行抓包，最终到1025晚上，意识到这些443错误总归是https的包无法抓到引发的问题，于是直接查如何解决这个问题 平行空间与抓包可行方案 经以上测试得结论，在真机上安装的证书实际都是无效的，因此如何使其对app有效，想到了先前看小黄鸟时的平行空间。于是下载平行空间，把浏览器放入，用fiddler everywhere代理测试，发现成功抓取到了基本所有的包。 放入抖音、b站时提示需要64位拓展，安装后，还是崩溃闪退，推测是因为app较大导致，因此换用抖音极速版和b站概念版进行测试，发现app可正常打开并可抓到很多https的包。 1026早上，发现用fiddler抓包可能不太可抓全 1026上午，使用httpcanary直接对平行空间中的抖音极速版等抓包，发现抓到的数据很完整 由此，可得出抓包分析的解决方案： pc fiddler/mitmproxy对真机抓包（平行空间） 优点是便于处理数据 缺点是抓到的可能不全 小黄鸟 抓的全 但数据不好保存处理 总结与后续问题目前解决了以下问题： 明确了爬取app数据的流程方法 确定了可行的抓包方案 问题 抖音短视频等信息是可直接获取的，但直播肯定加密了 protobuf 用一些签名算法 https://github.com/makelove/Programer_Log/tree/master/2020/4-1-mitmproxy-%E6%8A%96%E9%9F%B3 这基本上是最大难点 爬取脚本 自动化实现 其他参考与问题fiddler 443https://www.baidu.com/s?ie=UTF-8&amp;wd=%E5%93%8D%E5%BA%94%E7%A0%81443https://blog.csdn.net/kvpp0307/article/details/52451363https://blog.csdn.net/LY_Dengle/article/details/73459927?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242https://blog.csdn.net/weixin_42442458/article/details/80664423?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_paramhttps://www.baidu.com/s?ie=UTF-8&amp;wd=fiddler%E5%AE%89%E8%A3%85%E8%AF%81%E4%B9%A6%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98https://blog.csdn.net/cd_home/article/details/79459372?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param fiddler相关https://www.bilibili.com/video/BV1c4411c7zH?p=22https://www.baidu.com/s?ie=UTF-8&amp;wd=fiddler%20everywherehttps://www.jianshu.com/p/22829ac2848ahttps://www.jianshu.com/go-wild?ac=2&amp;url=https%3A%2F%2Fpan.baidu.com%2Fs%2F1hyxOi50CpmcGcmcB5hzQoAhttps://www.cnblogs.com/FunTester/p/13461653.htmlhttps://www.baidu.com/s?ie=UTF-8&amp;wd=failed%20to%20register%20fiddler%20ashttps://blog.csdn.net/weixin_43157068/article/details/104062921https://blog.csdn.net/qq_42119742/article/details/107786057?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242https://blog.csdn.net/qq_38355456/article/details/74323334?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_paramhttps://blog.csdn.net/weixin_43157068/article/details/104062921?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param mitmproxyhttps://www.baidu.com/s?ie=UTF-8&amp;wd=Cannot%20establish%20TLS%20with%20client%20(sni%3A%20o2o.api.xiaomi.com)%3A%20TlsException(%22SSL%20handshake%20error%3A%20Error(%5B(%27SSL%20routines%27,%20%27ssl3_read_bytes%27,%20%27sslv3%20alert%20certificate%20unknown%27)%5D)%22)https://www.cnblogs.com/liangmingshen/p/12375124.htmlhttps://blog.csdn.net/andrew_wf/article/details/84991989https://www.baidu.com/s?ie=UTF-8&amp;wd=mitmproxy%E5%AE%89%E5%8D%93%E8%AF%81%E4%B9%A6https://download.csdn.net/download/gjbfyhbfg/12249162https://blog.csdn.net/zhangyingchengqi/article/details/84326507?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecasehttps://www.jianshu.com/p/70208fbc8e43https://blog.csdn.net/zc520yzy/article/details/107200975https://www.jianshu.com/p/d9e419efe80chttps://www.baidu.com/s?ie=UTF-8&amp;wd=%3C%3C%20Cannot%20establish%20TLS%20with%20client%20(sni%3A%20appcloud.zhihu.com)%3A%20TlsException(%22SSL%20handshake%20error%3A%20Error(%5B(%27SSL%20routines%27,%20%27ssl3_read_bytes%27,%20%27sslv3%20alert%20certificate%20unknown%27)%5D)%22)https://segmentfault.com/q/1010000015723975?sort=createdhttps://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu&amp;wd=TLS%20passthrough%20for%20(%27sugar.zhihu.com%27%2C%20443)&amp;oq=clientdisconnect&amp;rsv_pq=b548e2490007b3e0&amp;rsv_t=56244onfLr24832Sfuf1sTE0Ql%2BEmI92suZOMV%2FQQPd1gG5xlHY%2FXE7V%2By0&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_btype=t&amp;inputT=1229&amp;rsv_sug3=5&amp;rsv_sug1=2&amp;rsv_sug7=100&amp;rsv_n=2&amp;rsv_sug2=0&amp;rsv_sug4=1967https://segmentfault.com/a/1190000018901022https://blog.csdn.net/qq_42677001/article/details/95203727","categories":[],"tags":[]},{"title":"以太坊和solidity复习其二","slug":"以太坊和solidity复习其二","date":"2020-10-18T06:18:39.000Z","updated":"2020-10-18T07:21:09.082Z","comments":true,"path":"2020/10/18/以太坊和solidity复习其二/","link":"","permalink":"https://shadowbynl.github.io/2020/10/18/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%92%8Csolidity%E5%A4%8D%E4%B9%A0%E5%85%B6%E4%BA%8C/","excerpt":"","text":"计划正式看一下相关的文档和代码，发现其实现还比较复杂，主要难点两方面：js一些特殊的语法，基于solidity要实现的目标。 正则文档看起，基本上都是关于规则的，如何实现还很模糊。 参考王的代码，还很少，直接参考葛的。 有ge的源码，还想测试辅助理解，于是又产生了两方面问题：（1）获得一定数量的solidity源码（2）有一个稳定可用的remix环境。 先前，就对怎样把这个插件嵌入remix比较好奇，于是直接看ge的相关代码，就写在index.html中 ge在csdn上也有文章介绍了部署插件的方法 https://blog.csdn.net/Nothing_1996/article/details/106520259 https://github.com/ethereum/remix-plugin/tree/master/examples 那么问题又变成了怎样安一个本地的remix环境，这个费功夫了 remix本地环境。。 参考 https://blog.csdn.net/qq_41569591/article/details/107642554https://blog.csdn.net/wangdenghui2005/article/details/84642803?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param几个命令就可以解决。但启动后，虽然没有明显报错，但就是访问不到界面。然后把相关警告查找后，发现可能是其兼容的node版本太低了，使用了很低版本的node的api已经废弃了，自然没法用，到github上想看看issue，但发现remix-ide这个仓库已经移到remix-project了，于是按照readme中的方法进行。https://xbuba.com/questions/56697360https://segmentfault.com/q/1010000021748022 node命令，结果需要安的东西太多了（应该有1g以上），中间卡住了。。 docker也装的慢。。 发现有remix-desktop，然后下release，结果超慢。。https://github.com/ethereum/remix-desktop/releases 无奈只能找可以下载快的网站，发现：https://blog.csdn.net/qq_30065853/article/details/106362791 中提到https://d.serctl.com 可用，于是直接下 相对快的下完了，但tm用不了。。cao","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://shadowbynl.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"8086指令系统","slug":"8086指令系统","date":"2020-10-14T12:12:48.000Z","updated":"2020-10-24T05:21:19.937Z","comments":true,"path":"2020/10/14/8086指令系统/","link":"","permalink":"https://shadowbynl.github.io/2020/10/14/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"8086指令系统 8086指令系统的指令分为六类，进行总结分析的话，可从串操作+控制转移看起，然后再运算、数据传送，要充分了解标志位的变化。对每个指令，明确其作用和注意事项（很明显，书上的代码很大部分是不能运行的）。 串操作指令说明 串操作的寻址方式： 源操作数指针———DS:SI(DS可超越)目的操作数指针——ES:DI 每次串操作后： 串操作指令自动修改SI和DI——字节:±1，字:±2 DF标志决定± 注意：退出串操作后，指针指向最后操作的元素的下一个元素 可完成存储单元到存储单元的传送、比较 重复前缀（指令的前缀） 有的串操作指令前面可加重复前缀。当使用重复前缀时，操作重复次数由CX决定(CX自动减量)。该指令重复执行,直至(CX)=0为止 REP ；无条件重复 REPE/REPZ ；当相等/为零时重复 REPNE/REPNZ ；当不相等/不为零时重复 执行串指令之前，应先进行如下设置 源串首地址（末地址）→ SI 目的串首地址（末地址）→ DI 串长度 → CX 建立方向标志（CLD使DF=0(增)，STD使DF=1 (减) ） 指令 串传送指令 MOVSB MOVSW DS到ES 串存储指令 STOSB STOSW A到ES 串读取指令 LODSB LODSW DS到A 串比较指令 CMPSB CMPSW DS-ES 串扫描 SCASB SCASW A-ES 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 串传送指令 MOVSB MOVSWMOVSB ； ((ES):(DI))←((DS):(SI)) SI±1, DI±1 MOVSW ； ((ES):(DI+1)(DI))←((DS):(SI+1)(SI)) SI±2, DI±2 例2.18 编写将数据段中自AREA1开始的100个字数据搬到附加段中以AREA2开始的数据区中的程序段。LEA SI，AREA1 LEA DI，AREA2 MOV CX，100 CLDDONE: MOVSW REP MOVSWLOOP DONE # 串存储指令STOSB / STOSW 写指令的操作为： 对字节：((ES):(DI))←(AL) DI±1 对字：((ES):(DI+1)(DI))←(AX) DI±2 本指令用于把一块存储区域填充成某一初始值(即对存储区进行初始化)把从A000H开始的2KB内存单元清零。程序段如下：MOV AX, 0MOV CX, 1024MOV DI, 0A000HCLDREP STOSW# 串读取指令LODSB / LODSW执行的操作为： 对字节：(AL)←((DS):(SI)) SI±1 对字：(AX)←((DS):(SI+1)(SI)) SI±2 串读取指令通常不加重复前缀。LODSB等价于: LODSW等价于: MOV AL,[SI］ MOV AX,[SI] INC SI INC SI INC SI # 串比较指令CMPSB / CMPSW指令执行的操作为：CMPSB ；((DS):(SI))-((ES):(DI)) SI±1, DI±1 CMPSW ；((DS):(SI+1)(SI))-((ES):(DI+1)(DI)) SI±2, DI±2 比较的结果只反映在标志位上，串本身无变化。本指令可用来检查两个串是否相等。与重复前缀REPZ/REPE、REPNZ/REPNE结合使用。# 串扫描SCASB / SCASW执行的操作： 对字节：(AL)－((ES):(DI)) DI±1 对字： (AX)－((ES):(DI＋1)(DI)) DI±2搜索指令执行的仍是比较(减法)操作,结果只影响标志位。要搜索的关键字放在AL(字节)或AX(字)中。本指令用于在串中查找指定的信息。与重复前缀REPZ/REPE、REPNZ/REPNE结合使用。SCAS指令加上重复前缀后,可对串进行连续扫描比较若前缀为REPZ，则表示比较结果相等(ZF=1)且串未结束(CX≠0)，则继续比较。若前缀为REPNZ，则表示比较结果不相等(ZF=0)且串未结束(CX≠0)，就继续比较。CMPS、SCAS与REPE/REPZ的使用： 满足下列两个条件时，重复扫描和比较： （1）CX≠0；重复次数还未完成； （2）ZF=1；目的操作数等于源操作数或扫描值。 CMPS、SCAS与REPNE/REPNZ的使用：满足下列两个条件时，重复扫描和比较： （1）CX≠0；表示重复次数还未完成； （2）ZF=0；目的操作数不等于源操作数或扫描值。 ​ 控制转移指令 有程序控制转移和处理器控制指令两种，主要了解程序控制转移指令。 程序转移指令的共同特点是可改变程序的正常执行顺序,使之转移。而改变程序的执行顺序,本质上就是要改变CS:(E)IP的内容这类指令对标志位无影响。 转移指令说明 转移指令的实质：改变IP(或CS)的内容。 所有转移指令不会影响标志位。 分为无条件转移和条件转移两种。 无条件转移指令 – JMP本指令无条件转移到指定的目标地址,以执行从该地址开始的程序段。 12345678910111213141516171819202122232425262728293031323334353637383940# 段内直接转移（相对转移）转移的目标地址由指令直接给出。指令中直接给出的目标地址实际上是一个相对于IP的位移量。 位移量 转移范围 汇编语言中格式 8位 -128～+127 JMP SHORT OPRD 16位 -32768～+32767 JMP NEAR PTR OPRD例： JMP 0120H；直接转向0120H JMP SHORT LPI ；转向LPI JMP NEAR PTR BBB ；转向BBB由于是段内转移,故转移后CS内容保持不变。# 段内间接转移转移的目标地址(偏移量)由寄存器或存储单元的内容给出。 例1：JMP SI 若指令执行前(SI)=1200H，则指令执行后，(IP)=1200H,于是转向代码段的偏移地址1200H处执行。注意：目标地址以段内偏移的形式给出，而不是相对于IP的位移量，所以它是一个16位的操作数。例2：JMP [BX+DI]设指令执行前: (DS)=3000H, (BX)=1300H, (DI)=1200H, (32500H)=2350H； 则指令执行后:(IP)=2350H在汇编语言中,段内间接寻址通常写成： JMP WORD PTR[BX+DI]表示所取得的目标地址是一个字。# 段间直接转移在指令中直接给出要转移到的目的段地址和偏移地址。 例：JMP 2000:1000H 执行时,(IP)←1000H,(CS)←2000H注：直接地址为符号地址时，段间直接转移指令中的符号地址前应加操作符FAR PTR。 例：JMP FAR PTR far_label 其中的far_label为远类型的标号。# 段间间接转移转移的目的地址(段和偏移)在两个相邻的字存储单元中。例如： JMP DWORD PTR [SI] 设指令执行前:(DS)=4000H，(SI)=1212H, (41212H)=1000H，(41214H)=4A00H 则指令执行后:(IP)=1000H，(CS)=4A00H，于是转到4B000H处开始执行指令。例中的DWORD PTR表示转移地址是一个双字。高位CS 低位IP 条件转移指令 - JXX 条件转移指令可实现程序的条件分支。 条件转移指令根据标志位的状态来决定是否进行分支转移。 格式： JXX label ；xx为条件名称缩写 条件转移指令只能是段内直接转移，且指令的转移范围为指令所在位置的-128～+127字节 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 无符号数JA/JNBE ；高于/不低于且不等于，则转移(A＞B) 条件为: CF=0∧ZF=0JAE/JNB ；高于或等于/不低于，则转移(A≥B) 条件为: CF=0∨ZF=1JB/JNAE ；低于/不高于且不等于，则转移(A&lt;B) 条件为: CF=1∧ZF=0JBE/JNA ； 低于或等于/不高于，则转移(AB) 条件为: CF=1∨ZF=1Not, Above, Bellow, Equal# 有符号数JG/JNLE ；大于/不小于且不等于，则转移(A＞B) 条件为: (SF⊕OF=0)∧ZF=0JGE/JNL ；大于或等于/不小于，则转移(A≥B) 条件为: (SF⊕OF=0)∨ZF=1JL/JNGE ；小于/不大于且不等于，则转移(A＜B) 条件为: (SF⊕OF=1)∧ZF=0JLE/JNG ；小于或等于/不大于，则转移(A≤B) 条件为: (SF⊕OF=1)∨ZF=1Not, larGe , Little, Equal# 根据单个标志位设置的条件转移指令JC ；CF=1,则转移JNC ；CF=0,则转移JE/JZ ；结果为零(ZF=1),则转移JNZ/JNE ；结果不为零(ZF=0),则转移JP/JPE ；奇偶标志PF=1(偶),则转移JNP/JPO ；奇偶标志PF=0(奇),则转移JS ；SF=1,则转移JNS ；SF=0,则转移JO ；OF=1,则转移JNO ；OF=0,则转移# 根据CX内容来决定是否转移的转移指令JCXZ label若(CX)=0, 则转移到label处开始执行例：在8000H开始的长度为1000字节的字符串中查找’S’，若找到，把其偏移地址记录在ADDR中，否则ADDR单元置为0FFFFH。 MOV DI, 8000H MOV CX, 1000 MOV AL, ’S’ MOV ADDR, 0FFFFH GOON: SCASB LOOPNZ GOON ; (CX)≠0∧ZF=0时，循环。 JNZ DONE ；ZF=0，转移 到串结束还没有找到 DEC DI ；找到 需要减量 因为 退出串操作后，指针指向最后操作的元素的下一个元素 MOV ADDR, DI DONE: HLT 循环控制指令 用在循环程序中以确定是否要继续循环。 循环次数通常置于CX中。 转移的目标应在距离本指令-128～+127的范围之内。 循环控制指令不影响标志位。 12345678910111213141516171819202122232425262728293031# LOOP格式：LOOP label操作：(CX)-1→CX； 若(CX)≠0,则转至label处执行； 否则退出循环,执行LOOP后面的指令。 LOOP指令与下面的指令段等价： DEC CX JNZ label # LOOPZ (LOOPE) 判等退出格式：LOOPZ label操作：(CX)-1→CX； 若(CX)≠0∧ZF=1,则转至label处继续循环； 否则退出循环,执行LOOP后面的指令。# LOOPNZ (LOOPNE) 不等退出格式：LOOPNZ label操作：(CX)-1→CX； 若(CX)≠0∧ZF=0,则转至label处继续循环； 否则退出循环,执行LOOP后面的指令。例1：给1A000H开始的256个内存单元均减去1，若发现某个单元减为0则立即退出循环，其后的单元不再减1。 MOV AX, 1A00H MOV DS, AX ；段基址 MOV DI, 0 ；偏移量 MOV CX, 256 ；循环次数 GOON: DEC BYTE PTR[DI] ；减1 INC DI ；移动指针 CMP BYTE PTR[DI-1],0 LOOPNZ GOON HLT 调用和返回指令 过程(子程序)：一段具有特定功能的，供其它程序调用的公用程序。 特点 调用子程序时，IP(CS)的内容被压入堆栈栈顶。从子程序返回时，栈顶的内容又被弹出到IP(CS)。 子程序执行结束后一般均要返回调用程序。 一次定义，可多次调用。 可带参数调用，以完成不同的功能。 1234567891011121314151617181920212223# 调用指令call一般格式：CALL sub ;sub为子程序的入口。根据子程序入口的寻址方式，子程序调用有四类。① 段内直接调用 子程序的偏移地址直接由CALL指令给出。 格式：CALL near_proc CALL执行时，它首先将IP内容压栈，然后把指令中给出的位移量加到IP上。注：经汇编后的调用地址是相对于CALL的下一条指令的位移量。例：CALL 0120H ;子程序偏移地址由指令给出注意是，给出的地址是相对call指令的下一条指令地址的位移量# 返回指令ret段内返回指令RET的操作为： IP←((SP)+1,(SP)) ;栈顶内容弹出到IP SP←(SP)+2段间返回指令RET的操作为： IP←((SP)+1,(SP)) ;栈顶内容弹出到IP SP←(SP)+2 CS←((SP)+1,(SP)) ;栈顶内容弹出到CS SP←(SP)+2另有一种带立即数返回指令：RET n 其中n为偶数，表示从栈顶弹出地址后另外丢弃的字节数。 例：RET 4 ;返回后再丢弃栈顶的4个字节 中断指令12345678910111213141516171819202122232425# INT n ;n=0～255,为中断类型号本指令的操作步骤为：①((SP)-1,(SP)-2)←(FLAGS)，SP←(SP)-2 保护标志寄存器的内容②IF←0,TF←0 中断服务程序中禁止外部INTR中断和单步中断③((SP)-1,(SP)-2)←(CS)，SP←(SP)-2，CS←(n*4+2) 中断服务程序的段地址送入CS。n*4为向量地址。该向量地址中的内容即为中断服务程序入口地址。④((SP)-1,(SP)-2)←(IP)，SP←(SP)-2，IP←(n*4) 中断服务程序的偏移地址送IP。INT指令只影响IF和TF, 对其余标志位无影响。INT指令可用于调用系统服务程序，如INT 21H。# 溢出中断INTOINTO检查溢出标志OF, 如果OF=1, 则启动一个类型4的中断过程；如果OF=0,不做任何操作。通常INTO指令安排在有符号数算术运算指令后面。如：IMUL DX INTO;若溢出，则启动INT 4,否则继续 MOV RESULT, AX MOV RESULT+2, DX# 中断返回指令IRET用于从中断服务程序返回到被中断的程序。任何中断服务程序不管是外部中断引起的, 还是内部中断引起的, 最后都要用IRET返回。该指令执行的操作为 IP←((SP)+1,(SP)) ;栈顶内容弹出到IP SP←(SP)+2 CS←((SP)+1,(SP)) ;栈顶内容弹出到CS SP←(SP)+2 FLAGS←((SP)+1,(SP)) ;栈顶内容弹出到FLAG SP←(SP)+2 从后两种总结、测试 再看全面的 完全看完后，再看第二章较长的例程 注：标志寄存器1234567891011121314151617181920212223242526右0开始进位标志CF 0 CF=1表示运算结果的最高位产生进位或借 主要用于多字节数的加减法运算 移位和循环指令也用到奇偶标志PF 2 PF=1表示运算结果的低8位中有偶数个1 主要用于数据传输过程中检错辅助进位标志AF 4 AF=1表示运算导致低4位向第5位的进位或借位 主要用于BCD码的运算零标志ZF 6 ZF=1表示运算结果的所有位为0符号标志SF 7 SF=1表示运算结果的最高位为1 对于用补码表示的有符号数，SF=1表示结果为负数自陷标志TF 8 TF=1表示CPU将进入单步执行方式，即每执行一条指令后都产生一个内部中断 利用它可逐条指令地调试程序中断允许标志IF 9 IF=1表示CPU允许外部可屏蔽中断，否则禁止外部可屏蔽中断 IF标志对内部中断和外部不可屏蔽中断不会产生影响方向标志DF 10 DF=1表示在串操作过程中地址指针DI和SI的变化方向是递减，否则为递增溢出标志OF 11 OF=1表示有符号数进行运算时产生溢出 逻辑运算指令 运算规则：按位操作，无进/借位 对标志位的影响 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# AND对两个操作数进行按位逻辑“与”操作。格式：AND dest, src用途：保留操作数的某几位，清零其他位。例1：保留AL中低4位，高4位清0。 AND AL, 0FH例3：测试AL的bit7, bit5, bit2是否都是1。AND AL, 10100100B CMP AL, 10100100B JZ YES … … ；不全为1时的处理YES: # OR对两个操作数进行按位逻辑”或”操作。格式：OR dest, src用途：对操作数的某几位置1； 对两操作数进行组合。例：把AL的第5位置为1 OR AL, 00100000B# 逻辑“非”(取反) NOT对操作数进行按位逻辑”非”操作。格式：NOT mem/reg例：NOT CX NOT BYTE PTR[DI] # 逻辑”异或” XOR对两个操作数按位进行”异或”操作。格式：XOR dest, src用途：对reg清零(自身异或) 把reg/mem的某几位变反(与’1’异或)例1：把AX寄存器清零。 例2：把DH的bit4,3变反 ① XOR AX, AX XOR DH,18H ② MOV AX, 0 ③ AND AX, 0 ④ SUB AX, AX # 测试指令TEST 操作与AND指令类似,但不将”与”的结果送回,只影响标志位。 TEST指令常用于位测试,与条件转移指令一起用。 例：测试AL的内容是否为负数。 TEST AL, 80H ；检查AL中D7=1？ JNZ MINUS ；是1(负数)，转MINUS … … ；否则为正数MINUS: …例3.11 已知寄存器DX：AX的内容为32位带符号数，编写一段程序使DX：AX的内容成为原来数据的绝对值。 解: TEST DX，8000H ;测试符号位，产生状态 JZ EXIT ;符号位=0，结束 NEG DX ;求绝对值 NEG AX SBB DX，0EXIT:HLT 移位指令非循环移位指令1234567891011121314151617181920# 格式算术左移指令 SAL(Shift Arithmetic Left)算术右移指令 SAR(Shift Arithmetic Right)逻辑左移指令 SHL(Shift Left)逻辑右移指令 SHR(Shift Right)这4条指令的格式相同,以SAL为例：SAL mem/reg, CL / 1算术移位——把操作数看做有符号数；逻辑移位——把操作数看做无符号数。移位位数放在CL寄存器中，如果只移1位,也 可以直接写在指令中。例如： MOV CL, 4 SHR AL, CL ；AL中的内容右移4位 影响C, P, S, Z, O标志。 结果未溢出时： 左移1位≡操作数×2 右移1位≡操作数 / 2 用移位操作代替乘除法可提高运算速度 循环移位指令123456789不含进位位的循环左移指令 ROL 不含进位位的循环右移指令 ROR含进位位的循环左移指令 RCL 含进位位的循环右移指令 RCR格式同非循环移位指令。移位位数放在CL寄存器中，如果只移1位,也可以直接写在指令中。循环移位指令只影响标志位CF和OF。 算术运算指令加法 不带进位的加法指令ADD 带进位位的加法指令ADC ADD/ADC对条件标志位的影响 加1指令INC（单操作数指令） 12345678910111213141516171819202122232425262728293031323334353637# 不带进位的加法指令ADD 格式： ADD acc, data ADD mem/reg, data ADD mem/reg1, mem/reg2 实例： ADD AL，30H ADD SI，[BX+20H] ADD CX，SI ADD [DI]，200HADD指令对6个状态标志均产生影响。 例：已知(BX)=E75FH，指令 ADD BX, 8046H 执行后，状态标志各是多少？ E75FH = 1 1 1 0 0 1 1 1 0 1 0 1 1 1 1 1 8046H = 1 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 0 1 0 0 1 0 1 结果：CF=1, ZF=0, PF=1, AF=1, OF=1, SF=0 # 带进位位的加法指令ADCADC指令在形式上和功能上与ADD类似，只是相加时还要包括进位标志CF的内容，例如： ADC AL，68H ;AL←(AL)+68H+(CF) ADC AX，CX ;AX←(AX)+(CX)+(CF) ADC BX，[DI] ; BX←(BX)+[DI+1][DI]+(CF) ADC指令用于多字节加法运算中 # ADD/ADC对条件标志位的影响 加1指令INC（单操作数指令） # 加1指令INC（单操作数指令）格式：INC reg/mem功能：类似于C语言中的++操作：对指定的操作数加1。 例： INC AL INC SI INC BYTE PTR[BX+4]注：本指令不影响CF标志。 减法 不带借位的减法指令SUB 带借位的减法指令SBB 减量指令DEC 求补(负)指令NEG 比较指令CMP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 不带借位的减法指令SUB格式： SUB dest, src 操作： dest←(dest)-(src)注：1.源和目的操作数不能同时为存储器操作数 2.立即数不能作为目的操作数例： SUB AL，60HSUB [BX+20H]，DXSUB AX，CX # 带借位的减法指令SBBSBB指令主要用于多字节的减法。格式： SBB dest, src操作： dest←(dest)-(src)-(CF)例：SBB AX，CXSBB WORD PTR[SI]，2080HSBB [SI],DX# 减量指令DEC作用类似于C语言中的”－－”操作符。格式：DEC opr 操作：opr←(opr)-1例：DEC CLDEC BYTE PTR[DI+2]DEC SI # 求补(负)指令NEG格式： NEG opr ;补码表示的带符号数操作： opr← 0-(opr)对一个操作数取补码相当于用0减去此操作数，故利用NEG指令可得到负数的绝对值。例：若(AL)=0FCH（ -4的补码），则执行 NEG AL， (AL)=04H，CF=1。即得到4(-4的绝对值)。# 比较指令CMP格式： CMP dest, src操作： (dest)-(src) CMP也是执行两个操作数相减，但结果不送目标操作数，其结果只反映在标志位上。例： CMP AL，0AH CMP CX，SI CMP DI，[BX+03] 根据标志位来判断比较的结果1) 根据ZF判断两个数是否相等。若ZF=1，则两数相等。2) 若两个数不相等,则分两种情况考虑:①比较的是两个无符号数 若CF=0，则dest＞src; 若CF=1，则dest＜src。②比较的是两个有符号数 若OF⊕SF=0，则dest＞src; 若OF⊕SF=1，则dest＜src。比较指令在使用时，一般在其后紧跟一条条件转移指令，判断比较结果的转向。举例：比较AL、BL、CL中带符号数的大小，将 最小数放在AL中。程序： CMP AL,BL ；AL和BL比较 JNG BBB ；若AL≤BL,则转 XCHG AL,BL ；若AL＞BL,则交换 BBB: CMP AL,CL ；AL和CL比较 JNG CCC ；若AL≤CL,则转 XCHG AL,CL ；若AL＞CL,则交换 CCC: HLT 乘法12345678910111213141516进行乘法时：8位× 8位→16位乘积 16位× 16位→32位乘积(1) 无符号数的乘法指令MUL(mem/reg)格式： MUL src；src的长度确定乘法类型操作：字节操作数 (AX) &lt;- (AL) × (src) 字操作数 (DX, AX) &lt;- (AX) × (src)指令例子： MUL BL ；(AL)×(BL),乘积在AX中MUL CX ；(AX)×(CX),乘积在DX,AX中MUL BYTE PTR[BX]乘法指令对CF/OF的影响MUL指令: CF/OF =0/0 乘积的高一半为零1/1 否则（高一半为有效数字） 除法12345678910111213141516171819进行除法时：16位/8位→8位商 32位/16位→16位商对被除数、商及余数存放有如下规定： 被除数 商 余数字节除法 AX AL AH字除法 DX:AX AX DX无符号数除法指令DIV格式： DIV src； src的长度确定除法类型操作：字节操作 (AL) &lt;- (AX) / (SRC) 的商(AH) &lt;- (AX) / (SRC) 的余数 字操作 (AX) &lt;- (DX, AX) / (SRC) 的商(DX) &lt;- (DX, AX) / (SRC) 的余数注：若除数为零或AL中商大于FFH,(或AX中商大于FFFFH)，则CPU产生一个类型0的内部中断。 数据传送指令通用数据传送指令 最基本的传送指令（MOV） 堆栈操作指令（PUSH, POP） 数据交换指令（XCHG） 查表换码指令（XLAT） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# MOV指令格式：MOV dst, src;MOV AL, BL;MOV [DI], AX;MOV CX, [1000H]; MOV BL, 40MOV WORD PTR[SI], 01H;WORD PTR 字长度标记BYTE PTR 字节长度标记DWORD PTR 双字长度标记 （伪指令）# MOV指令使用规则1) IP不能作目的寄存器；2) 不允许 mem2 ← mem1（存储器）；3) 不允许 segreg ← segreg（段寄存器）；4) 立即数不允许作为目的操作数；5) 源操作数与目的操作数类型要一致。# 几种不允许传送的解决办法： 用寄存器如AX作桥梁存储器←存储器： MOV AX，MEM1 MOV MEM2，AX段寄存器←段寄存器： MOV AX，DS MOV ES，AX段寄存器←立即数： MOV AX，DATA MOV DS，AX# 堆栈操作指令由SS指示堆栈段的段基址；堆栈指针SP始终指向堆栈的顶部；SP的初值规定了所用堆栈区的大小；堆栈的最高地址叫栈底。 ## 压栈指令PUSH src ; src为16位操作数PUSH reg ； PUSH mem/regPUSH segreg例如：PUSH AX； PUSH [BX]； PUSH DS ；## 出栈指令POP dest例：POP BX ；将栈顶内容弹至BX执行操作：(BL) ←[SP](BH) ← [(SP)+ 1](SP) ← (SP) + 2# 交换指令XCHG格式：XCHG reg，mem/reg功能：交换两操作数的内容。 要求：两操作数中必须至少有一个在寄存器中；操作数不能为段寄存器和立即数；源和目地操作数类型要一致。举例： XCHG AX，BX XCHG [2000]，CL# 查表换码指令XLAT 执行的操作：AL←[(BX)+(AL)]又叫查表转换指令，它可根据表项序号查出表中对应代码的内容。执行时先将表的首地址（偏移地址）送到BX中，表项序号存于AL中。XLAT是一条隐含寻址的指令。使用前要给隐含操作数赋初值。 输入输出指令 输入IN 输出OUT 取偏移地址指令用途：用于传送操作数的偏移地址 传送偏移地址：LEA reg，mem ； 将指定内存单元的偏移地址送到指定寄存器 要求： 1) 源操作数必须是一个存储器操作数； 2) 目的操作数必须是一个16位的通用寄存器。 LEA BX，[2000H] ;将存储单元的偏移地址取到 BX MOV BX， [2000H] ;将存储单元中的内容取到 BX 下面两条指令等效： LEA BX，BUFFER MOV BX, OFFSET BUFFER 其中OFFSET BUFFER表示存储器单元BUFFER的偏移地址。 二者都可用于取存储器单元的偏移地址。 注：指令介绍中采用符号的含义12345678910mem 存储器操作数acc 累加器操作数dest 目标操作数src 源操作数disp 8位或16位偏移量，可用符号地址表示DATA 8位或16位数据port 输入输出端口( ) 表示寄存器的内容[ ] 表示存储器的内容或偏移地址","categories":[{"name":"知识点总结","slug":"知识点总结","permalink":"https://shadowbynl.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"专业课","slug":"专业课","permalink":"https://shadowbynl.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"go http","slug":"go-http","date":"2020-10-13T08:28:32.000Z","updated":"2020-10-17T11:33:44.694Z","comments":true,"path":"2020/10/13/go-http/","link":"","permalink":"https://shadowbynl.github.io/2020/10/13/go-http/","excerpt":"","text":"本篇本是为记述：修改go-fabric的demo的controller方法直接返回json前，学习go的http包的内容。但发现其实无需全面了解http包的使用，因而该篇记述一下一个可行的修改测试代码流程（涉及链）的。 一、远程桌面连接首先为了便于在服务器上编码，需要直接通过远程桌面连接访问。https://blog.csdn.net/weixin_36553855/article/details/88709636 1234567891011121314151617181920linux服务器系统版本ubuntu16.041. 安装xrdpsudo apt-get install xrdp2.安装vnc4serversudo apt-get install vnc4server3.安装xubuntu-desktopsudo apt-get install xubuntu-desktop4.向xsession中写入cfce4-sessionecho &quot;xfce4-session&quot; &gt;~/.xsession5.开启xrdp服务sudo service xrdp restart6.重启服务器reboot 这样，通过windows的远程桌面连接即可访问。注意：要使远程桌面全屏显示，则在连接时，选择选项-显示-显示配置调到最大。 二、安装vscode，go插件 三、修改代码本来想在windows或者副本上改好再替换，后来直接在源码上改了。 默认给一个用户 注册个路由 加个返回json的代码 12msg, _ := json.Marshal(data)w.Write(msg) https://www.cnblogs.com/taoshihan/p/12912599.html 四、测试直接在源码上改是省事的，改完直接go build就可以看是否有语法错误。遇到了几种异常情况： 刚启动网络测试时（代码未修改），启动应用一直报错，显示连接有问题，后重启解决，推测是端口被占用或内存不足的问题，遇到这种情况只能重启。 启动应用后卡住，只能重启网络重来。 为确保端口号不被占用。用ps au来查看，并用kill -9 pid杀死进程 参考https://www.cnblogs.com/kehaimin/p/9030083.html 然后在postman上测试两个查询方法成功，说明直接通过接口访问获取数据可行。 五、后续步骤 把两个查询对应页面加到另一go项目中，联合测试。 其他方法修改。 用户传递。 重新设计。 六、不相干的记录 thinkpad目前clone代码是比联想快很多的 pip配置镜像源 https://www.cnblogs.com/ningzijie/p/12829239.html 123456789101112131415161718192021222324252627282930国内源：新版ubuntu要求使用https源，要注意。清华：https://pypi.tuna.tsinghua.edu.cn/simple阿里云：http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/华中理工大学：http://pypi.hustunique.com/山东理工大学：http://pypi.sdutlinux.org/豆瓣：http://pypi.douban.com/simple/临时使用：可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。永久修改，一劳永逸：Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)内容如下：[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.comwindows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。","categories":[{"name":"测试","slug":"测试","permalink":"https://shadowbynl.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shadowbynl.github.io/tags/Go/"}]},{"title":"关联方案","slug":"关联方案","date":"2020-10-11T10:41:30.000Z","updated":"2020-10-11T13:09:57.547Z","comments":true,"path":"2020/10/11/关联方案/","link":"","permalink":"https://shadowbynl.github.io/2020/10/11/%E5%85%B3%E8%81%94%E6%96%B9%E6%A1%88/","excerpt":"","text":"尽管已经在前文中确定mp的关联查询合适的方案，但仍有些问题尚未得到解决，该篇即针对这些问题进行解释。ps：其实再多看也没啥用，对于开发而言毕竟逻辑最重要，若是一直纠结于配置选型就如某篇文章说的那样真的很弱， 一、看了不少项目，不管是基础的还是用mp，为什么不用注解实现关联查了两个问题：（1）用注解有什么坏处吗 （2）为什么不用注解依次看了以下文章：https://segmentfault.com/a/1190000019365118 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Mybatis单表CRUD与多表关联的无SQL通用方案_2: 无SQL实现关联查询的自动绑定涉及关联的开发场景1. 关联查询另外一张表的字段1.1. id-name转换：如department表中有org_id字段，关联organization表的id字段，前端显示Department部门信息时需要显示组织名称organization.name。class DepartmentVO&#123; String orgName; //关联organization表的name字段&#125;1.2. 可配置的元数据/数据字典之类的value-label转换如department表中有状态字段status，存储值是&quot;A&quot;,&quot;I&quot;...，显示时需要转换为&quot;正常&quot;,&quot;无效&quot;...。class DepartmentVO&#123; String statusLabel; //关联字典表转换为显示值&#125;2. 关联查询另外一张表的单个实体如部门实体Department(department表的Java映射对象)对应的VO对象中需要关联组织Organization实体（organization表的映射对象）。class DepartmentVO &#123; Organization organization; //1对1关联另外的实体&#125;3. 关联查询另外一张表的多个实体如部门实体Department对应的VO对象中需要关联多个子部门Department实体。class DepartmentVO&#123; List&lt;Department&gt; children; //1对多关联另外的实体&#125;常规的实现方案Mybatis-plus并未实现关联查询的解决方案：对于字段关联，通常的解决方案是SQL关联查询，如：SELECT d.*, o.name as orgName, m.item_label as statusLabelFROM department d LEFT JOIN organization o ON d.org_id=o.idLEFT JOIN metadata m ON u.status=m.item_value AND m.type=&#x27;STATUS&#x27;或者通过另外一种不太优雅的方式：查询整个表得到id-name的Map，然后通过Java代码去绑定。对于关联一个或多个实体的情况，一般通过Mybatis的association实现：&lt;resultMap type=&quot;XX&quot; id=&quot;xx&quot;&gt; &lt;association select=&quot;...&quot;&gt;&lt;/resultMap&gt;无SQL的实现方案不写SQL，不通过Mybatis的association，要更优雅的实现关联的自动绑定，一个主流的方案就是类似JPA的注解了。JPA的注解需要复杂的设置，我们可以只借鉴其思想，将注解尽可能的简化。首先，需要明确关联到哪个表（实体），另外不管是哪种关联都必须要有关联条件condition，然后是字段关联呢我们需要指定字段名field。那么我们可以将注解定义简化如下：public class DepartmentVO &#123; ... // 关联Entity中的某字段 @BindField(entity=Organization.class, field=&quot;name&quot;, condition=&quot;this.org_id=id&quot;) private String orgName; // 关联Entity @BindEntity(entity=Organization.class, condition=&quot;this.org_id=id&quot;) private Organization organization; // 关联多个Entity @BindEntityList(entity=Department.class, condition=&quot;this.id=parent_id&quot;) private List&lt;Department&gt; children;&#125;简化的使用意味着要有完善的实现逻辑，后续的章节我们将具体讲解这些关联绑定注解的实现方案。 https://www.jianshu.com/p/b68a142509e7 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253mybatis-plus 注解实现多表关联查询的最佳实践1. 注解自动绑定数据字典(自定义枚举)的显示值Label开发过程中的枚举值，比如用户状态（ACTIVE:激活，LOCKED:锁定 ...）、身份证类型等，我们会将其名称name和值value定义在数据字典表，以支持扩展不改代码以及用户可编辑。其他数据表中关联该字典时，存储对应的value，显示时又需要查询字典表将value转换为对应的name。通过注解绑定，我希望简单使用如这样：@BindDict(type=&quot;USER_STATUS&quot;, field = &quot;status&quot;)private String statusLabel;2. 注解自动绑定其他表的字段如部门实体Department(department表的Java映射对象)对应的VO对象中需要关联组织Organization实体（organization表的映射对象）。我希望简单使用如这样：// 支持关联条件+附加条件绑定字段@BindField(entity=Department.class, field=&quot;name&quot;, condition=&quot;department_id=id AND parent_id&gt;=0&quot;)private String deptName;// 支持通过中间表的级联关联绑定字段@BindField(entity = Organization.class, field=&quot;name&quot;, condition=&quot;this.department_id=department.id AND department.org_id=id&quot;)private String orgName;3. 注解自动绑定其他表实体Entity如部门实体Department(department表的Java映射对象)对应的VO对象中需要关联组织Organization实体（organization表的映射对象）。我希望简单使用如这样：// 支持关联条件+附加条件绑定Entity@BindEntity(entity = Department.class, condition=&quot;department_id=id&quot;)private Department department;// 通过中间表的级联关联绑定Entity（支持附加条件）@BindEntity(entity = Organization.class, condition = &quot;this.department_id=department.id AND department.org_id=id AND department.deleted=0&quot;)private Organization organization;4. 注解自动绑定其他表实体集合List&lt;Entity&gt;如部门实体Department对应的VO对象中需要关联多个子部门Department实体。我希望简单使用如这样：// 支持关联条件+附加条件绑定多个Entity@BindEntityList(entity = Department.class, condition = &quot;id=parent_id&quot;)private List&lt;Department&gt; children;// 通过中间表的 多对多关联 绑定Entity（支持附加条件）@BindEntityList(entity = Role.class, condition=&quot;this.id=user_role.user_id AND user_role.role_id=id&quot;)private List&lt;Role&gt; roleList;实现以上方案，开发过程中的大部分关联场景SQL都可以大大简化，使代码具备极好的可维护性。另外以上方案实现需要拆解成单表查询SQL通过主键去查询，可以充分利用数据库缓存，提高性能。详细了解其实现代码，请至 Diboot - 简单高效的轻代码开发框架 (欢迎star)作者：一个鸡蛋壳儿链接：https://www.jianshu.com/p/b68a142509e7来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这两篇同一作者，基本思想是基于mp，借助其他框架的注解实现关联查询，类似jpa 使用的是diboot 一个自动化平台 后面可以学习一下 源码 https://github.com/dibo-software/diboot 视频 https://www.bilibili.com/video/BV17V411r7Cc 文档 https://www.diboot.com/guide/diboot-element-admin/%E6%B7%BB%E5%8A%A0%E9%A1%B5%E9%9D%A2.html#%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE 参考的其他：https://www.cnblogs.com/it-taosir/p/9992246.htmlhttps://blog.csdn.net/CoderYin/article/details/90768007 经过了上面的查找，就更困惑为什么不用注解了，于是到知乎上搜索相关问题。 二、知乎1. yBatis注解实现能取代XML配置么https://www.zhihu.com/question/297687402https://ld246.com/article/1488810828678https://www.cnblogs.com/java-zhao/p/5120792.html?utm_source=ld246.com 12345678xml使用场景（3个）：条件不定的查询（eg.下边代码中的getAdminByConditions方法）增加对象返回自增主键（eg.下边代码的insertAdminWithBackId方法）在一个Mapper接口中，出现多个select查询（&gt;=3个），且每个查询都需要写相同的返回@Results内容（这一部分内容通常很多），这样的话，为了使Mapper接口比较整洁，重复代码比较少，我们会将这些select方法的具体实现写在xml文件中，因为在xml文件的顶部我们就会配置与注解@Results异曲同工的东西。（当然，这一点如果嫌配置xml麻烦，这一点可忽略）注意：前两条是硬性的，是注解所解决不了的，而第三条只是建议。除了以上这三条之外，其他的都使用去注解就好。 结论 大多说xml好，原因：支持动态、关联查询，代码分离、为维护方便，自动生成 少数注解，说阿里这样的很少用复杂的多表了，代码一块更丝滑。。 各说各的，每个人的看法都有区别。有人认为遵从阿里的，不应有复杂的数据库表；有人认为阿里这样只是大数据量下的标准，小应用不应该完全按照这样的做法，复杂多表是有需求的；有人认为写简单sql，代码里组合进行关联更合理，符合开发理念，不应该给库太大负荷，有人认为不应有过于繁杂的代码，可以通过复杂sql实现的就直接实现。。可以说，都是按照自己的实践经验和业务需求的主观感受，实在不能片面地打定采取怎样的做法，要按照自己实际的需求开发。 下面甚至更出现了很多贬低mybatis这种“半orm”框架的，更合理应该用jpa，这样既能用注解实现关联，还能写原生sql；但也有人认为应该正向面向对象到表，而不应该从表逆向生成类。。这些也就看看罢了。 实际上，注解也有提供动态查询的。 总之，mybatis更多人推崇的是mp/mg + 全xml 2. 结合mybatis-plus 实现无XML多表联合查询https://zhuanlan.zhihu.com/p/79521445 3. MyBatis的esultMap标签、多表关联查询、注解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824831. 列名和属性名不一致问题_resultMap标签的使用(1) 什么是ResultMap? 有什么作用?用于自定义映射关系, 可以由程序员自主制定 列名和属性名的映射关系. 一旦使用 resultMap, 表示不再 采用自动映射机制. 可以解决列名和属性名不一致问题 。(2) resultType和resultMap有什么区别?①如果查询时使用 resultType 属性, 表示采用 MyBatis 的Auto-Mapping(自动映射)机制, 即相同的列名和属性名会自动匹配。②用于自定义映射关系, 可以由程序员自主制定 列名和属性名的映射关系. 一旦使用 resultMap, 表示不再 采用自动映射机制。(3) 解决列名和属性名不一致问题①使用列别名&lt;select id=&quot;selAll&quot; resultType=&quot;user&quot;&gt;select id id1, username username1, password password2 from t_user&lt;/select&gt;②使用&lt;resultMap&gt;&lt;resultMap type=&quot;user&quot; id=&quot;umap&quot;&gt;&lt;!-- id用于映射主键 --&gt;&lt;id column=&quot;id&quot; property=&quot;id1&quot; /&gt;&lt;!-- 非主键使用result映射 --&gt;&lt;result column=&quot;username&quot; property=&quot;username1&quot; /&gt;&lt;result column=&quot;password&quot; property=&quot;password1&quot; /&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll&quot; resultMap=&quot;umap&quot;&gt;select * from t_user&lt;/select&gt;2. 多表关联查询_设计表结构(1) MyBatis实现多表关联查询有哪些情况?单个对象多对一，n+1单个对象关联表查询，集合对象n+1集合对象 多表关联自动映射关联(2) 数据库表格间的关系有哪几种?一对一，一对多，多对多3. 多表关联查询_业务装配方式(1) 什么是业务装配? 简述如何实现?在一个表中可以查到其他表的信息①创建班级类(Clazz)和学生类(Student), 并在 Student 中添加一个 Clazz 类型的属性, 用于表示学生的班级信息。②mapper层：提供 StudentMapper 和 ClazzMapper, StudentMapper 查询所有学生信息, ClazzMapper 根据编号查询班级信息。&lt;mapper namespace=&quot;com.bjsxt.mapper.StudentMapper&quot;&gt;&lt;select id=&quot;selAll&quot; resultType=&quot;student&quot;&gt;select * from t_student&lt;/select&gt;&lt;/mapper&gt;&lt;mapper namespace=&quot;com.bjsxt.mapper.ClazzMapper&quot;&gt;&lt;select id=&quot;selById&quot; resultType=&quot;clazz&quot; parameterType=&quot;int&quot;&gt;select * from t_class where id=#&#123;0&#125;&lt;/select&gt;&lt;/mapper&gt;③service 层：调用 mapper 层, 先查询所有学生, 再根据每个学生的班级编号查询班级信息, 手动进行组装, 称之为业务装配。public class StudentServiceImpl implements StudentService &#123;@Overridepublic List&lt;Student&gt; selAll() &#123;SqlSession session = MyBatisUtil.getSession();// 学生mapperStudentMapper stuMapper = session.getMapper(StudentMapper.class);// 班级mapperClazzMapper clsMapper = session.getMapper(ClazzMapper.class);// 查询所有学生信息List&lt;Student&gt; list = stuMapper.selAll();// 为每一个student组装班级信息for (Student student : list) &#123;student.setClazz(clsMapper.selById(student.getCid()));&#125;session.close();return list;&#125;&#125;④测试代码public static void main(String[] args) &#123;StudentService ss = new StudentServiceImpl();List&lt;Student&gt; list = ss.selAll();for (Student student : list) &#123;System.out.println(student);&#125;&#125;(2) 请总结MyBatis有哪些优点?语法简单，将业务的使用全部放在了内部自动装配，逻辑清楚简单，数据库的查询少。4. 多表关联查询_resultMap_单个对象_N+1方式实现(1) 标签&lt;association&gt;有什么作用?&lt;association&gt;用于关联一个对象(2) &lt;association&gt;标签中有哪些属性? 分别有什么含义?①property: 指定要关联的属性名②select: 设定要继续引用的查询, namespace+id③column: 查询时需要传递的列&lt;mapper namespace=&quot;com.bjsxt.mapper.StudentMapper&quot;&gt;&lt;resultMap type=&quot;student&quot; id=&quot;smap&quot;&gt;&lt;!-- N+1查询时, 同名映射可以省略, 但是只能使用一次 --&gt;&lt;result property=&quot;cid&quot; column=&quot;cid&quot; /&gt;&lt;!-- 用于关联一个对象 --&gt;&lt;association property=&quot;clazz&quot;select=&quot;com.bjsxt.mapper.ClazzMapper.selById&quot;column=&quot;cid&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll&quot; resultMap=&quot;smap&quot;&gt;select * from t_student&lt;/select&gt;&lt;/mapper&gt;5. 多表关联查询_resultMap_单个对象_关联方式实现在mapper中如何传递多个参数?mapper 层①在 StudentMapper.xml 中定义多表连接查询 SQL 语句, 一次性查到需要的所有数据, 包括对应班级的信息。②通过&lt;resultMap&gt;定义映射关系, 并通过&lt;association&gt;定对象属性的映射关系. 可以把&lt;association&gt;看成一个&lt;resultMap&gt;使用. javaType 属性表示当前对象, 可以写全限定路径或别名。&lt;resultMap type=&quot;student&quot; id=&quot;smap&quot;&gt;&lt;id property=&quot;id&quot; column=&quot;sid&quot; /&gt;&lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt;&lt;result property=&quot;age&quot; column=&quot;age&quot; /&gt;&lt;result property=&quot;gender&quot; column=&quot;gender&quot; /&gt;&lt;result property=&quot;cid&quot; column=&quot;cid&quot; /&gt;&lt;association property=&quot;clazz&quot; javaType=&quot;clazz&quot;&gt;&lt;id property=&quot;id&quot; column=&quot;cid&quot; /&gt;&lt;result property=&quot;name&quot; column=&quot;cname&quot; /&gt;&lt;result property=&quot;room&quot; column=&quot;room&quot; /&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll&quot; resultMap=&quot;smap&quot;&gt;select s.id sid, s.name sname, s.age, s.gender, c.id cid,c.name cname, c.roomfrom t_student sleft join t_class con s.cid=c.id&lt;/select&gt;6. 多表关联查询_resultMap_集合对象_N+1方式实现(1) 标签&lt;collection&gt;有什么作用?&lt;collection&gt;用于关联一个集合(2) &lt;collection&gt;标签中有哪些属性? 分别有什么含义?①property: 指定要关联的属性名②select: 设定要继续引用的查询, namespace+id③column: 查询时需要传递的列&lt;mapper namespace=&quot;com.bjsxt.mapper.ClazzMapper&quot;&gt;&lt;resultMap type=&quot;clazz&quot; id=&quot;cmap&quot;&gt;&lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;&lt;collection property=&quot;stus&quot;select=&quot;com.bjsxt.mapper.StudentMapper.selByCid&quot;column=&quot;id&quot;&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll&quot; resultMap=&quot;cmap&quot;&gt;select * from t_class&lt;/select&gt;&lt;/mapper&gt;7. 多表关联查询_resultMap_集合对象_关联方式实现(1) 通常一个Xml映射文件，都会写一个Mapper接口与之对应，请问，这个Mapper接口的工作原理是什么?①接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement。②Mapper接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。(2) Mapper接口里的方法，参数不同时，方法能重载吗?Mapper接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。8. 多表关联查询_Auto-Mapping配合别名实现(1) Mybatis是如何将sql执行结果封装为目标对象并返回的? 都有哪些映射形式?①使用&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。②使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。(2) 什么情况下用注解绑定,什么情况下用xml绑定?当Sql语句比较简单时候,用注解绑定,当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。(3) 通过 Auto-Mapping 实现多表查询①通过 MyBatis 的 Auto-Mapping 机制及数据库查询时的别名结合, 可以方便的实现多表查询。&lt;mapper namespace=&quot;com.bjsxt.mapper.StudentMapper&quot;&gt;&lt;select id=&quot;selAll&quot; resultType=&quot;student&quot;&gt;select s.id, s.name, s.age, s.gender, s.cid, c.id `clazz.id`,c.name `clazz.name`, c.room `clazz.room`from t_student sleft join t_class con s.cid=c.id&lt;/select&gt;&lt;/mapper&gt;②SQL 语句中, 别名出现特殊符号时, 必须进行处理. MySQ可以使用(``)符号, Oracle 可以使用(&quot;&quot;)符号。9. 注解开发详解(1) 什么是注解? 有什么作用?①注解是用于描述代码的代码.②注解的使用风格: @xxx(属性), 使用前必须先导包③使用注解一般用于简化配置文件. 但是, 注解有时候也不是很友好(有时候反而更麻烦), 例如动态 SQL.④属性的设定方式是: 属性名=属性值⑤关于属性值的类型Ø 基本类型和 String, 可以直接使用双引号的形式Ø 数组类型, name=&#123;值 1, 值 2, ...&#125;; 如果数组元素只有 一个, 可以省略大括号Ø 对象类型, name=@对象名(属性)Ø 如果属性是该注解的默认属性, 而且该注解只配置这 一个属性, 可以将属性名省略⑥注解和配置文件可以配合使用(2) MyBatis中常用的注解有哪些?@Select: 类似于&lt;select&gt;--查询@Insert: 类似于&lt;insert&gt;--添加@Update: 类似于&lt;update&gt;--修改@Delete: 类似于&lt;delete&gt;--删除@Results: 类似于&lt;resultMap&gt;@Result: 类似于&lt;resultMap&gt;的子标签@One: 类似于&lt;association&gt;@Many: 类似于&lt;collection&gt;10. MyBatis注解_CRUD哪些注解可以实现增删改查操作?@Select: 类似于&lt;select&gt;--查询@Insert: 类似于&lt;insert&gt;--添加@Update: 类似于&lt;update&gt;--修改@Delete: 类似于&lt;delete&gt;--删除@Select(&quot;select * from t_student&quot;)List&lt;Student&gt; selAll();@Insert(&quot;insert into t_student values (default, #&#123;name&#125;, #&#123;age&#125;,#&#123;gender&#125;, #&#123;cid&#125;)&quot;)int insStu(Student student);@Update(&quot;update t_student set age=#&#123;1&#125; where id=#&#123;0&#125;&quot;)int updStu(int id, int age);@Delete(&quot;delete from t_student where id=#&#123;0&#125;&quot;)int delStu(int id);11. MyBatis注解_关联查询(1) @Results和@Result注解有什么作用?@Results: 类似于&lt;resultMap&gt;@Result: 类似于&lt;resultMap&gt;的子标签@One: 类似于&lt;association&gt;@Many: 类似于&lt;collection&gt;(2) 如何通过注解实现多表关联查询?public interface StudentMapper &#123;@Select(&quot;select * from t_student&quot;)@Results(value = &#123;@Result(column=&quot;id&quot;, property=&quot;id&quot;, id=true),@Result(column=&quot;name&quot;, property=&quot;name&quot;),@Result(column=&quot;age&quot;, property=&quot;age&quot;),@Result(column=&quot;gender&quot;, property=&quot;gender&quot;),@Result(column=&quot;cid&quot;, property=&quot;cid&quot;),@Result(property=&quot;clazz&quot;,one=@One(select=&quot;com.bjsxt.mapper.ClazzMapper.selById&quot;),column=&quot;cid&quot;)&#125;)List&lt;Student&gt; sel();&#125;public interface ClazzMapper &#123;@Select(&quot;select * from t_class where id=#&#123;0&#125;&quot;)Clazz selById(int id)&#125;12. 分析MyBatis的运行原理(1) SqlSession对象的创建经理的哪些过程?InputStream is =Resource.getResourceAsStream(“mybatis.xml”)\\Sqlsession session=sqlsessionFactoryBuilder().build(is).openSession(true);(2) 当实体类中的属性名和表中的字段名不一样 ，怎么办?resultMap 中的result column 和property一一对应13. 详述MyBatis的运行原理(1) MyBatis运行过程中涉及到哪些类或接口? 请列举并简述作用.①Resources(C)用于加载 MyBatis 核心配置文件②XMLConfigBuilder(C)用于解析 xml 文件(核心配置文件)③Configuration(C)用于存放 xml 文件解析后的结果④DefaultSqlSessionFactory(C)是 SqlSessionFactory(I)的 实 现 类 , 创 建 时 需 要 使 用Configuration 对象⑤SqlSession(I)是 MyBatis 操作的核心⑥DefaultSqlSession(C)是 SqlSession 接口的实现类⑦TransactionFactory(I)用于生产 Transaction 对象⑧Transaction(I)用于表示操作数据库的事务对象⑨Executor(I)是 MyBatis 的核心执行器, 类似于 jdbc 中的 Statement, 常用的实现类是 SimpleExecutor(2) 请总结MyBatis的运行原理当 MyBatis 运行开始时, 先要通过 Resources 加载核心配置文件, 之后使用 XMLConfigBuilder 对配置文件进行解析, 将解析结果封装为 Configuration 对象, 接着, 使用Configuration对象构建一个DefaultSqlSessionFactory对象, 至此, SqlSession 工厂构建完成。接下来, 通过工厂对象调用 openSession 方法创建SqlSession 对 象 . 在 这 个 过 程 中 , 需 要 通 过TransactionFactory 生成 Transaction 对象, 并且, 还需要创建核心执行器 Executor 对象, 之后, 通过这些对象来创建DefaultSqlSession对象, 至此, SqlSession对象创建成功。之后, 通过 SqlSession 对象执行相应的操作, 如果执行成功, 调用 commit 方法提交事务; 如果失败, 调用rollback 方法事务回滚. 最后, 调用 close 方法关闭session 资源. 以上, 就是 MyBatis 的运行原理。 4. mybatis用注解还是xmlspring boot集成mybatis时是用xml配置，还是用注解https://www.zhihu.com/question/294748079 mybatis开发，你用 xml 还是注解？我 pick…https://zhuanlan.zhihu.com/p/141748037 一步步放弃mybatis的xmlhttps://zhuanlan.zhihu.com/p/88209833 SpringBoot快速整合Mybatis（去XML化+注解进阶）https://zhuanlan.zhihu.com/p/56144977动态查询的注解 MyBatis-Plus: 谨慎入坑https://zhuanlan.zhihu.com/p/220084517 用注解的人说用xml的蠢，用xml的认为用注解的蠢。。 5. Mybatis还是Spring Data JPASpringBoot开发使用Mybatis还是Spring Data JPA??https://www.zhihu.com/question/316458408/answer/664023798 程序员，Mybatis 你踩过坑吗https://zhuanlan.zhihu.com/p/62894816 6. 其他详解Mybatis Generator和全注解风格的MyBatis3DynamicSqlhttps://zhuanlan.zhihu.com/p/137914700 谈谈自己用mybatis-plus中的一些经验https://zhuanlan.zhihu.com/p/52313516 三、总结 框架很多，很多公司还有在此基础上开发的自动化工具，都是针对各自业务需求的 目前自学的阶段，一定要尽快跳过一直配置的阶段，进入功能和逻辑实现的阶段，因此其实这些选型都可以选。建议就是mp/mg + 全xml 或 jpa 不要一直纠结这种问题了","categories":[{"name":"功能点学习","slug":"功能点学习","permalink":"https://shadowbynl.github.io/categories/%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"git与idea版本控制测试","slug":"git与idea版本控制测试","date":"2020-10-01T05:54:17.000Z","updated":"2020-10-02T06:58:42.640Z","comments":true,"path":"2020/10/01/git与idea版本控制测试/","link":"","permalink":"https://shadowbynl.github.io/2020/10/01/git%E4%B8%8Eidea%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%B5%8B%E8%AF%95/","excerpt":"","text":"本篇就git的一些基本概念和在idea中进行版本控制的方法进行测试总结。 为更好模拟多人协作情况，创建新账号 在edge上注册时出现错误：Unable to verify your captcha response参考 https://blog.csdn.net/qq_44920883/article/details/104561023发现可能是浏览器的原因，换chrome后可行。 在线学习网站 https://blog.csdn.net/qq_44920883/article/details/104561023https://www.runoob.com/git/git-tutorial.html git概念回顾 https://learngitbranching.js.org/?locale=zh_CN本地 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485git checkout -b bugFix创建分支并切换分支与合并：将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。第一种方法 —— git merge。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”git merge anotherbranchname由master合并其他分支第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。git rebase master 把分支副本拷到master上HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。git checkout 提交记录哈希 使HEAD指向某个提交记录通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 git log 来查查看提交记录的哈希值。并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 fed2da64c0efc5293610bdd892f82a58e8cbc5d8。舌头都快打结了吧...比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入fed2 而不是上面的一长串字符。正如我前面所说，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。相对引用非常给力，这里我介绍两个简单的用法：使用 ^ 向上移动 1 个提交记录使用 ~&lt;num&gt; 向上移动多个提交记录，如 ~3首先看看操作符 (^)。把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。所以 master^ 相当于“master 的父节点”。master^^ 是 master 的第二个父节点可以将 HEAD 作为相对引用的参照。可以一直使用 HEAD^ 向上移动。“~”操作符如果你想在提交树中向上移动很多步的话，敲那么多 ^ 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 ~。该操作符后面可以跟一个数字（可选，不跟数字时与 ^ 相同，向上移动一次），指定向上移动多少次。使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。例如:git branch -f master HEAD~3上面的命令会将 master 分支强制指向 HEAD 的第 3 级父提交。相对引用为我们提供了一种简洁的引用提交记录 C1 的方式， 而 -f 则容许我们将分支强制移动到那个位置。# 撤销变更在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。主要有两种方法用来撤销变更 —— 一是 git reset，还有就是 git revert。git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！为了撤销更改并分享给别人，我们需要使用 git revert。在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 C2&#x27; 引入了更改 —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2&#x27; 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。即revert是新增一个撤销的提交。# cherry-pick“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。本系列的第一个命令是 git cherry-pick, 命令形式为:git cherry-pick &lt;提交号&gt;...如果你想将一些提交复制到当前所在的位置（HEAD）下面的话， Cherry-pick 是最直接的方式了。我个人非常喜欢 cherry-pick，因为它特别简单。git cherry-pick 提交哈希1 提交哈希2当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。交互式 rebase 指的是使用带参数 --interactive 的 rebase 命令, 简写为 -i如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。当 rebase UI界面打开时, 你能做3件事:调整提交记录的顺序（通过鼠标拖放来完成）删除你不想要的提交（通过切换 pick 的状态来完成，关闭就意味着你不想要这个提交记录）合并提交。 遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。git rebase -i HEAD~4# 本地栈式提交来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！最后就差把 bugFix 分支里的工作合并回 master 分支了。你可以选择通过 fast-forward 快速合并到 master 分支上，但这样的话 master 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用git rebase -igit cherry-pick来达到目的。 1234567分支 提交 HEAD 其中分支和HEAD相当于两个指针HEAD可以指向分支或提交 分支可以指向提交HEAD引用的是检出的提交git reset必须有参数 git reset HEAD~git revert 同 git revert HEAD 远程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141# 远程分支你可能注意到的第一个事就是在我们的本地仓库多了一个名为 o/master 的分支, 这种类型的分支就叫远程分支。由于远程分支的特性导致其拥有一些特殊属性。远程分支反映了远程仓库(在你上次和它通信时)的状态。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。# 为什么有 o/？你可能想问这些远程分支的前面的 o/ 是什么意思呢？好吧, 远程分支有一个命名规范 —— 它们的格式是:&lt;remote name&gt;/&lt;branch name&gt;因此，如果你看到一个名为 o/master 的分支，那么这个分支就叫 master，远程仓库的名称就是 o。# 自动进入分离HEAD状态的含义Git 变成了分离 HEAD 状态，当添加新的提交时 o/master 也不会更新。这是因为 o/master 只有在远程仓库中相应的分支更新了以后才会更新。# Git FetchGit 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。 大多数的开发人员会将它们主要的远程仓库命名为 origin，并不是 o。这是因为当你用 git clone 某个仓库时，Git 已经帮你把远程仓库的名称设置为 origin 了不过 origin 对于我们的 UI 来说太长了，因此不得不使用简写 o :) 但是要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 origin!# git fetch 做了些什么git fetch 完成了仅有的但是很重要的两步:从远程仓库下载本地仓库中缺失的提交记录更新远程分支指针(如 o/master)git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你最后一次与它通信时的状态，git fetch 就是你与远程仓库通信的方式了！git fetch 通常通过互联网（使用 http:// 或 git:// 协议) 与远程仓库通信。# git fetch 不会做的事git fetch 并不会改变你本地仓库的状态。它不会更新你的 master 分支，也不会修改你磁盘上的文件。理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。所以, 你可以将 git fetch 的理解为单纯的下载操作。# Git Pull既然我们已经知道了如何用 git fetch 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:git cherry-pick o/mastergit rebase o/mastergit merge o/master等等实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 git pull。git pull 就是 git fetch 和 git merge 的缩写# 模拟团队合作这里有一件棘手的事 —— 为了接下来的课程, 我们需要先教你如何制造远程仓库的变更。这意味着，我们需要“假装”你的同事、朋友、合作伙伴更新了远程仓库，有可能是某个特定的分支，或是几个提交记录。为了做到这点，我们引入一个自造命令 git fakeTeamwork！fakeTeamwork 默认操作就是在远程仓库的 master 分支上做一次提交。# git pushOK，我们已经学过了如何从远程仓库获取更新并合并到本地的分支当中。这非常棒……但是我如何与大家分享我的成果呢？嗯，上传自己分享内容与下载他人的分享刚好相反，那与 git pull 相反的命令是什么呢？git push！git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！你可以将 git push 想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧……注意 —— git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。# 偏离的工作现在我们已经知道了如何从其它地方 pull 提交记录，以及如何 push 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？困难来自于远程库提交历史的偏离。假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。这种情况下, git push 就不知道该如何操作了。如果你执行 git push，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用 merge尽管 git merge 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。面已经介绍过 git pull 就是 fetch 和 merge 的简写，类似的 git pull --rebase 就是 fetch 和 rebase 的简写！git pull + git push即第二种实现方法# 远程服务器拒绝!(Remote Rejected)如果你是在一个大的合作团队中工作, 很可能是master被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地master, 然后试图推送(push)修改, 你将会收到这样类似的信息: ! [远程服务器拒绝] master -&gt; master (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.) 远程服务器拒绝直接推送(push)提交到master, 因为策略配置要求 pull requests 来提交更新.你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了master.现在你卡住并且无法推送你的更新.# 解决办法新建一个分支feature, 推送到远程服务器. 然后reset你的master分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题。# 合并特性分支既然你应该很熟悉 fetch、pull、push 了，现在我们要通过一个新的工作流来测试你的这些技能。在大型项目中开发人员通常会在（从 master 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.但是有些开发人员只在 master 上做 push、pull —— 这样的话 master 总是最新的，始终与远程分支 (o/master) 保持一致。对于接下来这个工作流，我们集成了两个步骤：将特性分支集成到 master 上推送并更新远程分支如何快速的更新 master 分支并推送到远程。我们执行了两个命令:将我们的工作 rebase 到远程分支的最新提交记录向远程仓库推送我们的工作# 为什么不用 merge 呢?为了 push 新变更到远程仓库，你要做的就是包含远程仓库中最新变更。意思就是只要你的本地分支包含了远程分支（如 o/master）中的最新变更就可以了，至于具体是用 rebase 还是 merge，并没有限制。那么既然没有规定限制，为何前面几节都在着重于 rebase 呢？为什么在操作远程分支时不喜欢用 merge 呢？在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：优点:Rebase 使你的提交树变得很干净, 所有的提交都在一条线上缺点:Rebase 修改了提交树的历史比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 )执行git fetch后远程仓库所有分支对应的远程分支都随之更新git pull工作偏离 123456789101112131415161718192021远程仓库的分支本身有个master 本地有个master 从远程过来就是o/master远程分支。远程分支不同于远程仓库的分支。git pull相当于 git fetch + 本地分支合并远程分支$ git fetch$ git rebase o/master side1$ git rebase side1 side2$ git rebase side2 side3$ git rebase side3 master快速前进...$ git push$ git checkout master$ git pull快速前进...$ git merge side1$ git merge side2$ git merge side3$ git push idea进行vcs https://blog.csdn.net/Alvin199765/article/details/107953261经过一些测试，分支创建（合并未测试），拉取推送，解决冲突（复杂的未测试）等。基本了解idea使用git vcs的方法。有以下几点需要注意： 如果要在一个分支上一直延伸，那么需要切到这个分支而不是提交上 如果不是创建项目的参与者 clone后必须在一个分支上有延伸 才会在local的分支中有对应的分支（应该是不是分支的创建者，必须在该分支上有拓展local才会有对应分支） 总体来说，所有开发者的分支分为local和远程orign两个部分 一般先pull 开发 push merge 一般不需要tag 提交的说明写清 分支分号就行 分支的合并暂不详细考虑 每个分支都是各推各的 当前是master 推上去的只有master 那么更新呢 pull会更新所有分支 一些问题 一、rebase和mergehttps://www.jianshu.com/p/4079284dd970https://zhuanlan.zhihu.com/p/75499871 二、如何解决冲突https://www.zhihu.com/question/27507789https://www.jianshu.com/p/2afbc7dcd76e 三、sourcetreehttps://www.cnblogs.com/fisherbook/p/11397168.html 目前如何使用分支和解决冲突 当前创建的分支基本是不需要合并到master的 根据技术选型开分支那么对于二人开发的项目，需要移到master上的 具体再看","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://shadowbynl.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}]},{"title":"以太坊和solidity复习其一","slug":"以太坊和solidity复习其一","date":"2020-09-29T13:59:16.000Z","updated":"2020-09-29T14:23:13.968Z","comments":true,"path":"2020/09/29/以太坊和solidity复习其一/","link":"","permalink":"https://shadowbynl.github.io/2020/09/29/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%92%8Csolidity%E5%A4%8D%E4%B9%A0%E5%85%B6%E4%B8%80/","excerpt":"","text":"因为不慎掉到了区块链这个坑里，导致现在还得花时间看这些东西。写这篇，是想开一下这个复习系列的头，以此走上正轨。这篇主要copy一下我从2020.3.5起，当时学以太坊时记录的一些东西。 相关资料 白皮书https://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6http://blog.leanote.com/post/heming/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6黄皮书http://blog.leanote.com/post/heming/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%BB%84%E7%9A%AE%E4%B9%A6[%E4%B8%AD%E6%96%87]remixhttp://remix.hubwiz.com/#optimize=false&amp;version=soljson-v0.5.1+commit.c8a2cb62.jshttps://remix.ethereum.org/ 2020.3.5 以太坊环境搭建 一、windows 以太坊环境搭建 参考：https://blog.csdn.net/salmonwilliam/article/details/84678261https://github.com/ethereum/go-ethereum/wiki/Installation-instructions-for-Windows geth客户端 官网无法下载最新版1.9.11 只能安1.8.3环境变量变化系统变量Path新增 D:\\Work\\Ethereum\\Geth 安好了go环境 geth version 显示 Geth Version: 1.8.3-stable Git Commit: 329ac18ef617d0238f71637bffe78f028b0f13f7 Architecture: amd64 Protocol Versions: [63 62] Network Id: 1 Go Version: go1.10 Operating System: windows GOPATH=D:\\Project\\go\\go_work GOROOT=C:\\go geth 启动默认连接主网 geth –datadir .\\data 启动节点同步 geth –-datadir . –syncmode fast fast是同步数据 会下区块 不验证 geth –testnet –datadir . –syncmode fast 一个网络对应一条链 一个ID 二、windows go环境搭建 参考：下载链接：https://golang.google.cn下载方式：手机迅雷 环境变量的变化参考：https://www.jianshu.com/p/602c9ed4847d用户变量多了 GOPATH %USERPROFILE%\\goPATH %USERPROFILE%\\go\\bin 此处表示go代码的工作路径系统变量多了 PATH D:\\Work\\Go\\bin根据 echo %USERPROFILE% 知 %USERPROFILE% 为 C:\\Users\\Administrator&gt;修改 用户变量 GOPATH 为 D:\\Project\\go\\go_work修改 用户变量 GOPATH 为 D:\\Project\\go\\go_work 三、windows geth编译源码方式安装 安好go环境后根据：https://studygolang.com/articles/11462https://blog.csdn.net/zhouxukun123/article/details/80387226自行修改后，视图源码安装 可见在 go install后开始不断下载依赖包，但太tm慢了，还会断掉而且我对go命令不熟，网上的支持太少所以我没法继续了go install -v ./cmd/geth 暂时我只能跳会第一步，在旧版本的基础上安装其他环境之后再考虑两条路：windows源码安装ubuntu源码安装 四、环境变量 用户PathD:\\Work\\atom\\bin;C:\\Users\\Administrator.atom\\packages\\uncrustify;C:\\Users\\Administrator\\AppData\\Roaming\\npm;D:\\Work\\Anaconda3;D:\\Work\\Anaconda3\\Scripts;D:\\Work\\Anaconda3\\Lib\\site-packages;%JAVA_HOME%\\bin;%MAVEN_HOME%\\bin;D:\\Work\\Dev-Cpp\\MinGW32\\bin;D:\\Work\\Git\\cmd; 系统PathD:\\Work\\Sql\\Oracle11g_Client\\product\\11.2.0\\client_1\\bin;D:\\Work\\Sql\\Oracle11g\\product\\11.2.0\\dbhome_1\\bin;C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath;%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem;%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0;D:\\Shortcut;D:\\Work\\nodejs;D:\\Work\\Git\\cmd;D:\\Work\\Anaconda3\\Scripts;D:\\Work\\Anaconda3\\Lib\\site-packages;D:\\Work\\Sql\\MySQL\\MySQL Server 5.5\\bin;D:\\Work\\SVN\\TortoiseSVN\\bin;D:\\Work\\Ethereum\\Geth 五、ubuntu相关环境安装及其他 go 和 npmhttps://blog.csdn.net/DittyChen/article/details/86134804 geth安装方式https://feelncut.com/2018/03/05/101.html 记录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235242020.3.4# 以太坊简介（五）GHOST协议 广播一般就几秒 十几秒的出块时间的安全威胁：有算力优势的矿工优势会越来越大# 以太坊简介（五）图灵完备 图灵机无法判断停机问题 引入gas gas和交易费 是一个东西吧 可替代通证 非同质通证3.5 助记词相当于私钥，MetaMask的密码只是解锁这个工具的 地址-公钥-私钥 助记词 Network ID 区分不同的以太坊网络 Ropsten Test Network 和 主网络几乎一样，缺点在于一样堵10.rinkeby获取测试币必须有twitter或者facebook账号 ropsten网络 根据交易显示结果知 https://ropsten.etherscan.io/tx/0xc7cf4066a2c470a137fd04f93f47a9a906bf9d2be5dc87b796ca21e450714163 如果没有其他的东西 消耗gas(数量) * gas price(单位gas等价的以太) = 这笔交易的交易费 测试网络中的矿工 要转移一个以太，其实要支付超过一个以太，因为有gas fee 转账时的gas price 和 gas limit是可以自己调整的 gas price是不能设为0的 可以无限小，但不能为0 但矿工可能不乐意打包你这个交易11. 12.faucet msg.sender 表示调用者的地址 msg.sender.transfer 是从合约账户抽取给调用账户13.合约创建的交易 # 给一个合约账户发币或者取币，合约必须有回退函数 payable # 上链的合约不可修改，有问题就作废了 # 同一份代码，多次deploy会产生不同的地址，算不同的合约 # 向水龙头请求币，会先产生自己账户向合约账户请求的交易----------------------------------# 实践时问题 编译的版本不同，会不会报错，报的什么错都难说 教程上的按现在的remix默认编译版本已经报错了，按教程上的版本没问题； 至于这点有什么影响，怎么解决这个问题，现在没法说 remix的文档（需要翻墙）：https://remix-ide.readthedocs.io/en/latest/compile.html---------------------------------------------------------------------以太坊客户端15. 满足标准规范 基于以太坊规范的网络 做开发不需要在本地部署全节点（要求硬件条件高） # 远程客户端 和 轻节点 区分 远程客户端就是钱包，只是创建和广播交易，不参与存储和验证 轻节点 是保存当前区块链状态，参与验证，不保存链上的历史数据 # 全节点是要同步网络的整条链的 ---------------------------------- ？ 账户和节点的关系 # 测试网络 # 本地私链 3.618. eth.accounts 列出系统中的账户是不包括genesis.json文件 中自己写的账户的信息的，只是作为创世块记录的一个信息， 实际账户还是0，产生的账户在keystore文件夹下 # 矿工是唯一的地址 所以挖矿的出块奖励都个账户 5eth/block19. 平行的链（不同的网络）同一账户的balance可以不同 geth --datadir .\\data init genesis.json geth --datadir . --networkid 666 console personal.newAccount() personal.unlockAccount(eth.accounts[0]) eth.getBalance(eth.accounts[0])--------------------------20. --dev 自动创建私链 有账户非常有钱 有交易自动挖矿 用的是POA权威证明 自动解锁账户 geth --datadir . --dev --rpc console eth.sendTransaction(&#123;from: eth.accounts[0], to: eth.accounts[1], value: web3.toWei(10, &#x27;ether&#x27;)&#125;) ----------------------------------------------------------------------------## geth 控制台总结 1. 用第一种由genesis文件建私有链的方式，挖矿启动三十分钟没有挖出一个块来， 所以直接使用--dev 2. geth --datadir . --dev --rpc console 直接就可以和小狐狸连上 keystore下的文件可以直接导入小狐狸生成账户，在小狐狸里直接转账都可以 挖矿很快 缺点是进行一次交易就搞一个块 3. eth.getBlock(0) 获得的是默认创建的创世块，自己交易后产生的块是从1开始的21. jsonrpc 实际上就是远程访问geth客户端调用其api22. UTXO 和 以太坊账户23. 合约账户 以太币余额 + 代码 + 内部存储 交易 消息 合约调合约 调函数 合约 合约应用 数据存储（账本） -- 代币 转发合同 多重签名 合同 3.724.交易 nonce机制 防止重放 序列号 无法真正实现并发25.gas 操作的成本 是硬件资源的消耗 耗算力 gas 对 以太的单价 是矿工决定的 相当于贡献算力挖矿的人 决定算力的价格 因此矿工可以拒绝gas price低于限额的交易 gas 和 ether解耦 但其价格与 ether衡量 gas的计算 21000 gas 是只交易不干其他的 gas limit26. 估计交易的gas eth.estimateGas from to value 交易的接收者 20字节的值 以太坊是不会确认这个值是否为有效地址 因此交易前用户应该自己验证接收者是否有效 value 和 data---------------------------------------------------测试 每次重开dev会消掉block 最开始在metamask上发起几个交易后好久没有出块 最后在dos写了个交易 出块了 之前交易都有效 说明 可能卡了 或者交易数不够27. 普通账户到合约账户 向EOA或合约账户传递data 特殊交易： 部署合约 零地址 0x0 函数选择器 -----------------------------------------------关于和智能合约的交互 payable 表示 合约接收 调用者 给的 以太 只有合约中有这个修饰的函数才可以 接收 那么如何在调用另一个函数时也可以通过value直接给合约账户以太， 那么让这个函数被payable修饰即可 另外给合约以太的方式是在命令行里直接转 ---------------------------------------- 所以说 payable 决定了调用 一个函数的同时 是否可以给合约账户 value28. EVM 验证交易 运行环境 沙盒封装 和一般分布式系统的区别在于 效率低 保证安全 存储空间 payload evm 和 gas 消耗 每步操作之后都会消耗 gas没了就有异常 因此需要事先预估 交易失败以太不会转移 但gas肯定消耗了 ### 重点 Storage 持久化数据库 键值对 256位 注意和一般语言的map是不一样的 没法遍历key Memory 消息调用时产生 Stack 29. 指令集 256位的字 消息调用 合约调合约 委托调用 统一上下文 合约创建 EOA 创建交易至零地址 合约创建合约 不会写到链上 合约自毁 移除的唯一操作 selfdestruct30. Solidity 静态类型语言 语言特性 address数据类型 用于定位账户 payable 等关键字 使用区块链进行数据存储 强调调用方式 异常机制 原子性### 源码和智能合约 编译时产生字节码和ABI(链上合约和外部交互的接口) 交易的方式部署 产生账户### 安装 solcjs cnpm install -g solc### 字节码部署在链上 ABI 结合 web3.js 与 DApp结合使用31. remix 中函数 不同颜色的按钮说明 由于不同的关键字的修饰 函数拥有不同的权限 函数返回的是数组 自己定义的数值变量单位就不是wei了### 可以利用web3.toHex等工具函数将string类型转成十六进制字节数据32. 代币合约 缺陷是可以无限造币 # 铸币者 minter 就是发布合约的账户 # 账户映射 私有 # 构造器 指定 铸币者 # 铸币方法 require(调用者为minter) # 转币方法 实现有溢出 安全风险33. 合理的实现 ERC20 3.833. ERC20 代币合约 属性 和 初始化34. ERC20 转账方法 私有 to 不是零地址 钱够 加上不会溢出 require 和 assert的区别 授权转账 事件emit和监听------------------------------------------ 总结 三种代币合约35. Ballot 投票合约37. solidity # 源文件布局 pragma import # 值类型 布尔 整型 int uint uint8 - uint256 浮点型 fixed128x20 fixedMxN M 8-256 N 最多80 address 20字节值 定长字节数组 byte1 ..... byte32 注意转换 enum function # 引用类型 Array 定长和不定长 storage 和 memory Struct Mapping # 地址类型 address 原来合约是由address派生 v5.0后不再是38. # 地址类型成员变量和方法 测试调用只能在方法里 &lt;addresspayable&gt;.transfer(uint256amount) 给调用者钱 send 功能和tansfer相近 但不进行异常处理 返回bool 两者都默认一次2300gas call delegatecall staticcall # 字符数组 定长字符数组 属于值类型 byte1 ... byte32 不定长 有 bytes string两种 为引用类型 bytes是hex字符串 # 枚举 Enum 枚举类型应该定义在函数外 不能定义空枚举 可转换为任意整型 # Array solidity定义多维数组时和其他语言相反，低维在前 但访问时就一样了 越界访问会导致调用回退 push pop 增加新元素 和 memory storage # 数组示例-----------------------------------------------------------pure关键字的含义应该是不会改变全局属性（状态变量）定长数组还只能这样定义 uint[] memory a = new uint[](7); 不能把个数写在方括号里 bytes默认情况下是8位 40. # 结构体 不可以包含自己类型的成员 # Mapping 键类型 值类型 例 合约外部调用 注意调用者41. ## # 数据位置 函数参数默认是memory 局部变量简单的是在stack中 复杂的如数组 结构体 映射 默认在 storage中 状态变量默认在 storage中 外部函数的参数 calldata # 数据位置总结 问题 为什么引用类型的局部变量默认为storage memory类型的数组不允许push42. # 错误代码的分析 实际上根本就是 solidity引用类型的局部变量是存在storage里的43. 一份编译错误的代码 memory 和 storage 间是可以相互传值的 s(状态) = m(参数) 将m的内容复制一份给s s(局部) = s(状态) 则 拷贝引用 s 的 可变类型的数组 可以通过 length 指定长度 delete 清空 s(局部指针) = m(参数) 会产生编译错误 m(局部) = m(参数) 引用拷贝 s(状态) = s(局部) 拷贝内容 # 猜数字游戏44. # 问题 还是 函数内为初始化的storage指针变量造成的问题 会影响定义的状态变量的值 局部storage未初始化会造成严重的问题 # 一般的payable修饰是在调用时可以传value给合约 -------------------------------- # 函数声明和类型 ### 函数的值类型 外部函数 内部函数 --------------- 合约继承 is 光部署子合约 被继承的合约也会编译 但只部署自己的字节码 ### 函数的可见性 区分值类型和可见性 值类型表示的是访问的方式 状态变量默认是internal 差不多就是 protected = internal -------------------------------- # 编译有问题的代码 外部合约调用的情况，internal修饰的方法只用继承合约的子类可以调用，且必须以internal的方式调用45.# 函数的状态可变性 payable 如果在部署合约的时候就要转币 那么constructor就要设为payable view constant pure # 修改状态 如果不加view或pure，编译器就会认为这个函数是修改状态的 读取状态 # modifier 感觉和装饰器差不多 下划线 占位符 占的不包括return # 回退函数 fallback 给合约纯转账时必须有payable修饰的回退函数 # 事件 event 日志 # 异常处理 assert require revert # 单位46. web3.js # 基本原理是 rpc ----------------------------- # 安装solcjs cnpm install solc web3 cnpm install web3 注 -g命令表示全局安装 ------------------------ # 注意 每次重启 geth dev 块都会没 且先前的交易也会清零 账户回归原始状态 metamask也会同步 # 全局安装 cnpm -g install solc cnpm -g install web3--------------------------------------------------------特别注意一点 本机的全局安装 先前的cnpm hexo 都下到了C:\\Users\\Administrator\\AppData\\Roaming\\npm下 此次的solc web3都下到了 D:\\Work\\nodejs 原因不明，但这两个地方先前均已加到了环境变量中 3.947. --save-dev 在D盘的全局目录下npm list web3才看到web3的版本是1.2.6 # 创建web3实例 设置provider 暴露rpc端口 注意不能覆盖metamask 判断浏览器是否已经定义web348. # 异步回调 web3jsAPI 设计的最初目的，主要是为了和本地RPC 节点共同使用，所 以默认情况下发送的是同步HTTP 请求 如果要发送异步请求，可以在函数的最后一个参数位置上，传入一个回调 函数。回调函数是可选（optioanl）的 # 回调函数 ----------------------------------------------------------- 注，理解：异步就是需有请求-响应过程 ------------------------------------------- # 为什么要有异步 因为同步可能会有阻塞的情况，卡住 因此前端一般用异步的 # web3 1.0后所有的调用都是异步的 封装成Promise # Promise 承诺事件 promise + eventemitter = promievent # 应用二进制接口 ABI 智能合约的json接口 函数 和 事件 的对象-------------------------------------------- geth里内嵌了web3 现在要自己引入 # var Web3 = require(&#x27;web3&#x27;) ------------------------------------------- 为了保证web3可以访问到 ，在用户变量path里加上包路径，结果没用，删掉 暂时不处理这个问题，就在包路径下测试###### ######################################## var Web3 = require(&#x27;web3&#x27;) var web3 = new Web3(new Web3.providers.HttpProvider(&#x27;http://localhost:8545&#x27;)) web3.isConnected() //经测试 geth的web3还真是 0.20.1 因此在web3目录 安一个局部的0.20.1的版本50.# 批处理请求 请求排序 然后一起请求 # 大数处理 依赖库 BigNumber 对于数值，应该先转换 引入 var BigNumber = require(&#x27;bignumber.js&#x27;) BigNumber的结构 s e c 符号 阶码 var xxx = new BigNumber(&#x27;&#x27;) xxx.toString(进制) 对浮点数可能不怎么有效51.常用API # 基本信息 # 网络状态 # Provider###############################################################################基本测试命令 此处必须是http不能是https geth --datadir . --dev --rpc console var Web3 = require(&#x27;web3&#x27;) var web3 = new Web3(new Web3.providers.HttpProvider(&#x27;http://localhost:8545&#x27;)) web3.isConnected() web3.eth.net.isListening().then(console.log) web3.version.network web3.eth.net.getId().then(console.log)---------------------------------------------------- --------------------------------------------------web3到底是作为怎样的一个角色它是和geth连的，意思是 是和metamask同级的，只不过是和abi交互 它那个设置provider和metamask设置本地网络差不多 metamask和bin交互geth web3 metamask 三者都有web3对象 web3 v1.0+的核心是promise 链式调用52. # Provider 查看 web3.currentProvider 设置 web3.setProvider(new web3.providers.HttpProvider(&#x27;http://localhost:8545&#x27;)) # ws协议 # metamask会创建一个web3对象，直接注入浏览器，在除了新标签页的每个网页都可获取------------------------------------------------------------------------- # 通用工具方法 注意这些方法在v1.0+里都放到了web3.utils里 # 账户相关 实际上，上述方法在geth中也可异步调用，不过不能用箭头形式53.# 区块相关 getBlock() # 交易相关 # 交易执行相关------------------------------------------------------------------------ 调用函数的总结 同步 web3. 异步 (error,result)=&gt;&#123;console.log(result)&#125; v1.0 只允许异步 链式调用 .then(console.log) --------------------------------------------- web3的文档 3.1053. # 发送交易 data是十六进制串 因为发送交易需要gas，会消耗发送者账户的以太，所以要先解锁 而在web3 或 geth里的解锁是同步的 当然dev就不用考虑了 # 消息调用 web3.eth.call 不提交54. # 日志过滤（事件监听） var filter = web3.eth.filter(&#x27;latest&#x27;);看区块 pending看交易 filter.watch(function(error, result)&#123; if (!error) console.log(result); &#125;); 监听事件，触发回调函数 filter.stopWatching() 注：geth启动时选项关掉日志 # 合约相关 两种方式 （1）var MyContract = web3.eth.contract(abiArray); 合约的abi var contractInstance = MyContract.at(address); （2）var contractInstance = MyContract.new([constructorParam1] [, constructorParam2], &#123;data: &#x27;0x12345...&#x27;, from: myAccount, gas: 1000000&#125;); 注意 data里是合约的字节码 十六进制 要有0x前缀 需定义部署时，发送的交易，即后面这个参数 constructor是部署合约时需传的参数，可以从abi获得---------------------------------------------------------------ps:感觉看web3就是看metamask底层的实现55. # 调用合约函数 三种调用方式 （1）直接调用 （2）call 消息调用 （3）sendTransaction 发送交易调用 会更改状态或转移币的函数56. # 监听合约事件 类似于filter 合约事件在与事件对应的函数调用时触发-----------------------------------------------------------------------__________web3js 写以太坊脚本 57.直接转以太58.调用部署的代币合约 转代币 # 创建合约 abi 绑定源码 和 地址 这是已经部署的情况 # 调用send 前面的是 send的参数 后面是交易对象，即调用合约这一交易 写明from即可，to就是合约地址 # geth有不同的连接方式 ---------------------------------- 要部署必须用第二种方式 部署必须有： abi bin 获取 abi 地址 ----------------------------------------------------------- 怪现象，部署和mint没什么问题，但获取balances[]一直报错 Error: invalid address 参考 ：https://www.jianshu.com/p/98719f97032e https://blog.csdn.net/qq_31915745/article/details/84205849 先写 web3.eth.defaultAccount=web3.eth.coinbase; 不报错了，但返回是交易的hash 也不是想要的结果 原因是什么，先不想了59. 错误处理 geth 开放rpc api 使在脚本账户中可以解锁 回调地狱 在异步的情况下为了保证执行顺序，过多的回调嵌套60. 查询脚本61. 监听脚本------------------------------------------------------------------------DApp3.1162. # 环境 cnpm install web3@0.20.1 --save-dev cnpm install ganache-cli --save-dev 不--save-dev会有err # ganache相当于给你起一个geth的dev节点，而且更便捷 默认10个账户 每个都有以太 .\\node_modules\\.bin\\ganache-cli -q # 合约 ------------------------------- 注意，正是因为在不同的编译器版本下，有不同的语法限制，所以要在源码中清晰地指明 编译选项，只要过了编译就可64. # 编译合约 compiledCode，一个js对象 包括所有编译结果 # 部署合约65. # 和在remix上的部署对比 部署合约时，传入的参数 byte32 remix中强制要求0x 命令行不用 # 调用函数 投票需要写交易对象 sendTransaction 查询不用 call67. 网页交互 # 合约做后台 交互就相当于测试接口 # html # 投票js（已部署合约） -- index.html -- index.js # 因为html中已经引入了web3js，所以不用require了 # ganache每次重启后的账户都不同 环境更新68. # js的局部变量用 let定义--------------------------------------------------- # 所谓Dapp就是 通过浏览器访问，区块链上部署的合约做后端的web应用69. # node作服务器 服务器的用处是显示这个网页 node.js web模块 参考菜鸟教程 # server.js 3.12--------------工作流1. 编译脚本 保存编译结果 到json文件 ------------ 清空处理 错误处理2. 部署脚本 # 部署的必要条件 通信连接 开发时可以用ganache或dev的节点，测试时用测试网络，发布时在主网 部署的账户必须有以太 # 1.0+ 72 23:40 # 0.20.13. 测试脚本 用moche测试 # npm install mocha --save-dev --save 和 --save-dev的区别 --save时打包好后运行需要的依赖 --save-dev是开发时依赖 例如运行时需要solcjs 那么--save 而只有开发时用到ganache 和 mache 那么就--save-dev # 示例 sum.js test.js moche改写的 然后用moche直接执行 # 生命周期4. 完整工作流-----------------------------------------以太坊白皮书78.-83.------------------------------------以太坊黄皮书------原理","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://shadowbynl.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"正则表达式基础与js中应用","slug":"正则表达式基础与js中应用","date":"2020-09-29T12:15:01.000Z","updated":"2020-09-29T13:39:20.736Z","comments":true,"path":"2020/09/29/正则表达式基础与js中应用/","link":"","permalink":"https://shadowbynl.github.io/2020/09/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%E4%B8%8Ejs%E4%B8%AD%E5%BA%94%E7%94%A8/","excerpt":"","text":"练习与测试 https://regexone.com/https://regexr.com/ 正则表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272一、魅力1 传统方式找出字符串中的数字2 正则找数字二、创建1 使用正则表达式字面量1.1 /pattern/flags1.2 脚本加载后即可得到编译，如果你的表达式不是变化的，用这种方式效率更高2 使用RegExp对象2.1 new RegExp(pattern[,flags])2.2 这种方式，在运行时编译，如果事先不能确定表达式的规则，可使用此方法三、编写1 简单模式1.1 直接匹配给出的字符，如/abc/就匹配 abc2 使用特殊字符2.1 /ab*c/ 匹配一个a，后面0个或多个b，最后是c四、基础1 字符串和RegExp的方法1.1 reg.exec1.1.1 reg.exec(str) 返回匹配结果数组，不匹配则返回null，每执行一次exec就向后匹配一次1.1.2 如果表达式里有括号()，称为组匹配，返回结果中，第一个是整体匹配结果，后面依次是每个括号匹配的结果1.1.3 如果表达式中有g选项进行全局搜索，则可以多次使用 exec，下次的匹配从上次的结果后开始1.2 reg.test1.2.1 reg.test(str) 返回true/false，表示是否匹配成功1.3 str.match1.3.1 str.match(reg)，与 reg.exec相似，但是，如果使用g选项，则str.match一次性返回所有结果1.4 str.search1.4.1 str.search(reg) ，返回匹配成功的第一个位置1.5 str.replace1.5.1 str.replace(reg,newstr) ; 用第一个参数reg去匹配，用第二个参数newstr 去替换1.6 str.split1.6.1 str.split(reg[,maxLength]) 用匹配的模式切割，第二个参数是限制返回结果的最大数量2 img选项2.1 i:忽略大小写2.2 m:多行模式2.3 g:全局搜索3 次数3.1 &#123;n&#125;3.1.1 前面的字符正好n次3.2 &#123;n,m&#125;3.2.1 前面的字符至少n次,最多m次3.2.2 &#123;n,&#125;3.2.3 &#123;,m&#125; —— 错的3.3 +3.3.1 匹配前一个表达式1次或多次，等价于&#123;1,&#125;console.log(str.match(/bc+/g));3.4 ？3.4.1 匹配前一个表达式0次或1次，等价于&#123;0,1&#125;console.log(str.match(/e?le?/g));let str = &#x27;lol&#x27;; // l lstr = &#x27;elaine&#x27;; //elstr = &#x27;ele&#x27;; //elestr = &#x27;elle&#x27;; //el lestr = &#x27;leel&#x27;; //le el3.4.2 如果紧跟在任何量词 *、 +、? 或 &#123;&#125; 的后面，将会使量词变为非贪婪的，默认是贪婪的console.log(str.match(/\\d+?/)); //1 对象console.log(str.match(/\\d+?/g)); //1,2,33.5 *3.5.1 匹配前一个表达式0次或多次(有或者没有都行)，等价于&#123;0,&#125;console.log(str.match(/bc*/g));4 贪婪五、特殊字符1 \\1.1 正常字符前面如果有 \\， 表示这个字符是特殊的而不再是原来的字符含义。如：b 表示 b，但 \\b 表示单词边界1.1.1 console.log(str.match(/b/g));1.1.2 console.log(str.match(/\\bhello\\b/g));1.1.3 console.log(str.match(/\\bhello/g));1.1.4 console.log(str.match(/hello\\b/g));1.2 特殊字符前面加了 \\，则特殊字符变为普通字符，如：* 表示 0个或多个，但 \\* 就表示 星号 *1.2.1 console.log(str.match(/a*/g));1.2.2 console.log(str.match(/a\\*/g));1.3 使用 new RegExp 方式时，因其第一个参数是字符串，所以想使用 \\ 做转义时，要写 \\\\1.3.1 let reg = new RegExp(&#x27;a\\\\*&#x27;,&#x27;g&#x27;);1.4 \\b 单词边界 \\B 非边界1.5 \\d 数字 \\D 非数字1.6 \\n 换行1.7 \\r 回车1.8 \\s 匹配一个空白字符，包括空格、制表符、换页符和换行符。 \\S 非空白1.9 \\w 匹配一个单字字符（字母、数字或者下划线）。 \\W 非单字字符2 ^2.1 匹配输入的开始，如果是多行模式，则可以匹配一行的开始2.1.1 console.log(str.match(/^b/g));2.1.2 多行：console.log(oT.value.match(/^b/g));2.1.3 多行：console.log(oT.value.match(/^b/gm));2.2 当 &#x27;^&#x27; 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义，如 [^......]3 $3.1 匹配输入的结束，如果是多行模式，则可以匹配一行的结尾3.1.1 console.log(oT.value.match(/a$/g));3.1.2 console.log(oT.value.match(/a$/gm));4 .4.1 匹配除了换行以外的任意一个字符5 (x) 分组5.1 匹配x并记住，()称为捕获括号5.1.1 不加括号只匹配一个字母，加括号可以匹配一组console.log(&#x27;fredd&#x27;.match(/d+/)); //ddconsole.log(&#x27;fredfred&#x27;.match(/(fred)+/)); //fredfred5.1.2 let str = &#x27;foo bar foo bar&#x27;使用括号里的模式对目标进行匹配，并且把匹配的结果存在\\1..\\n中，在接下来的模式表达式中可以使用\\1..\\n来代替前面匹配到的结果console.log(str.match(/(foo) (bar) \\1 \\2/)); //foo bar foo barconsole.log(str.match(/(foo) (bar) (foo) (bar)/)); //foo bar foo barconsole.log(str.match(/(.)o.*\\1oo/)); //foo bar fooconsole.log(&#x27;abcabc&#x27;.match(/(.)b(.)/)); //abcconsole.log(&#x27;abcabc&#x27;.match(/(.)b(.)\\1b\\2/)); //abcabc5.1.3 replace替换时使用分组信息不再是 \\n 而是 $nconsole.log(&#x27;hello world&#x27;.replace(/(\\w+) (\\w+)/,&#x27;$2 $1&#x27;));5.1.4 分组捕获时如果再使用/g，则match操作不会捕获分组，如果必须使用/g可以使用 reg.exec(str)6 (?:x)6.1 匹配x但不记住，称为非捕获括号,因为分组只有9个6.1.1 let str = &#x27;foo&#x27;;6.1.2 console.log(str.match(/(foo)&#123;1,2&#125;/));6.1.3 console.log(str.match(/(?:foo)&#123;1,2&#125;/));7 x(?=y)7.1 匹配x并且后面必须是y8 x(?!y)8.1 匹配x并且后面必须不是y9 x|y9.1 匹配 x 或者 y10 []10.1 [xyz]10.1.1 或者，x或y或z，一个字符10.1.2 [18]:1或810.1.3 [12-89]:1或2到8或910.2 [^xyz]10.2.1 非，不是x,不是y，不是z，一个字符10.3 范围:- [0-9]，[a-z]，[a-zA-Z0-9]六、应用1 验证是否手机号2 把手机号替换成***3 匹配网页标签4 在网页标签中找出电话号码5 敏感词替换6 去首尾空格7 千位分隔参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressionshttp://javascript.ruanyifeng.com/stdlib/regexp.html*0个或多个 +一个或多个 常用正则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186一、校验数字的表达式 1. 数字：^[0-9]*$2. n位的数字：^\\d&#123;n&#125;$3. 至少n位的数字：^\\d&#123;n,&#125;$4. m-n位的数字：^\\d&#123;m,n&#125;$5. 零和非零开头的数字：^(0|[1-9][0-9]*)$6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$9. 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10. 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$12. 非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1. 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$3. 长度为3-20的所有字符：^.&#123;3,20&#125;$4. 由26个英文字母组成的字符串：^[A-Za-z]+$5. 由26个大写英文字母组成的字符串：^[A-Z]+$6. 由26个小写英文字母组成的字符串：^[a-z]+$7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$ 11. 可以输入含有^%&amp;&#x27;,;=?$\\&quot;等字符：[^%&amp;&#x27;,;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$5. 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$6. 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;7. 身份证号(15位、18位数字)：^\\d&#123;15&#125;|\\d&#123;18&#125;$ 8. 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 12. 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15. 钱的输入格式： 16. 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ 17. 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 18. 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 19. 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 20. 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 21. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 22. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 24. 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 25. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$26. 中文字符的正则表达式：[\\u4e00-\\u9fa5] 27. 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 28. 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 29. HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 30. 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 31. 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)32. 中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字)33. IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)34. IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://shadowbynl.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"基本模式与相关技术、问题","slug":"基本模式与相关技术、问题","date":"2020-09-26T06:45:09.000Z","updated":"2020-09-26T14:21:05.391Z","comments":true,"path":"2020/09/26/基本模式与相关技术、问题/","link":"","permalink":"https://shadowbynl.github.io/2020/09/26/%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E3%80%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"本篇是在基本了解过前端vue+elementui、各种模板、前端框架，学习过基于springboot的基本配置、ORM框架、统一处理等，以及中间件redis及一些数据库后，对这一系列技术如何学习、使用进行总结，算是要解决长久以来的一些不确定的问题。此外，也会对一些零碎的概念或问题进行解答。 参考 zimughttps://edu.51cto.com/course/19170.html 教程https://www.kancloud.cn/hanxt/springboot2/1776439 文档https://gitee.com/hanxt/boot-launch/tree/master/ 新版代码baizhi 一些问题的解答 一、VO PO BO DTO DOhttps://www.kancloud.cn/hanxt/springboot2/1776439https://blog.csdn.net/u011870547/article/details/81077153https://blog.csdn.net/hz_blog/article/details/8506823?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-3.nonecasehttps://blog.csdn.net/qq_41604862/article/details/79675223?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_paramhttps://blog.csdn.net/jslrjb/article/details/86597851https://blog.csdn.net/weixin_30298497/article/details/99066720?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061PO：persistent object 持久对象1 ．有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。2 ．在hibernate持久化框架中与insert/delet操作密切相关。3 ．PO中不应该包含任何对数据库的操作。POJO ：plain ordinary java object 无规则简单java对象一个中间对象，可以转化为PO、DTO、VO。1 ．POJO持久化之后==〉PO（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。）2 ．POJO传输过程中==〉DTO3 ．POJO用作表示层==〉VOPO 和VO都应该属于它。BO：business object 业务对象业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。建立一个对应简历的BO对象处理简历，每个BO包含这些PO。这样处理业务逻辑时，我们就可以针对BO去处理。封装业务逻辑为一个对象（可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用）。关于BO主要有三种概念1 、只包含业务对象的属性；2 、只包含业务方法；3 、两者都包含。在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。VO：value object 值对象 / view object 表现层对象1 ．主要对应页面显示（web页面/swt、swing界面）的数据对象。2 ．可以和表对应，也可以不，这根据业务的需要。DTO（TO）：Data Transfer Object 数据传输对象1 ．用在需要跨进程或远程传输时，它不应该包含业务逻辑。2 ．比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。DAO：data access object数据访问对象1 ．主要用来封装对DB的访问（CRUD操作）。2 ．通过接收Business层的数据，把POJO持久化为PO。 12345VO与DTO的区别大家可能会有个疑问（在笔者参与的项目中，很多程序员也有相同的疑惑）：既然DTO是展示层与服务层之间传递数据的对象，为什么还需要一个VO呢？对！对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。用一个例子来说明可能会比较容易理解：例如服务层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的DTO，不应该出现与表现形式的耦合。 二、postman一般测试方法 三、序列化与IDhttps://blog.csdn.net/wangqiang9x/article/details/84541316https://blog.csdn.net/wangqiang9x/article/details/90409507https://blog.csdn.net/liji_xc/article/details/47302455https://blog.csdn.net/liji_xc/article/details/47290695https://blog.csdn.net/u013815832/article/details/95212567?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_paramhttps://www.cnblogs.com/yansum/p/12602561.htmlhttps://www.cnblogs.com/lixuwu/p/10662339.htmlhttps://www.jianshu.com/p/d1f100cebf2ahttp://www.360doc.com/content/15/0413/20/15242507_462975436.shtmlhttps://www.csdn.net/gather_26/MtTacgwsNDI0OTktYmxvZwO0O0OO0O0O.htmlhttps://www.imooc.com/qadetail/110529?t=109890 1234567891011121314151617181920什么是序列化反序列化？Java序列化是将对象转换为字节流的过程，因此我们可以将其存储在磁盘上或通过网络发送。反序列化是相反的过程–将字节流转换为内存中的对象。序列化过程在序列化期间，java运行时将版本号与每个可序列化的类相关联,此数字称为 serialVersionUID。在反序列化期间,用于验证序列化对象的发送者和接收者是否已为该对象加载了与序列化兼容的类。如果接收者为对象加载的类serialVersionUID与相应的发送者的类不同，则反序列化将导致InvalidClassException。假设一个英国人和另一个印度人都将分别执行序列化和反序列化。在这种情况下， 为了验证在印度的接收者是经过验证的人，JVM会创建一个唯一ID，称为SerialVersionUID。在大多数情况下，序列化和反序列化这两个活动都是由具有相同系统和相同位置的单个人完成的。但是在序列化中，发送者和接收者不是同一个人，即，这些人可能不同，机器或系统可能不同，并且位置必须不同。在序列化中，发送方和接收方都应仅在开始时具有.class文件，即，要进行序列化的人和准备反序列化的人仅应在开始时包含相同的.class文件。序列化：序列化时，每个对象发送方JVM都会保存一个Unique Identifier。JVM负责根据发送方系统中存在的相应.class文件生成该唯一ID。反序列化：反序列化时，接收方JVM将与对象关联的唯一ID与本地类Unique ID进行比较，即JVM还将基于接收方系统中存在的相应.class文件创建唯一ID。如果两个唯一的ID都匹配，则将仅执行反序列化。否则，我们将获得Runtime Exception，提示InvalidClassException。这个唯一的标识符不过是SerialVersionUID。SerialVersionUID的生成：就平台和版本而言，发送者和接收者都应使用相同的JVM。否则，由于不同的SerialVersionUID，接收器无法反序列化。发送方和接收方都应使用相同的.class文件版本。序列化后，如果接收方的.class文件中有任何更改，则接收方无法反序列化。为了在内部生成SerialVersionUID，JVM可能使用复杂的算法，这可能会导致性能问题。 如何生成序列化idhttps://blog.csdn.net/aa494661239/article/details/80520418修改idea设置 一键生成四、日期处理与显示 五、TODOhttps://blog.csdn.net/carter_yu/article/details/90410540https://www.cnblogs.com/Tpf386/p/11684437.htmlhttps://blog.csdn.net/shi_hong_fei_hei/article/details/86606414https://jingyan.baidu.com/article/ff42efa9c25811c19e2202ef.htmlhttps://blog.csdn.net/qq_36205206/article/details/94723082https://www.w3cschool.cn/intellij_idea_doc/intellij_idea_doc-nx4b2dto.html 六、多表 七、增改 技术选型与学习 从数据库到前端，可以分为七个部分。一、数据库选型与相关主要是mysql redis mongodb 这几种的相关原理、命令、配置 二、ORM框架基本的jdbc、spring data系列和mybatis+mp，基本看下来其实最后写法都差不多。spring data系列是由代码生成表，mybatis+相关插件+mp是由表生成代码。需要注意的三方面，一是配置，一是多表的实现，一是分页的实现。对于mybatis，有总结的最佳使用方法。https://www.kancloud.cn/hanxt/springboot2/1177609 12mybatis，尤其涉及多表+动态，建议使用xml方式使用驼峰映射结果属性 三、统一返回数据和异常处理https://www.kancloud.cn/hanxt/springboot2/1177634https://www.kancloud.cn/hanxt/springboot2/1177635问题：分页的封装 四、视图三种方案： elementui + vue layui freemarker 五、其他框架spring cloud搜索 六、中间件等消息队列分布式文件系统nginx日志：springboot默认实现使用logback 门面使用slf4j 七、机制jwt实现权限管理文件相关 工具 hutoolshttps://hutool.cn/docs/#/https://www.bilibili.com/video/BV1bQ4y1M7d9?p=2 实验 为将这些技术进行集中搭配处理，总结可用的技术点，需要对作者代码进行测试，自行编写案例进行测试实践。先归纳一下要集成的技术点： 第一部分（通用）：统一数据处理、异常处理、日志配置、swagger、lombok 第二部分（单表ORM选择）：mybatis + mp | spring data jpa | mongodb | redis总结单表规范 第三部分（多表和分页实现策略） 第四部分（前端选型）：完全分离、layui、freemarker 第五部分：结合机制、功能点 jwt poi 第六部分：安全框架 由此，应进行的步骤： 首先是对单个点的源码进行测试，这个基本不能单独做，需要看哪check就行。 所以关键是新建一个应用，模拟一个简单场景，以此来集成各个技术。 1234模拟如下场景：一个简单的有角色权限的系统（当前先不加安全控制）因此先简单模拟一个作者--书籍--读者的关系 两两间一对多 读者和作者先不涉及系统的用户和角色概念目前先做的是这样一个关联关系集成各种技术的小案例 问题记录 一、mysql在华为云上安装mysql并连接时，又出现问题2003-can&#39;t connect to MYSQL参考 https://www.cnblogs.com/chenjw-note/p/5887908.html修改配置 把bind-address = 127.0.0.1 设置成bind-address = 0.0.0.0然后连接仍有问题，1130-host . is not allowed to connect to this MySql server,MySQL参考 https://www.cnblogs.com/liangzhihong/p/10452207.html修改mysql远程访问权限 1234567891011你想root使用mypassword从任何主机连接到mysql服务器的话。 GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;mypassword&#x27; WITH GRANT OPTION; 如果你想允许用户myuser从ip为192.168.1.3的主机连接到mysql服务器，并使用mypassword作为密码 GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;192.168.1.3&#x27; IDENTIFIED BY &#x27;mypassword&#x27; WITH GRANT OPTION; 输入命令FLUSH PRIVILEGES; 再次远程连接数据库成功。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://shadowbynl.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"sql_study_1","slug":"sql_study_1","date":"2020-08-03T08:09:57.000Z","updated":"2020-08-03T09:01:56.296Z","comments":true,"path":"2020/08/03/sql_study_1/","link":"","permalink":"https://shadowbynl.github.io/2020/08/03/sql_study_1/","excerpt":"对牛客网sql练习61道做一个简单总结","text":"对牛客网sql练习61道做一个简单总结 牛客网 https://www.nowcoder.com/practice/218ae58dfdcd4af195fff264e062138f?tpId=82&amp;rp=1&amp;ru=%2Fta%2Fsql&amp;qru=%2Fta%2Fsql%2Fquestion-ranking相关视频 https://www.bilibili.com/video/BV175411s7yr?p=6161道题，大概分为两个部分，前35道基本全是查询，后26道是一些其他语句的用法，最难写的大概在22-35这十几道。 PDF To Markdown ConverterDebug ViewResult View 查找最晚入职员工的所有信息，为了减轻入门难度，目前所有的数据里员工入职的日期都不是同一天12345678CREATE TABLE `employees` (`emp_no` int(11) NOT NULL comment &#x27;员工编号&#x27;,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 123select *from employeeswhere hire_date = (select max(hire_date) from employees); 01. 查找最晚入职员工的所有信息2020 年 5 月 18 日 8: 题目描述查找入职员工时间排名倒数第三的员工所有信息，为了减轻入门难度，目前所有的数据里员工入职的日期都不是同一天12345678CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 12345678select *from employeeswhere hire_date = (select distinct hire_datefrom employeesorder by hire_date desclimit 2,); 02.查找入职员工时间排名倒数第三的员工所有信息2020 年 5 月 18 日 8: 题目描述查找各个部门当前(to_date=’9999- 01 - 01’)领导当前薪水详情以及其对应部门编号dept_no(请注 意输出结果，dept_no列是最后一列) CREATE TABLE dept_manager ( dept_no char(4) NOT NULL comment ‘部门编号’, emp_no int(11) NOT NULL comment ‘员工编号’, from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries ( emp_no int(11) NOT NULL comment ‘员工编号’, salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select s.*, d.dept_nofrom salaries sinner join dept_manager don s.emp_no = d.emp_nowhere s.to_date=’9999- 01 - 01’and d.to_date=’9999- 01 - 01’; 03.查找各个部门当前领导当前薪水详情以及其对应部门编号dept_no2020 年 5 月 18 日 8: 题目描述查找所有已经分配部门的员工的last_name和first_name以及dept_no(请注意输出描述里各个列 的前后顺序) CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select last_name,first_name,dept_nofrom employees einner join dept_emp don e.emp_no = d.emp_no; 04.查找所有已经分配部门的员工的last_name和first_name2020 年 5 月 18 日 8: 题目描述查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括暂时没有分配具体 部门的员工(请注意输出描述里各个列的前后顺序) CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select last_name,first_name,dept_nofrom employees eleft join dept_emp don e.emp_no = d.emp_no; 注意：INNER JOIN 两边表同时有对应的数据，即任何一边缺失数据就不显示。主LEFT JOIN 从 会读取左边数据表的全部数据，即便右边表无对应数据。从RIGHT JOIN 主 会读取右边数据表的全部数据，即便左边表无对应数据。05.查找所有员工的last_name和first_name以及对应部门编号dept_no2020 年 5 月 18 日 8: 题目描述查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序(请注 意，一个员工可能有多次涨薪的情况) CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL, hire_date date NOT NULL,#入职 PRIMARY KEY (emp_no)); CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL, from_date date NOT NULL,#入职日期=from_date to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select e.emp_no, s.salaryfrom employees einner join salaries son e.emp_no = s.emp_nowhere e.hire_date = s.from_dateorder by e.emp_no desc; 06.查找所有员工入职时候的薪水情况2020 年 5 月 18 日 8: 题目描述查找薪水涨幅超过 15 次的员工号emp_no以及其对应的涨幅次数t CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select s.emp_no, count() tfrom salaries sgroup by s.emp_nohaving count() &gt; 15; 07.查找薪水涨幅超过 15 次的员工号emp_no以及其对应的涨幅次数t2020 年 5 月 18 日 8: 题目描述找出所有员工当前(to_date=’9999- 01 - 01’)具体的薪水salary情况，对于相同的薪水只显示一次, 并按照逆序显示 CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select distinct salaryfrom salaries swhere s.to_date=’9999- 01 - 01’order by salary desc; select salaryfrom salaries swhere s.to_date=’9999- 01 - 01’group by salaryorder by salary desc; 08.找出所有员工当前具体的薪水salary情况2020 年 5 月 18 日 8: 题目描述获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示 to_date=’9999- 01 - 01’CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select d.dept_no, d.emp_no, s.salaryfrom dept_manager dinner join salaries son d.emp_no = s.emp_nowhere d.to_date=’9999- 01 - 01’and s.to_date=’9999- 01 - 01’; 09.获取所有部门当前manager的当前薪水情况2020 年 5 月 18 日 8: 题目描述获取所有非manager的员工emp_no CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select emp_nofrom employeeswhere emp_no not in(select e.emp_nofrom employees einner join dept_manager don e.emp_no = d.emp_no); 10.获取所有非manager的员工emp_no2020 年 5 月 18 日 8: 题目描述获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示 to_date=’9999- 01 - 01’。 结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。 CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); select e.emp_no, m.emp_nofrom dept_emp einner join dept_manager mon e.dept_no = m.dept_nowhere e.emp_no &lt;&gt; m.emp_noand e.to_date=’9999- 01 - 01’and m.to_date=’9999- 01 - 01’; 11.获取所有员工当前的manager2020 年 5 月 18 日 8: 题目描述获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select d.dept_no, d.emp_no, max(salary)from dept_emp dinner join salaries son d.emp_no = s.emp_nowhere d.to_date = ‘9999- 01 - 01’and s.to_date = ‘9999- 01 - 01’group by d.dept_no; 12.获取所有部门中当前员工薪水最高的相关信息2020 年 5 月 18 日 8: 题目描述从titles表获取按照title进行分组，每组个数大于等于 2 ，给出title以及对应的数目t。 CREATE TABLE IF NOT EXISTS “titles” (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); select title, count() tfrom titlesgroup by titlehaving count() &gt;= 2; 13.从titles表获取按照title进行分组2020 年 5 月 18 日 8: 题目描述从titles表获取按照title进行分组，每组个数大于等于 2 ，给出title以及对应的数目t。 注意对于重复的emp_no进行忽略。 CREATE TABLE IF NOT EXISTS titles (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); select title, count(distinct emp_no) tfrom titlesgroup by titlehaving t &gt;= 2; 14.从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略2020 年 5 月 18 日 8: 题目描述12345678910查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 12345select *from employees ewhere e.emp_no &amp; 1 = 1and e.last_name != &#x27;Mary&#x27;order by e.hire_date desc; 15.查找employees表所有emp_no为奇数2020 年 5 月 18 日 8: 题目描述统计出当前各个title类型对应的员工当前（to_date=’9999- 01 - 01’）薪水对应的平均工资。结果 给出title以及平均工资avg。 CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date));CREATE TABLE IF NOT EXISTS “titles” (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); select t.title, avg(s.salary) avgfrom titles tinner join salaries son t.emp_no = s.emp_nowhere t.to_date=’9999- 01 - 01’and s.to_date=’9999- 01 - 01’group by t.title; 16.统计出当前各个title类型对应的员工当前薪水对应的平均工资2020 年 5 月 18 日 8: 题目描述获取当前（to_date=’9999- 01 - 01’）薪水第二多的员工的emp_no以及其对应的薪水salary CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select emp_no,salaryfrom salarieswhere to_date=’9999- 01 - 01’and salary = (select distinct salaryfrom salariesorder by salary desclimit 1,); 17.获取当前薪水第二多的员工的emp_no以及其对应的薪水salary2020 年 5 月 18 日 8: 题目描述查找当前薪水(to_date=’9999- 01 - 01’)排名第二多的 员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select e.emp_no, max(s.salary), e.last_name, e.first_namefrom employees einner join salaries son e.emp_no = s.emp_nowhere s.to_date = ‘9999- 01 - 01’and s.salary not in(select max(salary)from salarieswhere to_date = ‘9999- 01 - 01’); 18.查找当前薪水排名第二多的员工编号emp_no2020 年 5 月 18 日 8: 题目描述查找所有员工的last_name和first_name以及对应的dept_name， 也包括暂时没有分配部门的员工left join CREATE TABLE departments (dept_no char(4) NOT NULL,dept_name varchar(40) NOT NULL,PRIMARY KEY (dept_no)); CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select last_name,first_name,dept_namefrom employees eleft join dept_emp de on e.emp_no = de.emp_noleft join departments d on d.dept_no = de.dept_no; 19.查找所有员工的last_name和first_name以及对应的dept_name2020 年 5 月 18 日 8: 题目描述查找员工编号emp_no为 10001 其自入职以来的薪水salary涨幅值growth CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select( #最近的-刚入职的 (select salary from salaries where emp_no = 10001 order by salary desc) (select salary from salaries where emp_no = 10001 order by salary)) growth; 20.查找员工编号emp_now为 10001 其自入职以来的薪水salary涨幅值growth2020 年 5 月 18 日 8: 题目描述查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅 growth，并按照growth进行升序 CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select e.emp_no, (s1.salary -s2.salary) as growthfrom employees einner join salaries s1 on e.emp_no = s1.emp_no and s1.to_date = ‘9999- 01 - 01’#当前薪资 inner join salaries s2 on e.emp_no = s2.emp_no and e.hire_date = s2.from_date#入职薪资 order by growth asc; 21.查找所有员工自入职以来的薪水涨幅情况2020 年 5 月 18 日 8:47 题目描述统计各个部门的工资记录数，给出部门编码dept_no、部门名称dept_name以及次数sum CREATE TABLE departments (dept_no char(4) NOT NULL,dept_name varchar(40) NOT NULL,PRIMARY KEY (dept_no));CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select d.dept_no, d.dept_name,count(s.salary) ‘sum’from departments dinner join dept_emp de on d.dept_no = de.dept_noinner join salaries s on de.emp_no = s.emp_nogroup by d.dept_no; 22.统计各个部门对应员工涨幅的次数总和2020 年 5 月 18 日 8:47 题目描述对所有员工的当前(to_date=’9999- 01 - 01’)薪水按照salary进行按照 1 - N的排名， 相同salary并列且按照emp_no升序排列 CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 输出描述: emp_no salary rank 110005 94692 1 110009 94409 2 110010 94409 2 110001 88958 3 110007 88070 4 110004 74057 5 110002 72527 6 110003 43311 7 110006 43311 7 110011 25828 8 来自&lt;https://www.nowcoder.com/practice/b9068bfe5df74276bd015b9729eec4bf?tpId=82&amp;tqId=29775&amp;tPage=2&amp;rp=&amp;ru=/ta/sql&amp;qru=/ta/sql/question-ranking&gt; select s1.emp_no, s1.salary, count(distinct s2.salary) rankfrom salaries s1, salaries s2where s1.to_date=’9999- 01 - 01’and s2.to_date=’9999- 01 - 01’and s1.salary &lt;= s2.salarygroup by s1.emp_noorder by s1.salary desc,s1.emp_no asc 23.对所有员工的当前薪水按照salary进行按照 1 - N的排名2020 年 5 月 18 日 8:47 题目描述获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ， 当前表示to_date=’9999- 01 - 01’ CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 1.查询所有员工的情况2.筛选掉manager员工 select de.dept_no,e.emp_no,s.salaryfrom employees einner join salaries son e.emp_no = s.emp_no and s.to_date=’9999- 01 - 01’inner join dept_emp deon e.emp_no = de.emp_nowhere de.emp_no not in(select emp_nofrom dept_manager dmwhere dm.to_date=’9999- 01 - 01’); 24.获取所有非manager员工当前的薪水情况2020 年 5 月 18 日 8:47 题目描述获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date=’9999- 01 - 01’, 结果第一列给出员工的emp_no， 第二列给出其manager的manager_no， 第三列给出该员工当前的薪水emp_salary, 第四列给该员工对应的manager当前的薪水manager_salary CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select de.emp_no emp_no,dm.emp_no manager_no,s1.salary emp_salary,s2.salary manager_salaryfrom dept_emp de, salaries s1, dept_manager dm, salaries s2where de.emp_no = s1.emp_noand s1.to_date=’9999- 01 - 01’and de.to_date=’9999- 01 - 01’and dm.emp_no = s2.emp_noand s2.to_date=’9999- 01 - 01’and dm.to_date=’9999- 01 - 01’and de.dept_no = dm.dept_noand s1.salary &gt; s2.salary; 25.获取员工其当前的薪水比其manager当前薪水还高的相关信息2020 年 5 月 18 日 8:47 题目描述汇总各个部门当前员工的title类型的分配数目，结果给出部门编号dept_no、dept_name、其当 前员工所有的title以及该类型title对应的数目count CREATE TABLE departments (dept_no char(4) NOT NULL,dept_name varchar(40) NOT NULL,PRIMARY KEY (dept_no));CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE IF NOT EXISTS titles (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); 输出描述:dept_no dept_name title count 1d001 Marketing Senior Engineer 1 1d001 Marketing Staff 1 1d002 Finance Senior Engineer 1 1d003 Human Resources Senior Staff 1 1d004 Production Senior Engineer 2 1d005 Development Senior Staff 1 1d006 Quality Management Engineer 2 1d006 Quality Management Senior Engineer 1 来自&lt;https://www.nowcoder.com/practice/4bcb6a7d3e39423291d2f7bdbbff87f8?tpId=82&amp;tqId=29778&amp;tPage=2&amp;rp=&amp;ru=%2Fta%2Fsql&amp;qru=%2Fta%2Fsql%2Fquestion-ranking&gt; select de.dept_no,d.dept_name,t.title,count(t.title) ‘count’from dept_emp deinner join titles ton de.emp_no = t.emp_noand de.to_date=’9999- 01 - 01’and t.to_date=’9999- 01 - 01’inner join departments d 26.汇总各个部门当前员工的title类型的分配数目2020 年 5 月 18 日 8:47 inner join departments don de.dept_no = d.dept_nogroup by de.dept_no, t.title; 题目描述给出每个员工每年薪水涨幅超过 5000 的员工编号emp_no、薪水变更开始日期from_date以及薪 水涨幅值salary_growth，并按照salary_growth逆序排列。 提示：在sqlite中获取datetime时间对应的年份函数为strftime(‘%Y’, to_date) CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select s2.emp_no,s2.from_date,(s2.salary -s1.salary) salary_growthfrom salaries s1, salaries s2where s1.emp_no = s2.emp_noand salary_growth &gt; 5000and (strftime(‘%Y’, s2.to_date) -strftime(‘%Y’, s1.to_date) = 1or strftime(‘%Y’, s2.from_date) -strftime(‘%Y’, s1.from_date) = 1)order by salary_growth desc; 27.给出每个员工每年薪水涨幅超过 5000 的员工编号emp_no2020 年 5 月 18 日 8:47 题目描述film表 1字段 说明 1film_id 电影id 1title 电影名称 1description 电影描述信息 CREATE TABLE IF NOT EXISTS film ( film_id smallint(5) NOT NULL DEFAULT ‘0’, title varchar(255) NOT NULL, description text, PRIMARY KEY (film_id)); category表 1字段 说明 1category_id 电影分类id 1name 电影分类名称 1last_update 电影分类最后更新时间 CREATE TABLE category ( category_id tinyint(3) NOT NULL , name varchar(25) NOT NULL, last_update timestamp, PRIMARY KEY ( category_id )); film_category表 1字段 说明 1film_id 电影id 1category_id 电影分类id 1last_update 电影id和分类id对应关系的最后更新时间 CREATE TABLE film_category ( film_id smallint(5) NOT NULL, category_id tinyint(3) NOT NULL, last_update timestamp); 查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数 量&gt;=5部 来自&lt;https://www.nowcoder.com/practice/3a303a39cc40489b99a7e1867e6507c5?tpId=82&amp;tqId=29780&amp;tPage=2&amp;rp=&amp;ru=%2Fta%2Fsql&amp;qru=%2Fta%2Fsql%2Fquestion-ranking&gt; 28.查找描述信息中包括robot的电影对应的分类名称以及电影数目2020 年 5 月 18 日 8:47 &amp;rp=&amp;ru=%2Fta%2Fsql&amp;qru=%2Fta%2Fsql%2Fquestion-ranking&gt; 查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影 数量&gt;=5部 CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT ‘0’,title varchar(255) NOT NULL, description text, #描述信息like ‘%robot%’ PRIMARY KEY (film_id)); CREATE TABLE category (category_id tinyint(3) NOT NULL , name varchar(25) NOT NULL, last_update timestamp, #分类名称 PRIMARY KEY ( category_id )); CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, last_update timestamp); select c.name,count(fc.film_id) numfrom category cinner join film_category fcon c.category_id = fc.category_idinner join(select *from film fwhere f.description like ‘%robot%’) f_robot on f_robot.film_id = fc.film_idinner join(select *,count(fc1.film_id) num1from film_category fc1group by category_idhaving num1 &gt;= 5) f5 on f5.category_id = fc.category_id; 使用join查询方式找出没有分类的电影id以及名称 CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT ‘0’,title varchar(255) NOT NULL, description text, #描述信息like ‘%robot%’ PRIMARY KEY (film_id)); CREATE TABLE category (category_id tinyint(3) NOT NULL , name varchar(25) NOT NULL, last_update timestamp, #分类名称 PRIMARY KEY ( category_id )); CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, last_update timestamp); select f.film_id, f.titlefrom film fleft join film_category fcon f.film_id = fc.film_idwhere fc.category_id is null; 29.使用join查询方式找出没有分类的电影id以及名称2020 年 5 月 18 日 8:47 使用子查询的方式找出属于Action分类的所有电影对应的title,description CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT ‘0’,title varchar(255) NOT NULL,description text,PRIMARY KEY (film_id)); CREATE TABLE category (category_id tinyint(3) NOT NULL , name varchar(25) NOT NULL, last_update timestamp, #分类名称 PRIMARY KEY ( category_id )); CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, last_update timestamp); select f.title, f.descriptionfrom film fwhere f.film_id in(select film_idfrom film_category fcwhere fc.category_id in(select c.category_idfrom category cwhere c.name=’Action’)); 30.使用子查询的方式找出属于Action分类的所有电影对应的title,description2020 年 5 月 18 日 8:47 题目描述获取select * from employees对应的执行计划 explain select * from employees; 31.获取select2020 年 5 月 18 日 18:14 题目描述将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分 CREATE TABLE employees ( emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select last_name||’ ‘||first_name as namefrom employees; 32.将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分2020 年 5 月 18 日 18:14 题目描述创建一个actor表，包含如下列信息 列表 类型 是否为NULL 含义 actor_id smallint(5) not null主键id first_name varchar(45) not null名字 last_name varchar(45) not null姓氏 last_update timestamp not null最后更新时间，默认是系统的当前时间 create table actor(actor_id smallint(5) not null primary key,first_name varchar(45) not null,last_name varchar(45) not null,last_update timestamp not null default (datetime(‘now’,’localtime’))); 33.创建一个actor表，包含如下列信息2020 年 5 月 18 日 18:14 题目描述对于表actor批量插入如下数据 CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(‘now’,’localtime’))) actor_id first_name last_name last_update1 PENELOPE GUINESS 2006 - 02 - 15 12:34:332 NICK WAHLBERG 2006 - 02 - 15 12:34:33 insert into actorvalues (1, ‘PENELOPE’, ‘GUINESS’, ‘2006- 02 - 15 12:34:33’),(2, ‘NICK’, ‘WAHLBERG’, ‘2006- 02 - 15 12:34:33’) insert into actorselect 1,’PENELOPE’,’GUINESS’,’2006- 02 - 15 12:34:33’union select 2,’NICK’,’WAHLBERG’,’2006- 02 - 15 12:34:33’; 34.批量插入数据2020 年 5 月 18 日 18:14 题目描述对于表actor批量插入如下数据,如果数据已经存在，请忽略，不使用replace操作 CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(‘now’,’localtime’))) actor_id first_name last_name last_update‘3’ ‘ED’ ‘CHASE’’2006- 02 - 15 12:34:33’ insert or ignore into actorvalues (3,’ED’,’CHASE’,’2006- 02 - 15 12:34:33’); 35.批量插入数据,如果数据已经存在，请忽略，不使用replace操作2020 年 5 月 18 日 18:14 题目描述对于如下表actor，其对应的数据为: actor_id first_name last_name last_update1 PENELOPE GUINESS 2006 - 02 - 15 12:34:332 NICK WAHLBERG 2006 - 02 - 15 12:34:33 创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表。actor_name表 结构如下： 列表 类型 是否为NULL 含义 first_name varchar(45) not null名字 last_name varchar(45) not null姓氏 create table actor_name asselect first_name,last_name from actor; 36.创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表2020 年 5 月 18 日 18:14 题目描述针对如下表actor结构创建索引： CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(‘now’,’localtime’))) 对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname create unique index uniq_idx_firstname on actor(first_name);create index idx_lastname on actor(last_name); 37.对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname2020 年 5 月 18 日 18:14 题目描述针对actor表创建视图actor_name_view， 只包含first_name以及last_name两列， 并对这两列重新命名，first_name为first_name_v，last_name修改为last_name_v： CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(‘now’,’localtime’))) create view actor_name_view (first_name_v,last_name_v) asselect first_name, last_name from actor; 38.针对actor表创建视图actor_name_view2020 年 5 月 18 日 18:14 题目描述针对salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 使用强制索引。 CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date));create index idx_emp_no on salaries(emp_no); select *from salariesindexed by idx_emp_nowhere emp_no = 10005; MYSQL中强制索引查询使用：FORCE INDEX(indexname); SQLite中强制索引查询使用：INDEXED BY indexname; 来自https://www.nowcoder.com/profile/340487413/codeBookDetail?submissionId=36255256 SQLite中，使用 INDEXED BY 语句进行强制索引查询，可参考： http://www.runoob.com/sqlite/sqlite-indexed-by.html 11 SELECT * FROM salaries INDEXED BY idx_emp_no WHERE emp_no = 10005 MySQL中，使用 FORCE INDEX 语句进行强制索引查询，可参考： http://www.jb51.net/article/49807.htm 11 SELECT * FROM salaries FORCE INDEX idx_emp_no WHERE emp_no = 10005 来自https://www.nowcoder.com/profile/340487413/codeBookDetail?submissionId=36255256 39.针对上面的salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005,2020 年 5 月 18 日 18:14 题目描述12345678存在actor表，包含如下列信息：CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(&#x27;now&#x27;,&#x27;localtime&#x27;)));现在在last_update后面新增加一列名字为create_date, 类型为datetime, NOT NULL，默认值为&#x27;0000 00:00:00&#x27; 1alter table actor add column create_date datetime not null default &#x27;0000- 00 - 00 00:00:00&#x27;; 40.在last_update后面新增加一列名字为create_date2020 年 5 月 18 日 18:14 题目描述构造一个触发器audit_log，在向employees_test表中插入一条数据的时候，触发插入相关的数 据到audit中。 CREATE TABLE employees_test(ID INT PRIMARY KEY NOT NULL,NAME TEXT NOT NULL,AGE INT NOT NULL,ADDRESS CHAR(50),SALARY REAL);CREATE TABLE audit(EMP_no INT NOT NULL,NAME TEXT NOT NULL); create trigger audit_log after insert on employees_testbegininsert into audit values (new.ID, new.NAME);end; 41.构造一个触发器audit_log，在向employees表中插入一条数据的时候，触发插入相关的数据到audit中2020 年 5 月 18 日 18:18 题目描述删除emp_no重复的记录，只保留最小的id对应的记录。 CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); insert into titles_test values(‘1’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘2’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘3’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘4’, ‘10004’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘5’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘6’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘7’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’); 1.group by和min 找到每个emp_no中 最小的id 2.删除不是这个最小id 数据 delete from titles_testwhere id not in(select min(id)from titles_testgroup by emp_no); 42.删除emp_no重复的记录，只保留最小的id对应的记录。2020 年 5 月 18 日 18:18 题目描述将所有to_date为 9999 - 01 - 01 的全部更新为NULL,且from_date更新为 2001 - 01 - 01 。 CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); insert into titles_test values (‘1’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘2’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘3’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘4’, ‘10004’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘5’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘6’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘7’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’); update titles_test set to_date = null, from_date = ‘2001- 01 - 01’where to_date = ‘9999- 01 - 01’; 43.将所有to_date为 9999 - 01 - 01 的全部更新为NULL,且2020 年 5 月 18 日 18:18 题目描述将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用 replace实现。 CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); insert into titles_test values (‘1’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘2’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘3’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘4’, ‘10004’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘5’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘6’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘7’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’); replace into titles_test select 5,10005,title,from_date,to_datefrom titles_testwhere id = 5and emp_no = 10001; 44.将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用replace实现。2020 年 5 月 18 日 18:18 题目描述将titles_test表名修改为titles_2017。 CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); insert into titles_test values (‘1’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘2’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘3’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘4’, ‘10004’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘5’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘6’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘7’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’); alter table titles_test rename to titles_2017; 45.将titles_test表名修改为titles_20172020 年 5 月 18 日 18:19 题目描述在audit表上创建外键约束，其emp_no对应employees_test表的主键id。 CREATE TABLE employees_test(ID INT PRIMARY KEY NOT NULL,NAME TEXT NOT NULL,AGE INT NOT NULL,ADDRESS CHAR(50),SALARY REAL); CREATE TABLE audit(EMP_no INT NOT NULL,create_date datetime NOT NULL); drop table audit;create table audit(EMP_no int not null,create_date datetime NOT NULL,foreign key(EMP_no) references employees_test(ID)); 46.在audit表上创建外键约束，其emp_no对应employees_test表的主键id2020 年 5 月 18 日 18:19 题目描述存在如下的视图：create view emp_v as select * from employees where emp_no &gt;10005; 如何获取emp_v和employees有相同的数据？ CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select * from emp_v; select e.*from employees e, emp_v evwhere e.emp_no = ev.emp_no; select e.*from employees eintersect select ev.* from emp_v ev; 47.如何获取emp_v和employees有相同的数据no2020 年 5 月 18 日 18:19 题目描述将所有获取奖金的员工当前的薪水增加10%。create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL, PRIMARY KEY (emp_no,from_date)); update salaries set salary = salary * 1.1where emp_no in(select s.emp_nofrom salaries sinner join emp_bonus ebon s.emp_no = eb.emp_noand s.to_date = ‘9999- 01 - 01’); 48.将所有获取奖金的员工当前的薪水增加10%2020 年 5 月 18 日 18:19 题目描述针对库中的所有表生成select count(*)对应的SQL语句 CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 输出格式: cntsselect count() from employees;select count() from departments;select count() from dept_emp;select count() from dept_manager;select count() from salaries;select count() from titles;select count(*) from emp_bonus; select ‘select count(*) from ‘||name||’;’ cntsfrom sqlite_master where type = ‘table’; 49.针对库中的所有表生成select2020 年 5 月 18 日 18:19 题目描述将employees表中的所有员工的last_name和first_name通过(‘)连接起来。 CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 输出格式: nameFacello’GeorgiSimmel’BezalelBamford’PartoKoblick’ChirstianMaliniak’KyoichiPreusig’AnnekeZielinski’TzvetanKalloufi’SaniyaPeac’SumantPiveteau’DuangkaewSluis’Mary select last_name||”‘“||first_name namefrom employees; 50.将employees表中的所有员工的last_name和first_name通过(‘)连接起来。2020 年 5 月 18 日 18:19 题目描述查找字符串’10,A,B’ 中逗号’,’出现的次数cnt。 select (length(“10,A,B”) -length(replace(“10,A,B”,”,”,””)))/length(“,”) as cnt; 51.查找字符串’10,A,B’2020 年 5 月 18 日 18:19 题目描述获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列 CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 输出格式： first_nameChirstianTzvetanBezalelDuangkaewGeorgiKyoichiAnnekeSumantMaryPartoSaniya select first_namefrom employeesorder by substr(first_name,-2,2) asc; 52.获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列2020 年 5 月 18 日 18:19 题目描述按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及 连接出的结果employees CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); 输出格式: dept_no employeesd001 10001,10002d002 10006d003 10005d004 10003,10004d005 10007,10008,10010d006 10009,10010 select dept_no, group_concat(emp_no,”,”) employeesfrom dept_empgroup by dept_no; 53.按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees2020 年 5 月 18 日 18:19 题目描述查找排除当前最大、最小salary之后的员工的平均工资avg_salary。 CREATE TABLE salaries ( emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 输出格式: avg_salary69462.5555555556 select avg(salary) avg_salaryfrom salarieswhere to_date = ‘9999- 01 - 01’and salary not in(select max(salary)from salaries)and salary not in(select min(salary)from salaries); 54.查找排除当前最大、最小salary之后的员工的平均工资avg_salary2020 年 5 月 18 日 18:19 题目描述123456789分页查询employees表，每 5 行一页，返回第 2 页的数据CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 1公式：limit (页数-1)*每一页的数量，每一页的数量 123select *from employeeslimit (2-1)*5,5; 55.分页查询employees表，每 5 行一页，返回第 2 页的数据2020 年 5 月 18 日 18:19 题目描述获取所有员工的emp_no、部门编号dept_no以及对应的bonus类型btype和received ，没有分配 具体的员工不显示 CREATE TABLE dept_emp ( emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date));create table emp_bonus(emp_no int not null,received datetime not null,btype smallint not null); 输出格式: e.emp_no dept_no btype received10001 d001 1 2010 - 01 - 0110002 d001 2 2010 - 10 - 0110003 d004 3 2011 - 12 - 0310004 d004 1 2010 - 01 - 0110005 d00310006 d00210007 d00510008 d00510009 d00610010 d00510010 d006 select e.emp_no,de.dept_no,eb.btype,eb.receviedfrom employees einner join dept_emp deon e.emp_no = de.emp_no 56.获取所有员工的emp_no2020 年 5 月 18 日 18:19 on e.emp_no = de.emp_noleft join emp_bonus ebon e.emp_no = eb.emp_no; 题目描述使用含有关键字exists查找未分配具体部门的员工的所有信息。 CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); 输出格式: emp_no birth_date first_name last_name genderhire_date10011 1953 - 11 - 07 Mary Sluis F 1990 - 01 - 22 select *from employees ewhere not exists(select *from dept_emp dewhere de.emp_no = e.emp_no); 57.使用含有关键字exists查找未分配具体部门的员工的所有信息。2020 年 5 月 18 日 18:19 题目描述存在如下的视图：create view emp_v as select * from employees where emp_no &gt;10005;CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 获取employees中的行数据，且这些行也存在于emp_v中。注意不能使用intersect关键字。 输出格式: emp_no birth_date first_name last_name genderhire_date10006 1953 - 04 - 20 AnnekePreusigF 1989 - 06 - 0210007 1957 - 05 - 23 TzvetanZielinskiF 1989 - 02 - 1010008 1958 - 02 - 19 Saniya KalloufiM 1994 - 09 - 1510009 1952 - 04 - 19 SumantPeac F 1985 - 02 - 1810010 1963 - 06 - 01 Duangkaew Piveteau F 1989 - 08 - 2410011 1953 - 11 - 07 Mary Sluis F 1990 - 01 - 22 select * from emp_v; select e.*from employees e, emp_v evwhere e.emp_no = ev.emp_no; 58.获取employees中的行数据，且这些行也存在于emp_v中2020 年 5 月 18 日 18:19 题目描述获取有奖金的员工相关信息。CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL, PRIMARY KEY (emp_no,from_date)); 给出emp_no、first_name、last_name、奖金类型btype、对应的当前薪水情况salary以及奖金金 额bonus。bonus类型btype为 1 其奖金为薪水salary的10%，btype为 2 其奖金为薪水的20%，其他 类型均为薪水的30%。 当前薪水表示to_date=’9999- 01 - 01’ 输出格式: emp_no first_name last_name btype salary bonus10001 Georgi Facello 1 88958 8895.810002 BezalelSimmel 2 72527 14505.410003 Parto Bamford 3 43311 12993.310004 Chirstian Koblick 1 74057 7405.7 select e.emp_no, e.first_name, e.last_name, b.btype, s.salary,(case b.btypewhen 1 then s.salary0.1when 2 then s.salary0.2else s.salary*0.3end) bonusfrom employees einner join emp_bonus bon e.emp_no = b.emp_noinner join salaries son s.emp_no = e.emp_noand s.to_date=’9999- 01 - 01’; 59.获取有奖金的员工相关信息。2020 年 5 月 18 日 18:19 题目描述按照salary的累计和running_total，其中running_total为前两个员工的salary累计和，其他以此类 推。 具体结果如下Demo展示。。 CREATE TABLE salaries ( emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 输出格式: emp_no salary running_total10001 88958 8895810002 72527 16148510003 43311 20479610004 74057 27885310005 94692 37354510006 43311 41685610007 88070 50492610009 95409 60033510010 94409 69474410011 25828 720572 select s.emp_no, s.salary,(select sum(s2.salary)from salaries s2where s2.emp_no &lt;= s.emp_noand s2.to_date = ‘9999- 01 - 01’) running_totalfrom salaries swhere s.to_date = ‘9999- 01 - 01’order by s.emp_no asc; 60.统计salary的累计和running_total2020 年 5 月 18 日 18:19 题目描述对于employees表中，给出奇数行的first_name CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 输出格式: first_nameGeorgiChirstianAnnekeTzvetanSaniyaMary 题目描述错误：更改为：对first_name 先排序 后给出奇数行 select e1.first_namefrom employees e1where(select count(*)from employees e2where e1.first_name &lt;= e2.first_name) % 2 = 1; 61.对于employees表中，给出奇数行的first_name2020 年 5 月 18 日 18:19 This is a offline tool, your data stays locally and is not send to any server!Feedback &amp; Bug Reports","categories":[{"name":"记录","slug":"记录","permalink":"https://shadowbynl.github.io/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://shadowbynl.github.io/tags/sql/"}]},{"title":"Go依赖管理与Iris项目运行示例 问题与解决","slug":"Go依赖管理与Iris项目运行示例-问题与解决","date":"2020-07-14T01:23:57.000Z","updated":"2020-09-29T02:31:08.384Z","comments":true,"path":"2020/07/14/Go依赖管理与Iris项目运行示例-问题与解决/","link":"","permalink":"https://shadowbynl.github.io/2020/07/14/Go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%8EIris%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/","excerpt":"本篇先就运行fabric demo时逐步查找确定的go依赖管理的问题与解决方案进行说明，然后就运行iris web demo过程中出现的问题进行记述。","text":"本篇先就运行fabric demo时逐步查找确定的go依赖管理的问题与解决方案进行说明，然后就运行iris web demo过程中出现的问题进行记述。 首先，写一下当前最新版本使用go mod管理的配置。 安装go后，命令行命令： 12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct 常用命令 123go mod initgo getgo build Go语言之依赖管理 Go语言的依赖管理随着版本的更迭正逐渐完善起来。 依赖管理为什么需要依赖管理最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？ godepGo语言从v1.5开始开始引入vendor模式，如果项目目录下有vendor目录，那么go工具链会优先使用vendor内的包进行编译、测试等。 godep是一个通过vender模式实现的Go语言的第三方依赖管理工具，类似的还有由社区维护准官方包管理工具dep。 安装执行以下命令安装godep工具。 1go get github.com/tools/godep 基本命令安装好godep之后，在终端输入godep查看支持的所有命令。 12345678godep save 将依赖项输出并复制到Godeps.json文件中godep go 使用保存的依赖项运行go工具godep get 下载并安装具有指定依赖项的包godep path 打印依赖的GOPATH路径godep restore 在GOPATH中拉取依赖的版本godep update 更新选定的包或go版本godep diff 显示当前和以前保存的依赖项集之间的差异godep version 查看版本信息 使用godep help [command]可以看看具体命令的帮助信息。 使用godep在项目目录下执行godep save命令，会在当前项目中创建Godeps和vender两个文件夹。 其中Godeps文件夹下有一个Godeps.json的文件，里面记录了项目所依赖的包信息。 vender文件夹下是项目依赖的包的源代码文件。 vender机制Go1.5版本之后开始支持，能够控制Go语言程序编译时依赖包搜索路径的优先级。 例如查找项目的某个依赖包，首先会在项目根目录下的vender文件夹中查找，如果没有找到就会去$GOAPTH/src目录下查找。 godep开发流程 保证程序能够正常编译 执行godep save保存当前项目的所有第三方依赖的版本信息和代码 提交Godeps目录和vender目录到代码库。 如果要更新依赖的版本，可以直接修改Godeps.json文件中的对应项 go modulego module是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。 GO111MODULE要启用go module支持首先要设置环境变量GO111MODULE，通过它可以开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是auto。 GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。 GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。 GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，开启模块支持。 简单来说，设置GO111MODULE=on之后就可以使用go module了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。 使用 go module 管理依赖后会在项目根目录下生成两个文件go.mod和go.sum。 GOPROXYGo1.11之后设置GOPROXY命令为： 1export GOPROXY=https://goproxy.cn Go1.13之后GOPROXY默认值为https://proxy.golang.org，在国内是无法访问的，所以十分建议大家设置GOPROXY，这里我推荐使用goproxy.cn。 12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct go mod命令常用的go mod命令如下： 12345678go mod download 下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）go mod edit 编辑go.mod文件go mod graph 打印模块依赖图go mod init 初始化当前文件夹, 创建go.mod文件go mod tidy 增加缺少的module，删除无用的modulego mod vendor 将依赖复制到vendor下go mod verify 校验依赖go mod why 解释为什么需要依赖 go.modgo.mod文件记录了项目所有的依赖信息，其结构大致如下： 123456789101112module github.com/Q1mi/studygo/bloggergo 1.12require ( github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586 github.com/gin-gonic/gin v1.4.0 github.com/go-sql-driver/mysql v1.4.1 github.com/jmoiron/sqlx v1.2.0 github.com/satori/go.uuid v1.2.0 google.golang.org/appengine v1.6.1 // indirect) 其中， module用来定义包名 require用来定义依赖包及版本 indirect表示间接引用 依赖的版本go mod支持语义化版本号，比如go get foo@v1.2.3，也可以跟git的分支或tag，比如go get foo@master，当然也可以跟git提交哈希，比如go get foo@e3702bed2。关于依赖的版本支持以下几种格式： 12345gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7gopkg.in/vmihailenco/msgpack.v2 v2.9.1gopkg.in/yaml.v2 &lt;=v2.2.1github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3elatest replace在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。 12345replace ( golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0) go get在项目中执行go get命令可以下载依赖包，并且还可以指定下载的版本。 运行go get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号) 运行go get -u=patch将会升级到最新的修订版本 运行go get package@version将会升级到指定的版本号version 如果下载所有依赖可以使用go mod download命令。 整理依赖我们在代码中删除依赖代码后，相关的依赖库并不会在go.mod文件中自动移除。这种情况下我们可以使用go mod tidy命令更新go.mod中的依赖关系。 go mod edit格式化因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令： 12go mod edit -fmt 添加依赖项12go mod edit -require=golang.org/x/text 移除依赖项如果只是想修改go.mod文件中的内容，那么可以运行go mod edit -droprequire=package path，比如要在go.mod中移除golang.org/x/text包，可以使用如下命令： 12go mod edit -droprequire=golang.org/x/text 关于go mod edit的更多用法可以通过go help mod edit查看。 在项目中使用go module既有项目如果需要对一个已经存在的项目启用go module，可以按照以下步骤操作： 在项目目录下执行go mod init，生成一个go.mod文件。 执行go get，查找并记录当前项目的依赖，同时生成一个go.sum记录每个依赖库的版本和哈希值。 运行fabirc demo的过程 开始，即7.11晚，认为不能解决go依赖的问题，其一go get的话，速度太慢还看不到进度；直接git clone的话，也是太慢，而且依赖总是不全完全看不到完全下完的希望；按demo的步骤，说是用dep命令，但那个实际和go get差不多，区别只是针对每个项目把依赖下到项目下而不是统一的地方，这个问题折磨了近一天，想想只能科学上网，但查找后发现也不可行，设置代理也不行。。如果不能解决依赖的下载问题，用go写项目根本不可能。后来发现go在1.13版本后的使用go mod进行依赖管理，无奈之下，只能把服务器上的1.10版本换成1.13以上，然后设置代理，用go mod init生成mod文件，再go get，很快就解决了。。这下，我真的意识到，七牛造福了go开发者，https://goproxy.cn/ 只要将下载源换成七牛的这个源，用go mod管理依赖，一般依赖的下载问题不会造成困扰。但其使用还需进一步测试。 go mod管理项目测试与Iris项目运行问题解决 一、测试关于go mod的说明是，不用再把项目放在go path下了，把项目建在任意目录下，用go mod管理依赖就行了，依赖会下在gopath下的pkg下，这就和maven很像了，这就真的很nb了。找了个只有main的iris的demo随便copy到了一个目录下，go mod init 自定义项目名（注意这个名称会在mod文件首行指定这个项目的根模块名，其他引包之类的可以根据这个模块名的路径引，这是后续在运行另一个项目时发现的，这点极其重要）然后 go get 再 go build，这样就可以有exe生成了，整个过程很简单。在码云上下了go版的若依，运行也很顺利。但在运行千锋iris教程的案例时，出现了不少问题。 二、运行iris案例问题与解决1.首先，按部就班，三步骤 init get build 但在build卡住了，看一下报错，main等找不到项目其他的自定义的包。细看确实，作者是按自己gopath src下的绝对路径引的包，和我的不一样，那我这样直接运行肯定报错，于是我就要把这些引入自定义包的语句都修改才行。但我想到，如果按绝对路径引，项目换个存放目录不是又要改吗，这样麻烦根本不现实，是不是可以使用相对路径导入呢。于是我用./表示同级包引入；../表示上级包引入这样的，在goland中是感觉可以引入的，go build了一下，有个no local的报错，以下还有问题，说找不到xorm logger等包，我当时认为是go mod init没有找全依赖的缘故，于是我决定先把这几个依赖添到mod中再get看行不行（事实证明这样引包确实不行）。2.先找xorm。到github上找，看不知道为啥，这个作者把项目迁到gitea上去了，那为了搞个新版本，就用https://gitea.com/xorm/xorm 中指定的 xorm.iox/xorm 引入。都改过来后，又解决了个mysql驱动的问题：但这个mysql驱动之后还会出问题，之后再说。然后又想要解决goed/logger这个依赖没有的问题，发现github上居然没这个库。。只能找了个其他的日志库引入 https://github.com/wonderivan/logger 解决问题。综上，发现 go mod init不能保证把所有需要的依赖都引入，以上的这三个如xorm是迁移了，logger那个是没这个库，也就是说如果都正常的话都可以导入，这些特殊情况就需要特殊处理了。3.暂时感觉依赖问题都解决了。于是再次build，还是有no local加没有找到包的问题出现，意识到按.相对导入的方法应该不可行，那么究竟导入呢。无奈之下，只能全部改成自己src下的绝对路径。但build时，居然往github上找自定义包了。。这机制把我搞糊涂了。。这样也不行，那我先前运行的那个go版本的若依也不是在开发者的地方跑的，为什么运行的那么顺利。于是我查看了一下它的导包方式，它的mod文件中指定了一个根包名，比如root，这样如果在main.go中导入service包就是root/service这样。但其实我之前把根包名设为cms，导入也这样试过了，为什么不行。我想了一下，是不是编译器没有开始就设置为go mod管理的项目。于是新建了个go mod项目（注意开始我设置的代理是direct，导致打开项目时一直加载 go list -m json all，依赖还一直都是红的，查了https://studygolang.com/articles/26923?fr=sidebar 之后才发现，那个代理设置应该设置成国内的 https://goproxy.cn 这样很快就导完了这样把go mod项目建在任意路径下都可以。4.这样依赖感觉又都没问题了，包括自定义包的引入。于是go build，没问题，但运行时又报错了。关于xorm的空指针，开始我自然地想到是不是新版本与旧版本不兼容导致的，我应该把版本切换成github上的版本，于是指定旧版本，但再go get时就又出问题了，报错 123456go: cms imports cms/datasource imports github.com/go-xorm/xorm imports github.com/go-xorm/core: github.com/go-xorm/core@v0.6.3: parsing go.mod: module declares its path as: xorm.io/core but was required as: github.com/go-xorm/core 查了issue https://github.com/henrylee2cn/faygo/issues/39 后发现，这是因为github上的xorm使用的迁移后的core导致的，开发者留言说已经解决这个问题。但是我下的0.5.6报错，在其仓库首页发现这是最新版本。。但打开release发现后，最新的已经到0.7.9了。。这告诉我首页的latest不可信。然后把版本换成0.7.9，发现go get是没问题了。5.go build生成exe，闪退。然后用go run main.go看报错，又是关于xorm的空指针，这样让我想到是不是创建数据库连接时出现了问题，看了下源码，根本没有对创建连接时的err进行处理。添了个输出，发现是没有找不到数据库驱动。。我之前运行时，命令行和编译器都提示mysql驱动引入都没有使用所以报错，于是我就注释掉了，现在又放开，果然还不行，那到底该怎样引入呢。。 12345import ( _ &quot;github.com/go-sql-driver/mysql&quot; //不能忘记导入 &quot;github.com/go-xorm/xorm&quot; &quot;cms/model&quot;) 这样的方式，记住了。。 总结一下 实际开发时，新创建项目，用goland使用Go mod方式在任意目录下创建项目即可，注意代理一定设置正确。引自定义包时按自定义的根包引。若是导入别人的项目，尤其是那种没有mod的，注意可能是因为比较老了，有的依赖是不能自动添加的，可能就是找不到了，而有mod的应该一般没有问题。","categories":[{"name":"Web框架","slug":"Web框架","permalink":"https://shadowbynl.github.io/categories/Web%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shadowbynl.github.io/tags/Go/"}]},{"title":"关于java后端学习提升路线的思考与总结","slug":"关于java后端学习提升路线的思考与总结","date":"2020-07-10T08:57:36.000Z","updated":"2020-07-10T16:06:58.482Z","comments":true,"path":"2020/07/10/关于java后端学习提升路线的思考与总结/","link":"","permalink":"https://shadowbynl.github.io/2020/07/10/%E5%85%B3%E4%BA%8Ejava%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87%E8%B7%AF%E7%BA%BF%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E6%80%BB%E7%BB%93/","excerpt":"写这篇总结的原因","text":"写这篇总结的原因 在一个多月前六月初的时候，正值学校课程基本结束，课设也基本完成。课设中使用ssm、springboot写了几个最简单的后台系统，当时感觉做一个基本的后台系统很容易，想找些项目参考进一步学习却找不到合适的，当时也受困于如何不仅仅只写一个后台网站的问题。那时时间充裕，就暂时放下这些，学了一下python相关的一些技术，后来又学go。到6月20日，也就是20天前，接手了一个学院科研信息系统的项目，当时看着需要的技术栈并不复杂，在后端开发方面只要再学一下Nosql的操作方式和与前端vue的对接方式就可以了。但事实证明，我对一个后台系统的理解确实过于浅薄了。先前我写的，仅仅是一些最简单的crud而已，页面也用的jsp，其实基本没有技术含量，业务逻辑也基本没有什么，系统功能完全不能满足一个正常后台的需求。接下来，我先记述一下，我是如何逐步意识到自己的能力确实不足以完成一个一般后台的开发的： 数据操作的问题。项目要求数据源使用mongodb，实现数据库操作使用spring data那一套的，而我先前用的基本都是mysql + mybatis。之前总结过，mybatis和spring data基本是两套操作方式，所以我从jpa学起，再重新认识spring data mongodb，然后系统基本实现的话，还要考虑解决多表操作和分页查询等的实现问题。此外，在数据方面，如何加入redis缓存，或是配置双数据源（双sql或sql+nosql）等，这些都是我想要了解或需要了解的。 视图的问题。开始定的vue，但先前和这几天没有整理之前，一直搞不清这些前端框架间的关系，有的只知其名不知其使用场景，而对那些模板引擎也只是一知半解，根本没用过，这样我controller也不知道怎么写，怎样写restful的controller也是问题。后来找了一套后台模板，看了一个demo，又学了一下beetl，但还是没怎么用过。到底这些东西的区别是什么，选择哪个，怎么用，这些问题困扰了我不仅仅是这二十天，应该是从四月第一次知道freemarker这东西以来就一直让我很迷惑。 一些工具的问题。在最近二十天看别人的源码时，第一次了解mybatis-plus、lombok、swagger这些东西，感觉很神奇。总想着一开始学习开发就能按通用简洁的方式进行就好了，所以这几天又在查这些东西是怎么用的。 权限管理实现的问题。之前也写过一个spring security实现的权限系统，在那个系统中权限表实际只起描述作用。在这次的项目开发中，开始我认为实现基本的需求是简单的，但由于使用场景和几个关键细节的区别，使过程并不顺利。其一，数据源是nosql；其二，若使用vue，就是前后端完全分离，我并不了解这种情形下怎样实现和jsp类似的权限控制方式；其三，是参考其他项目时，我了解到的鉴权使用的JWT的方式，还有OAuth第三方登录等方式，这些表明实际的权限控制应当更为复杂。先前正是见的少，理解浅，致使我所做的基于自己浅薄经验的系统设计绝对是完全的不完善的。在权限控制上存在的严重问题，使我意识到自己需要先多看一看别人的通用的实现是如何的，需要使用哪些技术，绝对不能故自坐井观天。 总结一下，说到底，见的项目太少，印象里的实现过于简单，导致自己想的也太简单了。事实上，不管是一个后台系统，或是其他类型的网站，其功能性需求和非功能性需求都必须满足，系统设计必须是严谨的，采用过于简单的方式实现绝对存在严重的缺陷。因此，我进一步学习必须要做的，是参考别人通用的实现，拓展自己的认识，明白别人都在用什么，为什么用，如何用，然后逐点突破，自己测试使用，并能够融入到自己的开发中。就是这样，故自开发是很危险的，现在更应该参考别人扩充眼界。 现在，说一说这几天看了一些项目和教程后的理解 经过先前的过程，我需要理顺一下自己需要解决哪些方面的问题：一、视图对于后台系统开发，使用什么模板，使用什么前端框架（ui/js），是前后端分离使用异步请求交互还是使用模板引擎，前后端分离采用怎样的技术选型，模板引擎选用哪种；开发其他类型网站，没有模板的话，对于布局，选用何种开发方式，flex伸缩布局、流式布局还是响应式布局。而controller相应的接口又该如何设计，按照何种标准。这些问题困扰了我相当长时间。从最开始的jsp+el+jstl+jquery，到后来的模板引擎freemarker、thymeleaf、beetl，再到前后端完全分离的vue+elementui，以及其他的layui、easyui、bootstrap等框架。在参考其他项目时，这些概念逐渐进入我的视野，也使我越来越迷惑，这些东西都有什么区别，到底选哪种比较合适。我先来说一说参考后的一些简单理解 几个模板引擎和jsp都是类似的，都是前后端不分离的，可以数据和视图一起返回 vue是一个js框架，和jquery进行区分，vue操作虚拟dom，jquery操作实际dom。vue和js是一级的东西 elementui layui easyui都是前端ui框架，其中第一个可以和vue结合，而后两个都是基于jquery的 如此，如果做前后端完全分离的实现，可以有两套 vue+elementui+axios(vue推荐异步请求技术) 或是 layui/easyui+ajax。其中layui是近几年诞生的国产框架，easyui诞生较早。 显然，layui和easyui也可以直接放在后端代码中，与模板引擎结合进行开发https://gitee.com/sentsin/layui layui源码 一些参考https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=layui%E5%92%8Cvue&amp;fenlei=256&amp;oq=easyui%25E5%2592%258Clayui&amp;rsv_pq=cdfffb8100077d3a&amp;rsv_t=91e6EYl1Z9IkusNuRzbahclBaj%2FRiliadJmtiTs%2BNKXjUCe0AIZdc727b3Y&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=13&amp;rsv_sug1=11&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=t&amp;inputT=3820&amp;rsv_sug4=5300https://blog.csdn.net/qq_45174759/article/details/93634846https://bbs.csdn.net/topics/392565977https://www.zhihu.com/question/346660680 参考https://zhidao.baidu.com/question/1952982575172825628.htmlhttps://zhidao.baidu.com/question/558004864349929612.html?qbl=relate_question_4&amp;word=layui%BA%CDvue 二、数据前几篇中有相关框架总结，需要考虑的是多数据源的配置。 三、权限关于权限的概念与教程，查了很多1.JWT Json web tokenhttps://www.jianshu.com/p/576dbf44b2aehttps://www.jianshu.com/p/99a458c62aa42.OAuth2https://www.jianshu.com/p/4f5fcddb41063.RBAC 基于角色的访问控制https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=RBAC&amp;fenlei=256&amp;oq=pbft%25E7%259A%2584%25E7%25BC%25BA%25E7%2582%25B9&amp;rsv_pq=d3d78e0700280686&amp;rsv_t=34b7Km8mLHZEhHr7T8Uv9n5phA0np5%2BNF21gH2kZuUK0ramPfz0EK3XPeXc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_btype=t&amp;inputT=1720&amp;rsv_sug3=105&amp;rsv_sug1=65&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=3330https://www.cnblogs.com/niuli1987/p/9871182.html4.Spring Security Oauthhttps://www.jianshu.com/p/f6b73cd23114以我看来一方面是基于安全框架和JWT的token认证基本实现，一方面是基于安全框架和OAuth2规范的第三方登录实现。具体实现参考下面提到的两个后台系统，如何学习也在后面分析。 四、中间件之前了解了一些中间件，如redis、nginx等等，渐渐的就产生疑惑，什么是中间件，目前常见的中间件有哪些，各有什么使用场景。查了一些，并没有专门的博客介绍，只能根据一个教程https://www.bilibili.com/video/BV1XZ4y1x7FW?from=search&amp;seid=16936818641223030662 的内容分析。消息中间件rabbitmqhttps://baike.baidu.com/item/rabbitmq/9372144?fr=aladdinkafkahttps://baike.baidu.com/item/Kafka/17930165?fr=aladdin负载均衡 nginx缓存redis数据库中间件 mycat分布式相关dubbo 开源分布式服务框架https://baike.baidu.com/item/Dubbo/18907815?fr=aladdinfastdfs 轻量级分布式文件系统https://www.jianshu.com/p/b7c330a87855https://baike.baidu.com/item/fastdfs/5609710?fr=aladdinzookeeperhttps://baike.baidu.com/item/zookeeper/4836397?fr=aladdin搜索相关 分析一下两个后台系统 security 和 ruoyi这两个系统作为后台系统，基本功能是差不多的，但在具体实现技术、项目结构等上都有区别，不过有一些功能的实现是类似的。 SpringBoot Spring Security JWT redis Swagger 整合这个系统让我初次意识到一个springboot开发的后台系统需要哪些功能，实际的权限控制应该如何实现，这个项目的代码虽然有些繁琐，但解决了我先前的不少问题，且是用spring security实现安全控制的，也比较符合我的需求，因此先把这个项目的实现要点看了一遍，以下进行总结。 结合spring security和JWT实现的token机制，可选择性地将token存入redis或mysql中。其中JWT的构造和过期与刷新机制需要注意。 关于ajax请求，全局配置与跨域请求配置。 关于页面，使用layui框架。表单校验使用bootstrapValidator.min.js插件，分页使用datatables分页插件，菜单显示要注意分级关系的实现，给角色赋权的页面使用了ztree菜单树，日期laydate，弹出框layer。 字典管理。即系统中一些常量的配置。使用场景：表单中的下拉选择内容，列表的一些属性显示。 文件上传：注意springboot的jar打包决定了系统保存文件的路径必须是一个绝对路径，不能是项目的相对路径。而想要访问上传的文件，就需要给这个硬盘绝对路径配置一个url的映射。在上传文件前，先根据文件md5加密后的值与文件表中的id（文件md5后其对应记录id）进行比对，判断是否已存在决定是否再上传。 富文本：实现的一个关键点是，需要同时上传文件。公告管理中，统计公告的已读人员，显示用户未读公告数目的逻辑需要注意。 日志：一方面是日志记录，即保存系统的运行日志在文件中，一方面是系统的日志管理功能，该功能主要是查看某个用户在某个时间进行了某个模块的操作。这样的功能是通过自定义注解进行AOP拦截实现的，比较巧妙。 定时任务：首先数据库表中以qrtz开头的都是需要的默认表。新增一个定时任务，需要指定其cron表达式来确定执行规则，在系统中的bean所有的方法中进行选择定时执行。 邮件：注意配置以及富文本邮件的发送。 excel导出：依赖poi，根据select查询系统数据，获取指定字段的数据记录进行导出，注意验证sql正确性和生成excel的逻辑。 代码生成：一个看起来强大但也限制明显的功能。可以根据数据库表自动生成对应实体类、各层类甚至crud界面，可以直接copy进代码，再通过添加菜单将相关功能添到系统中。限制是暂时只能是单表操作，但也足够强大。实现的关键是使用模板进行替换。 swagger接口：三个依赖，在类、方法、参数等级别上添加注解分别指定其含义，这样系统就可以自动生成对应的接口文档。https://www.jianshu.com/p/349e130e40d5 若依若依的功能其实和上面这个后台功能差不多，但近两三年开发出来后，生态造的太好了，各种文档、拓展都有，美中不足是若依的权限管理使用的是shiro。 总结看了上面这两个后台系统的功能后，我认识到我先前认知的后台有些过于简单了，不能应付实际需求，因此还应参考这两个系统的设计思想。 相关资料 第一个系统，只有bilibili的视频和github源码，并没有详细的文档。教程 https://www.bilibili.com/video/av795700580源码 https://github.com/freeMak/boot-security.git 若依，是码云开源的项目，文档、拓展丰富，视频得花钱买。。bi7.6还有，现在7.10就没了，幸亏下载下来了文档 http://doc.ruoyi.vip/ruoyi/document/xmjs.html#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84源码 https://gitee.com/y_project/RuoYi 接下来就整理一下需要学哪些方面和如何进行吧 一、权限控制首先是需要搞清JWT和OAuth那些如何结合spring security实现，然后再根据需要学学shiro。1.spring security相关的参考黑马的教程https://www.bilibili.com/video/BV1WJ411W7wT/?spm_id_from=333.788.videocard.3https://www.bilibili.com/video/BV1VE411h7aL/?spm_id_from=333.788.videocard.4 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465UP黑马程序员置顶完整的JAVA中级程序员全面学习路线教程爱学习的小伙伴们加油了！欢迎评论 点赞 转发！Java基础：av80585971数据库Mysql：av68811608Oracle：av81386804JDBC：av68736927C3P0：av73840600前端技术HTML、CSS、Javascript：av73840600jQuery-：av37976701Ajax：av15657082 av15866060Vue：av76249419微信小程序：av73342655 av40455083动态网页：av73840600编程强化JVM优化：av70549061数据结构算法：av83826038 av78639604软件项目管理Maven： av52364221SVN：av73840600 av7959491Git：av75718460Jenkins：av83089670热门技术框架SSM：av7770852Mybatis-Plus ：av69233006Spring Data：av71980390Spring：av70828462分布式架构Dubbo、Zookeeper：av74933720SpringCloud：av77085442 av89898642Eureka：av74127911Skywalking：av80349807服务器中间件RocketMQ：av66702383Kafka：av71991051Sharding-JDBC：av68736927Redis：av76235738MongoDB：av80450883服务器技术Tomcat：av67233983Linux系统：av73840600CentOS、Virtualbox：av23360560Ubuntu、Vmware：av14184325容器技术Docker：av69121091业务解决方案（实战项目）Elasticsearch：av66600360Lucene：av77895717Quartz：av36062910Elastic-Job：av74128695SpringSecurity：av74851468Activiti：av7670054 字母哥的教程和书https://www.bilibili.com/video/BV16J41127jq/?spm_id_from=333.788.videocard.1https://github.com/hanxt/bootsecuritybasichttps://www.kancloud.cn/hanxt/springsecurity 需要买。。系列博客https://blog.csdn.net/yuanlaijike/category_9283872.html2.如果需要学shiro 看up编程不良人的 二、java新特性黑马https://www.bilibili.com/video/bv1kt4y1y7d1/字母哥https://www.bilibili.com/video/BV1sE411P7C1 三、项目十次方https://www.bilibili.com/video/BV1HE411M7G8/?spm_id_from=333.788.videocard.5 未下载租房https://www.bilibili.com/video/BV11J411C7HY?from=search&amp;seid=14421220897827985663 四、前端（优先分离，再模板引擎）vue就参照百知了教程 https://space.bilibili.com/352224540 https://www.bilibili.com/video/BV1SE411H7CY https://www.bilibili.com/video/BV1p54y1B7Aa https://www.bilibili.com/video/BV1NK4y187XH https://www.bilibili.com/video/BV1Nt4y127Jh资料 http://www.baizhiedu.xin/front/index#/main目的是先学会vue与后端结合开发的基本用法 五、工具与组件1.lombokhttps://www.bilibili.com/video/BV1gg4y1v7Mi2.swaggerhttps://www.bilibili.com/video/BV1BA411v7BT3.mybatis-plushttps://www.bilibili.com/video/BV1pK411W7Hu4.redishttps://www.bilibili.com/video/BV1jD4y1Q7tU5.nginx6.RabbitMQhttps://www.bilibili.com/video/BV1dE411K7MG7.Lucenehttps://www.bilibili.com/video/BV1PE41157NT8.elasticsearchhttps://www.bilibili.com/video/BV1FK4y1x7Dr 六、mysql练习与强化主要是sql语句、表关系、特性等。牛客练习sqlhttps://www.bilibili.com/video/BV175411s7yr/?spm_id_from=333.788.videocard.2在线练习：https://www.nowcoder.com/ta/sqlgithub：https://github.com/ljz756245026/sql-test-niukewang其他教程https://www.bilibili.com/video/BV1DE411n7fU/?spm_id_from=333.788.videocard.0https://www.bilibili.com/video/BV1H5411475W文字音频材料必知必会实战45讲 七、goweb与区块链1.iris框架2.fabric相关教程华为云https://www.bilibili.com/video/BV1pE411Y7DJ?p=2孔壹学院https://www.bilibili.com/video/BV13E411u7Pjhttps://www.bilibili.com/video/BV1a4411X7Z1如何运行github上面的学籍项目https://www.bilibili.com/video/BV1V7411t79W?from=search&amp;seid=275682470572440048Hyperledger Fabric 1.4-关键概念https://www.bilibili.com/video/BV1a4411P7fC?from=search&amp;seid=275682470572440048学历征信系统https://www.bilibili.com/video/BV1pE411t7KH?p=123.仓库https://gitee.com/thats_not_all_right/kongyixueyuan?_from=gitee_searchhttps://gitee.com/dddkyi/Education?_from=gitee_search4.主要参考百度云下载的资料。。","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"https://shadowbynl.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"go-study-5","slug":"go-study-5","date":"2020-07-02T15:38:16.000Z","updated":"2020-07-14T02:35:32.807Z","comments":true,"path":"2020/07/02/go-study-5/","link":"","permalink":"https://shadowbynl.github.io/2020/07/02/go-study-5/","excerpt":"Go基础学习其五","text":"Go基础学习其五 2020.6.30-7.1 学习了go的time包和文件操作相关的内容。 笔记 time包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package mainimport ( &quot;time&quot; &quot;fmt&quot; &quot;math/rand&quot;)func main() &#123; /* time包： 1年=365天，day 1天=24小时，hour 1小时=60分钟，minute 1分钟=60秒，second 1秒钟=1000毫秒，millisecond 1毫秒=1000微秒，microsecond--&gt;μs 1微秒=1000纳秒，nanosecond--&gt;ns 1纳秒=1000皮秒，picosecond--&gt;ps */ //1.获取当前的时间 t1 := time.Now() fmt.Printf(&quot;%T\\n&quot;,t1) fmt.Println(t1) //2019-06-26 10:46:40.349196 +0800 CST m=+0.000495846 //2.获取指定的时间 t2 := time.Date(2008,7,15,16,30,28,0,time.Local) fmt.Println(t2) //2008-07-15 16:30:28 +0800 CST //3.time--&gt;string之间的转换 /* t1.Format(&quot;格式模板&quot;)--&gt;string 模板的日期必须是固定：06-1-2-3-4-5 */ s1 := t1.Format(&quot;2006-1-2 15:04:05&quot;) fmt.Println(s1) s2 := t1.Format(&quot;2006/01/02&quot;) fmt.Println(s2) //string--&gt;time /* time.Parse(&quot;模板&quot;,str)--&gt;time,err */ s3 := &quot;1999年10月10日&quot;//string t3 ,err := time.Parse(&quot;2006年01月02日&quot;,s3) if err != nil&#123; fmt.Println(&quot;err:&quot;,err) &#125; fmt.Println(t3) fmt.Printf(&quot;%T\\n&quot;,t3) fmt.Println(t1.String()) //4.根据当前时间，获取指定的内容 year,month,day := t1.Date() //年，月，日 fmt.Println(year,month,day) hour,min,sec := t1.Clock() fmt.Println(hour,min,sec) //时，分，秒 year2 := t1.Year() fmt.Println(&quot;年：&quot;,year2) fmt.Println(t1.YearDay()) month2 := t1.Month() fmt.Println(&quot;月：&quot;,month2) fmt.Println(&quot;日：&quot;,t1.Day()) fmt.Println(&quot;时：&quot;,t1.Hour()) fmt.Println(&quot;分钟：&quot;,t1.Minute()) fmt.Println(&quot;秒：&quot;,t1.Second()) fmt.Println(&quot;纳秒：&quot;,t1.Nanosecond()) fmt.Println(t1.Weekday()) //Wednesday //5.时间戳：指定的日期，距离1970年1月1日0点0时0分0秒的时间差值：秒，纳秒 t4 := time.Date(1970,1,1,1,0,0,0,time.UTC) timeStamp1:=t4.Unix() //秒的差值 fmt.Println(timeStamp1) timeStamp2 := t1.Unix() fmt.Println(timeStamp2) timeStamp3 := t4.UnixNano() fmt.Println(timeStamp3) //3600 000 000 000 timeStamp4 := t1.UnixNano() fmt.Println(timeStamp4) //6.时间间隔 t5 := t1.Add(time.Minute) fmt.Println(t1) fmt.Println(t5) fmt.Println(t1.Add(24 * time.Hour)) t6 := t1.AddDate(1,0,0) fmt.Println(t6) d1 := t5.Sub(t1) fmt.Println(d1) //7.睡眠 time.Sleep(3 *time.Second) //让当前的程序进入睡眠状态 fmt.Println(&quot;main。。。over。。。。。&quot;) //睡眠[1-10]的随机秒数 rand.Seed(time.Now().UnixNano()) randNum := rand.Intn(10) + 1 //int fmt.Println(randNum) time.Sleep(time.Duration(randNum)*time.Second) fmt.Println(&quot;睡醒了。。&quot;)&#125; 一、File文件操作首先，file类是在os包中的，封装了底层的文件描述符和相关信息，同时封装了Read和Write的实现。 1、FileInfo接口FileInfo接口中定义了File信息相关的方法。 12345678type FileInfo interface &#123; Name() string // base name of the file 文件名.扩展名 aa.txt Size() int64 // 文件大小，字节数 12540 Mode() FileMode // 文件权限 -rw-rw-rw- ModTime() time.Time // 修改时间 2018-04-13 16:30:53 +0800 CST IsDir() bool // 是否文件夹 Sys() interface&#123;&#125; // 基础数据源接口(can return nil)&#125; 2、权限至于操作权限perm，除非创建文件时才需要指定，不需要创建新文件时可以将其设定为０。虽然go语言给perm权限设定了很多的常量，但是习惯上也可以直接使用数字，如0666(具体含义和Unix系统的一致)。 权限控制： 123456789101112131415161718192021linux 下有2种文件权限表示方式，即“符号表示”和“八进制表示”。（1）符号表示方式:- --- --- ---type owner group others文件的权限是这样子分配的 读 写 可执行 分别对应的是 r w x 如果没有那一个权限，用 - 代替(-文件 d目录 |连接符号)例如：-rwxr-xr-x（2）八进制表示方式： r ——&gt; 004w ——&gt; 002x ——&gt; 001- ——&gt; 00007550777055504440666 3、打开模式文件打开模式： 12345678910const ( O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件 O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件 O_RDWR int = syscall.O_RDWR // 读写模式打开文件 O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部 O_CREATE int = syscall.O_CREAT // 如果不存在将创建一个新文件 O_EXCL int = syscall.O_EXCL // 和O_CREATE配合使用，文件必须不存在 O_SYNC int = syscall.O_SYNC // 打开文件用于同步I/O O_TRUNC int = syscall.O_TRUNC // 如果可能，打开时清空文件) 4、File操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051type File//File代表一个打开的文件对象。func Create(name string) (file *File, err error)//Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于I/O；对应的文件描述符具有O_RDWR模式。如果出错，错误底层类型是*PathError。func Open(name string) (file *File, err error)//Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。func OpenFile(name string, flag int, perm FileMode) (file *File, err error)//OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。func NewFile(fd uintptr, name string) *File//NewFile使用给出的Unix文件描述符和名称创建一个文件。func Pipe() (r *File, w *File, err error)//Pipe返回一对关联的文件对象。从r的读取将返回写入w的数据。本函数会返回两个文件对象和可能的错误。func (f *File) Name() string//Name方法返回（提供给Open/Create等方法的）文件名称。func (f *File) Stat() (fi FileInfo, err error)//Stat返回描述文件f的FileInfo类型值。如果出错，错误底层类型是*PathError。func (f *File) Fd() uintptr//Fd返回与文件f对应的整数类型的Unix文件描述符。func (f *File) Chdir() error//Chdir将当前工作目录修改为f，f必须是一个目录。如果出错，错误底层类型是*PathError。func (f *File) Chmod(mode FileMode) error//Chmod修改文件的模式。如果出错，错误底层类型是*PathError。func (f *File) Chown(uid, gid int) error//Chown修改文件的用户ID和组ID。如果出错，错误底层类型是*PathError。func (f *File) Close() error//Close关闭文件f，使文件不能用于读写。它返回可能出现的错误。func (f *File) Readdir(n int) (fi []FileInfo, err error)//Readdir读取目录f的内容，返回一个有n个成员的[]FileInfo，这些FileInfo是被Lstat返回的，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。如果n&gt;0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。如果n&lt;=0，Readdir函数返回目录中剩余所有文件对象的FileInfo构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的FileInfo构成的切片和该错误。func (f *File) Readdirnames(n int) (names []string, err error)//Readdir读取目录f的内容，返回一个有n个成员的[]string，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。如果n&gt;0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。如果n&lt;=0，Readdir函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。func (f *File) Truncate(size int64) error//Truncate改变文件的大小，它不会改变I/O的当前位置。 如果截断文件，多出的部分就会被丢弃。如果出错，错误底层类型是*PathError。 5、示例代码文件信息：FileInfo 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;os&quot; &quot;fmt&quot;)func main() &#123; /* FileInfo：文件信息 interface Name()，文件名 Size()，文件大小，字节为单位 IsDir()，是否是目录 ModTime()，修改时间 Mode()，权限 */ fileInfo,err := os.Stat(&quot;/Users/ruby/Documents/pro/a/aa.txt&quot;) if err != nil&#123; fmt.Println(&quot;err :&quot;,err) return &#125; fmt.Printf(&quot;%T\\n&quot;,fileInfo) //文件名 fmt.Println(fileInfo.Name()) //文件大小 fmt.Println(fileInfo.Size()) //是否是目录 fmt.Println(fileInfo.IsDir()) //IsDirectory //修改时间 fmt.Println(fileInfo.ModTime()) //权限 fmt.Println(fileInfo.Mode()) //-rw-r--r--&#125; 运行结果： 文件操作实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package mainimport ( &quot;fmt&quot; &quot;path/filepath&quot; &quot;path&quot; &quot;os&quot;)func main() &#123; /* 文件操作： 1.路径： 相对路径：relative ab.txt 相对于当前工程 绝对路径：absolute /Users/ruby/Documents/pro/a/aa.txt .当前目录 ..上一层 2.创建文件夹，如果文件夹存在，创建失败 os.MkDir()，创建一层 os.MkDirAll()，可以创建多层 3.创建文件，Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件） os.Create()，创建文件 4.打开文件：让当前的程序，和指定的文件之间建立一个连接 os.Open(filename) os.OpenFile(filename,mode,perm) 5.关闭文件：程序和文件之间的链接断开。 file.Close() 5.删除文件或目录：慎用，慎用，再慎用 os.Remove()，删除文件和空目录 os.RemoveAll()，删除所有 */ //1.路径 fileName1:=&quot;/Users/ruby/Documents/pro/a/aa.txt&quot; fileName2:=&quot;bb.txt&quot; fmt.Println(filepath.IsAbs(fileName1)) //true fmt.Println(filepath.IsAbs(fileName2)) //false fmt.Println(filepath.Abs(fileName1)) fmt.Println(filepath.Abs(fileName2)) // /Users/ruby/go/src/l_file/bb.txt fmt.Println(&quot;获取父目录：&quot;,path.Join(fileName1,&quot;..&quot;)) //2.创建目录 //err := os.Mkdir(&quot;/Users/ruby/Documents/pro/a/bb&quot;,os.ModePerm) //if err != nil&#123; // fmt.Println(&quot;err:&quot;,err) // return //&#125; //fmt.Println(&quot;文件夹创建成功。。&quot;) //err :=os.MkdirAll(&quot;/Users/ruby/Documents/pro/a/cc/dd/ee&quot;,os.ModePerm) //if err != nil&#123; // fmt.Println(&quot;err:&quot;,err) // return //&#125; //fmt.Println(&quot;多层文件夹创建成功&quot;) //3.创建文件:Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件） //file1,err :=os.Create(&quot;/Users/ruby/Documents/pro/a/ab.txt&quot;) //if err != nil&#123; // fmt.Println(&quot;err：&quot;,err) // return //&#125; //fmt.Println(file1) //file2,err := os.Create(fileName2)//创建相对路径的文件，是以当前工程为参照的 //if err != nil&#123; // fmt.Println(&quot;err :&quot;,err) // return //&#125; //fmt.Println(file2) //4.打开文件： //file3 ,err := os.Open(fileName1) //只读的 //if err != nil&#123; // fmt.Println(&quot;err:&quot;,err) // return //&#125; //fmt.Println(file3) /* 第一个参数：文件名称 第二个参数：文件的打开方式 const ( // Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified. O_RDONLY int = syscall.O_RDONLY // open the file read-only. O_WRONLY int = syscall.O_WRONLY // open the file write-only. O_RDWR int = syscall.O_RDWR // open the file read-write. // The remaining values may be or&#x27;ed in to control behavior. O_APPEND int = syscall.O_APPEND // append data to the file when writing. O_CREATE int = syscall.O_CREAT // create a new file if none exists. O_EXCL int = syscall.O_EXCL // used with O_CREATE, file must not exist. O_SYNC int = syscall.O_SYNC // open for synchronous I/O. O_TRUNC int = syscall.O_TRUNC // truncate regular writable file when opened. ) 第三个参数：文件的权限：文件不存在创建文件，需要指定权限 */ //file4,err := os.OpenFile(fileName1,os.O_RDONLY|os.O_WRONLY,os.ModePerm) //if err != nil&#123; // fmt.Println(&quot;err:&quot;,err) // return //&#125; //fmt.Println(file4) //5关闭文件， //file4.Close() //6.删除文件或文件夹： //删除文件 //err := os.Remove(&quot;/Users/ruby/Documents/pro/a/aa.txt&quot;) //if err != nil&#123; // fmt.Println(&quot;err:&quot;,err) // return //&#125; //fmt.Println(&quot;删除文件成功。。&quot;) //删除目录 err := os.RemoveAll(&quot;/Users/ruby/Documents/pro/a/cc&quot;) if err != nil&#123; fmt.Println(&quot;err:&quot;,err) return &#125; fmt.Println(&quot;删除目录成功。。&quot;)&#125; 二、I/O操作I/O操作也叫输入输出操作。其中I是指Input，O是指Output，用于读或者写数据的，有些语言中也叫流操作，是指数据通信的通道。 Golang 标准库对 IO 的抽象非常精巧，各个组件可以随意组合，可以作为接口设计的典范。 1、io包io包中提供I/O原始操作的一系列接口。它主要包装了一些已有的实现，如 os 包中的那些，并将这些抽象成为实用性的功能和一些其他相关的接口。 由于这些接口和原始的操作以不同的实现包装了低级操作，客户不应假定它们对于并行执行是安全的。 在io包中最重要的是两个接口：Reader和Writer接口，首先来介绍这两个接口． Reader接口的定义，Read()方法用于读取数据。 123type Reader interface &#123; Read(p []byte) (n int, err error)&#125; 1234567Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的错误。即使 Read 返回的 n &lt; len(p)，它也会在调用过程中使用 p的全部作为暂存空间。若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的东西，而不是等待更多。当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或 EOF 情况，它就会返回读取的字节数。它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（和 n == 0）。这种一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，可能的返回不是 err == EOF 就是 err == nil。无论如何，下一个 Read 都应当返回 0, EOF。调用者应当总在考虑到错误 err 前处理 n &gt; 0 的字节。这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理I/O错误。Read 的实现会阻止返回零字节的计数和一个 nil 错误，调用者应将这种情况视作空操作。 Writer接口的定义，Write()方法用于写出数据。 123type Writer interface &#123; Write(p []byte) (n int, err error)&#125; 1Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的n &lt; len(p)，它就必须返回一个非nil的错误。Write 不能修改此切片的数据，即便它是临时的。 Seeker接口的定义，封装了基本的 Seek 方法。 123type Seeker interface &#123; Seek(offset int64, whence int) (int64, error)&#125; 12345678Seeker 用来移动数据的读写指针Seek 设置下一次读写操作的指针位置，每次的读写操作都是从指针位置开始的whence 的含义： 如果 whence 为 0：表示从数据的开头开始移动指针 如果 whence 为 1：表示从数据的当前指针位置开始移动指针 如果 whence 为 2：表示从数据的尾部开始移动指针offset 是指针移动的偏移量 返回移动后的指针位置和移动过程中遇到的任何错误 ReaderFrom接口的定义，封装了基本的 ReadFrom 方法。 123type ReaderFrom interface &#123; ReadFrom(r Reader) (n int64, err error)&#125; 1234ReadFrom 从 r 中读取数据到对象的数据流中 直到 r 返回 EOF 或 r 出现读取错误为止 返回值 n 是读取的字节数 返回值 err 就是 r 的返回值 err WriterTo接口的定义，封装了基本的 WriteTo 方法。 123type WriterTo interface &#123; WriteTo(w Writer) (n int64, err error)&#125; 1234WriterTo 将对象的数据流写入到 w 中 直到对象的数据流全部写入完毕或遇到写入错误为止 返回值 n 是写入的字节数 返回值 err 就是 w 的返回值 err 定义ReaderAt接口，ReaderAt 接口封装了基本的 ReadAt 方法 123type ReaderAt interface &#123; ReadAt(p []byte, off int64) (n int, err error)&#125; 12345678910111213ReadAt 从对象数据流的 off 处读出数据到 p 中 忽略数据的读写指针，从数据的起始位置偏移 off 处开始读取 如果对象的数据流只有部分可用，不足以填满 p 则 ReadAt 将等待所有数据可用之后，继续向 p 中写入 直到将 p 填满后再返回 在这点上 ReadAt 要比 Read 更严格 返回读取的字节数 n 和读取时遇到的错误 如果 n &lt; len(p)，则需要返回一个 err 值来说明 为什么没有将 p 填满（比如 EOF） 如果 n = len(p)，而且对象的数据没有全部读完，则 err 将返回 nil 如果 n = len(p)，而且对象的数据刚好全部读完，则 err 将返回 EOF 或者 nil（不确定） 定义WriterAt接口，WriterAt 接口封装了基本的 WriteAt 方法 123type WriterAt interface &#123; WriteAt(p []byte, off int64) (n int, err error)&#125; 12345WriteAt 将 p 中的数据写入到对象数据流的 off 处 忽略数据的读写指针，从数据的起始位置偏移 off 处开始写入 返回写入的字节数和写入时遇到的错误 如果 n &lt; len(p)，则必须返回一个 err 值来说明 为什么没有将 p 完全写入 其他。。。 2、文件读写file类是在os包中的，封装了底层的文件描述符和相关信息，同时封装了Read和Write的实现。 12345678910111213141516171819202122func (f *File) Read(b []byte) (n int, err error)//Read方法从f中读取最多len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取0个字节且返回值err为io.EOF。func (f *File) ReadAt(b []byte, off int64) (n int, err error)//ReadAt从指定的位置（相对于文件开始位置）读取len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。当n&lt;len(b)时，本方法总是会返回错误；如果是因为到达文件结尾，返回值err会是io.EOF。func (f *File) Write(b []byte) (n int, err error)//Write向文件中写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。func (f *File) WriteString(s string) (ret int, err error)//WriteString类似Write，但接受一个字符串参数。func (f *File) WriteAt(b []byte, off int64) (n int, err error)//WriteAt在指定的位置（相对于文件开始位置）写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。func (f *File) Seek(offset int64, whence int) (ret int64, err error)//Seek设置下一次读/写的位置。offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。func (f *File) Sync() (err error)//Sync递交文件的当前内容进行稳定的存储。一般来说，这表示将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存。 3、实例代码读取文件中的数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( &quot;os&quot; &quot;fmt&quot; &quot;io&quot;)func main() &#123; /* 读取数据： Reader接口： Read(p []byte)(n int, error) */ //读取本地aa.txt文件中的数据 //step1：打开文件 fileName := &quot;/Users/ruby/Documents/pro/a/aa.txt&quot; file,err := os.Open(fileName) if err != nil&#123; fmt.Println(&quot;err:&quot;,err) return &#125; //step3：关闭文件 defer file.Close() //step2：读取数据 bs := make([]byte,4,4) /* //第一次读取 n,err :=file.Read(bs) fmt.Println(err) //&lt;nil&gt; fmt.Println(n) //4 fmt.Println(bs) //[97 98 99 100] fmt.Println(string(bs)) //abcd //第二次读取 n,err = file.Read(bs) fmt.Println(err)//&lt;nil&gt; fmt.Println(n)//4 fmt.Println(bs) //[101 102 103 104] fmt.Println(string(bs)) //efgh //第三次读取 n,err = file.Read(bs) fmt.Println(err) //&lt;nil&gt; fmt.Println(n) //2 fmt.Println(bs) //[105 106 103 104] fmt.Println(string(bs)) //ijgh //第四次读取 n,err = file.Read(bs) fmt.Println(err) //EOF fmt.Println(n) //0 */ n := -1 for&#123; n,err = file.Read(bs) if n == 0 || err == io.EOF&#123; fmt.Println(&quot;读取到了文件的末尾，结束读取操作。。&quot;) break &#125; fmt.Println(string(bs[:n])) &#125;&#125; 写出数据到本地文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( &quot;os&quot; &quot;fmt&quot; &quot;log&quot;)func main() &#123; /* 写出数据： */ fileName := &quot;/Users/ruby/Documents/pro/a/ab.txt&quot; //step1：打开文件 //step2：写出数据 //step3：关闭文件 //file,err := os.Open(fileName) file,err := os.OpenFile(fileName,os.O_CREATE|os.O_WRONLY|os.O_APPEND,os.ModePerm) if err != nil&#123; fmt.Println(err) return &#125; defer file.Close() //写出数据 //bs :=[]byte&#123;65,66,67,68,69,70&#125;//A,B,C,D,E,F bs :=[] byte&#123;97,98,99,100&#125; //a,b,c,d //n,err := file.Write(bs) n,err := file.Write(bs[:2]) fmt.Println(n) HandleErr(err) file.WriteString(&quot;\\n&quot;) //直接写出字符串 n,err = file.WriteString(&quot;HelloWorld&quot;) fmt.Println(n) HandleErr(err) file.WriteString(&quot;\\n&quot;) n,err =file.Write([]byte(&quot;today&quot;)) fmt.Println(n) HandleErr(err)&#125;func HandleErr(err error)&#123; if err != nil&#123; log.Fatal(err) &#125;&#125; 三、文件复制在io包中主要是操作流的一些方法，今天主要学习一下copy。就是把一个文件复制到另一个目录下。 它的原理就是通过程序，从源文件读取文件中的数据，在写出到目标文件里。 1、方法一：io包下的Read()和Write()方法实现我们可以通过io包下的Read()和Write()方法，边读边写，就能够实现文件的复制。这个方法是按块读取文件，块的大小也会影响到程序的性能。 123456789101112131415161718192021222324252627282930313233343536&#125;/*该函数的功能：实现文件的拷贝，返回值是拷贝的总数量(字节),错误 */func copyFile1(srcFile,destFile string)(int,error)&#123; file1,err:=os.Open(srcFile) if err != nil&#123; return 0,err &#125; file2,err:=os.OpenFile(destFile,os.O_WRONLY|os.O_CREATE,os.ModePerm) if err !=nil&#123; return 0,err &#125; defer file1.Close() defer file2.Close() //拷贝数据 bs := make([]byte,1024,1024) n :=-1//读取的数据量 total := 0 for &#123; n,err = file1.Read(bs) if err == io.EOF || n == 0&#123; fmt.Println(&quot;拷贝完毕。。&quot;) break &#125;else if err !=nil&#123; fmt.Println(&quot;报错了。。。&quot;) return total,err &#125; total += n file2.Write(bs[:n]) &#125; return total,nil&#125; 2、方法二：io包下的Copy()方法实现我们也可以直接使用io包下的Copy()方法。 示例代码如下： 123456789101112131415func copyFile2(srcFile, destFile string)(int64,error)&#123; file1,err:=os.Open(srcFile) if err != nil&#123; return 0,err &#125; file2,err:=os.OpenFile(destFile,os.O_WRONLY|os.O_CREATE,os.ModePerm) if err !=nil&#123; return 0,err &#125; defer file1.Close() defer file2.Close() return io.Copy(file2,file1)&#125; 扩展内容：在io包（golang 版本 1.12）中，不止提供了Copy()方法，还有另外2个公开的copy方法：CopyN()，CopyBuffer()。 1234567Copy（dst,src） 为复制src 全部到 dst 中。CopyN(dst,src,n) 为复制src 中 n 个字节到 dst。CopyBuffer（dst,src,buf）为指定一个buf缓存区，以这个大小完全复制。 他们的关系如下： (图片来自网络) 从图可以看出，无论是哪个copy方法最终都是由copyBuffer（）这个私有方法实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) &#123; // If the reader has a WriteTo method, use it to do the copy. // Avoids an allocation and a copy. if wt, ok := src.(WriterTo); ok &#123; return wt.WriteTo(dst) &#125; // Similarly, if the writer has a ReadFrom method, use it to do the copy. if rt, ok := dst.(ReaderFrom); ok &#123; return rt.ReadFrom(src) &#125; if buf == nil &#123; size := 32 * 1024 if l, ok := src.(*LimitedReader); ok &amp;&amp; int64(size) &gt; l.N &#123; if l.N &lt; 1 &#123; size = 1 &#125; else &#123; size = int(l.N) &#125; &#125; buf = make([]byte, size) &#125; for &#123; nr, er := src.Read(buf) if nr &gt; 0 &#123; nw, ew := dst.Write(buf[0:nr]) if nw &gt; 0 &#123; written += int64(nw) &#125; if ew != nil &#123; err = ew break &#125; if nr != nw &#123; err = ErrShortWrite break &#125; &#125; if er != nil &#123; if er != EOF &#123; err = er &#125; break &#125; &#125; return written, err&#125; 从这部分代码可以看出，复制主要分为3种。 1.如果被复制的Reader（src）会尝试能否断言成writerTo，如果可以则直接调用下面的writerTo方法 2.如果 Writer（dst） 会尝试能否断言成ReadFrom ，如果可以则直接调用下面的readfrom方法 3.如果都木有实现，则调用底层read实现复制。 其中，有这么一段代码： 123456789101112if buf == nil &#123; size := 32 * 1024 if l, ok := src.(*LimitedReader); ok &amp;&amp; int64(size) &gt; l.N &#123; if l.N &lt; 1 &#123; size = 1 &#125; else &#123; size = int(l.N) &#125; &#125; buf = make([]byte, size) &#125; 这部分主要是实现了对Copy和CopyN的处理。通过上面的调用关系图，我们看出CopyN在调用后，会把Reader转成LimiteReader。 区别是如果Copy，直接建立一个缓存区默认大小为 32* 1024 的buf，如果是CopyN 会先判断 要复制的字节数，如果小于默认大小，会创建一个等于要复制字节数的buf。 3、方法三：ioutil包第三种方法是使用ioutil包中的 ioutil.WriteFile()和 ioutil.ReadFile()，但由于使用一次性读取文件，再一次性写入文件的方式，所以该方法不适用于大文件，容易内存溢出。 示例代码： 123456789101112131415161718func copyFile3(srcFile, destFile string)(int,error)&#123; input, err := ioutil.ReadFile(srcFile) if err != nil &#123; fmt.Println(err) return 0,err &#125; err = ioutil.WriteFile(destFile, input, 0644) if err != nil &#123; fmt.Println(&quot;操作失败：&quot;, destFile) fmt.Println(err) return 0,err &#125; return len(input),nil&#125; 4、总结最后，我们来测试一下这3种拷贝需要花费时间，拷贝的文件都是一样的一个mp4文件(400M)， 代码： 123456789101112131415func main() &#123; /* 复制文件： */ //srcFile := &quot;/home/ruby/文档/pro/aa.txt&quot; //destFile := &quot;/home/ruby/文档/aa.txt&quot; srcFile :=&quot;/Users/ruby/Documents/pro/a/001_小程序入门.mp4&quot; destFile:=&quot;001_小程序入门.mp4&quot; total,err:=copyFile1(srcFile,destFile) fmt.Println(err) fmt.Println(total)&#125; 第一种：io包下Read()和Write()直接读写：我们自己创建读取数据的切片的大小，直接影响性能。 1234567891011localhost:l_file ruby$ time go run demo05_copy.go 拷贝完毕。。&lt;nil&gt;401386819real 0m7.911suser 0m2.900ssys 0m7.661s 第二种：io包下Copy()方法： 12345678910localhost:l_file ruby$ time go run demo05_copy.go &lt;nil&gt;401386819real 0m1.594suser 0m0.533ssys 0m1.136s 第三种：ioutil包 123456789localhost:l_file ruby$ time go run demo05_copy.go &lt;nil&gt;401386819real 0m1.515suser 0m0.339ssys 0m0.625s 运行结果： 这3种方式，在性能上，不管是还是io.Copy()还是ioutil包，性能都是还不错的。 四、断点续传1、Seeker接口Seeker是包装基本Seek方法的接口。 1234type Seeker interface &#123; Seek(offset int64, whence int) (int64, error)&#125; seek(offset,whence),设置指针光标的位置，随机读写文件： 第一个参数：偏移量 第二个参数：如何设置 0：seekStart表示相对于文件开始， 1：seekCurrent表示相对于当前偏移量， 2：seek end表示相对于结束。123456const ( SeekStart = 0 // seek relative to the origin of the file SeekCurrent = 1 // seek relative to the current offset SeekEnd = 2 // seek relative to the end) 示例代码： 我们要读取本地/Users/ruby/Documents/pro/a 目录下的aa.txt文件，文件中的内容是：abcdefghij这几个字符。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( &quot;os&quot; &quot;fmt&quot; &quot;io&quot;)func main() &#123; /* seek(offset,whence),设置指针光标的位置 第一个参数：偏移量 第二个参数：如何设置 0：seekStart表示相对于文件开始， 1：seekCurrent表示相对于当前偏移量， 2：seek end表示相对于结束。 const ( SeekStart = 0 // seek relative to the origin of the file SeekCurrent = 1 // seek relative to the current offset SeekEnd = 2 // seek relative to the end) 随机读取文件： 可以设置指针光标的位置 */ file,_:=os.OpenFile(&quot;/Users/ruby/Documents/pro/a/aa.txt&quot;,os.O_RDWR,0) defer file.Close() bs :=[]byte&#123;0&#125; file.Read(bs) fmt.Println(string(bs)) file.Seek(4,io.SeekStart) file.Read(bs) fmt.Println(string(bs)) file.Seek(2,0) //也是SeekStart file.Read(bs) fmt.Println(string(bs)) file.Seek(3,io.SeekCurrent) file.Read(bs) fmt.Println(string(bs)) file.Seek(0,io.SeekEnd) file.WriteString(&quot;ABC&quot;)&#125; 运行结果： 本地文件： 2、断点续传首先思考几个问题Q1：如果你要传的文件，比较大，那么是否有方法可以缩短耗时？Q2：如果在文件传递过程中，程序因各种原因被迫中断了，那么下次再重启时，文件是否还需要重头开始？Q3：传递文件的时候，支持暂停和恢复么？即使这两个操作分布在程序进程被杀前后。 通过断点续传可以实现，不同的语言有不同的实现方式。我们看看Go语言中，通过Seek()方法如何实现： 先说一下思路：想实现断点续传，主要就是记住上一次已经传递了多少数据，那我们可以创建一个临时文件，记录已经传递的数据量，当恢复传递的时候，先从临时文件中读取上次已经传递的数据量，然后通过Seek()方法，设置到该读和该写的位置，再继续传递数据。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot; &quot;io&quot;)func main() &#123; /* 断点续传： 文件传递：文件复制 /Users/ruby/Documents/pro/a/guliang.jpeg 复制到 guliang4.jpeg 思路： 边复制，边记录复制的总量 */ srcFile:=&quot;/Users/ruby/Documents/pro/a/guliang.jpeg&quot; destFile:=&quot;guliang4.jpeg&quot; tempFile:=destFile+&quot;temp.txt&quot; //fmt.Println(tempFile) file1,_:=os.Open(srcFile) file2,_:=os.OpenFile(destFile,os.O_CREATE|os.O_WRONLY,os.ModePerm) file3,_:=os.OpenFile(tempFile,os.O_CREATE|os.O_RDWR,os.ModePerm) defer file1.Close() defer file2.Close() //1.读取临时文件中的数据，根据seek file3.Seek(0,io.SeekStart) bs:=make([]byte,100,100) n1,err:=file3.Read(bs) fmt.Println(n1) countStr:=string(bs[:n1]) fmt.Println(countStr) //count,_:=strconv.Atoi(countStr) count,_:=strconv.ParseInt(countStr,10,64) fmt.Println(count) //2. 设置读，写的偏移量 file1.Seek(count,0) file2.Seek(count,0) data:=make([]byte,1024,1024) n2:=-1// 读取的数据量 n3:=-1//写出的数据量 total :=int(count)//读取的总量 for&#123; //3.读取数据 n2,err=file1.Read(data) if err ==io.EOF&#123; fmt.Println(&quot;文件复制完毕。。&quot;) file3.Close() os.Remove(tempFile) break &#125; //将数据写入到目标文件 n3,_=file2.Write(data[:n2]) total += n3 //将复制总量，存储到临时文件中 file3.Seek(0,io.SeekStart) file3.WriteString(strconv.Itoa(total)) //假装断电 //if total&gt;8000&#123; // panic(&quot;假装断电了。。。，假装的。。。&quot;) //&#125; &#125;&#125; 五、bufio包 @author：韩茹版权所有：北京千锋互联科技有限公司 生命不止，继续Go go go。。 Go语言在io操作中，还提供了一个bufio的包，使用这个包可以大幅提高文件读写的效率。 1、bufio包原理bufio 是通过缓冲来提高效率。 io操作本身的效率并不低，低的是频繁的访问本地磁盘的文件。所以bufio就提供了缓冲区(分配一块内存)，读和写都先在缓冲区中，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。 简单的说就是，把文件读取进缓冲（内存）之后再读取的时候就可以避免文件系统的io 从而提高速度。同理，在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。看完以上解释有人可能会表示困惑了，直接把 内容-&gt;文件 和 内容-&gt;缓冲-&gt;文件相比， 缓冲区好像没有起到作用嘛。其实缓冲区的设计是为了存储多次的写入，最后一口气把缓冲区内容写入文件。 bufio 封装了io.Reader或io.Writer接口对象，并创建另一个也实现了该接口的对象。 io.Reader或io.Writer 接口实现read() 和 write() 方法，对于实现这个接口的对象都是可以使用这两个方法的。 Reader对象 bufio.Reader 是bufio中对io.Reader 的封装 12345678910// Reader implements buffering for an io.Reader object.type Reader struct &#123; buf []byte rd io.Reader // reader provided by the client r, w int // buf read and write positions err error lastByte int // last byte read for UnreadByte; -1 means invalid lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid&#125; bufio.Read(p []byte) 相当于读取大小len(p)的内容，思路如下： 当缓存区有内容的时，将缓存区内容全部填入p并清空缓存区 当缓存区没有内容的时候且len(p)&gt;len(buf),即要读取的内容比缓存区还要大，直接去文件读取即可 当缓存区没有内容的时候且len(p)&lt;len(buf),即要读取的内容比缓存区小，缓存区从文件读取内容充满缓存区，并将p填满（此时缓存区有剩余内容） 以后再次读取时缓存区有内容，将缓存区内容全部填入p并清空缓存区（此时和情况1一样） 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Read reads data into p.// It returns the number of bytes read into p.// The bytes are taken from at most one Read on the underlying Reader,// hence n may be less than len(p).// To read exactly len(p) bytes, use io.ReadFull(b, p).// At EOF, the count will be zero and err will be io.EOF.func (b *Reader) Read(p []byte) (n int, err error) &#123; n = len(p) if n == 0 &#123; return 0, b.readErr() &#125; if b.r == b.w &#123; if b.err != nil &#123; return 0, b.readErr() &#125; if len(p) &gt;= len(b.buf) &#123; // Large read, empty buffer. // Read directly into p to avoid copy. n, b.err = b.rd.Read(p) if n &lt; 0 &#123; panic(errNegativeRead) &#125; if n &gt; 0 &#123; b.lastByte = int(p[n-1]) b.lastRuneSize = -1 &#125; return n, b.readErr() &#125; // One read. // Do not use b.fill, which will loop. b.r = 0 b.w = 0 n, b.err = b.rd.Read(b.buf) if n &lt; 0 &#123; panic(errNegativeRead) &#125; if n == 0 &#123; return 0, b.readErr() &#125; b.w += n &#125; // copy as much as we can n = copy(p, b.buf[b.r:b.w]) b.r += n b.lastByte = int(b.buf[b.r-1]) b.lastRuneSize = -1 return n, nil&#125; 说明： reader内部通过维护一个r, w 即读入和写入的位置索引来判断是否缓存区内容被全部读出。 Writer对象 bufio.Writer 是bufio中对io.Writer 的封装 12345678910111213// Writer implements buffering for an io.Writer object.// If an error occurs writing to a Writer, no more data will be// accepted and all subsequent writes, and Flush, will return the error.// After all data has been written, the client should call the// Flush method to guarantee all data has been forwarded to// the underlying io.Writer.type Writer struct &#123; err error buf []byte n int wr io.Writer&#125; bufio.Write(p []byte) 的思路如下 判断buf中可用容量是否可以放下 p 如果能放下，直接把p拼接到buf后面，即把内容放到缓冲区 如果缓冲区的可用容量不足以放下，且此时缓冲区是空的，直接把p写入文件即可 如果缓冲区的可用容量不足以放下，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区 判断p的剩余内容大小能否放到缓冲区，如果能放下（此时和步骤1情况一样）则把内容放到缓冲区 如果p的剩余内容依旧大于缓冲区，（注意此时缓冲区是空的，情况和步骤3一样）则把p的剩余内容直接写入文件 以下是源码 1234567891011121314151617181920212223242526272829// Write writes the contents of p into the buffer.// It returns the number of bytes written.// If nn &lt; len(p), it also returns an error explaining// why the write is short.func (b *Writer) Write(p []byte) (nn int, err error) &#123; for len(p) &gt; b.Available() &amp;&amp; b.err == nil &#123; var n int if b.Buffered() == 0 &#123; // Large write, empty buffer. // Write directly from p to avoid copy. n, b.err = b.wr.Write(p) &#125; else &#123; n = copy(b.buf[b.n:], p) b.n += n b.Flush() &#125; nn += n p = p[n:] &#125; if b.err != nil &#123; return nn, b.err &#125; n := copy(b.buf[b.n:], p) b.n += n nn += n return nn, nil&#125; 说明： b.wr 存储的是一个io.writer对象，实现了Write()的接口，所以可以使用b.wr.Write(p) 将p的内容写入文件。 b.flush() 会将缓存区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush()到文件。 b.Available() 为buf可用容量，等于len(buf) - n。 下图解释的是其中一种情况，即缓存区有内容，剩余p大于缓存区 2、bufio包bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I/O的帮助函数的对象。 bufio.Reader： bufio.Reader 实现了如下接口： io.Reader io.WriterTo io.ByteScanner io.RuneScanner 1234567891011121314151617181920212223242526272829303132333435// NewReaderSize 将 rd 封装成一个带缓存的 bufio.Reader 对象，// 缓存大小由 size 指定（如果小于 16 则会被设置为 16）。// 如果 rd 的基类型就是有足够缓存的 bufio.Reader 类型，则直接将// rd 转换为基类型返回。func NewReaderSize(rd io.Reader, size int) *Reader// NewReader 相当于 NewReaderSize(rd, 4096)func NewReader(rd io.Reader) *Reader// Peek 返回缓存的一个切片，该切片引用缓存中前 n 个字节的数据，// 该操作不会将数据读出，只是引用，引用的数据在下一次读取操作之// 前是有效的。如果切片长度小于 n，则返回一个错误信息说明原因。// 如果 n 大于缓存的总大小，则返回 ErrBufferFull。func (b *Reader) Peek(n int) ([]byte, error)// Read 从 b 中读出数据到 p 中，返回读出的字节数和遇到的错误。// 如果缓存不为空，则只能读出缓存中的数据，不会从底层 io.Reader// 中提取数据，如果缓存为空，则：// 1、len(p) &gt;= 缓存大小，则跳过缓存，直接从底层 io.Reader 中读// 出到 p 中。// 2、len(p) &lt; 缓存大小，则先将数据从底层 io.Reader 中读取到缓存// 中，再从缓存读取到 p 中。func (b *Reader) Read(p []byte) (n int, err error)// Buffered 返回缓存中未读取的数据的长度。func (b *Reader) Buffered() int// ReadBytes 功能同 ReadSlice，只不过返回的是缓存的拷贝。func (b *Reader) ReadBytes(delim byte) (line []byte, err error)// ReadString 功能同 ReadBytes，只不过返回的是字符串。func (b *Reader) ReadString(delim byte) (line string, err error)... bufio.Writer： bufio.Writer 实现了如下接口： io.Writer io.ReaderFrom io.ByteWriter 123456789101112131415161718192021222324252627282930// NewWriterSize 将 wr 封装成一个带缓存的 bufio.Writer 对象，// 缓存大小由 size 指定（如果小于 4096 则会被设置为 4096）。// 如果 wr 的基类型就是有足够缓存的 bufio.Writer 类型，则直接将// wr 转换为基类型返回。func NewWriterSize(wr io.Writer, size int) *Writer// NewWriter 相当于 NewWriterSize(wr, 4096)func NewWriter(wr io.Writer) *Writer// WriteString 功能同 Write，只不过写入的是字符串func (b *Writer) WriteString(s string) (int, error)// WriteRune 向 b 写入 r 的 UTF-8 编码，返回 r 的编码长度。func (b *Writer) WriteRune(r rune) (size int, err error)// Flush 将缓存中的数据提交到底层的 io.Writer 中func (b *Writer) Flush() error// Available 返回缓存中未使用的空间的长度func (b *Writer) Available() int// Buffered 返回缓存中未提交的数据的长度func (b *Writer) Buffered() int// Reset 将 b 的底层 Writer 重新指定为 w，同时丢弃缓存中的所有数据，复位// 所有标记和错误信息。相当于创建了一个新的 bufio.Writer。func (b *Writer) Reset(w io.Writer)... 3、实例代码读取数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package mainimport ( &quot;os&quot; &quot;fmt&quot; &quot;bufio&quot;)func main() &#123; /* bufio:高效io读写 buffer缓存 io：input/output 将io包下的Reader，Write对象进行包装，带缓存的包装，提高读写的效率 ReadBytes() ReadString() ReadLine() */ fileName:=&quot;/Users/ruby/Documents/pro/a/english.txt&quot; file,err := os.Open(fileName) if err != nil&#123; fmt.Println(err) return &#125; defer file.Close() //创建Reader对象 //b1 := bufio.NewReader(file) //1.Read()，高效读取 //p := make([]byte,1024) //n1,err := b1.Read(p) //fmt.Println(n1) //fmt.Println(string(p[:n1])) //2.ReadLine() //data,flag,err := b1.ReadLine() //fmt.Println(flag) //fmt.Println(err) //fmt.Println(data) //fmt.Println(string(data)) //3.ReadString() // s1,err :=b1.ReadString(&#x27;\\n&#x27;) // fmt.Println(err) // fmt.Println(s1) // // s1,err = b1.ReadString(&#x27;\\n&#x27;) // fmt.Println(err) // fmt.Println(s1) // //s1,err = b1.ReadString(&#x27;\\n&#x27;) //fmt.Println(err) //fmt.Println(s1) // //for&#123; // s1,err := b1.ReadString(&#x27;\\n&#x27;) // if err == io.EOF&#123; // fmt.Println(&quot;读取完毕。。&quot;) // break // &#125; // fmt.Println(s1) //&#125; //4.ReadBytes() //data,err :=b1.ReadBytes(&#x27;\\n&#x27;) //fmt.Println(err) //fmt.Println(string(data)) //Scanner //s2 := &quot;&quot; //fmt.Scanln(&amp;s2) //fmt.Println(s2) b2 := bufio.NewReader(os.Stdin) s2, _ := b2.ReadString(&#x27;\\n&#x27;) fmt.Println(s2)&#125; 本地文件：english.txt文件内容： 写数据示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( &quot;os&quot; &quot;fmt&quot; &quot;bufio&quot;)func main() &#123; /* bufio:高效io读写 buffer缓存 io：input/output 将io包下的Reader，Write对象进行包装，带缓存的包装，提高读写的效率 func (b *Writer) Write(p []byte) (nn int, err error) func (b *Writer) WriteByte(c byte) error func (b *Writer) WriteRune(r rune) (size int, err error) func (b *Writer) WriteString(s string) (int, error) */ fileName := &quot;/Users/ruby/Documents/pro/a/cc.txt&quot; file,err := os.OpenFile(fileName,os.O_CREATE|os.O_WRONLY,os.ModePerm) if err != nil&#123; fmt.Println(err) return &#125; defer file.Close() w1 := bufio.NewWriter(file) //n,err := w1.WriteString(&quot;helloworld&quot;) //fmt.Println(err) //fmt.Println(n) //w1.Flush() //刷新缓冲区 for i:=1;i&lt;=1000;i++&#123; w1.WriteString(fmt.Sprintf(&quot;%d:hello&quot;,i)) &#125; w1.Flush()&#125; 六、ioutil包除了io包可以读写数据，Go语言中还提供了一个辅助的工具包就是ioutil，里面的方法虽然不多，但是都还蛮好用的。 12import &quot;io/ioutil&quot; 该包的介绍只有一句话：Package ioutil implements some I/O utility functions。 1、ioutil包的方法下面我们来看一下里面的方法： 1234567891011121314151617181920212223242526272829303132333435// Discard 是一个 io.Writer 接口，调用它的 Write 方法将不做任何事情// 并且始终成功返回。var Discard io.Writer = devNull(0)// ReadAll 读取 r 中的所有数据，返回读取的数据和遇到的错误。// 如果读取成功，则 err 返回 nil，而不是 EOF，因为 ReadAll 定义为读取// 所有数据，所以不会把 EOF 当做错误处理。func ReadAll(r io.Reader) ([]byte, error)// ReadFile 读取文件中的所有数据，返回读取的数据和遇到的错误。// 如果读取成功，则 err 返回 nil，而不是 EOFfunc ReadFile(filename string) ([]byte, error)// WriteFile 向文件中写入数据，写入前会清空文件。// 如果文件不存在，则会以指定的权限创建该文件。// 返回遇到的错误。func WriteFile(filename string, data []byte, perm os.FileMode) error// ReadDir 读取指定目录中的所有目录和文件（不包括子目录）。// 返回读取到的文件信息列表和遇到的错误，列表是经过排序的。func ReadDir(dirname string) ([]os.FileInfo, error)// NopCloser 将 r 包装为一个 ReadCloser 类型，但 Close 方法不做任何事情。func NopCloser(r io.Reader) io.ReadCloser// TempFile 在 dir 目录中创建一个以 prefix 为前缀的临时文件，并将其以读// 写模式打开。返回创建的文件对象和遇到的错误。// 如果 dir 为空，则在默认的临时目录中创建文件（参见 os.TempDir），多次// 调用会创建不同的临时文件，调用者可以通过 f.Name() 获取文件的完整路径。// 调用本函数所创建的临时文件，应该由调用者自己删除。func TempFile(dir, prefix string) (f *os.File, err error)// TempDir 功能同 TempFile，只不过创建的是目录，返回目录的完整路径。func TempDir(dir, prefix string) (name string, err error) 2、示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( &quot;io/ioutil&quot; &quot;fmt&quot; &quot;os&quot;)func main() &#123; /* ioutil包： ReadFile() WriteFile() ReadDir() .. */ //1.读取文件中的所有的数据 //fileName1 := &quot;/Users/ruby/Documents/pro/a/aa.txt&quot; //data, err := ioutil.ReadFile(fileName1) //fmt.Println(err) //fmt.Println(string(data)) //2.写出数据 //fileName2:=&quot;/Users/ruby/Documents/pro/a/bbb.txt&quot; //s1:=&quot;helloworld面朝大海春暖花开&quot; //err:=ioutil.WriteFile(fileName2,[]byte(s1),0777) //fmt.Println(err) //3. //s2:=&quot;qwertyuiopsdfghjklzxcvbnm&quot; //r1:=strings.NewReader(s2) //data,_:=ioutil.ReadAll(r1) //fmt.Println(data) //4.ReadDir(),读取一个目录下的子内容：子文件和子目录，但是仅有一层 //dirName:=&quot;/Users/ruby/Documents/pro/a&quot; //fileInfos,_:=ioutil.ReadDir(dirName) //fmt.Println(len(fileInfos)) //for i:=0;i&lt;len(fileInfos);i++&#123; // //fmt.Printf(&quot;%T\\n&quot;,fileInfos[i]) // fmt.Println(i,fileInfos[i].Name(),fileInfos[i].IsDir()) // //&#125; // 5.创建临时目录 dir, err := ioutil.TempDir(&quot;/Users/ruby/Documents/pro/a&quot;, &quot;Test&quot;) if err != nil &#123; fmt.Println(err) &#125; defer os.Remove(dir) // 用完删除 fmt.Printf(&quot;%s\\n&quot;, dir) // 创建临时文件 f, err := ioutil.TempFile(dir, &quot;Test&quot;) if err != nil &#123; fmt.Println(err) &#125; defer os.Remove(f.Name()) // 用完删除 fmt.Printf(&quot;%s\\n&quot;, f.Name())&#125; 七、遍历文件夹学习io之后，尤其是文件操作，我们就可以遍历给定的目录文件夹了。可以使用ioutil包下的readDir()方法，这个方法可以获取指定目录下的内容，返回文件和子目录。 因为文件夹下还有子文件夹，而ioutil包的ReadDir()只能获取一层目录，所以我们需要自己去设计算法来实现，最容易实现的思路就是使用递归。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;io/ioutil&quot; &quot;fmt&quot; &quot;log&quot;)func main() &#123; /** 遍历文件夹： */ dirname := &quot;/Users/ruby/Documents/pro&quot; listFiles(dirname, 0)&#125;func listFiles(dirname string, level int) &#123; // level用来记录当前递归的层次 // 生成有层次感的空格 s := &quot;|--&quot; for i := 0; i &lt; level; i++ &#123; s = &quot;| &quot; + s &#125; fileInfos, err := ioutil.ReadDir(dirname) if err != nil&#123; log.Fatal(err) &#125; for _, fi := range fileInfos &#123; filename := dirname + &quot;/&quot; + fi.Name() fmt.Printf(&quot;%s%s\\n&quot;, s, filename) if fi.IsDir() &#123; //继续遍历fi这个目录 listFiles(filename, level+1) &#125; &#125;&#125; 运行结果：","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shadowbynl.github.io/tags/Go/"}]},{"title":"Java安全框架其四 | Shiro","slug":"Java安全框架其四-Shiro","date":"2020-06-25T15:50:40.000Z","updated":"2020-06-25T15:51:08.480Z","comments":true,"path":"2020/06/25/Java安全框架其四-Shiro/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E5%85%B6%E5%9B%9B-Shiro/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"https://shadowbynl.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"Java安全框架其三 | SpringBoot 配置 Spring Security","slug":"Java安全框架其三-SpringBoot-配置-Spring-Security","date":"2020-06-25T15:49:14.000Z","updated":"2020-06-28T14:15:21.776Z","comments":true,"path":"2020/06/25/Java安全框架其三-SpringBoot-配置-Spring-Security/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E5%85%B6%E4%B8%89-SpringBoot-%E9%85%8D%E7%BD%AE-Spring-Security/","excerpt":"本篇先就基本集成方式进行记述（不涉及数据库），然后就迁移测试的结果给出一个可行的配置方案，若测试不成功，则参考网上的方案进行测试配置（2020.6.27)","text":"本篇先就基本集成方式进行记述（不涉及数据库），然后就迁移测试的结果给出一个可行的配置方案，若测试不成功，则参考网上的方案进行测试配置（2020.6.27) 基本配置与问题 一、基本配置：登录认证、访问授权、登出记住引导类 12345678910111213141516171819202122232425262728293031323334package com.n.security;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 1、引入SpringSecurity； * 2、编写SpringSecurity的配置类； * @EnableWebSecurity extends WebSecurityConfigurerAdapter * 3、控制请求的访问权限： * configure(HttpSecurity http) &#123; * http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() * .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;) * &#125; * 4、定义认证规则： * configure(AuthenticationManagerBuilder auth)&#123; * auth.inMemoryAuthentication() * .withUser(&quot;zhangsan&quot;).password(&quot;123456&quot;).roles(&quot;VIP1&quot;,&quot;VIP2&quot;) * &#125; * 5、开启自动配置的登陆功能： * configure(HttpSecurity http)&#123; * http.formLogin(); * &#125; * 6、注销：http.logout(); * 7、记住我：Remeberme()； */@SpringBootApplicationpublic class SecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityApplication.class, args); &#125;&#125; 自定义配置类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.n.security.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); //定制请求的授权规则 http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;); //开启自动配置的登陆功能，效果，如果没有登陆，没有权限就会来到登陆页面 http.formLogin().usernameParameter(&quot;user&quot;).passwordParameter(&quot;pwd&quot;) .loginPage(&quot;/userlogin&quot;); //1、/login来到登陆页 //2、重定向到/login?error表示登陆失败 //3、更多详细规定 //4、默认post形式的 /login代表处理登陆 //5、一但定制loginPage；那么 loginPage的post请求就是登陆 //开启自动配置的注销功能。 http.logout().logoutSuccessUrl(&quot;/&quot;);//注销成功以后来到首页 //1、访问 /logout 表示用户注销，清空session //2、注销成功会返回 /login?logout 页面； //开启记住我功能 http.rememberMe().rememberMeParameter(&quot;remeber&quot;); //登陆成功以后，将cookie发给浏览器保存，以后访问页面带上这个cookie，只要通过检查就可以免登录 //点击注销会删除cookie &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication().passwordEncoder(new MyPasswordEncoder()) .withUser(&quot;zhangsan&quot;).password(&quot;123456&quot;).roles(&quot;VIP1&quot;,&quot;VIP2&quot;) .and() .withUser(&quot;lisi&quot;).password(&quot;123456&quot;).roles(&quot;VIP2&quot;,&quot;VIP3&quot;) .and() .withUser(&quot;wangwu&quot;).password(&quot;123456&quot;).roles(&quot;VIP1&quot;,&quot;VIP3&quot;); &#125;&#125; 依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.n&lt;/groupId&gt; &lt;artifactId&gt;security&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;!-- &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;--&gt;&lt;!-- &lt;thymeleaf-layout-dialect.version&gt;2.3.0&lt;/thymeleaf-layout-dialect.version&gt;--&gt;&lt;!-- &lt;thymeleaf-extras-springsecurity4.version&gt;3.0.4.RELEASE&lt;/thymeleaf-extras-springsecurity4.version&gt;--&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 二、问题与解决 解决java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null”参考 https://blog.csdn.net/weixin_39220472/article/details/80865411自定义PasswordEncorder的实现类1234567891011121314151617package com.n.security.config;import org.springframework.context.annotation.Bean;import org.springframework.security.crypto.password.PasswordEncoder;public class MyPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; return s.equals(charSequence.toString()); &#125;&#125; 在thymeleaf测试时发现相关标签失效参考 https://blog.csdn.net/qq_34729698/article/details/86760219在pom.xml中添加如下依赖解决123456&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 通过迁移证书信息系统对springboot集成spring security的配置进行测试 开始，浪费了数个小时时间在使用传统xml配置上，一直希望仅加载原来配置过的文件就实现集成，但在这个过程中出现了各种各样的问题，最终还有一个问题尝试过很多方法都无法解决：An Authentication object was not found in the SecurityContext，最后无奈放弃，再尝试自定义配置类的方式，幸运的是，参考了一篇合适的博客，本身配置也不太负责，在解决了几个小问题后配置基本测试成功了。以下就我整个过程中的想法、遇到的问题和尝试的解决方法以及最终配置进行详细记述。一、迁移前与迁移初的疑虑第一个问题是，先前我使用ssm集成过spring security，使用xml可以进行详细直观地配置。而本项目要求使用springboot。该框架虽然都说其使用简便，但在学习过程中集成不同框架时需要写的各种配置类，以及我先前实现时遇到的种种不便，使我感觉这个框架过于鸡肋。原有的xml配置我可以自定义较详细的配置，但springboot会自动配置好很多配置，这样造成的问题就是你自己想定义的配置和默认的配置存在冲突，而想要自定义，要么自定义配置类（这个我还很不熟），要么使用@ImportResource加载传统xml文件（实践证明可能出现很多冲突和不可知的问题）。因此在集成之前，我对最终是否能做成实在缺乏信心。即便集成成功，项目要求前端vue，也就是前后端完全分离，而我之前实现的访问控制很大程度上借助与相关的标签，这就需要绝对不能分离，因此这个需求我也不知道怎么实现。总之就是只能摸着石头过河。二、传统xml配置过程1.首先，我的做法是jar包方式下，把java类、配置文件等都copy到对应目录下，依赖选择性复制。然后调整copy过来的三个传统xml配置文件：spring、springmvc、spring security的。spring中留存数据源 + 分页的，其他基本不作处理，同时把yml配置中重复的部分注释掉（但有一个很大的隐患，就是springboot的自动配置配了很多东西，是否有多配置的引起冲突我无法预估）2.那么，接下来应该考虑的是，怎么让传统xml配置生效。参考https://blog.csdn.net/qq_16504067/article/details/53924180https://blog.csdn.net/lovelovelovelovelo/article/details/88615261使用@ImportResource可以加载xml配置，但是否生效暂时无法验证。 123456789@Configuration@ImportResource(locations = &#123;&quot;classpath:applicationContext.xml&quot;, &quot;classpath:spring-security.xml&quot;&#125;)@EnableWebSecuritypublic class MyConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; super.configure(http); &#125;&#125; 以上其实为我经过一些报错并解决后才写成的配置，即便如此，还有问题无法解决。org.springframework.security.config.annotation.ObjectPostProcessor这个问题我在加了@EnableWebSecurity后解决，但不一定要加（说不清，这些配置互相影响）error creating bean with name &#39;org.springframework.aop.config.internalAutoProxyCreator&#39;参考 https://blog.csdn.net/deer_sheep/article/details/103668983 添加依赖解决 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; 然后就是卡死我的问题org.springframework.security.authentication.AuthenticationCredentialsNotFoundException:An Authentication object was not found in the SecurityContext这个问题我在参考了很多网站，结合https://blog.csdn.net/m0_37834471/article/details/81210429 等我认定（其实不是）是框架默认的过滤链没有注册成功，而这个过滤器的配置是在web.xml中的（当然springboot自动配置也有且加载早于web.xml，这样才保证了即使web.xml中有重复的关于mvc的配置不会冲突，当然这是后话），我意识到web.xml配置有影响时，我就开始计划使其生效，先参考一些链接使webapp成为web模块，且保证web.xml被扫描到，但没用，于是我就想直接建成web项目是不是更好，于是我下一步就是迁移为web项目。3.迁移后，发现先前的一些报错的配置正常了，但关于安全框架的这个问题还是无法解决。我就在想是不是springboot的自动配置与我的传统xml配置存在冲突而导致失效，那么我是不是该把关于安全框架的所有配置都自行处理。那么如何取消掉springboot关于安全框架的自动配置呢。我先想的策略是更换依赖，换为单独的安全框架依赖，无效；又在启动类上添注解排除相关配置，自己添过滤链配置，无效，还会报重复注册的错误；使用@Order提升加载优先级，无效。。。总之，花了四五个小时时间，这个问题始终解决不了，我只能无奈放弃，转为使用自定义配置类的方式。三、自定义配置类1.之前为什么不用一是我有现成的xml配置文件，其中配置有些复杂；而是我实在不想用不太熟悉的自定义配置类的方式进行配置，但在上述情形下只能自定义了。首先是迁移项目，还是web。然后关于spring和springmvc的配置可以用自己的，但要注意要解决BeanDefinitionOverrideException的问题，当时报错的意思是，springmvc已经有些自动配置了，使用xml做了重复的配置，解决方法是在yml中添加 123spring: main: allow-bean-definition-overriding: true 这样配置类可以直接加载相关xml 12345@Configuration@ImportResource(locations = &#123;&quot;classpath:applicationContext.xml&quot;, &quot;classpath:spring-mvc.xml&quot;&#125;)public class MyConfig &#123;&#125; 2.自定义配置类参考 https://www.jianshu.com/p/3295cb74481e整个配置类的配置与xml基本是一致的，但测试时出现了两个问题，以下记述。注意，该配置类为最终版本，记述的错误是未修改前的配置错误造成的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.n.config;import com.n.service.IUserInfoService;import com.n.service.impl.UserInfoServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired UserInfoServiceImpl userInfoService; /** * 指定userService * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userInfoService).passwordEncoder(passwordEncoder()); &#125; @Bean PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/**&quot;).hasRole(&quot;USER&quot;) .antMatchers(&quot;/**&quot;).hasRole(&quot;ADMIN&quot;) .antMatchers(&quot;/face_back/css/**&quot;).permitAll() .antMatchers(&quot;/face_back/img/**&quot;).permitAll() .antMatchers(&quot;/face_back/plugins/**&quot;).permitAll() .antMatchers(&quot;/face_back/pages/**&quot;).permitAll() .antMatchers(&quot;/face_back/**&quot;).permitAll() .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); http.formLogin().usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;) .loginPage(&quot;/login.jsp&quot;).successForwardUrl(&quot;/pages/main.jsp&quot;) .loginProcessingUrl(&quot;/face_back/login.do&quot;).failureForwardUrl(&quot;/failer.jsp&quot;); &#125;&#125; 3.配置完成后，可显示登录页。但点击登录后，出现错误No qualifying bean of type &#39;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&#39;，尽管已经使用了@Bean，但实际没有注入，因此我直接在spring的xml中将其注入 1&lt;bean id=&quot;passwordEncoder&quot; class=&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot;/&gt; 注入后，再运行，报错There is no PasswordEncoder mapped for the id &quot;null&quot;，意识到这个密码编码根本没用 12345# 错误配置auth.userDetailsService(userInfoService)；# 修改后auth.userDetailsService(userInfoService).passwordEncoder(passwordEncoder()); 解决后，再运行又报错The absolute uri: [http://www.springframework.org/security/tags] cannot be resolved in either web.xml or the jar files deployed with this application结合其他参考与jsp中约束标签的报错情况，推断为缺少相关依赖，查找后添加，解决问题 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-taglibs --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;5.3.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 四、可行方案最终发现，实际配置类还是比较简单的，而使用xml配置也是可行的。因测试迁移项目中其他依赖过多，就对关键点作出说明。1.引导类这个没有测试，但我也不想测试了，是否需要排除这个自动配置，直接排除得了，虽然根据@EnableWebSecurity的作用https://blog.csdn.net/weixin_42849689/article/details/89953107 发现似乎不用排除，但写上也没影响 1234567891011@MapperScan(&quot;com.n.dao&quot;)//@SpringBootApplication@SpringBootApplication(exclude=&#123;SecurityAutoConfiguration.class, SecurityFilterAutoConfiguration.class&#125;)public class MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisApplication.class, args); &#125;&#125; 2.自定义配置类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.n.config;import com.n.service.IUserInfoService;import com.n.service.impl.UserInfoServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired UserInfoServiceImpl userInfoService; /** * 指定userService * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userInfoService).passwordEncoder(passwordEncoder()); &#125; @Bean PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/**&quot;).hasRole(&quot;USER&quot;) .antMatchers(&quot;/**&quot;).hasRole(&quot;ADMIN&quot;) .antMatchers(&quot;/face_back/css/**&quot;).permitAll() .antMatchers(&quot;/face_back/img/**&quot;).permitAll() .antMatchers(&quot;/face_back/plugins/**&quot;).permitAll() .antMatchers(&quot;/face_back/pages/**&quot;).permitAll() .antMatchers(&quot;/face_back/**&quot;).permitAll() .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); http.formLogin().usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;) .loginPage(&quot;/login.jsp&quot;).successForwardUrl(&quot;/pages/main.jsp&quot;) .loginProcessingUrl(&quot;/face_back/login.do&quot;).failureForwardUrl(&quot;/failer.jsp&quot;); &#125;&#125; 3.密码编码bean注入4.依赖完整五、收获1.传统xml配置加载确实可行2.初步实现了springboot+安全框架的集成（数据库）","categories":[{"name":"安全","slug":"安全","permalink":"https://shadowbynl.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"Java安全框架其二 | SSM 配置 Spring Security","slug":"Java安全框架其二-SSM-配置-Spring-Security","date":"2020-06-25T15:48:46.000Z","updated":"2020-06-25T15:49:11.440Z","comments":true,"path":"2020/06/25/Java安全框架其二-SSM-配置-Spring-Security/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E5%85%B6%E4%BA%8C-SSM-%E9%85%8D%E7%BD%AE-Spring-Security/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"https://shadowbynl.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"Java安全框架其一 | Spring Security","slug":"Java安全框架其一-Spring-Security","date":"2020-06-25T15:47:49.000Z","updated":"2020-06-25T15:48:34.252Z","comments":true,"path":"2020/06/25/Java安全框架其一-Spring-Security/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E5%85%B6%E4%B8%80-Spring-Security/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"https://shadowbynl.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"Java数据访问框架其七 | Mybatis与JPA对比","slug":"Java数据访问框架其七-Mybatis与JPA对比","date":"2020-06-25T15:41:29.000Z","updated":"2020-06-27T15:03:01.860Z","comments":true,"path":"2020/06/25/Java数据访问框架其七-Mybatis与JPA对比/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E4%B8%83-Mybatis%E4%B8%8EJPA%E5%AF%B9%E6%AF%94/","excerpt":"本篇是对ORM框架进行总结，记录一些mybatis与jpa框架的对比的文章。简单地说，mybatis优势在于多表和sql优化，jpa优势在于移植性。","text":"本篇是对ORM框架进行总结，记录一些mybatis与jpa框架的对比的文章。简单地说，mybatis优势在于多表和sql优化，jpa优势在于移植性。 Spring Data项目https://spring.io/projects/spring-data Spring Data 项目的目的是为了简化构建基于Spring 框架应用的数据访问技术，包括非关系数据库、Map-Reduce 框架、云数据服务等等；另外也包含对关系数据库的访问支持。• Spring Data 包含多个子项目：– Spring Data Commons– Spring Data JPA– Spring Data KeyValue– Spring Data LDAP– Spring Data MongoDB– Spring Data Gemfire– Spring Data REST– Spring Data Redis– Spring Data for Apache Cassandra– Spring Data for Apache Solr– Spring Data Couchbase (community module)– Spring Data Elasticsearch (community module)– Spring Data Neo4j (community module) mybatis与jpa对比 https://www.baidu.com/s?wd=mybatis%E4%B8%8Ejpa&amp;rsv_spt=1&amp;rsv_iqid=0xccdc7fcb001e5769&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=17&amp;rsv_sug1=18&amp;rsv_sug7=101&amp;rsv_t=db289xARc8fGqE4zpbBCcvjoCZAR7TNFhtsF8rARNoL8hdMYLNMOAn3Ec%2FS%2ByPjFpKEr&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=13263&amp;rsv_sug4=14448https://www.cnblogs.com/llywy/p/10103136.htmlhttps://www.jianshu.com/p/32ce87c163d6https://www.cnblogs.com/ymstars/p/10629285.htmlhttps://blog.csdn.net/sinolover/article/details/96966213https://blog.csdn.net/RAVEEE/article/details/89951468https://www.jianshu.com/p/1fb00955302ahttps://www.zhihu.com/question/356307466","categories":[{"name":"ORM","slug":"ORM","permalink":"https://shadowbynl.github.io/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"Java数据访问框架其六 | SpringBoot 集成 Mybatis","slug":"Java数据访问框架其六-SpringBoot-集成-Mybatis","date":"2020-06-25T15:41:10.000Z","updated":"2020-06-27T14:52:18.815Z","comments":true,"path":"2020/06/25/Java数据访问框架其六-SpringBoot-集成-Mybatis/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E5%85%AD-SpringBoot-%E9%9B%86%E6%88%90-Mybatis/","excerpt":"本篇的主要内容为SpringBoot集成Mybatis的配置（根据mybatis实现有两种，可结合），此外还有Driud数据库连接池的配置。在记述这些配置之前，首先要进行一些概念的剖析。","text":"本篇的主要内容为SpringBoot集成Mybatis的配置（根据mybatis实现有两种，可结合），此外还有Driud数据库连接池的配置。在记述这些配置之前，首先要进行一些概念的剖析。 概念 一、druid与jdbcJDBC与Druid简单介绍及Druid与MyBatis连接数据库https://www.cnblogs.com/knowledgesea/p/11202918.html从JDBC到Druid，谈谈datasource的发展与druid使用https://blog.csdn.net/a3427603/article/details/86449198Druid 介绍和应用https://www.jianshu.com/p/221f795ff462二、druid与c3p0c3p0、dbcp、druid三大连接池对比https://blog.csdn.net/wawa3338/article/details/81380662druid和c3p0连接池https://blog.csdn.net/weixin_41417585/article/details/87633470c3p0，dbcp与druid 三大连接池的区别https://www.cnblogs.com/starliang/p/11736868.html三、数据源与数据库连接池数据源 与数据库连接池的 关系https://blog.csdn.net/u013065023/article/details/54973770?utm_source=blogxgwz8数据库、数据源和数据库连接池https://www.cnblogs.com/echola/p/10997587.html总结一下，druid就是一种最好的数据库连接池。 环境配置mybatis实现有注解和映射两种方式，也可结合，因此也有对应的集成配置方式，但也有一些相同的部分，如依赖和数据库连接池的配置，先列出相同的配置，再就分别的需要注意的点进行说明。 一、依赖pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--引入druid--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 二、数据库连接池配置application.yml 12345678910111213141516171819202122232425262728293031323334353637383940spring: datasource:# 数据源基本配置 username: root password: 6774258 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/senior type: com.alibaba.druid.pool.DruidDataSource# 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500# 在初次运行项目时，可以根据以下配置创建表 注意相关sql文件已经存放在resources/sql目录下# schema:# - classpath:sql/department.sql# - classpath:sql/employee.sqlmybatis: # 指定全局配置文件位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml # 指明实体类位置 type-aliases-package: com.n.mybatis.bean Druid配置类config.DruidConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.n.mybatis.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问 initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; &#125;&#125; 三、注解配置可能老版本引导类添加scan后相关包的类不需注入，但现在除了扫描以外，必须用@Component或@Repository将dao层接口注入。引导类@Mapper 12345678@SpringBootApplication@MapperScan(&quot;com.n.mybatis.mapper&quot;)public class MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisApplication.class, args); &#125;&#125; dao层接口注入 1234567@Componentpublic interface EmployeeMapper &#123; public Employee getEmpById(Integer id); public void insertEmp(Employee employee);&#125; 四、映射配置在resources下mapper目录下创建映射文件，并在application.yml中指明。 1234567mybatis: # 指定全局配置文件位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml # 指明实体类位置 type-aliases-package: com.n.mybatis.bean 五、下划线转驼峰命名参考 https://blog.csdn.net/weixin_43908647/article/details/104464261实现方式一：mybatis配置类 123456789101112131415161718192021package com.n.mybatis.config;import org.apache.ibatis.session.Configuration;import org.mybatis.spring.boot.autoconfigure.ConfigurationCustomizer;import org.springframework.context.annotation.Bean;@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 实现方式二：mybatis配置文件+yml中指明mybatis-config.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; application.yml 1234567mybatis: # 指定全局配置文件位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml # 指明实体类位置 type-aliases-package: com.n.mybatis.bean 小结据我对springboot集成orm、安全等框架的方法的观察分析，发现事实上，对单个框架的详细配置，既可以在yml中写明（可能有限），也可以在单独配置文件中写出，如ssm那样，再在yml中指明位置（这个需要参考资料），还能单独写配置类实现（这个个人认为比较麻烦）。","categories":[{"name":"ORM","slug":"ORM","permalink":"https://shadowbynl.github.io/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"Java数据访问框架其五 | Mybatis","slug":"Java数据访问框架其五-Mybatis","date":"2020-06-25T15:40:32.000Z","updated":"2020-06-27T14:03:46.804Z","comments":true,"path":"2020/06/25/Java数据访问框架其五-Mybatis/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E4%BA%94-Mybatis/","excerpt":"关于mybatis的使用（基本crud和多表操作）已基本熟悉，本篇是就其原理和注解与映射两种实现方式进行总结回顾。","text":"关于mybatis的使用（基本crud和多表操作）已基本熟悉，本篇是就其原理和注解与映射两种实现方式进行总结回顾。","categories":[{"name":"ORM","slug":"ORM","permalink":"https://shadowbynl.github.io/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"Java数据访问框架其四 | SpringBoot 集成 SpringData JPA","slug":"Java数据访问框架其四-SpringBoot-集成-SpringData-JPA","date":"2020-06-25T15:40:07.000Z","updated":"2020-06-27T13:42:48.174Z","comments":true,"path":"2020/06/25/Java数据访问框架其四-SpringBoot-集成-SpringData-JPA/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E5%9B%9B-SpringBoot-%E9%9B%86%E6%88%90-SpringData-JPA/","excerpt":"本篇以一个简单的用户操作为例，介绍springboot集成springdata jpa的配置。与SpringBoot集成，不需要再向先前那样考虑jdk版本等问题，只要保证数据库配置正确，就能正常操作，同样可以忽略实体类注解的红线。但有一个需要注意的地方是，新版本的springdata jpa中的某些api可能发生变化了，如findOne-&gt;findById.get","text":"本篇以一个简单的用户操作为例，介绍springboot集成springdata jpa的配置。与SpringBoot集成，不需要再向先前那样考虑jdk版本等问题，只要保证数据库配置正确，就能正常操作，同样可以忽略实体类注解的红线。但有一个需要注意的地方是，新版本的springdata jpa中的某些api可能发生变化了，如findOne-&gt;findById.get 环境 pom.xml注意因为本地mysql版本较低的缘故，可见此处springboot为较新版本，相应的mysql驱动版本也较新，因此连接时可能出现乱码问题，需要手动将mysql驱动版本改为较低的。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; application.yml注意数据库连接配置一定要正确 123456789101112spring: datasource: url: jdbc:mysql://localhost:3306/senior?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;zeroDateTimeBehavior=convertToNull username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true 实例 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.n.jpa.entity;import javax.persistence.*;//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = &quot;tbl_user&quot;) //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = &quot;last_name&quot;,length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; dao层接口 12345678910package com.n.jpa.repository;import com.n.jpa.entity.User;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt;, JpaSpecificationExecutor&lt;User&gt; &#123;&#125; controller层测试 123456789101112131415161718192021222324252627282930package com.n.jpa.controller;import com.n.jpa.entity.User;import com.n.jpa.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserController &#123; @Autowired UserRepository userRepository; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public User getUser(@PathVariable(&quot;id&quot;)Integer id)&#123; User user = userRepository.findById(id).get(); return user; &#125; @GetMapping(&quot;/user&quot;) public User insertUser(User user)&#123; User save = userRepository.save(user); return save; &#125;&#125;","categories":[{"name":"ORM","slug":"ORM","permalink":"https://shadowbynl.github.io/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"Java数据访问框架其三 | SpringData JPA","slug":"Java数据访问框架其三-SpringData-JPA","date":"2020-06-25T15:39:37.000Z","updated":"2020-06-27T13:21:31.494Z","comments":true,"path":"2020/06/25/Java数据访问框架其三-SpringData-JPA/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E4%B8%89-SpringData-JPA/","excerpt":"本篇从SpingData JPA的介绍出发，依次介绍该框架的配置、基本CRUD、多种查询方式、动态查询和多表操作、对象导航查询。","text":"本篇从SpingData JPA的介绍出发，依次介绍该框架的配置、基本CRUD、多种查询方式、动态查询和多表操作、对象导航查询。 概述 一、概述Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！Spring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现,在实际的工作工程中，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦。SpringData Jpa 极大简化了数据库访问层代码。 如何简化的呢？ 使用了SpringDataJpa，我们的dao层中只需要写接口，就自动具有了增删改查、分页查询等方法。二、Spring Data JPA 与 JPA和hibernate之间的关系JPA是一套规范，内部是有接口和抽象类组成的。hibernate是一套成熟的ORM框架，而且Hibernate实现了JPA规范，所以也可以称hibernate为JPA的一种实现方式，我们使用JPA的API编程，意味着站在更高的角度上看待问题（面向接口编程）Spring Data JPA是Spring提供的一套对JPA操作更加高级的封装，是在JPA规范下的专门用来进行数据持久化的解决方案。 springdata jpa 配置配置过程中出现的问题与解决方法和jpa测试类似，都是保证数据库配置正确的前提下，添加依赖 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast&lt;/groupId&gt; &lt;artifactId&gt;springdatajpa&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;hibernate.version&gt;5.0.7.Final&lt;/hibernate.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring beg --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring对orm框架的支持包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring end --&gt; &lt;!-- hibernate beg --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- hibernate end --&gt; &lt;!-- c3p0 beg --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;$&#123;c3p0.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 end --&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring data jpa 的坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.9.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- el beg 使用spring data jpa 必须引入 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- el end --&gt; &lt;!-- 解决因jdk版本等原因造成的java.lang.ClassNotFoundException: javax.xml.bind.JAXBException问题 --&gt; &lt;!-- 参考 https://blog.csdn.net/w405722907/article/details/80523790 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; resources/applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt; &lt;!--spring 和 spring data jpa的配置--&gt; &lt;!-- 1.创建entityManagerFactory对象交给spring容器管理--&gt; &lt;bean id=&quot;entityManagerFactoty&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!--配置的扫描的包（实体类所在的包） --&gt; &lt;property name=&quot;packagesToScan&quot; value=&quot;cn.itcast.domain&quot; /&gt; &lt;!-- jpa的实现厂家 --&gt; &lt;property name=&quot;persistenceProvider&quot;&gt; &lt;bean class=&quot;org.hibernate.jpa.HibernatePersistenceProvider&quot;/&gt; &lt;/property&gt; &lt;!--jpa的供应商适配器 --&gt; &lt;property name=&quot;jpaVendorAdapter&quot;&gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt; &lt;!--配置是否自动创建数据库表 --&gt; &lt;property name=&quot;generateDdl&quot; value=&quot;false&quot; /&gt; &lt;!--指定数据库类型 --&gt; &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot; /&gt; &lt;!--数据库方言：支持的特有语法 --&gt; &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&gt; &lt;!--是否显示sql --&gt; &lt;property name=&quot;showSql&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!--jpa的方言 ：高级的特性 --&gt; &lt;property name=&quot;jpaDialect&quot; &gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot; /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--2.创建数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///senior&quot; &gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--3.整合spring dataJpa--&gt; &lt;jpa:repositories base-package=&quot;cn.itcast.dao&quot; transaction-manager-ref=&quot;transactionManager&quot; entity-manager-factory-ref=&quot;entityManagerFactoty&quot; &gt;&lt;/jpa:repositories&gt; &lt;!--4.配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt; &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactoty&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.txAdvice--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 5.aop--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* cn.itcast.service.*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot; /&gt; &lt;/aop:config&gt; &lt;!--5.声明式事务 --&gt; &lt;!-- 6. 配置包扫描--&gt; &lt;context:component-scan base-package=&quot;cn.itcast&quot; &gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 基本操作注意在新版本中，该框架已无findOne方法，而是用findById().get()取代 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081编写符合Spring Data JPA规范的Dao层接口Spring Data JPA是spring提供的一款对于数据访问层（Dao层）的框架，使用Spring Data JPA，只需要按照框架的规范提供dao接口，不需要实现类就可以完成数据库的增删改查、分页查询等方法的定义，极大的简化了我们的开发过程。在Spring Data JPA中，对于定义符合规范的Dao层接口，我们只需要遵循以下几点就可以了：1.创建一个Dao层接口，并实现JpaRepository和JpaSpecificationExecutor2.提供相应的泛型package cn.itcast.dao;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import cn.itcast.entity.Customer;/** * JpaRepository&lt;实体类类型，主键类型&gt;：用来完成基本CRUD操作 * JpaSpecificationExecutor&lt;实体类类型&gt;：用于复杂查询（分页等查询操作） */public interface CustomerDao extends JpaRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor&lt;Customer&gt; &#123;&#125;这样我们就定义好了一个符合Spring Data JPA规范的Dao层接口完成基本CRUD操作完成了Spring Data JPA的环境搭建，并且编写了符合Spring Data JPA 规范的Dao层接口之后，就可以使用定义好的Dao层接口进行客户的基本CRUD操作@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)public class CustomerDaoTest &#123; @Autowired private CustomerDao customerDao; /** * 保存客户：调用save(obj)方法 */ @Test public void testSave() &#123; Customer c = new Customer(); c.setCustName(&quot;传智播客&quot;); customerDao.save(c); &#125; /** * 修改客户：调用save(obj)方法 * 对于save方法的解释：如果执行此方法是对象中存在id属性，即为更新操作会先根据id查询，再更新 * 如果执行此方法中对象中不存在id属性，即为保存操作 * */ @Test public void testUpdate() &#123; //根据id查询id为1的客户 Customer customer = customerDao.findOne(1l); //修改客户名称 customer.setCustName(&quot;传智播客顺义校区&quot;); //更新 customerDao.save(customer); &#125; /** * 根据id删除：调用delete(id)方法 */ @Test public void testDelete() &#123; customerDao.delete(1l); &#125; /** * 根据id查询：调用findOne(id)方法 */ @Test public void testFindById() &#123; Customer customer = customerDao.findOne(2l); System.out.println(customer); &#125;&#125; 四种查询方式 一、使用Spring Data JPA中接口定义的方法进行查询在继承JpaRepository和JpaSpecificationExecutor接口后,我们就可以使用接口中定义的方法进行查询，前者中定义的方法用于基本crud，后者中定义的方法用于动态查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package cn.itcast.test;import cn.itcast.dao.CustomerDao;import cn.itcast.domain.Customer;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class) //声明spring提供的单元测试环境@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)//指定spring容器的配置信息public class CustomerDaoTest &#123; @Autowired private CustomerDao customerDao; /** * 根据id查询 */ @Test public void testFindOne() &#123; Customer customer = customerDao.findOne(4l); System.out.println(customer); &#125; /** * save : 保存或者更新 * 根据传递的对象是否存在主键id， * 如果没有id主键属性：保存 * 存在id主键属性，根据id查询数据，更新数据 */ @Test public void testSave() &#123; Customer customer = new Customer(); customer.setCustName(&quot;黑马程序员&quot;); customer.setCustLevel(&quot;vip&quot;); customer.setCustIndustry(&quot;it教育&quot;); customerDao.save(customer); &#125; @Test public void testUpdate() &#123; Customer customer = new Customer(); customer.setCustId(4l); customer.setCustName(&quot;黑马程序员很厉害&quot;); customerDao.save(customer); &#125; @Test public void testDelete () &#123; customerDao.delete(3l); &#125; /** * 查询所有 */ @Test public void testFindAll() &#123; List&lt;Customer&gt; list = customerDao.findAll(); for(Customer customer : list) &#123; System.out.println(customer); &#125; &#125; /** * 测试统计查询：查询客户的总数量 * count:统计总条数 */ @Test public void testCount() &#123; long count = customerDao.count();//查询全部的客户数量 System.out.println(count); &#125; /** * 测试：判断id为4的客户是否存在 * 1. 可以查询以下id为4的客户 * 如果值为空，代表不存在，如果不为空，代表存在 * 2. 判断数据库中id为4的客户的数量 * 如果数量为0，代表不存在，如果大于0，代表存在 */ @Test public void testExists() &#123; boolean exists = customerDao.exists(4l); System.out.println(&quot;id为4的客户 是否存在：&quot;+exists); &#125; /** * 根据id从数据库查询 * @Transactional : 保证getOne正常运行 * * findOne： * em.find() :立即加载 * getOne： * em.getReference :延迟加载 * * 返回的是一个客户的动态代理对象 * * 什么时候用，什么时候查询 */ @Test @Transactional public void testGetOne() &#123; Customer customer = customerDao.getOne(4l); System.out.println(customer); &#125;&#125; 二、使用JPQL的方式查询 123456789101112131415161718192021使用Spring Data JPA提供的查询方法已经可以解决大部分的应用场景，但是对于某些业务来说，我们还需要灵活的构造查询条件，这时就可以使用@Query注解，结合JPQL的语句方式完成查询@Query 注解的使用非常简单，只需在方法上面标注该注解，同时提供一个JPQL查询语句即可public interface CustomerDao extends JpaRepository&lt;Customer, Long&gt;,JpaSpecificationExecutor&lt;Customer&gt; &#123; //@Query 使用jpql的方式查询。 @Query(value=&quot;from Customer&quot;) public List&lt;Customer&gt; findAllCustomer(); //@Query 使用jpql的方式查询。?1代表参数的占位符，其中1对应方法中的参数索引 @Query(value=&quot;from Customer where custName = ?1&quot;) public Customer findCustomer(String custName);&#125;此外，也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询 @Query(value=&quot;update Customer set custName = ?1 where custId = ?2&quot;) @Modifying public void updateCustomer(String custName,Long custId); 三、使用SQL语句查询 12345678Spring Data JPA同样也支持sql语句的查询，如下：/** * nativeQuery : 使用本地sql的方式查询 */@Query(value=&quot;select * from cst_customer&quot;,nativeQuery=true)public void findSql(); 四、方法命名规则查询 1234567顾名思义，方法命名规则查询就是根据方法的名字，就能创建查询。只需要按照Spring Data JPA提供的方法命名规则定义方法的名称，就可以完成查询工作。Spring Data JPA在程序执行的时候会根据方法名称进行解析，并自动生成查询语句进行查询按照Spring Data JPA 定义的规则，查询方法以findBy开头，涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性首字母需大写。框架在进行方法名解析时，会先把方法名多余的前缀截取掉，然后对剩下部分进行解析。//方法命名方式查询（根据客户名称查询客户）public Customer findByCustName(String custName); Keyword Sample JPQL And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is,Equals findByFirstnameIs, findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age ⇐ ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection age) … where x.age not in ?1 TRUE findByActiveTrue() … where x.active = true FALSE findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) 后三种查询方法测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198dao层package cn.itcast.dao;import cn.itcast.domain.Customer;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import java.util.List;/** * 符合SpringDataJpa的dao层接口规范 * JpaRepository&lt;操作的实体类类型，实体类中主键属性的类型&gt; * * 封装了基本CRUD操作 * JpaSpecificationExecutor&lt;操作的实体类类型&gt; * * 封装了复杂查询（分页） */public interface CustomerDao extends JpaRepository&lt;Customer,Long&gt; ,JpaSpecificationExecutor&lt;Customer&gt; &#123; /** * 案例：根据客户名称查询客户 * 使用jpql的形式查询 * jpql：from Customer where custName = ? * * 配置jpql语句，使用的@Query注解 */ @Query(value=&quot;from Customer where custName = ?&quot;) public Customer findJpql(String custName); /** * 案例：根据客户名称和客户id查询客户 * jpql： from Customer where custName = ? and custId = ? * * 对于多个占位符参数 * 赋值的时候，默认的情况下，占位符的位置需要和方法参数中的位置保持一致 * * 可以指定占位符参数的位置 * ? 索引的方式，指定此占位的取值来源 */ @Query(value = &quot;from Customer where custName = ?2 and custId = ?1&quot;) public Customer findCustNameAndId(Long id,String name); /** * 使用jpql完成更新操作 * 案例 ： 根据id更新，客户的名称 * 更新4号客户的名称，将名称改为“黑马程序员” * * sql ：update cst_customer set cust_name = ? where cust_id = ? * jpql : update Customer set custName = ? where custId = ? * * @Query : 代表的是进行查询 * * 声明此方法是用来进行更新操作 * @Modifying * * 当前执行的是一个更新操作 * */ @Query(value = &quot; update Customer set custName = ?2 where custId = ?1 &quot;) @Modifying public void updateCustomer(long custId,String custName); /** * 使用sql的形式查询： * 查询全部的客户 * sql ： select * from cst_customer; * Query : 配置sql查询 * value ： sql语句 * nativeQuery ： 查询方式 * true ： sql查询 * false：jpql查询 * */ //@Query(value = &quot; select * from cst_customer&quot; ,nativeQuery = true) @Query(value=&quot;select * from cst_customer where cust_name like ?1&quot;,nativeQuery = true) public List&lt;Object [] &gt; findSql(String name); /** * 方法名的约定： * findBy : 查询 * 对象中的属性名（首字母大写） ： 查询的条件 * CustName * * 默认情况 ： 使用 等于的方式查询 * 特殊的查询方式 * * findByCustName -- 根据客户名称查询 * * 再springdataJpa的运行阶段 * 会根据方法名称进行解析 findBy from xxx(实体类) * 属性名称 where custName = * * 1.findBy + 属性名称 （根据属性名称进行完成匹配的查询=） * 2.findBy + 属性名称 + “查询方式（Like | isnull）” * findByCustNameLike * 3.多条件查询 * findBy + 属性名 + “查询方式” + “多条件的连接符（and|or）” + 属性名 + “查询方式” */ public Customer findByCustName(String custName); public List&lt;Customer&gt; findByCustNameLike(String custName); //使用客户名称模糊匹配和客户所属行业精准匹配的查询 public Customer findByCustNameLikeAndCustIndustry(String custName,String custIndustry);&#125;测试package cn.itcast.test;import cn.itcast.dao.CustomerDao;import cn.itcast.domain.Customer;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.jpa.repository.Query;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import java.util.Arrays;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class) //声明spring提供的单元测试环境@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)//指定spring容器的配置信息public class JpqlTest &#123; @Autowired private CustomerDao customerDao; @Test public void testFindJPQL() &#123; Customer customer = customerDao.findJpql(&quot;传智播客&quot;); System.out.println(customer); &#125; @Test public void testFindCustNameAndId() &#123; // Customer customer = customerDao.findCustNameAndId(&quot;传智播客&quot;,1l); Customer customer = customerDao.findCustNameAndId(1l,&quot;传智播客&quot;); System.out.println(customer); &#125; /** * 测试jpql的更新操作 * * springDataJpa中使用jpql完成 更新/删除操作 * * 需要手动添加事务的支持 * * 默认会执行结束之后，回滚事务 * @Rollback : 设置是否自动回滚 * false | true */ @Test @Transactional //添加事务的支持 @Rollback(value = false) public void testUpdateCustomer() &#123; customerDao.updateCustomer(4l,&quot;黑马程序员&quot;); &#125; //测试sql查询 @Test public void testFindSql() &#123; List&lt;Object[]&gt; list = customerDao.findSql(&quot;传智播客%&quot;); for(Object [] obj : list) &#123; System.out.println(Arrays.toString(obj)); &#125; &#125; //测试方法命名规则的查询 @Test public void testNaming() &#123; Customer customer = customerDao.findByCustName(&quot;传智播客&quot;); System.out.println(customer); &#125; //测试方法命名规则的查询 @Test public void testFindByCustNameLike() &#123; List&lt;Customer&gt; list = customerDao.findByCustNameLike(&quot;传智播客%&quot;); for (Customer customer : list) &#123; System.out.println(customer); &#125; &#125; //测试方法命名规则的查询 @Test public void testFindByCustNameLikeAndCustIndustry() &#123; Customer customer = customerDao.findByCustNameLikeAndCustIndustry(&quot;传智播客1%&quot;, &quot;it教育&quot;); System.out.println(customer); &#125;&#125; Specifications动态查询有时我们在查询某个实体的时候，给定的条件是不固定的，这时就需要动态构建相应的查询语句，在Spring Data JPA中可以通过JpaSpecificationExecutor接口查询。相比JPQL,其优势是类型安全,更加的面向对象。 1234567891011121314151617181920212223import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.domain.Specification;/** * JpaSpecificationExecutor中定义的方法 **/ public interface JpaSpecificationExecutor&lt;T&gt; &#123; //根据条件查询一个对象 T findOne(Specification&lt;T&gt; spec); //根据条件查询集合 List&lt;T&gt; findAll(Specification&lt;T&gt; spec); //根据条件分页查询 Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable); //排序查询查询 List&lt;T&gt; findAll(Specification&lt;T&gt; spec, Sort sort); //统计查询 long count(Specification&lt;T&gt; spec);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170package cn.itcast.test;import cn.itcast.dao.CustomerDao;import cn.itcast.domain.Customer;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.domain.Specification;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.persistence.criteria.*;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class SpecTest &#123; @Autowired private CustomerDao customerDao; /** * 根据条件，查询单个对象 * */ @Test public void testSpec() &#123; //匿名内部类 /** * 自定义查询条件 * 1.实现Specification接口（提供泛型：查询的对象类型） * 2.实现toPredicate方法（构造查询条件） * 3.需要借助方法参数中的两个参数（ * root：获取需要查询的对象属性 * CriteriaBuilder：构造查询条件的，内部封装了很多的查询条件（模糊匹配，精准匹配） * ） * 案例：根据客户名称查询，查询客户名为传智播客的客户 * 查询条件 * 1.查询方式 * cb对象 * 2.比较的属性名称 * root对象 * */ Specification&lt;Customer&gt; spec = new Specification&lt;Customer&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; //1.获取比较的属性 Path&lt;Object&gt; custName = root.get(&quot;custId&quot;); //2.构造查询条件 ： select * from cst_customer where cust_name = &#x27;传智播客&#x27; /** * 第一个参数：需要比较的属性（path对象） * 第二个参数：当前需要比较的取值 */ Predicate predicate = cb.equal(custName, &quot;传智播客&quot;);//进行精准的匹配 （比较的属性，比较的属性的取值） return predicate; &#125; &#125;; Customer customer = customerDao.findOne(spec); System.out.println(customer); &#125; /** * 多条件查询 * 案例：根据客户名（传智播客）和客户所属行业查询（it教育） * */ @Test public void testSpec1() &#123; /** * root:获取属性 * 客户名 * 所属行业 * cb：构造查询 * 1.构造客户名的精准匹配查询 * 2.构造所属行业的精准匹配查询 * 3.将以上两个查询联系起来 */ Specification&lt;Customer&gt; spec = new Specification&lt;Customer&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Path&lt;Object&gt; custName = root.get(&quot;custName&quot;);//客户名 Path&lt;Object&gt; custIndustry = root.get(&quot;custIndustry&quot;);//所属行业 //构造查询 //1.构造客户名的精准匹配查询 Predicate p1 = cb.equal(custName, &quot;传智播客&quot;);//第一个参数，path（属性），第二个参数，属性的取值 //2..构造所属行业的精准匹配查询 Predicate p2 = cb.equal(custIndustry, &quot;it教育&quot;); //3.将多个查询条件组合到一起：组合（满足条件一并且满足条件二：与关系，满足条件一或满足条件二即可：或关系） Predicate and = cb.and(p1, p2);//以与的形式拼接多个查询条件 // cb.or();//以或的形式拼接多个查询条件 return and; &#125; &#125;; Customer customer = customerDao.findOne(spec); System.out.println(customer); &#125; /** * 案例：完成根据客户名称的模糊匹配，返回客户列表 * 客户名称以 ’传智播客‘ 开头 * * equal ：直接的到path对象（属性），然后进行比较即可 * gt，lt,ge,le,like : 得到path对象，根据path指定比较的参数类型，再去进行比较 * 指定参数类型：path.as(类型的字节码对象) */ @Test public void testSpec3() &#123; //构造查询条件 Specification&lt;Customer&gt; spec = new Specification&lt;Customer&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; //查询属性：客户名 Path&lt;Object&gt; custName = root.get(&quot;custName&quot;); //查询方式：模糊匹配 Predicate like = cb.like(custName.as(String.class), &quot;传智播客%&quot;); return like; &#125; &#125;;// List&lt;Customer&gt; list = customerDao.findAll(spec);// for (Customer customer : list) &#123;// System.out.println(customer);// &#125; //添加排序 //创建排序对象,需要调用构造方法实例化sort对象 //第一个参数：排序的顺序（倒序，正序） // Sort.Direction.DESC:倒序 // Sort.Direction.ASC ： 升序 //第二个参数：排序的属性名称 Sort sort = new Sort(Sort.Direction.DESC,&quot;custId&quot;); List&lt;Customer&gt; list = customerDao.findAll(spec, sort); for (Customer customer : list) &#123; System.out.println(customer); &#125; &#125; /** * 分页查询 * Specification: 查询条件 * Pageable：分页参数 * 分页参数：查询的页码，每页查询的条数 * findAll(Specification,Pageable)：带有条件的分页 * findAll(Pageable)：没有条件的分页 * 返回：Page（springDataJpa为我们封装好的pageBean对象，数据列表，共条数） */ @Test public void testSpec4() &#123; Specification spec = null; //PageRequest对象是Pageable接口的实现类 /** * 创建PageRequest的过程中，需要调用他的构造方法传入两个参数 * 第一个参数：当前查询的页数（从0开始） * 第二个参数：每页查询的数量 */ Pageable pageable = new PageRequest(0,2); //分页查询 Page&lt;Customer&gt; page = customerDao.findAll(null, pageable); System.out.println(page.getContent()); //得到数据集合列表 System.out.println(page.getTotalElements());//得到总条数 System.out.println(page.getTotalPages());//得到总页数 &#125;&#125; 一对多 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483.1 示例分析 我们采用的示例为客户和联系人。 客户：指的是一家公司，我们记为A。 联系人：指的是A公司中的员工。 在不考虑兼职的情况下，公司和员工的关系即为一对多。3.2 表关系建立在一对多关系中，我们习惯把一的一方称之为主表，把多的一方称之为从表。在数据库中建立一对多的关系，需要使用数据库的外键约束。什么是外键？指的是从表中有一列，取值参照主表的主键，这一列就是外键。一对多数据库关系的建立，如下图所示 3.3 实体类关系建立以及映射配置在实体类中，由于客户是少的一方，它应该包含多个联系人，所以实体类要体现出客户中有多个联系人的信息，代码如下：/** * 客户的实体类 * 明确使用的注解都是JPA规范的 * 所以导包都要导入javax.persistence包下的 */@Entity//表示当前类是一个实体类@Table(name=&quot;cst_customer&quot;)//建立当前实体类和表之间的对应关系public class Customer implements Serializable &#123; @Id//表明当前私有属性是主键 @GeneratedValue(strategy=GenerationType.IDENTITY)//指定主键的生成策略 @Column(name=&quot;cust_id&quot;)//指定和数据库表中的cust_id列对应 private Long custId; @Column(name=&quot;cust_name&quot;)//指定和数据库表中的cust_name列对应 private String custName; @Column(name=&quot;cust_source&quot;)//指定和数据库表中的cust_source列对应 private String custSource; @Column(name=&quot;cust_industry&quot;)//指定和数据库表中的cust_industry列对应 private String custIndustry; @Column(name=&quot;cust_level&quot;)//指定和数据库表中的cust_level列对应 private String custLevel; @Column(name=&quot;cust_address&quot;)//指定和数据库表中的cust_address列对应 private String custAddress; @Column(name=&quot;cust_phone&quot;)//指定和数据库表中的cust_phone列对应 private String custPhone; //配置客户和联系人的一对多关系 @OneToMany(targetEntity=LinkMan.class) @JoinColumn(name=&quot;lkm_cust_id&quot;,referencedColumnName=&quot;cust_id&quot;) private Set&lt;LinkMan&gt; linkmans = new HashSet&lt;LinkMan&gt;(0); public Long getCustId() &#123; return custId; &#125; public void setCustId(Long custId) &#123; this.custId = custId; &#125; public String getCustName() &#123; return custName; &#125; public void setCustName(String custName) &#123; this.custName = custName; &#125; public String getCustSource() &#123; return custSource; &#125; public void setCustSource(String custSource) &#123; this.custSource = custSource; &#125; public String getCustIndustry() &#123; return custIndustry; &#125; public void setCustIndustry(String custIndustry) &#123; this.custIndustry = custIndustry; &#125; public String getCustLevel() &#123; return custLevel; &#125; public void setCustLevel(String custLevel) &#123; this.custLevel = custLevel; &#125; public String getCustAddress() &#123; return custAddress; &#125; public void setCustAddress(String custAddress) &#123; this.custAddress = custAddress; &#125; public String getCustPhone() &#123; return custPhone; &#125; public void setCustPhone(String custPhone) &#123; this.custPhone = custPhone; &#125; public Set&lt;LinkMan&gt; getLinkmans() &#123; return linkmans; &#125; public void setLinkmans(Set&lt;LinkMan&gt; linkmans) &#123; this.linkmans = linkmans; &#125; @Override public String toString() &#123; return &quot;Customer [custId=&quot; + custId + &quot;, custName=&quot; + custName + &quot;, custSource=&quot; + custSource + &quot;, custIndustry=&quot; + custIndustry + &quot;, custLevel=&quot; + custLevel + &quot;, custAddress=&quot; + custAddress + &quot;, custPhone=&quot; + custPhone + &quot;]&quot;; &#125;&#125;由于联系人是多的一方，在实体类中要体现出，每个联系人只能对应一个客户，代码如下：/** * 联系人的实体类（数据模型） */@Entity@Table(name=&quot;cst_linkman&quot;)public class LinkMan implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=&quot;lkm_id&quot;) private Long lkmId; @Column(name=&quot;lkm_name&quot;) private String lkmName; @Column(name=&quot;lkm_gender&quot;) private String lkmGender; @Column(name=&quot;lkm_phone&quot;) private String lkmPhone; @Column(name=&quot;lkm_mobile&quot;) private String lkmMobile; @Column(name=&quot;lkm_email&quot;) private String lkmEmail; @Column(name=&quot;lkm_position&quot;) private String lkmPosition; @Column(name=&quot;lkm_memo&quot;) private String lkmMemo; //多对一关系映射：多个联系人对应客户 @ManyToOne(targetEntity=Customer.class) @JoinColumn(name=&quot;lkm_cust_id&quot;,referencedColumnName=&quot;cust_id&quot;) private Customer customer;//用它的主键，对应联系人表中的外键 public Long getLkmId() &#123; return lkmId; &#125; public void setLkmId(Long lkmId) &#123; this.lkmId = lkmId; &#125; public String getLkmName() &#123; return lkmName; &#125; public void setLkmName(String lkmName) &#123; this.lkmName = lkmName; &#125; public String getLkmGender() &#123; return lkmGender; &#125; public void setLkmGender(String lkmGender) &#123; this.lkmGender = lkmGender; &#125; public String getLkmPhone() &#123; return lkmPhone; &#125; public void setLkmPhone(String lkmPhone) &#123; this.lkmPhone = lkmPhone; &#125; public String getLkmMobile() &#123; return lkmMobile; &#125; public void setLkmMobile(String lkmMobile) &#123; this.lkmMobile = lkmMobile; &#125; public String getLkmEmail() &#123; return lkmEmail; &#125; public void setLkmEmail(String lkmEmail) &#123; this.lkmEmail = lkmEmail; &#125; public String getLkmPosition() &#123; return lkmPosition; &#125; public void setLkmPosition(String lkmPosition) &#123; this.lkmPosition = lkmPosition; &#125; public String getLkmMemo() &#123; return lkmMemo; &#125; public void setLkmMemo(String lkmMemo) &#123; this.lkmMemo = lkmMemo; &#125; public Customer getCustomer() &#123; return customer; &#125; public void setCustomer(Customer customer) &#123; this.customer = customer; &#125; @Override public String toString() &#123; return &quot;LinkMan [lkmId=&quot; + lkmId + &quot;, lkmName=&quot; + lkmName + &quot;, lkmGender=&quot; + lkmGender + &quot;, lkmPhone=&quot; + lkmPhone + &quot;, lkmMobile=&quot; + lkmMobile + &quot;, lkmEmail=&quot; + lkmEmail + &quot;, lkmPosition=&quot; + lkmPosition + &quot;, lkmMemo=&quot; + lkmMemo + &quot;]&quot;; &#125;&#125;3.4 映射的注解说明@OneToMany: 作用：建立一对多的关系映射 属性： targetEntityClass：指定多的多方的类的字节码 mappedBy：指定从表实体类中引用主表对象的名称。 cascade：指定要使用的级联操作 fetch：指定是否采用延迟加载 orphanRemoval：是否使用孤儿删除@ManyToOne 作用：建立多对一的关系 属性： targetEntityClass：指定一的一方实体类字节码 cascade：指定要使用的级联操作 fetch：指定是否采用延迟加载 optional：关联是否可选。如果设置为false，则必须始终存在非空关系。@JoinColumn 作用：用于定义主键字段和外键字段的对应关系。 属性： name：指定外键字段的名称 referencedColumnName：指定引用主表的主键字段名称 unique：是否唯一。默认值不唯一 nullable：是否允许为空。默认值允许。 insertable：是否允许插入。默认值允许。 updatable：是否允许更新。默认值允许。 columnDefinition：列的定义信息。3.5 一对多的操作3.5.1 添加@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)public class OneToManyTest &#123; @Autowired private CustomerDao customerDao; @Autowired private LinkManDao linkManDao; /** * 保存操作 * 需求: * 保存一个客户和一个联系人 * 要求： * 创建一个客户对象和一个联系人对象 * 建立客户和联系人之间关联关系（双向一对多的关联关系） * 先保存客户，再保存联系人 * 问题： * 当我们建立了双向的关联关系之后，先保存主表，再保存从表时： * 会产生2条insert和1条update. * 而实际开发中我们只需要2条insert。 * */ @Test @Transactional //开启事务 @Rollback(false)//设置为不回滚 public void testAdd() &#123; Customer c = new Customer(); c.setCustName(&quot;TBD云集中心&quot;); c.setCustLevel(&quot;VIP客户&quot;); c.setCustSource(&quot;网络&quot;); c.setCustIndustry(&quot;商业办公&quot;); c.setCustAddress(&quot;昌平区北七家镇&quot;); c.setCustPhone(&quot;010-84389340&quot;); LinkMan l = new LinkMan(); l.setLkmName(&quot;TBD联系人&quot;); l.setLkmGender(&quot;male&quot;); l.setLkmMobile(&quot;13811111111&quot;); l.setLkmPhone(&quot;010-34785348&quot;); l.setLkmEmail(&quot;98354834@qq.com&quot;); l.setLkmPosition(&quot;老师&quot;); l.setLkmMemo(&quot;还行吧&quot;); c.getLinkMans().add(l); l.setCustomer(c); customerDao.save(c); linkManDao.save(l); &#125;&#125;通过保存的案例，我们可以发现在设置了双向关系之后，会发送两条insert语句，一条多余的update语句，那我们的解决是思路很简单，就是一的一方放弃维护权 /** *放弃外键维护权的配置将如下配置改为 */ //@OneToMany(targetEntity=LinkMan.class)//@JoinColumn(name=&quot;lkm_cust_id&quot;,referencedColumnName=&quot;cust_id&quot;) //设置为 @OneToMany(mappedBy=&quot;customer&quot;)3.5.2 删除 @Autowired private CustomerDao customerDao; @Test @Transactional @Rollback(false)//设置为不回滚 public void testDelete() &#123; customerDao.delete(1l); &#125;删除操作的说明如下：删除从表数据：可以随时任意删除。删除主表数据： 有从表数据 1、在默认情况下，它会把外键字段置为null，然后删除主表数据。如果在数据库的表 结构上，外键字段有非空约束，默认情况就会报错了。 2、如果配置了放弃维护关联关系的权利，则不能删除（与外键字段是否允许为null， 没有关系）因为在删除时，它根本不会去更新从表的外键字段了。 3、如果还想删除，使用级联删除引用 没有从表数据引用：随便删在实际开发中，级联删除请慎用！(在一对多的情况下)3.5.3 级联操作级联操作：指操作一个对象同时操作它的关联对象使用方法：只需要在操作主体的注解上配置cascade /** * cascade:配置级联操作 * CascadeType.MERGE 级联更新 * CascadeType.PERSIST 级联保存： * CascadeType.REFRESH 级联刷新： * CascadeType.REMOVE 级联删除： * CascadeType.ALL 包含所有 */ @OneToMany(mappedBy=&quot;customer&quot;,cascade=CascadeType.ALL) 多对多 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422434.1 示例分析 我们采用的示例为用户和角色。 用户：指的是咱们班的每一个同学。 角色：指的是咱们班同学的身份信息。 比如A同学，它是我的学生，其中有个身份就是学生，还是家里的孩子，那么他还有个身份是子女。 同时B同学，它也具有学生和子女的身份。 那么任何一个同学都可能具有多个身份。同时学生这个身份可以被多个同学所具有。 所以我们说，用户和角色之间的关系是多对多。4.2 表关系建立多对多的表关系建立靠的是中间表，其中用户表和中间表的关系是一对多，角色表和中间表的关系也是一对多，如下图所示： 4.3 实体类关系建立以及映射配置一个用户可以具有多个角色，所以在用户实体类中应该包含多个角色的信息，代码如下：/** * 用户的数据模型 */@Entity@Table(name=&quot;sys_user&quot;)public class SysUser implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=&quot;user_id&quot;) private Long userId; @Column(name=&quot;user_code&quot;) private String userCode; @Column(name=&quot;user_name&quot;) private String userName; @Column(name=&quot;user_password&quot;) private String userPassword; @Column(name=&quot;user_state&quot;) private String userState; //多对多关系映射 @ManyToMany(mappedBy=&quot;users&quot;) private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0); public Long getUserId() &#123; return userId; &#125; public void setUserId(Long userId) &#123; this.userId = userId; &#125; public String getUserCode() &#123; return userCode; &#125; public void setUserCode(String userCode) &#123; this.userCode = userCode; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUserPassword() &#123; return userPassword; &#125; public void setUserPassword(String userPassword) &#123; this.userPassword = userPassword; &#125; public String getUserState() &#123; return userState; &#125; public void setUserState(String userState) &#123; this.userState = userState; &#125; public Set&lt;SysRole&gt; getRoles() &#123; return roles; &#125; public void setRoles(Set&lt;SysRole&gt; roles) &#123; this.roles = roles; &#125; @Override public String toString() &#123; return &quot;SysUser [userId=&quot; + userId + &quot;, userCode=&quot; + userCode + &quot;, userName=&quot; + userName + &quot;, userPassword=&quot; + userPassword + &quot;, userState=&quot; + userState + &quot;]&quot;; &#125;&#125;一个角色可以赋予多个用户，所以在角色实体类中应该包含多个用户的信息，代码如下：/** * 角色的数据模型 */@Entity@Table(name=&quot;sys_role&quot;)public class SysRole implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=&quot;role_id&quot;) private Long roleId; @Column(name=&quot;role_name&quot;) private String roleName; @Column(name=&quot;role_memo&quot;) private String roleMemo; //多对多关系映射 @ManyToMany @JoinTable(name=&quot;user_role_rel&quot;,//中间表的名称 //中间表user_role_rel字段关联sys_role表的主键字段role_id joinColumns=&#123;@JoinColumn(name=&quot;role_id&quot;,referencedColumnName=&quot;role_id&quot;)&#125;, //中间表user_role_rel的字段关联sys_user表的主键user_id inverseJoinColumns=&#123;@JoinColumn(name=&quot;user_id&quot;,referencedColumnName=&quot;user_id&quot;)&#125; ) private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0); public Long getRoleId() &#123; return roleId; &#125; public void setRoleId(Long roleId) &#123; this.roleId = roleId; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getRoleMemo() &#123; return roleMemo; &#125; public void setRoleMemo(String roleMemo) &#123; this.roleMemo = roleMemo; &#125; public Set&lt;SysUser&gt; getUsers() &#123; return users; &#125; public void setUsers(Set&lt;SysUser&gt; users) &#123; this.users = users; &#125; @Override public String toString() &#123; return &quot;SysRole [roleId=&quot; + roleId + &quot;, roleName=&quot; + roleName + &quot;, roleMemo=&quot; + roleMemo + &quot;]&quot;; &#125;&#125;4.4 映射的注解说明@ManyToMany 作用：用于映射多对多关系 属性： cascade：配置级联操作。 fetch：配置是否采用延迟加载。 targetEntity：配置目标的实体类。映射多对多的时候不用写。@JoinTable 作用：针对中间表的配置 属性： nam：配置中间表的名称 joinColumns：中间表的外键字段关联当前实体类所对应表的主键字段 inverseJoinColumn：中间表的外键字段关联对方表的主键字段 @JoinColumn 作用：用于定义主键字段和外键字段的对应关系。 属性： name：指定外键字段的名称 referencedColumnName：指定引用主表的主键字段名称 unique：是否唯一。默认值不唯一 nullable：是否允许为空。默认值允许。 insertable：是否允许插入。默认值允许。 updatable：是否允许更新。默认值允许。 columnDefinition：列的定义信息。4.5 多对多的操作4.5.1 保存 @Autowired private UserDao userDao; @Autowired private RoleDao roleDao; /** * 需求： * 保存用户和角色 * 要求： * 创建2个用户和3个角色 * 让1号用户具有1号和2号角色(双向的) * 让2号用户具有2号和3号角色(双向的) * 保存用户和角色 * 问题： * 在保存时，会出现主键重复的错误，因为都是要往中间表中保存数据造成的。 * 解决办法： * 让任意一方放弃维护关联关系的权利 */ @Test @Transactional //开启事务 @Rollback(false)//设置为不回滚 public void test1()&#123; //创建对象 SysUser u1 = new SysUser(); u1.setUserName(&quot;用户1&quot;); SysRole r1 = new SysRole(); r1.setRoleName(&quot;角色1&quot;); //建立关联关系 u1.getRoles().add(r1); r1.getUsers().add(u1); //保存 roleDao.save(r1); userDao.save(u1); &#125;在多对多（保存）中，如果双向都设置关系，意味着双方都维护中间表，都会往中间表插入数据，中间表的2个字段又作为联合主键，所以报错，主键重复，解决保存失败的问题：只需要在任意一方放弃对中间表的维护权即可，推荐在被动的一方放弃，配置如下： //放弃对中间表的维护权，解决保存中主键冲突的问题 @ManyToMany(mappedBy=&quot;roles&quot;) private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0);4.5.2 删除 @Autowired private UserDao userDao; /** * 删除操作 * 在多对多的删除时，双向级联删除根本不能配置 * 禁用 * 如果配了的话，如果数据之间有相互引用关系，可能会清空所有数据 */ @Test @Transactional @Rollback(false)//设置为不回滚 public void testDelete() &#123; userDao.delete(1l); &#125; 对象导航查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293945.1 对象导航查询对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。例如：我们通过ID查询方式查出一个客户，可以调用Customer类中的getLinkMans()方法来获取该客户的所有联系人。对象导航查询的使用要求是：两个对象之间必须存在关联关系。查询一个客户，获取该客户下的所有联系人 @Autowired private CustomerDao customerDao; @Test //由于是在java代码中测试，为了解决no session问题，将操作配置到同一个事务中 @Transactional public void testFind() &#123; Customer customer = customerDao.findOne(5l); Set&lt;LinkMan&gt; linkMans = customer.getLinkMans();//对象导航查询 for(LinkMan linkMan : linkMans) &#123; System.out.println(linkMan); &#125; &#125;查询一个联系人，获取该联系人的所有客户 @Autowired private LinkManDao linkManDao; @Test public void testFind() &#123; LinkMan linkMan = linkManDao.findOne(4l); Customer customer = linkMan.getCustomer(); //对象导航查询 System.out.println(customer); &#125;对象导航查询的问题分析问题1：我们查询客户时，要不要把联系人查询出来？分析：如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的，不使用时又会白白的浪费了服务器内存。解决：采用延迟加载的思想。通过配置的方式来设定当我们在需要使用时，发起真正的查询。配置方式： /** * 在客户对象的@OneToMany注解中添加fetch属性 * FetchType.EAGER ：立即加载 * FetchType.LAZY ：延迟加载 */ @OneToMany(mappedBy=&quot;customer&quot;,fetch=FetchType.EAGER) private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;&gt;(0);问题2：我们查询联系人时，要不要把客户查询出来？分析：例如：查询联系人详情时，肯定会看看该联系人的所属客户。如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的话，一个对象不会消耗太多的内存。而且多数情况下我们都是要使用的。解决： 采用立即加载的思想。通过配置的方式来设定，只要查询从表实体，就把主表实体对象同时查出来配置方式 /** * 在联系人对象的@ManyToOne注解中添加fetch属性 * FetchType.EAGER ：立即加载 * FetchType.LAZY ：延迟加载 */ @ManyToOne(targetEntity=Customer.class,fetch=FetchType.EAGER) @JoinColumn(name=&quot;cst_lkm_id&quot;,referencedColumnName=&quot;cust_id&quot;) private Customer customer;5.2 使用Specification查询 /** * Specification的多表查询 */ @Test public void testFind() &#123; Specification&lt;LinkMan&gt; spec = new Specification&lt;LinkMan&gt;() &#123; public Predicate toPredicate(Root&lt;LinkMan&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; //Join代表链接查询，通过root对象获取 //创建的过程中，第一个参数为关联对象的属性名称，第二个参数为连接查询的方式（left，inner，right） //JoinType.LEFT : 左外连接,JoinType.INNER：内连接,JoinType.RIGHT：右外连接 Join&lt;LinkMan, Customer&gt; join = root.join(&quot;customer&quot;,JoinType.INNER); return cb.like(join.get(&quot;custName&quot;).as(String.class),&quot;传智播客1&quot;); &#125; &#125;; List&lt;LinkMan&gt; list = linkManDao.findAll(spec); for (LinkMan linkMan : list) &#123; System.out.println(linkMan); &#125; &#125;","categories":[{"name":"ORM","slug":"ORM","permalink":"https://shadowbynl.github.io/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"Java数据访问框架其二 | JPA规范与基本操作","slug":"Java数据访问框架其二-JPA规范与基本操作","date":"2020-06-25T15:35:48.000Z","updated":"2020-06-27T12:35:50.756Z","comments":true,"path":"2020/06/25/Java数据访问框架其二-JPA规范与基本操作/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E4%BA%8C-JPA%E8%A7%84%E8%8C%83%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"本篇从简介Hibernate框架出发，详细介绍JPA规范与接口。个人理解，JPA规范–Hibernate框架/Toplink框架–JDBC规范–JDBC驱动，层层抽象封装，但JPA作为一种规范，类似与JDBC的，其接口必然还可进一步作出封装，这就是后续会介绍的SpringData JPA实现的。","text":"本篇从简介Hibernate框架出发，详细介绍JPA规范与接口。个人理解，JPA规范–Hibernate框架/Toplink框架–JDBC规范–JDBC驱动，层层抽象封装，但JPA作为一种规范，类似与JDBC的，其接口必然还可进一步作出封装，这就是后续会介绍的SpringData JPA实现的。 先记述相关的笔记，然后为代码和配置的环境及过程中出现的问题与解决方法。 hibernate与JPA规范 一、hibernate概述Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 二、JPA概述JPA的全称是Java Persistence API， 即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成。 JPA通过JDK 5.0注解描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 三、JPA的优势 1234567891011121314151. 标准化 JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。2. 容器级特性的支持 JPA框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。3. 简单方便 JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成4. 查询能力 JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。5. 高级特性 JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。 四、JPA与hibernate的关系JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现。JPA和Hibernate的关系就像JDBC和JDBC驱动的关系，JPA是规范，Hibernate除了作为ORM框架之外，它也是一种JPA实现。JPA怎么取代Hibernate呢？JDBC规范可以驱动底层数据库吗？答案是否定的，也就是说，如果使用JPA规范进行数据库操作，底层需要hibernate作为其实现类完成数据持久化工作。 JPA API 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162jpa操作的操作步骤 1.加载配置文件创建实体管理器工厂 Persisitence：静态方法（根据持久化单元名称创建实体管理器工厂） createEntityMnagerFactory（持久化单元名称） 作用：创建实体管理器工厂 2.根据实体管理器工厂，创建实体管理器 EntityManagerFactory ：获取EntityManager对象 方法：createEntityManager * 内部维护的很多的内容 内部维护了数据库信息， 维护了缓存信息 维护了所有的实体管理器对象 再创建EntityManagerFactory的过程中会根据配置创建数据库表 * EntityManagerFactory的创建过程比较浪费资源 特点：线程安全的对象 多个线程访问同一个EntityManagerFactory不会有线程安全问题 * 如何解决EntityManagerFactory的创建过程浪费资源（耗时）的问题？ 思路：创建一个公共的EntityManagerFactory的对象 * 静态代码块的形式创建EntityManagerFactory 3.创建事务对象，开启事务 EntityManager对象：实体类管理器 beginTransaction : 创建事务对象 presist ： 保存 merge ： 更新 remove ： 删除 find/getRefrence ： 根据id查询 Transaction 对象 ： 事务 begin：开启事务 commit：提交事务 rollback：回滚 4.增删改查操作 5.提交事务 6.释放资源i.搭建环境的过程 1.创建maven工程导入坐标 2.需要配置jpa的核心配置文件 *位置：配置到类路径下的一个叫做 META-INF 的文件夹下 *命名：persistence.xml 3.编写客户的实体类 4.配置实体类和表，类中属性和表中字段的映射关系 5.保存客户到数据库中ii.完成基本CRUD案例 persist ： 保存 merge ： 更新 remove ： 删除 find/getRefrence ： 根据id查询 iii.jpql查询 sql：查询的是表和表中的字段 jpql：查询的是实体类和类中的属性 * jpql和sql语句的语法相似 1.查询全部 2.分页查询 3.统计查询 4.条件查询 5.排序 一、核心对象 Persistence对象Persistence对象主要作用是用于获取EntityManagerFactory对象的 。通过调用该类的createEntityManagerFactory静态方法，根据配置文件中持久化单元名称创建EntityManagerFactory。1234//1. 创建 EntitymanagerFactory@TestString unitName = &quot;myJpa&quot;;EntityManagerFactory factory= Persistence.createEntityManagerFactory(unitName); EntityManagerFactoryEntityManagerFactory 接口主要用来创建 EntityManager 实例由于EntityManagerFactory 是一个线程安全的对象（即多个线程访问同一个EntityManagerFactory 对象不会有线程安全问题），并且EntityManagerFactory 的创建极其浪费资源，所以在使用JPA编程时，我们可以对EntityManagerFactory 的创建进行优化，只需要做到一个工程只存在一个EntityManagerFactory 即可12//创建实体管理类EntityManager em = factory.createEntityManager(); EntityManager在 JPA 规范中, EntityManager是完成持久化操作的核心对象。实体类作为普通 java对象，只有在调用 EntityManager将其持久化后才会变成持久化对象。EntityManager对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。我们可以通过调用EntityManager的方法完成获取事务，以及持久化数据库的操作方法说明：12345getTransaction : 获取事务对象persist ： 保存操作merge ： 更新操作remove ： 删除操作find/getReference ： 根据id查询 EntityTransaction在 JPA 规范中, EntityTransaction是完成事务操作的核心对象，对于EntityTransaction在我们的java代码中承接的功能比较简单123begin：开启事务commit：提交事务rollback：回滚事务 二、基本增删改查 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package cn.itcast.test;import cn.itcast.domain.Customer;import cn.itcast.utils.JpaUtils;import org.junit.Test;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class JpaTest &#123; /** * 测试jpa的保存 * 案例：保存一个客户到数据库中 * Jpa的操作步骤 * 1.加载配置文件创建工厂（实体管理器工厂）对象 * 2.通过实体管理器工厂获取实体管理器 * 3.获取事务对象，开启事务 * 4.完成增删改查操作 * 5.提交事务（回滚事务） * 6.释放资源 */ @Test public void testSave() &#123;// //1.加载配置文件创建工厂（实体管理器工厂）对象// EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);// //2.通过实体管理器工厂获取实体管理器// EntityManager em = factory.createEntityManager(); EntityManager em = JpaUtils.getEntityManager(); //3.获取事务对象，开启事务 EntityTransaction tx = em.getTransaction(); //获取事务对象 tx.begin();//开启事务 //4.完成增删改查操作：保存一个客户到数据库中 Customer customer = new Customer(); customer.setCustName(&quot;传智播客&quot;); customer.setCustIndustry(&quot;教育&quot;); //保存， em.persist(customer); //保存操作 //5.提交事务 tx.commit(); //6.释放资源 em.close(); // factory.close(); &#125; /** * 根据id查询客户 * 使用find方法查询： * 1.查询的对象就是当前客户对象本身 * 2.在调用find方法的时候，就会发送sql语句查询数据库 * * 立即加载 * * */ @Test public void testFind() &#123; //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 根据id查询客户 /** * find : 根据id查询数据 * class：查询数据的结果需要包装的实体类类型的字节码 * id：查询的主键的取值 */ Customer customer = entityManager.find(Customer.class, 1l); // System.out.print(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); &#125; /** * 根据id查询客户 * getReference方法 * 1.获取的对象是一个动态代理对象 * 2.调用getReference方法不会立即发送sql语句查询数据库 * * 当调用查询结果对象的时候，才会发送查询的sql语句：什么时候用，什么时候发送sql语句查询数据库 * * 延迟加载（懒加载） * * 得到的是一个动态代理对象 * * 什么时候用，什么使用才会查询 */ @Test public void testReference() &#123; //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 根据id查询客户 /** * getReference : 根据id查询数据 * class：查询数据的结果需要包装的实体类类型的字节码 * id：查询的主键的取值 */ Customer customer = entityManager.getReference(Customer.class, 1l); System.out.print(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); &#125; /** * 删除客户的案例 * */ @Test public void testRemove() &#123; //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 删除客户 //i 根据id查询客户 Customer customer = entityManager.find(Customer.class,1l); //ii 调用remove方法完成删除操作 entityManager.remove(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); &#125; /** * 更新客户的操作 * merge(Object) */ @Test public void testUpdate() &#123; //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 更新操作 //i 查询客户 Customer customer = entityManager.find(Customer.class,1l); //ii 更新客户 customer.setCustIndustry(&quot;it教育&quot;); entityManager.merge(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931 保存 /** * 保存一个实体 */ @Test public void testAdd() &#123; // 定义对象 Customer c = new Customer(); c.setCustName(&quot;传智学院&quot;); c.setCustLevel(&quot;VIP客户&quot;); c.setCustSource(&quot;网络&quot;); c.setCustIndustry(&quot;IT教育&quot;); c.setCustAddress(&quot;昌平区北七家镇&quot;); c.setCustPhone(&quot;010-84389340&quot;); EntityManager em = null; EntityTransaction tx = null; try &#123; // 获取实体管理对象 em = JPAUtil.getEntityManager(); // 获取事务对象 tx = em.getTransaction(); // 开启事务 tx.begin(); // 执行操作 em.persist(c); // 提交事务 tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;2 修改 @Test public void testMerge()&#123; //定义对象 EntityManager em=null; EntityTransaction tx=null; try&#123; //获取实体管理对象 em=JPAUtil.getEntityManager(); //获取事务对象 tx=em.getTransaction(); //开启事务 tx.begin(); //执行操作 Customer c1 = em.find(Customer.class, 6L); c1.setCustName(&quot;江苏传智学院&quot;); em.clear();//把c1对象从缓存中清除出去 em.merge(c1); //提交事务 tx.commit(); &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); e.printStackTrace(); &#125;finally&#123; //释放资源 em.close(); &#125; &#125;3 删除 /** * 删除 */ @Test public void testRemove() &#123; // 定义对象 EntityManager em = null; EntityTransaction tx = null; try &#123; // 获取实体管理对象 em = JPAUtil.getEntityManager(); // 获取事务对象 tx = em.getTransaction(); // 开启事务 tx.begin(); // 执行操作 Customer c1 = em.find(Customer.class, 6L); em.remove(c1); // 提交事务 tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;4 根据id查询 /** * 查询一个： 使用立即加载的策略 */ @Test public void testGetOne() &#123; // 定义对象 EntityManager em = null; EntityTransaction tx = null; try &#123; // 获取实体管理对象 em = JPAUtil.getEntityManager(); // 获取事务对象 tx = em.getTransaction(); // 开启事务 tx.begin(); // 执行操作 Customer c1 = em.find(Customer.class, 1L); // 提交事务 tx.commit(); System.out.println(c1); // 输出查询对象 &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125; // 查询实体的缓存问题 @Test public void testGetOne() &#123; // 定义对象 EntityManager em = null; EntityTransaction tx = null; try &#123; // 获取实体管理对象 em = JPAUtil.getEntityManager(); // 获取事务对象 tx = em.getTransaction(); // 开启事务 tx.begin(); // 执行操作 Customer c1 = em.find(Customer.class, 1L); Customer c2 = em.find(Customer.class, 1L); System.out.println(c1 == c2);// 输出结果是true，EntityManager也有缓存 // 提交事务 tx.commit(); System.out.println(c1); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125; // 延迟加载策略的方法： /** * 查询一个： 使用延迟加载策略 */ @Test public void testLoadOne() &#123; // 定义对象 EntityManager em = null; EntityTransaction tx = null; try &#123; // 获取实体管理对象 em = JPAUtil.getEntityManager(); // 获取事务对象 tx = em.getTransaction(); // 开启事务 tx.begin(); // 执行操作 Customer c1 = em.getReference(Customer.class, 1L); // 提交事务 tx.commit(); System.out.println(c1); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125; 三、Jpql查询JPQL全称Java Persistence Query Language 基于首次在EJB2.0中引入的EJB查询语言(EJB QL),Java持久化查询语言(JPQL)是一种可移植的查询语言，旨在以面向对象表达式语言的表达式，将SQL语法和简单查询语义绑定在一起·使用这种语言编写的查询是可移植的，可以被编译成所有主流数据库服务器上的SQL。 其特征与原生SQL语句类似，并且完全面向对象，通过类名和属性访问，而不是表名和表的属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197package cn.itcast.test;import cn.itcast.domain.Customer;import cn.itcast.utils.JpaUtils;import org.junit.Test;import javax.persistence.EntityManager;import javax.persistence.EntityTransaction;import javax.persistence.Query;import java.util.List;/** * 测试jqpl查询 */public class JpqlTest &#123; /** * 查询全部 * jqpl：from cn.itcast.domain.Customer * sql：SELECT * FROM cst_customer */ @Test public void testFindAll() &#123; //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 String jpql = &quot;from Customer &quot;; Query query = em.createQuery(jpql);//创建Query查询对象，query对象才是执行jqpl的对象 //发送查询，并封装结果集 List list = query.getResultList(); for (Object obj : list) &#123; System.out.print(obj); &#125; //4.提交事务 tx.commit(); //5.释放资源 em.close(); &#125; /** * 排序查询： 倒序查询全部客户（根据id倒序） * sql：SELECT * FROM cst_customer ORDER BY cust_id DESC * jpql：from Customer order by custId desc * * 进行jpql查询 * 1.创建query查询对象 * 2.对参数进行赋值 * 3.查询，并得到返回结果 */ @Test public void testOrders() &#123; //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 String jpql = &quot;from Customer order by custId desc&quot;; Query query = em.createQuery(jpql);//创建Query查询对象，query对象才是执行jqpl的对象 //发送查询，并封装结果集 List list = query.getResultList(); for (Object obj : list) &#123; System.out.println(obj); &#125; //4.提交事务 tx.commit(); //5.释放资源 em.close(); &#125; /** * 使用jpql查询，统计客户的总数 * sql：SELECT COUNT(cust_id) FROM cst_customer * jpql：select count(custId) from Customer */ @Test public void testCount() &#123; //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 //i.根据jpql语句创建Query查询对象 String jpql = &quot;select count(custId) from Customer&quot;; Query query = em.createQuery(jpql); //ii.对参数赋值 //iii.发送查询，并封装结果 /** * getResultList ： 直接将查询结果封装为list集合 * getSingleResult : 得到唯一的结果集 */ Object result = query.getSingleResult(); System.out.println(result); //4.提交事务 tx.commit(); //5.释放资源 em.close(); &#125; /** * 分页查询 * sql：select * from cst_customer limit 0,2 * jqpl : from Customer */ @Test public void testPaged() &#123; //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 //i.根据jpql语句创建Query查询对象 String jpql = &quot;from Customer&quot;; Query query = em.createQuery(jpql); //ii.对参数赋值 -- 分页参数 //起始索引 query.setFirstResult(0); //每页查询的条数 query.setMaxResults(2); //iii.发送查询，并封装结果 /** * getResultList ： 直接将查询结果封装为list集合 * getSingleResult : 得到唯一的结果集 */ List list = query.getResultList(); for(Object obj : list) &#123; System.out.println(obj); &#125; //4.提交事务 tx.commit(); //5.释放资源 em.close(); &#125; /** * 条件查询 * 案例：查询客户名称以‘传智播客’开头的客户 * sql：SELECT * FROM cst_customer WHERE cust_name LIKE ? * jpql : from Customer where custName like ? */ @Test public void testCondition() &#123; //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 //i.根据jpql语句创建Query查询对象 String jpql = &quot;from Customer where custName like ? &quot;; Query query = em.createQuery(jpql); //ii.对参数赋值 -- 占位符参数 //第一个参数：占位符的索引位置（从1开始），第二个参数：取值 query.setParameter(1,&quot;传智播客%&quot;); //iii.发送查询，并封装结果 /** * getResultList ： 直接将查询结果封装为list集合 * getSingleResult : 得到唯一的结果集 */ List list = query.getResultList(); for(Object obj : list) &#123; System.out.println(obj); &#125; //4.提交事务 tx.commit(); //5.释放资源 em.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641 查询全部 //查询所有客户 @Test public void findAll() &#123; EntityManager em = null; EntityTransaction tx = null; try &#123; //获取实体管理对象 em = JPAUtil.getEntityManager(); //获取事务对象 tx = em.getTransaction(); tx.begin(); // 创建query对象 String jpql = &quot;from Customer&quot;; Query query = em.createQuery(jpql); // 查询并得到返回结果 List list = query.getResultList(); // 得到集合返回类型 for (Object object : list) &#123; System.out.println(object); &#125; tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;2 分页查询 //分页查询客户 @Test public void findPaged () &#123; EntityManager em = null; EntityTransaction tx = null; try &#123; //获取实体管理对象 em = JPAUtil.getEntityManager(); //获取事务对象 tx = em.getTransaction(); tx.begin(); //创建query对象 String jpql = &quot;from Customer&quot;; Query query = em.createQuery(jpql); //起始索引 query.setFirstResult(0); //每页显示条数 query.setMaxResults(2); //查询并得到返回结果 List list = query.getResultList(); //得到集合返回类型 for (Object object : list) &#123; System.out.println(object); &#125; tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;3 条件查询 //条件查询 @Test public void findCondition () &#123; EntityManager em = null; EntityTransaction tx = null; try &#123; //获取实体管理对象 em = JPAUtil.getEntityManager(); //获取事务对象 tx = em.getTransaction(); tx.begin(); //创建query对象 String jpql = &quot;from Customer where custName like ? &quot;; Query query = em.createQuery(jpql); //对占位符赋值，从1开始 query.setParameter(1, &quot;传智播客%&quot;); //查询并得到返回结果 Object object = query.getSingleResult(); //得到唯一的结果集对象 System.out.println(object); tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;4 排序查询 //根据客户id倒序查询所有客户 //查询所有客户 @Test public void testOrder() &#123; EntityManager em = null; EntityTransaction tx = null; try &#123; //获取实体管理对象 em = JPAUtil.getEntityManager(); //获取事务对象 tx = em.getTransaction(); tx.begin(); // 创建query对象 String jpql = &quot;from Customer order by custId desc&quot;; Query query = em.createQuery(jpql); // 查询并得到返回结果 List list = query.getResultList(); // 得到集合返回类型 for (Object object : list) &#123; System.out.println(object); &#125; tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;5 统计查询 //统计查询 @Test public void findCount() &#123; EntityManager em = null; EntityTransaction tx = null; try &#123; //获取实体管理对象 em = JPAUtil.getEntityManager(); //获取事务对象 tx = em.getTransaction(); tx.begin(); // 查询全部客户 // 1.创建query对象 String jpql = &quot;select count(custId) from Customer&quot;; Query query = em.createQuery(jpql); // 2.查询并得到返回结果 Object count = query.getSingleResult(); // 得到集合返回类型 System.out.println(count); tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125; JPA测试配置首先在这里写一下我在配置JPA和SpringData JPA过程中遇到数个错误采取多种措施之后解决所得的结论：第一，JPA实体类中@Table等注解有红线，其实不用管，当然我查了很多赋予数据源的设置，也尝试过，使红线消失了，但对问题的解决没有帮助，该报错还是报错。因此我得出了编译器中这个红线不用管的结论，当然也可以配置，在下面我会给出方法。第二，说是JPA，其实实现多半都是Hibernate相关的额一些配置，因此相关的版本和依赖是根本问题。说一下我发现的几点：其一是单用JPA测试或SpringData JPA测试最好用jdk1.8，当然jdk11行不行没测试过，但有一个地方必须配，必须添几个依赖，不然就算1.8也会不错，在下面会贴出来；其二是若用springboot整合springdata jpa的话就不用在意这个问题，当然也许实体类注解也会有红线，但只要yml文件中数据库配置正确，就毫无影响。 下面贴一下可以正确运行的相关配置pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;jpa&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.hibernate.version&gt;5.0.7.Final&lt;/project.hibernate.version&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;!-- &lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;!-- hibernate对jpa的支持包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt; &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mysql驱动 --&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 解决因jdk版本等原因造成的java.lang.ClassNotFoundException: javax.xml.bind.JAXBException问题 --&gt; &lt;!-- 参考 https://blog.csdn.net/w405722907/article/details/80523790 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; resources/META-INF/persistence.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;2.0&quot;&gt; &lt;!--需要配置persistence-unit节点 持久化单元： name：持久化单元名称 transaction-type：事务管理的方式 JTA：分布式事务管理 RESOURCE_LOCAL：本地事务管理 --&gt; &lt;persistence-unit name=&quot;myJpa&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; &lt;!--jpa的实现方式 --&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;!--可选配置：配置jpa实现方的配置信息--&gt; &lt;properties&gt; &lt;!-- 数据库信息 用户名，javax.persistence.jdbc.user 密码， javax.persistence.jdbc.password 驱动， javax.persistence.jdbc.driver 数据库地址 javax.persistence.jdbc.url --&gt; &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;123456&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:mysql:///senior&quot;/&gt; &lt;!--配置jpa实现方(hibernate)的配置信息 显示sql ： false|true 自动创建数据库表 ： hibernate.hbm2ddl.auto create : 程序运行时创建数据库表（如果有表，先删除表再创建） update ：程序运行时创建表（如果有表，不会创建表） none ：不会创建表 --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot; /&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 附：JPA数据源设置https://blog.csdn.net/w405722907/article/details/84643906mysql时区https://www.cnblogs.com/mengw/p/12213093.htmljdbc:mysql://localhost/blog?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC 附：实体类映射示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package cn.itcast.domain;import org.hibernate.annotations.Proxy;import javax.persistence.*;/** * 客户的实体类 * 配置映射关系 * * * 1.实体类和表的映射关系 * @Entity:声明实体类 * @Table : 配置实体类和表的映射关系 * name : 配置数据库表的名称 * 2.实体类中属性和表中字段的映射关系 * * */@Entity@Table(name = &quot;cst_customer&quot;)public class Customer &#123; /** * @Id：声明主键的配置 * @GeneratedValue:配置主键的生成策略 * strategy * GenerationType.IDENTITY ：自增，mysql * * 底层数据库必须支持自动增长（底层数据库支持的自动增长方式，对id自增） * GenerationType.SEQUENCE : 序列，oracle * * 底层数据库必须支持序列 * GenerationType.TABLE : jpa提供的一种机制，通过一张数据库表的形式帮助我们完成主键自增 * GenerationType.AUTO ： 由程序自动的帮助我们选择主键生成策略 * @Column:配置属性和字段的映射关系 * name：数据库表中字段的名称 */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;cust_id&quot;) private Long custId; //客户的主键 @Column(name = &quot;cust_name&quot;) private String custName;//客户名称 @Column(name=&quot;cust_source&quot;) private String custSource;//客户来源 @Column(name=&quot;cust_level&quot;) private String custLevel;//客户级别 @Column(name=&quot;cust_industry&quot;) private String custIndustry;//客户所属行业 @Column(name=&quot;cust_phone&quot;) private String custPhone;//客户的联系方式 @Column(name=&quot;cust_address&quot;) private String custAddress;//客户地址 public Long getCustId() &#123; return custId; &#125; public void setCustId(Long custId) &#123; this.custId = custId; &#125; public String getCustName() &#123; return custName; &#125; public void setCustName(String custName) &#123; this.custName = custName; &#125; public String getCustSource() &#123; return custSource; &#125; public void setCustSource(String custSource) &#123; this.custSource = custSource; &#125; public String getCustLevel() &#123; return custLevel; &#125; public void setCustLevel(String custLevel) &#123; this.custLevel = custLevel; &#125; public String getCustIndustry() &#123; return custIndustry; &#125; public void setCustIndustry(String custIndustry) &#123; this.custIndustry = custIndustry; &#125; public String getCustPhone() &#123; return custPhone; &#125; public void setCustPhone(String custPhone) &#123; this.custPhone = custPhone; &#125; public String getCustAddress() &#123; return custAddress; &#125; public void setCustAddress(String custAddress) &#123; this.custAddress = custAddress; &#125; @Override public String toString() &#123; return &quot;Customer&#123;&quot; + &quot;custId=&quot; + custId + &quot;, custName=&#x27;&quot; + custName + &#x27;\\&#x27;&#x27; + &quot;, custSource=&#x27;&quot; + custSource + &#x27;\\&#x27;&#x27; + &quot;, custLevel=&#x27;&quot; + custLevel + &#x27;\\&#x27;&#x27; + &quot;, custIndustry=&#x27;&quot; + custIndustry + &#x27;\\&#x27;&#x27; + &quot;, custPhone=&#x27;&quot; + custPhone + &#x27;\\&#x27;&#x27; + &quot;, custAddress=&#x27;&quot; + custAddress + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;","categories":[{"name":"ORM","slug":"ORM","permalink":"https://shadowbynl.github.io/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"Java数据访问框架其一 | 概述","slug":"Java数据访问框架其一-概述","date":"2020-06-25T15:07:41.000Z","updated":"2020-06-26T15:17:23.599Z","comments":true,"path":"2020/06/25/Java数据访问框架其一-概述/","link":"","permalink":"https://shadowbynl.github.io/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E4%B8%80-%E6%A6%82%E8%BF%B0/","excerpt":"写作目的","text":"写作目的 自年初以来，陆续学习了ssm、springboot、springdata jpa、spring security等框架以及相关的一些基础技术，如restful风格、前端模板引擎等，此外还为一些其他的需要学习过java爬虫相关框架和python的web框架等。经过该阶段的学习，我认识到需要对已经了解到的内容进行简单归类总结。对于一个框架，认识其核心原理+功能+配置是最关键的，而要掌握的第一步就是有一个可行的环境。在这些框架中，有些功能类似但原理有所差异，因此在该系列篇章中，我会就ORM、安全、模板、日志、控制器等方面就JavaWeb相关的框架及一些技术进行简单介绍和归纳整理。突出介绍其原理、基本使用和环境配置，保证环境切实可用。 ORM框架概述 ORM（Object-Relational Mapping） 表示对象关系映射。在面向对象的软件开发中，通过ORM，就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了ORM对象关系映射 简单的说：ORM就是建立实体类和数据库表之间的关系，从而达到操作实体类就相当于操作数据库表的目的。 为什么使用ORM 当实现一个应用程序时（不使用O/R Mapping），我们可能会写特别多数据访问层的代码，从数据库保存数据、修改数据、删除数据，而这些代码都是重复的。而使用ORM则会大大减少重复性代码。对象关系映射（Object Relational Mapping，简称ORM），主要实现程序对象到关系数据库数据的映射。 常见ORM框架 常见的orm框架：Mybatis（ibatis）、Hibernate、Jpa orm思想 12345678主要目的：操作实体类就相当于操作数据库表建立两个映射关系： 实体类和表的映射关系 实体类中属性和表中字段的映射关系不再重点关注：sql语句实现了ORM思想的框架：mybatis，hibernate 接下来的几篇，会从JPA规范写起，技术JPA接口、SpringData JPA接口与集成、Mybatis集成以及两种ORM的对比。","categories":[{"name":"ORM","slug":"ORM","permalink":"https://shadowbynl.github.io/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"docker","slug":"docker","date":"2020-06-23T10:46:53.000Z","updated":"2020-06-23T13:20:49.290Z","comments":true,"path":"2020/06/23/docker/","link":"","permalink":"https://shadowbynl.github.io/2020/06/23/docker/","excerpt":"该篇记述一下docker的安装，基本命令与tomcat、mysql的配置。","text":"该篇记述一下docker的安装，基本命令与tomcat、mysql的配置。 一、docker安装参考 https://blog.csdn.net/b9567/article/details/105027440/ 1234567891011121314151617181920212223# 安装需要的包sudo apt-get update# 安装 apt 依赖包，用于通过HTTPS来获取仓库sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common # 添加 Docker 的官方 GPG 密钥curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 设置稳定版仓库sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;# 安装 Docker-cesudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io 修改docker镜像参考 https://blog.csdn.net/jixuju/article/details/80158493 1234567891011121314docker默认的源为国外官方源，下载速度较慢，可改为国内，加速方案一修改或新增 /etc/docker/daemon.jsonvi /etc/docker/daemon.json&#123;&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]&#125;systemctl restart docker.service其余参考 https://blog.csdn.net/whatday/article/details/86770609https://blog.csdn.net/niukaoying6674/article/details/87788282 二、docker基本命令https://hub.docker.com/ 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run ‐‐name mytomcat ‐d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps ‐a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run ‐d ‐p 8888:8080 tomcat‐d：后台运行‐p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container‐name/container‐id 更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 三、实例以下均为下载镜像后，启动容器运行实例的命令。 tomcat12docker run --name tomcat -d -p 8080:8080 -v /root/tomcat:/usr/local/tomcat/webapps tomcat mysql12docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=password -d mysql:5.5.62 四、配置过程中存在的问题与参考 高版本tomcat无法访问默认页面https://blog.csdn.net/weixin_42970847/article/details/104534764https://blog.csdn.net/weixin_43309946/article/details/103223091https://blog.csdn.net/LZJSTUDY/article/details/81097534 docker的挂载目录https://www.baidu.com/s?wd=docker%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%9B%AE%E5%BD%95&amp;rsv_spt=1&amp;rsv_iqid=0xcc387ff200244ee5&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=20&amp;rsv_sug1=10&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=5030&amp;rsv_sug4=5029https://www.cnblogs.com/douh/p/12560439.htmlhttp://www.manongjc.com/article/148684.htmlhttps://www.jianshu.com/p/806485990aeahttps://blog.csdn.net/one_chao/article/details/98671330https://blog.csdn.net/wywinstonwy/article/details/106612226https://blog.csdn.net/i042416/article/details/82900177","categories":[{"name":"容器","slug":"容器","permalink":"https://shadowbynl.github.io/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"go-study-4","slug":"go-study-4","date":"2020-06-23T07:13:57.000Z","updated":"2020-06-25T15:31:52.584Z","comments":true,"path":"2020/06/23/go-study-4/","link":"","permalink":"https://shadowbynl.github.io/2020/06/23/go-study-4/","excerpt":"Go基础学习其四","text":"Go基础学习其四 2020.6.20-21 学习了go复合类型中的指针、结构体类型，还有通过方法、接口等实现模拟OOP的语法，type关键字的使用，错误处理、包的管理等概念。先记录一下我在学习时觉得需要注意的点，然后copy千锋的笔记和代码。个人笔记一、首先是一个问题，go是面向过程的还是面向对象的参考 https://www.zhihu.com/question/315995798/answer/623870413https://www.cnblogs.com/wangerhu/p/11397479.html一个答主的结论：严格来讲，Go不是OOP的语言，但是又允许有OOP的编程风格。Go中没有class等。但可以结合结构体、方法、接口实现OOP式的编程。二、指针 指针的语法和c类似 声明 var var_name *var_type 三、结构体 四种创建方式。成员变量首字母大写公有，小写私有。这对Go中一切变量、函数等的定义都是相同的。 通过new(T)返回结构体T类型的指针 go的结构体指针和结构体都是用.取成员变量的，不像c结构体指针是用-&gt;的。 匿名字段 四、OOP 结构体类型的匿名字段可以模拟继承关系，不匿名的就是模拟聚合 提升字段 五、方法method 与函数的区别在于指明了调用者 func (t Type) name()(){}，实际上t指明了结构体类型，则该方法就相当于此结构体的成员方法。 method继承 六、接口 go的接口是非侵入式的，这是它的一个显著特征。不需要指明接口，只需要指明接口中的方法，但必须实现所有的方法。 只要一个结构体实现了接口中的方法，就是实现了该接口，在传参时就可作为该接口的类型。 多态：一个函数如果接受接口类型作为参数，那么实际上可以传入该接口的任意实现类型对象作为参数；定义一个类型为接口类型，实际上可以赋值为任意实现类的对象。 空接口(interface{}) 不包含任何的方法，正因为如此，所有的类型都实现了空接口，因此空接口可以存储任意类型的数值。以空接口为参数表示可接收任意类型的参数。这样可定义接收任意类型参数的函数，存储任意类型的切片、数组、集合。 接口嵌套 接口断言：在以接口类型为参数的函数中获取其实际类型，就是根据断言判断其类型。 七、type关键字type关键字：定义类型、类型别名、注意两种使用方式的区别。 八、错误处理 go和java中都区分错误和异常，但定义和处理方式都有很大区别。参考：javahttps://www.jb51.net/article/92115.htmhttps://www.cnblogs.com/cyydmlrs520/p/11350047.htmlhttps://blog.csdn.net/qq_42350107/article/details/82588228https://www.cnblogs.com/prayjourney/p/11099388.htmlgohttps://www.jianshu.com/p/2ce9cc81712bhttps://www.jianshu.com/p/40cbeb02520f go中的错误error：error类型、创建error的方法、定义返回error的函数。 自定义error：定义结构体，表示错误类型，实现error接口 实现Error()方法。 panic和recover实现异常处理。 九、包的管理 目录的名字和包的名字不一定一致，但最好一致 同一目录下的package相同 导包，绝对路径（src起）和相对路径 init函数 go的变量定义不使用 包导入而未使用其中的函数或定义的变量等 都会报错 如果只想导入包中的init 那么可用 _ 注意导包是以包为单位 可有多个go文件在一个包中，导入时不区分哪个文件 第三方包通过 go get 下到gopath的 src下 笔记 一、指针 @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 指针的概念指针是存储另一个变量的内存地址的变量。 我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。 一个指针变量可以指向任何一个值的内存地址它指向那个值的内存地址。 在上面的图中，变量b的值为156，存储在内存地址0x1040a124。变量a持有b的地址，现在a被认为指向b。 1.2 获取变量的地址Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。 123456789package mainimport &quot;fmt&quot;func main() &#123; var a int = 10 fmt.Printf(&quot;变量的地址: %x\\n&quot;, &amp;a )&#125; 运行结果： 1变量的地址: 20818a220 1.3 声明指针声明指针，*T是指针变量的类型，它指向T类型的值。 1var var_name *var-type var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。 12var ip *int /* 指向整型*/var fp *float32 /* 指向浮点型 */ 示例代码： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; var a int= 20 /* 声明实际变量 */ var ip *int /* 声明指针变量 */ ip = &amp;a /* 指针变量的存储地址 */ fmt.Printf(&quot;a 变量的地址是: %x\\n&quot;, &amp;a ) /* 指针变量的存储地址 */ fmt.Printf(&quot;ip 变量的存储地址: %x\\n&quot;, ip ) /* 使用指针访问值 */ fmt.Printf(&quot;*ip 变量的值: %d\\n&quot;, *ip )&#125; 运行结果： 123a 变量的地址是: 20818a220ip 变量的存储地址: 20818a220*ip 变量的值: 20 示例代码： 1234567891011121314151617package mainimport &quot;fmt&quot;type name int8type first struct &#123; a int b bool name&#125;func main() &#123; a := new(first) a.a = 1 a.name = 11 fmt.Println(a.b, a.a, a.name)&#125; 运行结果： 1false 1 11 未初始化的变量自动赋上初始值 12345678910111213141516package mainimport &quot;fmt&quot;type name int8type first struct &#123; a int b bool name&#125;func main() &#123; var a = first&#123;1, false, 2&#125; var b *first = &amp;a fmt.Println(a.b, a.a, a.name, &amp;a, b.a, &amp;b, (*b).a)&#125; 运行结果： 1false 1 2 &amp;&#123;1 false 2&#125; 1 0xc042068018 1 获取指针地址在指针变量前加&amp;的方式 1.4 空指针Go 空指针当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。一个指针变量通常缩写为 ptr。 空指针判断： 12if(ptr != nil) /* ptr 不是空指针 */if(ptr == nil) /* ptr 是空指针 */ 1.5 获取指针的值获取一个指针意味着访问指针指向的变量的值。语法是：*a 示例代码： 1234567891011package main import ( &quot;fmt&quot;)func main() &#123; b := 255 a := &amp;b fmt.Println(&quot;address of b is&quot;, a) fmt.Println(&quot;value of b is&quot;, *a)&#125; 1.6 操作指针改变变量的数值示例代码： 1234567891011121314package mainimport ( &quot;fmt&quot;)func main() &#123; b := 255 a := &amp;b fmt.Println(&quot;address of b is&quot;, a) fmt.Println(&quot;value of b is&quot;, *a) *a++ fmt.Println(&quot;new value of b is&quot;, b)&#125; 运行结果 123address of b is 0x1040a124 value of b is 255 new value of b is 256 1.7 使用指针传递函数的参数示例代码 12345678910111213141516package mainimport ( &quot;fmt&quot;)func change(val *int) &#123; *val = 55&#125;func main() &#123; a := 58 fmt.Println(&quot;value of a before function call is&quot;,a) b := &amp;a change(b) fmt.Println(&quot;value of a after function call is&quot;, a)&#125; 运行结果 12value of a before function call is 58 value of a after function call is 55 不要将一个指向数组的指针传递给函数。使用切片。 假设我们想对函数内的数组进行一些修改，并且对调用者可以看到函数内的数组所做的更改。一种方法是将一个指向数组的指针传递给函数。 12345678910111213141516package mainimport ( &quot;fmt&quot;)func modify(arr *[3]int) &#123; (*arr)[0] = 90&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(&amp;a) fmt.Println(a)&#125; 运行结果 12[90 90 91] 示例代码： 12345678910111213141516package mainimport ( &quot;fmt&quot;)func modify(arr *[3]int) &#123; arr[0] = 90&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(&amp;a) fmt.Println(a)&#125; 运行结果 12[90 90 91] 虽然将指针传递给一个数组作为函数的参数并对其进行修改，但这并不是实现这一目标的惯用方法。我们有切片。 示例代码： 12345678910111213141516package mainimport ( &quot;fmt&quot;)func modify(sls []int) &#123; sls[0] = 90&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(a[:]) fmt.Println(a)&#125; 运行结果： 12[90 90 91] Go不支持指针算法。 package main func main() {b := […]int{109, 110, 111}p := &amp;bp++} nvalid operation: p++ (non-numeric type *[3]int) 指针数组 12345678910111213141516package mainimport &quot;fmt&quot;const MAX int = 3func main() &#123; a := []int&#123;10,100,200&#125; var i int for i = 0; i &lt; MAX; i++ &#123; fmt.Printf(&quot;a[%d] = %d\\n&quot;, i, a[i] ) &#125;&#125; 结果 1234a[0] = 10a[1] = 100a[2] = 200 有一种情况，我们可能需要保存数组，这样我们就需要使用到指针。 1234567891011121314151617181920package mainimport &quot;fmt&quot;const MAX int = 3func main() &#123; a := []int&#123;10,100,200&#125; var i int var ptr [MAX]*int; for i = 0; i &lt; MAX; i++ &#123; ptr[i] = &amp;a[i] /* 整数地址赋值给指针数组 */ &#125; for i = 0; i &lt; MAX; i++ &#123; fmt.Printf(&quot;a[%d] = %d\\n&quot;, i,*ptr[i] ) &#125;&#125; 结果 1234a[0] = 10a[1] = 100a[2] = 200 1.8 指针的指针指针的指针 如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。 12var ptr **int; 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; var a int var ptr *int var pptr **int a = 3000 /* 指针 ptr 地址 */ ptr = &amp;a /* 指向指针 ptr 地址 */ pptr = &amp;ptr /* 获取 pptr 的值 */ fmt.Printf(&quot;变量 a = %d\\n&quot;, a ) fmt.Printf(&quot;指针变量 *ptr = %d\\n&quot;, *ptr ) fmt.Printf(&quot;指向指针的指针变量 **pptr = %d\\n&quot;, **pptr)&#125; 结果 1234变量 a = 3000指针变量 *ptr = 3000指向指针的指针变量 **pptr = 3000 指针作为函数参数 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;func main() &#123; /* 定义局部变量 */ var a int = 100 var b int= 200 fmt.Printf(&quot;交换前 a 的值 : %d\\n&quot;, a ) fmt.Printf(&quot;交换前 b 的值 : %d\\n&quot;, b ) /* 调用函数用于交换值 * &amp;a 指向 a 变量的地址 * &amp;b 指向 b 变量的地址 */ swap(&amp;a, &amp;b); fmt.Printf(&quot;交换后 a 的值 : %d\\n&quot;, a ) fmt.Printf(&quot;交换后 b 的值 : %d\\n&quot;, b )&#125;func swap(x *int, y *int) &#123; var temp int temp = *x /* 保存 x 地址的值 */ *x = *y /* 将 y 赋值给 x */ *y = temp /* 将 temp 赋值给 y */&#125; 结果 12345交换前 a 的值 : 100交换前 b 的值 : 200交换后 a 的值 : 200交换后 b 的值 : 100 一、结构体 @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是结构体Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。 1.2 结构体的定义和初始化123456type struct_variable_type struct &#123; member definition; member definition; ... member definition;&#125; 一旦定义了结构体类型，它就能用于变量的声明 1variable_name := structure_variable_type &#123;value1, value2...valuen&#125; 初始化结构体 1234567// 1.按照顺序提供初始化值P := person&#123;&quot;Tom&quot;, 25&#125;// 2.通过field:value的方式初始化，这样可以任意顺序P := person&#123;age:24, name:&quot;Tom&quot;&#125;// 3.new方式,未设置初始值的，会赋予类型的默认初始值p := new(person)p.age=24 1.3 结构体的访问访问结构体成员(访问结构的各个字段) 通过点.操作符用于访问结构的各个字段。 123456789101112131415161718192021222324252627282930313233343536373839package mainimport &quot;fmt&quot;type Books struct &#123; title string author string subject string book_id int&#125;func main() &#123; var Book1 Books /* 声明 Book1 为 Books 类型 */ var Book2 Books /* 声明 Book2 为 Books 类型 */ /* book 1 描述 */ Book1.title = &quot;Go 语言&quot; Book1.author = &quot;www.runoob.com&quot; Book1.subject = &quot;Go 语言教程&quot; Book1.book_id = 6495407 /* book 2 描述 */ Book2.title = &quot;Python 教程&quot; Book2.author = &quot;www.runoob.com&quot; Book2.subject = &quot;Python 语言教程&quot; Book2.book_id = 6495700 /* 打印 Book1 信息 */ fmt.Printf( &quot;Book 1 title : %s\\n&quot;, Book1.title) fmt.Printf( &quot;Book 1 author : %s\\n&quot;, Book1.author) fmt.Printf( &quot;Book 1 subject : %s\\n&quot;, Book1.subject) fmt.Printf( &quot;Book 1 book_id : %d\\n&quot;, Book1.book_id) /* 打印 Book2 信息 */ fmt.Printf( &quot;Book 2 title : %s\\n&quot;, Book2.title) fmt.Printf( &quot;Book 2 author : %s\\n&quot;, Book2.author) fmt.Printf( &quot;Book 2 subject : %s\\n&quot;, Book2.subject) fmt.Printf( &quot;Book 2 book_id : %d\\n&quot;, Book2.book_id)&#125; 运行结果： 12345678Book 1 title : Go 语言Book 1 author : www.runoob.comBook 1 subject : Go 语言教程Book 1 book_id : 6495407Book 2 title : Python 教程Book 2 author : www.runoob.comBook 2 subject : Python 语言教程Book 2 book_id : 6495700 1.4 结构体指针指针指向一个结构体也可以创建指向结构的指针。 结构体指针 1var struct_pointer *Books 以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前 1struct_pointer = &amp;Book1; 使用结构体指针访问结构体成员，使用 “.” 操作符 1struct_pointer.title; 123456789101112131415161718192021222324252627282930313233343536373839package mainimport &quot;fmt&quot;type Books struct &#123; title string author string subject string book_id int&#125;func main() &#123; var Book1 Books /* Declare Book1 of type Book */ var Book2 Books /* Declare Book2 of type Book */ /* book 1 描述 */ Book1.title = &quot;Go 语言&quot; Book1.author = &quot;www.runoob.com&quot; Book1.subject = &quot;Go 语言教程&quot; Book1.book_id = 6495407 /* book 2 描述 */ Book2.title = &quot;Python 教程&quot; Book2.author = &quot;www.runoob.com&quot; Book2.subject = &quot;Python 语言教程&quot; Book2.book_id = 6495700 /* 打印 Book1 信息 */ printBook(&amp;Book1) /* 打印 Book2 信息 */ printBook(&amp;Book2)&#125;func printBook( book *Books ) &#123; fmt.Printf( &quot;Book title : %s\\n&quot;, book.title); fmt.Printf( &quot;Book author : %s\\n&quot;, book.author); fmt.Printf( &quot;Book subject : %s\\n&quot;, book.subject); fmt.Printf( &quot;Book book_id : %d\\n&quot;, book.book_id);&#125; 结构体实例化也可以是这样的 12345678910111213package mainimport &quot;fmt&quot;type Books struct &#123;&#125;func (s Books) String() string &#123; return &quot;data&quot;&#125;func main() &#123; fmt.Printf(&quot;%v\\n&quot;, Books&#123;&#125;)&#125; 1.5 结构体的匿名字段结构体的匿名字段 可以用字段来创建结构，这些字段只包含一个没有字段名的类型。这些字段被称为匿名字段。 在类型中，使用不写字段名的方式，使用另一个类型 123456789101112131415161718192021222324252627282930type Human struct &#123; name string age int weight int&#125; type Student struct &#123; Human // 匿名字段，那么默认Student就包含了Human的所有字段 speciality string&#125; func main() &#123; // 我们初始化一个学生 mark := Student&#123;Human&#123;&quot;Mark&quot;, 25, 120&#125;, &quot;Computer Science&quot;&#125; // 我们访问相应的字段 fmt.Println(&quot;His name is &quot;, mark.name) fmt.Println(&quot;His age is &quot;, mark.age) fmt.Println(&quot;His weight is &quot;, mark.weight) fmt.Println(&quot;His speciality is &quot;, mark.speciality) // 修改对应的备注信息 mark.speciality = &quot;AI&quot; fmt.Println(&quot;Mark changed his speciality&quot;) fmt.Println(&quot;His speciality is &quot;, mark.speciality) // 修改他的年龄信息 fmt.Println(&quot;Mark become old&quot;) mark.age = 46 fmt.Println(&quot;His age is&quot;, mark.age) // 修改他的体重信息 fmt.Println(&quot;Mark is not an athlet anymore&quot;) mark.weight += 60 fmt.Println(&quot;His weight is&quot;, mark.weight)&#125; 可以使用”.”的方式进行调用匿名字段中的属性值 实际就是字段的继承 其中可以将匿名字段理解为字段名和字段类型都是同一个 基于上面的理解，所以可以mark.Human = Human&#123;&quot;Marcus&quot;, 55, 220&#125;和mark.Human.age -= 1 若存在匿名字段中的字段与非匿名字段名字相同，则最外层的优先访问，就近原则 通过匿名访问和修改字段相当的有用，但是不仅仅是struct字段哦，所有的内置类型和自定义类型都是可以作为匿名字段的。 1.6 结构体嵌套嵌套的结构体一个结构体可能包含一个字段，而这个字段反过来就是一个结构体。这些结构被称为嵌套结构。 示例代码： 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot;)type Address struct &#123; city, state string&#125;type Person struct &#123; name string age int address Address&#125;func main() &#123; var p Person p.name = &quot;Naveen&quot; p.age = 50 p.address = Address &#123; city: &quot;Chicago&quot;, state: &quot;Illinois&quot;, &#125; fmt.Println(&quot;Name:&quot;, p.name) fmt.Println(&quot;Age:&quot;,p.age) fmt.Println(&quot;City:&quot;,p.address.city) fmt.Println(&quot;State:&quot;,p.address.state)&#125; 1.7 提升字段在结构体中属于匿名结构体的字段称为提升字段，因为它们可以被访问，就好像它们属于拥有匿名结构字段的结构一样。理解这个定义是相当复杂的。 示例代码： 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot;)type Address struct &#123; city, state string&#125;type Person struct &#123; name string age int Address&#125;func main() &#123; var p Person p.name = &quot;Naveen&quot; p.age = 50 p.Address = Address&#123; city: &quot;Chicago&quot;, state: &quot;Illinois&quot;, &#125; fmt.Println(&quot;Name:&quot;, p.name) fmt.Println(&quot;Age:&quot;, p.age) fmt.Println(&quot;City:&quot;, p.city) //city is promoted field fmt.Println(&quot;State:&quot;, p.state) //state is promoted field&#125; 运行结果 1234Name: Naveen Age: 50 City: Chicago State: Illinois 1.8 导出结构体和字段如果结构体类型以大写字母开头，那么它是一个导出类型，可以从其他包访问它。类似地，如果结构体的字段以大写开头，则可以从其他包访问它们。 示例代码： 1.在computer目录下，创建文件spec.go 1234567package computertype Spec struct &#123; //exported struct Maker string //exported field model string //unexported field Price int //exported field&#125; 2.创建main.go 文件 1234567891011package mainimport &quot;structs/computer&quot; import &quot;fmt&quot;func main() &#123; var spec computer.Spec spec.Maker = &quot;apple&quot; spec.Price = 50000 fmt.Println(&quot;Spec:&quot;, spec)&#125; 目录结构如下： src structs computer spec.go main.go 1.9 结构体比较结构体是值类型，如果每个字段具有可比性，则是可比较的。如果它们对应的字段相等，则认为两个结构体变量是相等的。 示例代码： 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot;)type name struct &#123; firstName string lastName string&#125;func main() &#123; name1 := name&#123;&quot;Steve&quot;, &quot;Jobs&quot;&#125; name2 := name&#123;&quot;Steve&quot;, &quot;Jobs&quot;&#125; if name1 == name2 &#123; fmt.Println(&quot;name1 and name2 are equal&quot;) &#125; else &#123; fmt.Println(&quot;name1 and name2 are not equal&quot;) &#125; name3 := name&#123;firstName:&quot;Steve&quot;, lastName:&quot;Jobs&quot;&#125; name4 := name&#123;&#125; name4.firstName = &quot;Steve&quot; if name3 == name4 &#123; fmt.Println(&quot;name3 and name4 are equal&quot;) &#125; else &#123; fmt.Println(&quot;name3 and name4 are not equal&quot;) &#125;&#125; 运行结果 123name1 and name2 are equal name3 and name4 are not equal 如果结构变量包含的字段是不可比较的，那么结构变量是不可比较的 示例代码： 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot;)type image struct &#123; data map[int]int&#125;func main() &#123; image1 := image&#123;data: map[int]int&#123; 0: 155, &#125;&#125; image2 := image&#123;data: map[int]int&#123; 0: 155, &#125;&#125; if image1 == image2 &#123; fmt.Println(&quot;image1 and image2 are equal&quot;) &#125;&#125; 2.0 结构体作为函数的参数结构体作为函数参数使用 1234567891011121314151617181920212223242526272829303132333435363738394041ackage mainimport &quot;fmt&quot;type Books struct &#123; title string author string subject string book_id int&#125;func main() &#123; var Book1 Books /* 声明 Book1 为 Books 类型 */ var Book2 Books /* 声明 Book2 为 Books 类型 */ /* book 1 描述 */ Book1.title = &quot;Go 语言&quot; Book1.author = &quot;www.runoob.com&quot; Book1.subject = &quot;Go 语言教程&quot; Book1.book_id = 6495407 /* book 2 描述 */ Book2.title = &quot;Python 教程&quot; Book2.author = &quot;www.runoob.com&quot; Book2.subject = &quot;Python 语言教程&quot; Book2.book_id = 6495700 /* 打印 Book1 信息 */ printBook(Book1) /* 打印 Book2 信息 */ printBook(Book2)&#125;func printBook( book Books ) &#123; fmt.Printf( &quot;Book title : %s\\n&quot;, book.title); fmt.Printf( &quot;Book author : %s\\n&quot;, book.author); fmt.Printf( &quot;Book subject : %s\\n&quot;, book.subject); fmt.Printf( &quot;Book book_id : %d\\n&quot;, book.book_id);&#125; make、new操作 make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：new返回指针 内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。 make返回初始化后的（非零）值。 方法 @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是方法Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集 方法只是一个函数，它带有一个特殊的接收器类型，它是在func关键字和方法名之间编写的。接收器可以是struct类型或非struct类型。接收方可以在方法内部访问。 方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。 在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。 也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。 1.2 方法的语法定义方法的语法 123456func (t Type) methodName(parameter list)(return list) &#123; &#125;func funcName(parameter list)(return list)&#123; &#125; 实例代码： 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot;)type Employee struct &#123; name string salary int currency string&#125;/* displaySalary() method has Employee as the receiver type*/func (e Employee) displaySalary() &#123; fmt.Printf(&quot;Salary of %s is %s%d&quot;, e.name, e.currency, e.salary)&#125;func main() &#123; emp1 := Employee &#123; name: &quot;Sam Adolf&quot;, salary: 5000, currency: &quot;$&quot;, &#125; emp1.displaySalary() //Calling displaySalary() method of Employee type&#125; 可以定义相同的方法名 示例代码： 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Rectangle struct &#123; width, height float64&#125;type Circle struct &#123; radius float64&#125;func (r Rectangle) area() float64 &#123; return r.width * r.height&#125;//该 method 属于 Circle 类型对象中的方法func (c Circle) area() float64 &#123; return c.radius * c.radius * math.Pi&#125;func main() &#123; r1 := Rectangle&#123;12, 2&#125; r2 := Rectangle&#123;9, 4&#125; c1 := Circle&#123;10&#125; c2 := Circle&#123;25&#125; fmt.Println(&quot;Area of r1 is: &quot;, r1.area()) fmt.Println(&quot;Area of r2 is: &quot;, r2.area()) fmt.Println(&quot;Area of c1 is: &quot;, c1.area()) fmt.Println(&quot;Area of c2 is: &quot;, c2.area())&#125; 运行结果 1234Area of r1 is: 24Area of r2 is: 36Area of c1 is: 314.1592653589793Area of c2 is: 1963.4954084936207 虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样 method里面可以访问接收者的字段 调用method通过.访问，就像struct里面访问字段一样 1.3 方法和函数既然我们已经有了函数，为什么还要使用方法？ 示例代码： 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot;)type Employee struct &#123; name string salary int currency string&#125;/* displaySalary() method converted to function with Employee as parameter*/func displaySalary(e Employee) &#123; fmt.Printf(&quot;Salary of %s is %s%d&quot;, e.name, e.currency, e.salary)&#125;func main() &#123; emp1 := Employee&#123; name: &quot;Sam Adolf&quot;, salary: 5000, currency: &quot;$&quot;, &#125; displaySalary(emp1)&#125; 在上面的程序中，displaySalary方法被转换为一个函数，而Employee struct作为参数传递给它。这个程序也产生了相同的输出：Salary of Sam Adolf is $5000.。 为什么我们可以用函数来写相同的程序呢?有以下几个原因 Go不是一种纯粹面向对象的编程语言，它不支持类。因此，类型的方法是一种实现类似于类的行为的方法。 相同名称的方法可以在不同的类型上定义，而具有相同名称的函数是不允许的。假设我们有一个正方形和圆形的结构。可以在正方形和圆形上定义一个名为Area的方法。这是在下面的程序中完成的。 1.4 变量作用域作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。 Go 语言中变量可以在三个地方声明： 函数内定义的变量称为局部变量 函数外定义的变量称为全局变量 函数定义中的变量称为形式参数 局部变量 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 全局变量 在函数体外声明的变量称之为全局变量，首字母大写全局变量可以在整个包甚至外部包（被导出后）使用。 12345678910111213141516171819package mainimport &quot;fmt&quot;/* 声明全局变量 */var g intfunc main() &#123; /* 声明局部变量 */ var a, b int /* 初始化参数 */ a = 10 b = 20 g = a + b fmt.Printf(&quot;结果： a = %d, b = %d and g = %d\\n&quot;, a, b, g)&#125; 结果 1结果： a = 10, b = 20 and g = 30 形式参数 形式参数会作为函数的局部变量来使用 指针作为接收者 若不是以指针作为接收者，实际只是获取了一个copy，而不能真正改变接收者的中的数据 123func (b *Box) SetColor(c Color) &#123; b.color = c&#125; 示例代码 1234567891011121314151617181920package mainimport ( &quot;fmt&quot;)type Rectangle struct &#123; width, height int&#125;func (r *Rectangle) setVal() &#123; r.height = 20&#125;func main() &#123; p := Rectangle&#123;1, 2&#125; s := p p.setVal() fmt.Println(p.height, s.height)&#125; 结果 120 2 如果没有那个*，则值就是2 2 1.5 method继承method是可以继承的，如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method 123456789101112131415161718192021222324252627package mainimport &quot;fmt&quot;type Human struct &#123; name string age int phone string&#125;type Student struct &#123; Human //匿名字段 school string&#125;type Employee struct &#123; Human //匿名字段 company string&#125;func (h *Human) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s you can call me on %s\\n&quot;, h.name, h.phone)&#125;func main() &#123; mark := Student&#123;Human&#123;&quot;Mark&quot;, 25, &quot;222-222-YYYY&quot;&#125;, &quot;MIT&quot;&#125; sam := Employee&#123;Human&#123;&quot;Sam&quot;, 45, &quot;111-888-XXXX&quot;&#125;, &quot;Golang Inc&quot;&#125; mark.SayHi() sam.SayHi()&#125; 运行结果： 12Hi, I am Mark you can call me on 222-222-YYYYHi, I am Sam you can call me on 111-888-XXXX 1.6 method重写12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;type Human struct &#123; name string age int phone string&#125;type Student struct &#123; Human //匿名字段 school string&#125;type Employee struct &#123; Human //匿名字段 company string&#125;//Human定义methodfunc (h *Human) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s you can call me on %s\\n&quot;, h.name, h.phone)&#125;//Employee的method重写Human的methodfunc (e *Employee) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\\n&quot;, e.name, e.company, e.phone) //Yes you can split into 2 lines here.&#125;func main() &#123; mark := Student&#123;Human&#123;&quot;Mark&quot;, 25, &quot;222-222-YYYY&quot;&#125;, &quot;MIT&quot;&#125; sam := Employee&#123;Human&#123;&quot;Sam&quot;, 45, &quot;111-888-XXXX&quot;&#125;, &quot;Golang Inc&quot;&#125; mark.SayHi() sam.SayHi()&#125; 运行结果： 12Hi, I am Mark you can call me on 222-222-YYYYHi, I am Sam, I work at Golang Inc. Call me on 111-888-XXXX 方法是可以继承和重写的 存在继承关系时，按照就近原则，进行调用 接口 @author：韩茹版权所有：北京千锋互联科技有限公司 1.1 什么是接口?面向对象世界中的接口的一般定义是“接口定义对象的行为”。它表示让指定对象应该做什么。实现这种行为的方法(实现细节)是针对对象的。 在Go中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与OOP非常相似。接口指定了类型应该具有的方法，类型决定了如何实现这些方法。 它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口 接口定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了该接口。 1.2 接口的定义语法定义接口 12345678910111213141516171819202122/* 定义接口 */type interface_name interface &#123; method_name1 [return_type] method_name2 [return_type] method_name3 [return_type] ... method_namen [return_type]&#125;/* 定义结构体 */type struct_name struct &#123; /* variables */&#125;/* 实现接口方法 */func (struct_name_variable struct_name) method_name1() [return_type] &#123; /* 方法实现 */&#125;...func (struct_name_variable struct_name) method_namen() [return_type] &#123; /* 方法实现*/&#125; 示例代码： 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot;)type Phone interface &#123; call()&#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123; fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123; var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; 运行结果： 12I am Nokia, I can call you!I am iPhone, I can call you! interface可以被任意的对象实现 一个对象可以实现任意多个interface 任意的类型都实现了空interface(我们这样定义：interface{})，也就是包含0个method的interface 1.3 interface值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport &quot;fmt&quot;type Human struct &#123; name string age int phone string&#125;type Student struct &#123; Human //匿名字段 school string loan float32&#125;type Employee struct &#123; Human //匿名字段 company string money float32&#125; //Human实现Sayhi方法func (h Human) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s you can call me on %s\\n&quot;, h.name, h.phone)&#125; //Human实现Sing方法func (h Human) Sing(lyrics string) &#123; fmt.Println(&quot;La la la la...&quot;, lyrics)&#125; //Employee重写Human的SayHi方法func (e Employee) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\\n&quot;, e.name, e.company, e.phone) //Yes you can split into 2 lines here.&#125;// Interface Men被Human,Student和Employee实现// 因为这三个类型都实现了这两个方法type Men interface &#123; SayHi() Sing(lyrics string)&#125;func main() &#123; mike := Student&#123;Human&#123;&quot;Mike&quot;, 25, &quot;222-222-XXX&quot;&#125;, &quot;MIT&quot;, 0.00&#125; paul := Student&#123;Human&#123;&quot;Paul&quot;, 26, &quot;111-222-XXX&quot;&#125;, &quot;Harvard&quot;, 100&#125; sam := Employee&#123;Human&#123;&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;&#125;, &quot;Golang Inc.&quot;, 1000&#125; Tom := Employee&#123;Human&#123;&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;&#125;, &quot;Things Ltd.&quot;, 5000&#125; //定义Men类型的变量i var i Men //i能存储Student i = mike fmt.Println(&quot;This is Mike, a Student:&quot;) i.SayHi() i.Sing(&quot;November rain&quot;) //i也能存储Employee i = Tom fmt.Println(&quot;This is Tom, an Employee:&quot;) i.SayHi() i.Sing(&quot;Born to be wild&quot;) //定义了slice Men fmt.Println(&quot;Let&#x27;s use a slice of Men and see what happens&quot;) x := make([]Men, 3) //T这三个都是不同类型的元素，但是他们实现了interface同一个接口 x[0], x[1], x[2] = paul, sam, mike for _, value := range x &#123; value.SayHi() &#125;&#125; 运行结果： 12345678910This is Mike, a Student:Hi, I am Mike you can call me on 222-222-XXXLa la la la... November rainThis is Tom, an Employee:Hi, I am Sam, I work at Things Ltd.. Call me on 444-222-XXXLa la la la... Born to be wildLet&#x27;s use a slice of Men and see what happensHi, I am Paul you can call me on 111-222-XXXHi, I am Sam, I work at Golang Inc.. Call me on 444-222-XXXHi, I am Mike you can call me on 222-222-XXX 那么interface里面到底能存什么值呢？如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值 当然，使用指针的方式，也是可以的 但是，接口对象不能调用实现对象的属性 interface函数参数 interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数 嵌入interface 12345678910111213141516171819202122package mainimport &quot;fmt&quot;type Human interface &#123; Len()&#125;type Student interface &#123; Human&#125;type Test struct &#123;&#125;func (h *Test) Len() &#123; fmt.Println(&quot;成功&quot;)&#125;func main() &#123; var s Student s = new(Test) s.Len()&#125; 示例代码： 12345678910111213141516171819202122package testimport ( &quot;fmt&quot;)type Controller struct &#123; M int32&#125;type Something interface &#123; Get() Post()&#125;func (c *Controller) Get() &#123; fmt.Print(&quot;GET&quot;)&#125;func (c *Controller) Post() &#123; fmt.Print(&quot;POST&quot;)&#125; 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;test&quot;)type T struct &#123; test.Controller&#125;func (t *T) Get() &#123; //new(test.Controller).Get() fmt.Print(&quot;T&quot;)&#125;func (t *T) Post() &#123; fmt.Print(&quot;T&quot;)&#125;func main() &#123; var something test.Something something = new(T) var t T t.M = 1 // t.Controller.M = 1 something.Get()&#125; Controller实现了所有的Something接口方法，当结构体T中调用Controller结构体的时候，T就相当于Java中的继承，T继承了Controller，因此，T可以不用重写所有的Something接口中的方法，因为父构造器已经实现了接口。 如果Controller没有实现Something接口方法，则T要调用Something中方法，就要实现其所有方法。 如果something = new(test.Controller)则调用的是Controller中的Get方法。 T可以使用Controller结构体中定义的变量 1.4 接口的类型接口与鸭子类型： 先直接来看维基百科里的定义： If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. 翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。 Duck Typing，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。 而在静态语言如 Java, C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用某个数，却传入了一个根本就没有实现另一个的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。 动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写 python 的同学比较清楚。 Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。 总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定。Go 作为一种静态语言，通过接口实现了鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。 Go语言的多态性： Go中的多态性是在接口的帮助下实现的。正如我们已经讨论过的，接口可以在Go中隐式地实现。如果类型为接口中声明的所有方法提供了定义，则实现一个接口。让我们看看在接口的帮助下如何实现多态。 任何定义接口所有方法的类型都被称为隐式地实现该接口。 类型接口的变量可以保存实现接口的任何值。接口的这个属性用于实现Go中的多态性。 1.5 接口断言前面说过，因为空接口 interface{}没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。 语法格式： 12345678// 安全类型断言&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 )//非安全类型断言&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 ) 示例代码： 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func main() &#123; var i1 interface&#123;&#125; = new (Student) s := i1.(Student) //不安全，如果断言失败，会直接panic fmt.Println(s) var i2 interface&#123;&#125; = new(Student) s, ok := i2.(Student) //安全，断言失败，也不会panic，只是ok的值为false if ok &#123; fmt.Println(s) &#125;&#125;type Student struct &#123;&#125; 断言其实还有另一种形式，就是用在利用 switch语句判断接口的类型。每一个case会被顺序地考虑。当命中一个case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case匹配的情况。 示例代码： 12345678switch ins:=s.(type) &#123; case Triangle: fmt.Println(&quot;三角形。。。&quot;,ins.a,ins.b,ins.c) case Circle: fmt.Println(&quot;圆形。。。。&quot;,ins.radius) case int: fmt.Println(&quot;整型数据。。&quot;) &#125; 面向对象(OOP) @author：韩茹版权所有：北京千锋互联科技有限公司 go并不是一个纯面向对象的编程语言。在go中的面向对象，结构体替换了类。 Go并没有提供类class，但是它提供了结构体struct，方法method，可以在结构体上添加。提供了捆绑数据和方法的行为，这些数据和方法与类类似。 1.1 定义结构体和方法通过以下代码来更好的理解，首先在src目录下创建一个package命名为oop，在oop目录下，再创建一个子目录命名为employee，在该目录下创建一个go文件命名为employee.go。 目录结构：oop -&gt; employee -&gt; employee.go 在employee.go文件中保存以下代码： 12345678910111213141516package employeeimport ( &quot;fmt&quot;)type Employee struct &#123; FirstName string LastName string TotalLeaves int LeavesTaken int&#125;func (e Employee) LeavesRemaining() &#123; fmt.Printf(&quot;%s %s has %d leaves remaining&quot;, e.FirstName, e.LastName, (e.TotalLeaves - e.LeavesTaken))&#125; 然后在oop目录下，创建文件并命名为main.go，并保存以下内容 12345678910111213package mainimport &quot;oop/employee&quot;func main() &#123; e := employee.Employee &#123; FirstName: &quot;Sam&quot;, LastName: &quot;Adolf&quot;, TotalLeaves: 30, LeavesTaken: 20, &#125; e.LeavesRemaining()&#125; 运行结果： 1Sam Adolf has 10 leaves remaining 1.2 New()函数替代了构造函数我们上面写的程序看起来不错，但是里面有一个微妙的问题。让我们看看当我们用0值定义employee struct时会发生什么。更改main的内容。转到下面的代码， 12345678package mainimport &quot;oop/employee&quot;func main() &#123; var e employee.Employee e.LeavesRemaining()&#125; 运行结果： 1has 0 leaves remaining 通过运行结果可以知道，使用Employee的零值创建的变量是不可用的。它没有有效的名、姓，也没有有效的保留细节。在其他的OOP语言中，比如java，这个问题可以通过使用构造函数来解决。使用参数化构造函数可以创建一个有效的对象。 go不支持构造函数。如果某个类型的零值不可用，则程序员的任务是不导出该类型以防止其他包的访问，并提供一个名为NewT(parameters)的函数，该函数初始化类型T和所需的值。在go中，它是一个命名一个函数的约定，它创建了一个T类型的值给NewT(parameters)。这就像一个构造函数。如果包只定义了一个类型，那么它的一个约定就是将这个函数命名为New(parameters)而不是NewT(parameters)。 更改employee.go的代码： 首先修改employee结构体为非导出，并创建一个函数New()，它将创建一个新Employee。代码如下： 123456789101112131415161718192021package employeeimport ( &quot;fmt&quot;)type employee struct &#123; firstName string lastName string totalLeaves int leavesTaken int&#125;func New(firstName string, lastName string, totalLeave int, leavesTaken int) employee &#123; e := employee &#123;firstName, lastName, totalLeave, leavesTaken&#125; return e&#125;func (e employee) LeavesRemaining() &#123; fmt.Printf(&quot;%s %s has %d leaves remaining&quot;, e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken))&#125; 我们在这里做了一些重要的改变。我们已经将Employee struct的起始字母e设置为小写，即我们已经将类型Employee struct更改为type Employee struct。通过这样做，我们成功地导出了employee结构并阻止了其他包的访问。将未导出的结构的所有字段都导出为未导出的方法是很好的做法，除非有特定的需要导出它们。由于我们不需要在包之外的任何地方使用employee struct的字段，所以我们也没有导出所有字段。 由于employee是未导出的，所以不可能从其他包中创建类型employee的值。因此，我们提供了一个输出的新函数。将所需的参数作为输入并返回新创建的employee。 这个程序还需要做一些修改，让它能够工作，但是让我们运行这个程序来了解到目前为止变化的效果。如果这个程序运行，它将会失败，有以下编译错误， 1go/src/constructor/main.go:6: undefined: employee.Employee 这是因为我们有未导出的Employee，因此编译器抛出错误，该类型在main中没有定义。完美的。正是我们想要的。现在没有其他的包能够创建一个零值的员工。我们成功地防止了一个无法使用的员工结构价值被创建。现在创建员工的唯一方法是使用新功能。 修改main.go代码 12345678package main import &quot;oop/employee&quot;func main() &#123; e := employee.New(&quot;Sam&quot;, &quot;Adolf&quot;, 30, 20) e.LeavesRemaining()&#125; 运行结果： 1Sam Adolf has 10 leaves remaining 因此，我们可以明白，虽然Go不支持类，但是结构体可以有效地使用，在使用构造函数的位置，使用New(parameters)的方法即可。 1.3组成(Composition )替代了继承(Inheritance)Go不支持继承，但它支持组合。组合的一般定义是“放在一起”。构图的一个例子就是汽车。汽车是由轮子、发动机和其他各种部件组成的。 博客文章就是一个完美的组合例子。每个博客都有标题、内容和作者信息。这可以用组合完美地表示出来。 1.3.1 通过嵌入结构体实现组成可以通过将一个struct类型嵌入到另一个结构中实现。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;fmt&quot;)/*我们创建了一个author struct，它包含字段名、lastName和bio。我们还添加了一个方法fullName()，将作者作为接收者类型，这将返回作者的全名。*/type author struct &#123; firstName string lastName string bio string&#125;func (a author) fullName() string &#123; return fmt.Sprintf(&quot;%s %s&quot;, a.firstName, a.lastName)&#125;/*post struct有字段标题、内容。它还有一个嵌入式匿名字段作者。这个字段表示post struct是由author组成的。现在post struct可以访问作者结构的所有字段和方法。我们还在post struct中添加了details()方法，它打印出作者的标题、内容、全名和bio。*/type post struct &#123; title string content string author&#125;func (p post) details() &#123; fmt.Println(&quot;Title: &quot;, p.title) fmt.Println(&quot;Content: &quot;, p.content) fmt.Println(&quot;Author: &quot;, p.author.fullName()) fmt.Println(&quot;Bio: &quot;, p.author.bio)&#125;func main() &#123; author1 := author&#123; &quot;Naveen&quot;, &quot;Ramanathan&quot;, &quot;Golang Enthusiast&quot;, &#125; post1 := post&#123; &quot;Inheritance in Go&quot;, &quot;Go supports composition instead of inheritance&quot;, author1, &#125; post1.details()&#125; 运行结果： 1234Title: Inheritance in Go Content: Go supports composition instead of inheritance Author: Naveen Ramanathan Bio: Golang Enthusiast 嵌入结构体的切片 在以上程序的main函数下增加以下代码，并运行 12345678910type website struct &#123; []post&#125;func (w website) contents() &#123; fmt.Println(&quot;Contents of Website\\n&quot;) for _, v := range w.posts &#123; v.details() fmt.Println() &#125;&#125; 运行报错： 1main.go:31:9: syntax error: unexpected [, expecting field name or embedded type 这个错误指向structs []post的嵌入部分。原因是不可能匿名嵌入一片。需要一个字段名。我们来修正这个错误，让编译器通过。 123type website struct &#123; posts []post&#125; 现在让我们修改的main函数,为我们的新的website创建几个posts。修改完完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( &quot;fmt&quot;)type author struct &#123; firstName string lastName string bio string&#125;func (a author) fullName() string &#123; return fmt.Sprintf(&quot;%s %s&quot;, a.firstName, a.lastName)&#125;type post struct &#123; title string content string author&#125;func (p post) details() &#123; fmt.Println(&quot;Title: &quot;, p.title) fmt.Println(&quot;Content: &quot;, p.content) fmt.Println(&quot;Author: &quot;, p.fullName()) fmt.Println(&quot;Bio: &quot;, p.bio)&#125;type website struct &#123; posts []post&#125;func (w website) contents() &#123; fmt.Println(&quot;Contents of Website\\n&quot;) for _, v := range w.posts &#123; v.details() fmt.Println() &#125;&#125;func main() &#123; author1 := author&#123; &quot;Naveen&quot;, &quot;Ramanathan&quot;, &quot;Golang Enthusiast&quot;, &#125; post1 := post&#123; &quot;Inheritance in Go&quot;, &quot;Go supports composition instead of inheritance&quot;, author1, &#125; post2 := post&#123; &quot;Struct instead of Classes in Go&quot;, &quot;Go does not support classes but methods can be added to structs&quot;, author1, &#125; post3 := post&#123; &quot;Concurrency&quot;, &quot;Go is a concurrent language and not a parallel one&quot;, author1, &#125; w := website&#123; posts: []post&#123;post1, post2, post3&#125;, &#125; w.contents()&#125; 运行结果： 12345678910111213141516Contents of WebsiteTitle: Inheritance in Go Content: Go supports composition instead of inheritance Author: Naveen Ramanathan Bio: Golang EnthusiastTitle: Struct instead of Classes in Go Content: Go does not support classes but methods can be added to structs Author: Naveen Ramanathan Bio: Golang EnthusiastTitle: Concurrency Content: Go is a concurrent language and not a parallel one Author: Naveen Ramanathan Bio: Golang Enthusiast 1.4 多态性(Polymorphism)Go中的多态性是在接口的帮助下实现的。正如我们已经讨论过的，接口可以在Go中隐式地实现。如果类型为接口中声明的所有方法提供了定义，则实现一个接口。让我们看看在接口的帮助下如何实现多态。 任何定义接口所有方法的类型都被称为隐式地实现该接口。 类型接口的变量可以保存实现接口的任何值。接口的这个属性用于实现Go中的多态性。 举个例子，一个虚构的组织有两种项目的收入:固定的账单和时间和材料。组织的净收入是由这些项目的收入之和计算出来的。为了保持本教程的简单，我们假设货币是美元，我们不会处理美分。它将使用整数来表示。 首先我们定义一个接口：Income 12345type Income interface &#123; calculate() int source() string&#125; 接下来，定义两个结构体：FixedBilling和TimeAndMaterial 12345type FixedBilling struct &#123; projectName string biddedAmount int&#125; 123456type TimeAndMaterial struct &#123; projectName string noOfHours int hourlyRate int&#125; 下一步是定义这些结构体类型的方法，计算并返回实际收入和收入来源。 12345678910111213141516func (fb FixedBilling) calculate() int &#123; return fb.biddedAmount&#125;func (fb FixedBilling) source() string &#123; return fb.projectName&#125;func (tm TimeAndMaterial) calculate() int &#123; return tm.noOfHours * tm.hourlyRate&#125;func (tm TimeAndMaterial) source() string &#123; return tm.projectName&#125; 接下来，我们来声明一下计算和打印总收入的calculateNetIncome函数。 123456789func calculateNetIncome(ic []Income) &#123; var netincome int = 0 for _, income := range ic &#123; fmt.Printf(&quot;Income From %s = $%d\\n&quot;, income.source(), income.calculate()) netincome += income.calculate() &#125; fmt.Printf(&quot;Net income of organisation = $%d&quot;, netincome)&#125; 上面的calculateNetIncome函数接受一部分Income接口作为参数。它通过遍历切片和调用calculate()方法来计算总收入。它还通过调用source()方法来显示收入来源。根据收入接口的具体类型，将调用不同的calculate()和source()方法。因此，我们在calculateNetIncome函数中实现了多态。 在未来，如果组织增加了一种新的收入来源，这个函数仍然可以正确地计算总收入，而没有一行代码更改。 最后我们写以下主函数： 12345678func main() &#123; project1 := FixedBilling&#123;projectName: &quot;Project 1&quot;, biddedAmount: 5000&#125; project2 := FixedBilling&#123;projectName: &quot;Project 2&quot;, biddedAmount: 10000&#125; project3 := TimeAndMaterial&#123;projectName: &quot;Project 3&quot;, noOfHours: 160, hourlyRate: 25&#125; incomeStreams := []Income&#123;project1, project2, project3&#125; calculateNetIncome(incomeStreams)&#125; 运行结果： 12345Income From Project 1 = $5000 Income From Project 2 = $10000 Income From Project 3 = $4000 Net income of organisation = $19000 假设该组织通过广告找到了新的收入来源。让我们看看如何简单地添加新的收入方式和计算总收入，而不用对calculateNetIncome函数做任何更改。由于多态性，这样是可行的。 首先让我们定义Advertisement类型和calculate()和source()方法。 1234567891011121314type Advertisement struct &#123; adName string CPC int noOfClicks int&#125;func (a Advertisement) calculate() int &#123; return a.CPC * a.noOfClicks&#125;func (a Advertisement) source() string &#123; return a.adName&#125; 广告类型有三个字段adName, CPC(cost per click)和noof点击数(cost per click)。广告的总收入是CPC和noOfClicks的产品。 修改主函数： 12345678910func main() &#123; project1 := FixedBilling&#123;projectName: &quot;Project 1&quot;, biddedAmount: 5000&#125; project2 := FixedBilling&#123;projectName: &quot;Project 2&quot;, biddedAmount: 10000&#125; project3 := TimeAndMaterial&#123;projectName: &quot;Project 3&quot;, noOfHours: 160, hourlyRate: 25&#125; bannerAd := Advertisement&#123;adName: &quot;Banner Ad&quot;, CPC: 2, noOfClicks: 500&#125; popupAd := Advertisement&#123;adName: &quot;Popup Ad&quot;, CPC: 5, noOfClicks: 750&#125; incomeStreams := []Income&#123;project1, project2, project3, bannerAd, popupAd&#125; calculateNetIncome(incomeStreams)&#125; 运行结果： 1234567Income From Project 1 = $5000 Income From Project 2 = $10000 Income From Project 3 = $4000 Income From Banner Ad = $1000 Income From Popup Ad = $3750 Net income of organisation = $23750 综上，我们没有对calculateNetIncome函数做任何更改，尽管我们添加了新的收入方式。它只是因为多态性而起作用。由于新的Advertisement类型也实现了Income接口，我们可以将它添加到incomeStreams切片中。calculateNetIncome函数也在没有任何更改的情况下工作，因为它可以调用Advertisement类型的calculate()和source()方法。 type关键字 @author：韩茹版权所有：北京千锋互联科技有限公司 type是go语法里的重要而且常用的关键字，type绝不只是对应于C/C++中的typedef。搞清楚type的使用，就容易理解go语言中的核心概念struct、interface、函数等的使用。 一、类型定义1.1 定义结构体使用type 可以定义结构体类型： 123456//1、定义结构体//结构体定义type person struct &#123; name string //注意后面不能有逗号 age int&#125; 1.2 定义接口使用type 可以定义接口类型： 1234type USB interface &#123; start() end()&#125; 1.3 定义其他的新类型使用type，还可以定义新类型。 语法： 1type 类型名 Type 示例代码： 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;type myint inttype mystr stringfunc main() &#123; var i1 myint var i2 = 100 i1 = 100 fmt.Println(i1) //i1 = i2 //cannot use i2 (type int) as type myint in assignment fmt.Println(i1,i2) var name mystr name = &quot;王二狗&quot; var s1 string s1 = &quot;李小花&quot; fmt.Println(name) fmt.Println(s1) name = s1 //cannot use s1 (type string) as type mystr in assignment&#125; 1.4 定义函数的类型Go语言支持函数式编程，可以使用高阶编程语法。一个函数可以作为另一个函数的参数，也可以作为另一个函数的返回值，那么在定义这个高阶函数的时候，如果函数的类型比较复杂，我们可以使用type来定义这个函数的类型： 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)func main() &#123; res1 := fun1() fmt.Println(res1(10,20))&#125;type my_fun func (int,int)(string)//fun1()函数的返回值是my_func类型func fun1 () my_fun&#123; fun := func(a,b int) string &#123; s := strconv.Itoa(a) + strconv.Itoa(b) return s &#125; return fun&#125; 二、类型别名类型别名的写法为： 1type 别名 = Type 类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。 类型别名是 Go 1.9 版本添加的新功能。主要用于代码升级、迁移中类型的兼容性问题。在 C/C++语言中，代码重构升级可以使用宏快速定义新的一段代码。Go 语言中没有选择加入宏，而是将解决重构中最麻烦的类型名变更问题。 在 Go 1.9 版本之前的内建类型定义的代码是这样写的： 12type byte uint8type rune int32 而在 Go 1.9 版本之后变为： 12type byte = uint8type rune = int32 这个修改就是配合类型别名而进行的修改。 示例代码： 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot;)func main() &#123; var i1 myint var i2 = 100 i1 = 100 fmt.Println(i1) //i1 = i2 //cannot use i2 (type int) as type myint in assignment fmt.Println(i1,i2) var i3 myint2 i3 = i2 fmt.Println(i1,i2,i3)&#125;type myint inttype myint2 = int //不是重新定义类型，只是给int起别名 三、非本地类型不能定义方法能够随意地为各种类型起名字，是否意味着可以在自己包里为这些类型任意添加方法？ 1234567891011package mainimport ( &quot;time&quot;)// 定义time.Duration的别名为MyDurationtype MyDuration = time.Duration// 为MyDuration添加一个函数func (m MyDuration) EasySet(a string) &#123; //cannot define new methods on non-local type time.Duration&#125;func main() &#123;&#125; 以上代码报错。报错信息：cannot define new methods on non-local type time.Duration 编译器提示：不能在一个非本地的类型 time.Duration 上定义新方法。非本地方法指的就是使用 time.Duration 的代码所在的包，也就是 main 包。因为 time.Duration 是在 time 包中定义的，在 main 包中使用。time.Duration 包与 main 包不在同一个包中，因此不能为不在一个包中的类型定义方法。 解决这个问题有下面两种方法： 将类型别名改为类型定义： type MyDuration time.Duration，也就是将 MyDuration 从别名改为类型。 将 MyDuration 的别名定义放在 time 包中。 四、在结构体成员嵌入时使用别名当类型别名作为结构体嵌入的成员时会发生什么情况？ 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot;)type Person struct &#123; name string&#125;func (p Person) Show() &#123; fmt.Println(&quot;Person--&gt;&quot;,p.name)&#125;//类型别名type People = Persontype Student struct &#123; // 嵌入两个结构 Person People&#125;func (p People) Show2()&#123; fmt.Println(&quot;People------&gt;&quot;,p.name)&#125;func main() &#123; // var s Student //s.name = &quot;王二狗&quot; //ambiguous selector s.name s.People.name = &quot;李小花&quot; s.Person.name = &quot;王二狗&quot; //s.Show() //ambiguous selector s.Show s.Person.Show() s.People.Show2() fmt.Printf(&quot;%T,%T\\n&quot;,s.Person,s.People) //main.Person,main.Person&#125; 在通过s直接访问name的时候，或者s直接调用Show()方法，因为两个类型都有 name字段和Show() 方法，会发生歧义，证明People 的本质确实是Person 类型。 部分内容引自：http://c.biancheng.net/view/25.html 错误处理 @author：韩茹 版权所有：北京千锋互联科技有限公司 在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。Go语言没有提供像Java、C#语言中的try...catch异常处理方式，而是通过函数返回值逐层往上抛。这种设计，鼓励工程师在代码中显式的检查错误，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端，让代码啰嗦。 1.1 什么是错误错误是什么? 错误指的是可能出现问题的地方出现了问题。比如打开一个文件时失败，这种情况在人们的意料之中 。 而异常指的是不应该出现问题的地方出现了问题。比如引用了空指针，这种情况在人们的意料之外。可见，错误是业务过程的一部分，而异常不是 。 Go中的错误也是一种类型。错误用内置的error 类型表示。就像其他类型的，如int，float64，。错误值可以存储在变量中，从函数中返回，等等。 1.2 演示错误让我们从一个示例程序开始，这个程序尝试打开一个不存在的文件。 示例代码： 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; f, err := os.Open(&quot;/test.txt&quot;) if err != nil &#123; fmt.Println(err) return &#125; //根据f进行文件的读或写 fmt.Println(f.Name(), &quot;opened successfully&quot;)&#125; 在os包中有打开文件的功能函数： ​ func Open(name string) (file *File, err error) 如果文件已经成功打开，那么Open函数将返回文件处理。如果在打开文件时出现错误，将返回一个非nil错误。 ​ 如果一个函数或方法返回一个错误，那么按照惯例，它必须是函数返回的最后一个值。因此，Open 函数返回的值是最后一个值。 处理错误的惯用方法是将返回的错误与nil进行比较。nil值表示没有发生错误，而非nil值表示出现错误。在我们的例子中，我们检查错误是否为nil。如果它不是nil，我们只需打印错误并从主函数返回。 运行结果： 1open /test.txt: No such file or directory 我们得到一个错误，说明该文件不存在。 1.3 错误类型表示Go 语言通过内置的错误接口提供了非常简单的错误处理机制。 让我们再深入一点，看看如何定义错误类型的构建。错误是一个带有以下定义的接口类型， 123type error interface &#123; Error() string&#125; 它包含一个带有Error（）字符串的方法。任何实现这个接口的类型都可以作为一个错误使用。这个方法提供了对错误的描述。 当打印错误时，fmt.Println函数在内部调用Error() 方法来获取错误的描述。这就是错误描述是如何在一行中打印出来的。 从错误中提取更多信息的不同方法 既然我们知道错误是一种接口类型，那么让我们看看如何提取更多关于错误的信息。 在上面的例子中，我们仅仅是打印了错误的描述。如果我们想要的是导致错误的文件的实际路径。一种可能的方法是解析错误字符串。这是我们程序的输出， 1open /test.txt: No such file or directory 我们可以解析这个错误消息并从中获取文件路径”/test.txt”。但这是一个糟糕的方法。在新版本的语言中，错误描述可以随时更改，我们的代码将会中断。 是否有办法可靠地获取文件名？答案是肯定的，它可以做到，标准Go库使用不同的方式提供更多关于错误的信息。让我们一看一看。 1.断言底层结构类型并从结构字段获取更多信息 如果仔细阅读打开函数的文档，可以看到它返回的是PathError类型的错误。PathError是一个struct类型，它在标准库中的实现如下， 1234567type PathError struct &#123; Op string Path string Err error&#125;func (e *PathError) Error() string &#123; return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error() &#125; 从上面的代码中，您可以理解PathError通过声明Error()string方法实现了错误接口。该方法连接操作、路径和实际错误并返回它。这样我们就得到了错误信息， 1open /test.txt: No such file or directory PathError结构的路径字段包含导致错误的文件的路径。让我们修改上面写的程序，并打印出路径。 修改代码： 123456789101112131415package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; f, err := os.Open(&quot;/test.txt&quot;) if err, ok := err.(*os.PathError); ok &#123; fmt.Println(&quot;File at path&quot;, err.Path, &quot;failed to open&quot;) return &#125; fmt.Println(f.Name(), &quot;opened successfully&quot;)&#125; 在上面的程序中，我们使用类型断言获得错误接口的基本值。然后我们用错误来打印路径.这个程序输出, 1File at path /test.txt failed to open 断言底层结构类型，并使用方法获取更多信息 获得更多信息的第二种方法是断言底层类型，并通过调用struct类型的方法获取更多信息。 示例代码： 1234567891011121314type DNSError struct &#123; ...&#125;func (e *DNSError) Error() string &#123; ...&#125;func (e *DNSError) Timeout() bool &#123; ... &#125;func (e *DNSError) Temporary() bool &#123; ... &#125; 从上面的代码中可以看到，DNSError struct有两个方法Timeout() bool和Temporary() bool，它们返回一个布尔值，表示错误是由于超时还是临时的。 让我们编写一个断言*DNSError类型的程序，并调用这些方法来确定错误是临时的还是超时的。 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot; &quot;net&quot;)func main() &#123; addr, err := net.LookupHost(&quot;golangbot123.com&quot;) if err, ok := err.(*net.DNSError); ok &#123; if err.Timeout() &#123; fmt.Println(&quot;operation timed out&quot;) &#125; else if err.Temporary() &#123; fmt.Println(&quot;temporary error&quot;) &#125; else &#123; fmt.Println(&quot;generic error: &quot;, err) &#125; return &#125; fmt.Println(addr)&#125; 在上面的程序中，我们正在尝试获取一个无效域名的ip地址，这是一个无效的域名。golangbot123.com。我们通过声明它来输入*net.DNSError来获得错误的潜在价值。 在我们的例子中，错误既不是暂时的，也不是由于超时，因此程序会打印出来， 12generic error: lookup golangbot123.com: no such host 如果错误是临时的或超时的，那么相应的If语句就会执行，我们可以适当地处理它。 3.直接比较 获得更多关于错误的详细信息的第三种方法是直接与类型错误的变量进行比较。让我们通过一个例子来理解这个问题。 filepath包的Glob函数用于返回与模式匹配的所有文件的名称。当模式出现错误时，该函数将返回一个错误ErrBadPattern。 在filepath包中定义了ErrBadPattern，如下所述： 12var ErrBadPattern = errors.New(&quot;syntax error in pattern&quot;) errors.New()用于创建新的错误。 当模式出现错误时，由Glob函数返回ErrBadPattern。 让我们写一个小程序来检查这个错误： 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;path/filepath&quot;)func main() &#123; files, error := filepath.Glob(&quot;[&quot;) if error != nil &amp;&amp; error == filepath.ErrBadPattern &#123; fmt.Println(error) return &#125; fmt.Println(&quot;matched files&quot;, files)&#125; 运行结果： 12syntax error in pattern 不要忽略错误 永远不要忽略一个错误。忽视错误会招致麻烦。让我重新编写一个示例，该示例列出了与模式匹配的所有文件的名称，而忽略了错误处理代码。 123456789101112package mainimport ( &quot;fmt&quot; &quot;path/filepath&quot;)func main() &#123; files, _ := filepath.Glob(&quot;[&quot;) fmt.Println(&quot;matched files&quot;, files)&#125; 我们从前面的例子中已经知道模式是无效的。我忽略了Glob函数返回的错误，方法是使用行号中的空白标识符。 12matched files [] 由于我们忽略了这个错误，输出看起来好像没有文件匹配这个模式，但是实际上这个模式本身是畸形的。所以不要忽略错误。 1.4 自定义错误创建自定义错误可以使用errors包下的New()函数，以及fmt包下的：Errorf()函数。 123456//errors包：func New(text string) error &#123;&#125;//fmt包：func Errorf(format string, a ...interface&#123;&#125;) error &#123;&#125; 在使用New()函数创建自定义错误之前，让我们了解它是如何实现的。下面提供了错误包中的新功能的实现。 1234567891011121314151617// Package errors implements functions to manipulate errors. package errors // New returns an error that formats as the given text. func New(text string) error &#123; return &amp;errorString&#123;text&#125; &#125; // errorString is a trivial implementation of error. type errorString struct &#123; s string &#125; func (e *errorString) Error() string &#123; return e.s &#125; 既然我们知道了New()函数是如何工作的，那么就让我们在自己的程序中使用它来创建一个自定义错误。 我们将创建一个简单的程序，计算一个圆的面积，如果半径为负，将返回一个错误。 12345678910111213141516171819202122232425package mainimport ( &quot;errors&quot; &quot;fmt&quot; &quot;math&quot;)func circleArea(radius float64) (float64, error) &#123; if radius &lt; 0 &#123; return 0, errors.New(&quot;Area calculation failed, radius is less than zero&quot;) &#125; return math.Pi * radius * radius, nil&#125;func main() &#123; radius := -20.0 area, err := circleArea(radius) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(&quot;Area of circle %0.2f&quot;, area)&#125; 运行结果： 12Area calculation failed, radius is less than zero 使用Errorf向错误添加更多信息 上面的程序运行得很好，但是如果我们打印出导致错误的实际半径，那就不好了。这就是fmt包的Errorf函数的用武之地。这个函数根据一个格式说明器格式化错误，并返回一个字符串作为值来满足错误。 使用Errorf函数，修改程序。 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;math&quot;)func circleArea(radius float64) (float64, error) &#123; if radius &lt; 0 &#123; return 0, fmt.Errorf(&quot;Area calculation failed, radius %0.2f is less than zero&quot;, radius) &#125; return math.Pi * radius * radius, nil&#125;func main() &#123; radius := -20.0 area, err := circleArea(radius) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(&quot;Area of circle %0.2f&quot;, area)&#125; 运行结果： 12Area calculation failed, radius -20.00 is less than zero 使用struct类型和字段提供关于错误的更多信息 还可以使用将错误接口实现为错误的struct类型。这给我们提供了更多的错误处理的灵活性。在我们的示例中，如果我们想要访问导致错误的半径，那么现在唯一的方法是解析错误描述区域计算失败，半径-20.00小于零。这不是一种正确的方法，因为如果描述发生了变化，我们的代码就会中断。 我们将使用在前面的教程中解释的标准库的策略，在“断言底层结构类型并从struct字段获取更多信息”，并使用struct字段来提供对导致错误的半径的访问。我们将创建一个实现错误接口的struct类型，并使用它的字段来提供关于错误的更多信息。 第一步是创建一个struct类型来表示错误。错误类型的命名约定是，名称应该以文本Error结束。让我们把struct类型命名为areaError 12345type areaError struct &#123; err string radius float64&#125; 上面的struct类型有一个字段半径，它存储了为错误负责的半径的值，并且错误字段存储了实际的错误消息。 下一步，是实现error 接口 1234func (e *areaError) Error() string &#123; return fmt.Sprintf(&quot;radius %0.2f: %s&quot;, e.radius, e.err)&#125; 在上面的代码片段中，我们使用一个指针接收器区域错误来实现错误接口的Error() string方法。这个方法打印出半径和错误描述。 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( &quot;fmt&quot; &quot;math&quot;)type areaError struct &#123; err string radius float64&#125;func (e *areaError) Error() string &#123; return fmt.Sprintf(&quot;radius %0.2f: %s&quot;, e.radius, e.err)&#125;func circleArea(radius float64) (float64, error) &#123; if radius &lt; 0 &#123; return 0, &amp;areaError&#123;&quot;radius is negative&quot;, radius&#125; &#125; return math.Pi * radius * radius, nil&#125;func main() &#123; radius := -20.0 area, err := circleArea(radius) if err != nil &#123; if err, ok := err.(*areaError); ok &#123; fmt.Printf(&quot;Radius %0.2f is less than zero&quot;, err.radius) return &#125; fmt.Println(err) return &#125; fmt.Printf(&quot;Area of circle %0.2f&quot;, area)&#125; 程序输出： 12Radius -20.00 is less than zero 使用结构类型的方法提供关于错误的更多信息 在本节中，我们将编写一个程序来计算矩形的面积。如果长度或宽度小于0，这个程序将输出一个错误。 第一步是创建一个结构来表示错误。 123456type areaError struct &#123; err string //error description length float64 //length which caused the error width float64 //width which caused the error&#125; 上面的错误结构类型包含一个错误描述字段，以及导致错误的长度和宽度。 现在我们有了错误类型，让我们实现错误接口，并在错误类型上添加一些方法来提供关于错误的更多信息。 123456789101112func (e *areaError) Error() string &#123; return e.err&#125;func (e *areaError) lengthNegative() bool &#123; return e.length &lt; 0&#125;func (e *areaError) widthNegative() bool &#123; return e.width &lt; 0&#125; 在上面的代码片段中，我们返回Error() string 方法的错误描述。当长度小于0时，lengthNegative() bool方法返回true;当宽度小于0时，widthNegative() bool方法返回true。这两种方法提供了更多关于误差的信息，在这种情况下，他们说面积计算是否失败，因为长度是负的，还是宽度为负的。因此，我们使用了struct错误类型的方法来提供更多关于错误的信息。 下一步是写出面积计算函数。 123456789101112131415161718func rectArea(length, width float64) (float64, error) &#123; err := &quot;&quot; if length &lt; 0 &#123; err += &quot;length is less than zero&quot; &#125; if width &lt; 0 &#123; if err == &quot;&quot; &#123; err = &quot;width is less than zero&quot; &#125; else &#123; err += &quot;, width is less than zero&quot; &#125; &#125; if err != &quot;&quot; &#123; return 0, &amp;areaError&#123;err, length, width&#125; &#125; return length * width, nil&#125; 上面的rectArea函数检查长度或宽度是否小于0，如果它返回一个错误消息，则返回矩形的面积为nil。 主函数： 1234567891011121314151617181920func main() &#123; length, width := -5.0, -9.0 area, err := rectArea(length, width) if err != nil &#123; if err, ok := err.(*areaError); ok &#123; if err.lengthNegative() &#123; fmt.Printf(&quot;error: length %0.2f is less than zero\\n&quot;, err.length) &#125; if err.widthNegative() &#123; fmt.Printf(&quot;error: width %0.2f is less than zero\\n&quot;, err.width) &#125; &#125; fmt.Println(err) return &#125; fmt.Println(&quot;area of rect&quot;, area)&#125; 运行结果： 123error: length -5.00 is less than zero error: width -9.00 is less than zero 1.5 panic()和recover()Golang中引入两个内置函数panic和recover来触发和终止异常处理流程，同时引入关键字defer来延迟执行defer后面的函数。一直等到包含defer语句的函数执行完毕时，延迟函数（defer后的函数）才会被执行，而不管包含defer语句的函数是通过return的正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数等。如果一路在延迟函数中没有recover函数的调用，则会到达该协程的起点，该协程结束，然后终止其他所有协程，包括主协程（类似于C语言中的主线程，该协程ID为1）。 panic： 1、内建函数 2、假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行 3、返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行，这里的defer 有点类似 try-catch-finally 中的 finally 4、直到goroutine整个退出，并报告错误 recover： 1、内建函数 2、用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为 3、一般的调用建议 a). 在defer函数中，通过recever来终止一个gojroutine的panicking过程，从而恢复正常代码的执行 b). 可以获取通过panic传递的error 简单来讲：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。 错误和异常从Golang机制上讲，就是error和panic的区别。很多其他语言也一样，比如C++/Java，没有error但有errno，没有panic但有throw。 Golang错误和异常是可以互相转换的： 错误转异常，比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试完第三次还不成功的话，失败就被提升为异常了。 异常转错误，比如panic触发的异常被recover恢复后，将返回值中error类型的变量进行赋值，以便上层函数继续走错误处理流程。 什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况。 以下给出异常处理的作用域（场景）： 空指针引用 下标越界 除数为0 不应该出现的分支，比如default 输入不应该引起函数错误 其他场景我们使用错误处理，这使得我们的函数接口很精炼。对于异常，我们可以选择在一个合适的上游去recover，并打印堆栈信息，使得部署后的程序不会终止。 说明： Golang错误处理方式一直是很多人诟病的地方，有些人吐槽说一半的代码都是”if err != nil { / 打印 &amp;&amp; 错误处理 / }”，严重影响正常的处理逻辑。当我们区分错误和异常，根据规则设计函数，就会大大提高可读性和可维护性。 1.6 错误处理的正确姿势姿势一：失败的原因只有一个时，不使用error 我们看一个案例： 12345678910func (self *AgentContext) CheckHostType(host_type string) error &#123; switch host_type &#123; case &quot;virtual_machine&quot;: return nil case &quot;bare_metal&quot;: return nil &#125; return errors.New(&quot;CheckHostType ERROR:&quot; + host_type)&#125; 我们可以看出，该函数失败的原因只有一个，所以返回值的类型应该为bool，而不是error，重构一下代码： 1234func (self *AgentContext) IsValidHostType(hostType string) bool &#123; return hostType == &quot;virtual_machine&quot; || hostType == &quot;bare_metal&quot;&#125; 说明：大多数情况，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息，这时的返回值类型不再是简单的bool，而是error。 姿势二：没有失败时，不使用error error在Golang中是如此的流行，以至于很多人设计函数时不管三七二十一都使用error，即使没有一个失败原因。我们看一下示例代码： 12345func (self *CniParam) setTenantId() error &#123; self.TenantId = self.PodNs return nil&#125; 对于上面的函数设计，就会有下面的调用代码： 1234567err := self.setTenantId()if err != nil &#123; // log // free resource return errors.New(...)&#125; 根据我们的正确姿势，重构一下代码： 1234func (self *CniParam) setTenantId() &#123; self.TenantId = self.PodNs&#125; 于是调用代码变为： 12self.setTenantId() 姿势三：error应放在返回值类型列表的最后 对于返回值类型error，用来传递错误信息，在Golang中通常放在最后一个。 12345resp, err := http.Get(url)if err != nil &#123; return nill, err&#125; bool作为返回值类型时也一样。 12345value, ok := cache.Lookup(key) if !ok &#123; // ...cache[key] does not exist… &#125; 姿势四：错误值统一定义，而不是跟着感觉走 很多人写代码时，到处return errors.New(value)，而错误value在表达同一个含义时也可能形式不同，比如“记录不存在”的错误value可能为： “record is not existed.” “record is not exist!” “###record is not existed！！！” … 这使得相同的错误value撒在一大片代码里，当上层函数要对特定错误value进行统一处理时，需要漫游所有下层代码，以保证错误value统一，不幸的是有时会有漏网之鱼，而且这种方式严重阻碍了错误value的重构。 于是，我们可以参考C/C++的错误码定义文件，在Golang的每个包中增加一个错误对象定义文件，如下所示： 1234567var ERR_EOF = errors.New(&quot;EOF&quot;)var ERR_CLOSED_PIPE = errors.New(&quot;io: read/write on closed pipe&quot;)var ERR_NO_PROGRESS = errors.New(&quot;multiple Read calls return no data or error&quot;)var ERR_SHORT_BUFFER = errors.New(&quot;short buffer&quot;)var ERR_SHORT_WRITE = errors.New(&quot;short write&quot;)var ERR_UNEXPECTED_EOF = errors.New(&quot;unexpected EOF&quot;) 姿势五：错误逐层传递时，层层都加日志 层层都加日志非常方便故障定位。 说明：至于通过测试来发现故障，而不是日志，目前很多团队还很难做到。如果你或你的团队能做到，那么请忽略这个姿势。 姿势六：错误处理使用defer 我们一般通过判断error的值来处理错误，如果当前操作失败，需要将本函数中已经create的资源destroy掉，示例代码如下： 12345678910111213141516171819202122232425262728func deferDemo() error &#123; err := createResource1() if err != nil &#123; return ERR_CREATE_RESOURCE1_FAILED &#125; err = createResource2() if err != nil &#123; destroyResource1() return ERR_CREATE_RESOURCE2_FAILED &#125; err = createResource3() if err != nil &#123; destroyResource1() destroyResource2() return ERR_CREATE_RESOURCE3_FAILED &#125; err = createResource4() if err != nil &#123; destroyResource1() destroyResource2() destroyResource3() return ERR_CREATE_RESOURCE4_FAILED &#125; return nil&#125; 当Golang的代码执行时，如果遇到defer的闭包调用，则压入堆栈。当函数返回时，会按照后进先出的顺序调用闭包。对于闭包的参数是值传递，而对于外部变量却是引用传递，所以闭包中的外部变量err的值就变成外部函数返回时最新的err值。根据这个结论，我们重构上面的示例代码： 12345678910111213141516171819202122232425262728293031323334353637func deferDemo() error &#123; err := createResource1() if err != nil &#123; return ERR_CREATE_RESOURCE1_FAILED &#125; defer func() &#123; if err != nil &#123; destroyResource1() &#125; &#125;() err = createResource2() if err != nil &#123; return ERR_CREATE_RESOURCE2_FAILED &#125; defer func() &#123; if err != nil &#123; destroyResource2() &#125; &#125;() err = createResource3() if err != nil &#123; return ERR_CREATE_RESOURCE3_FAILED &#125; defer func() &#123; if err != nil &#123; destroyResource3() &#125; &#125;() err = createResource4() if err != nil &#123; return ERR_CREATE_RESOURCE4_FAILED &#125; return nil&#125; 姿势七：当尝试几次可以避免失败时，不要立即返回错误 如果错误的发生是偶然性的，或由不可预知的问题导致。一个明智的选择是重新尝试失败的操作，有时第二次或第三次尝试时会成功。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。 两个案例： 我们平时上网时，尝试请求某个URL，有时第一次没有响应，当我们再次刷新时，就有了惊喜。 团队的一个QA曾经建议当Neutron的attach操作失败时，最好尝试三次，这在当时的环境下验证果然是有效的。 姿势八：当上层函数不关心错误时，建议不返回error 对于一些资源清理相关的函数（destroy/delete/clear），如果子函数出错，打印日志即可，而无需将错误进一步反馈到上层函数，因为一般情况下，上层函数是不关心执行结果的，或者即使关心也无能为力，于是我们建议将相关函数设计为不返回error。 姿势九：当发生错误时，不忽略有用的返回值 通常，当函数返回non-nil的error时，其他的返回值是未定义的(undefined)，这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，应该将读取到的字符串和错误信息一起打印出来。 说明：对函数的返回值要有清晰的说明，以便于其他人使用。 1.7 异常处理的正确姿势姿势一：在程序开发阶段，坚持速错 速错，简单来讲就是“让它挂”，只有挂了你才会第一时间知道错误。在早期开发以及任何发布阶段之前，最简单的同时也可能是最好的方法是调用panic函数来中断程序的执行以强制发生错误，使得该错误不会被忽略，因而能够被尽快修复。 姿势二：在程序部署后，应恢复异常避免程序终止 在Golang中，某个Goroutine如果panic了，并且没有recover，那么整个Golang进程就会异常退出。所以，一旦Golang程序部署后，在任何情况下发生的异常都不应该导致程序异常退出，我们在上层函数中加一个延迟执行的recover调用来达到这个目的，并且是否进行recover需要根据环境变量或配置文件来定，默认需要recover。这个姿势类似于C语言中的断言，但还是有区别：一般在Release版本中，断言被定义为空而失效，但需要有if校验存在进行异常保护，尽管契约式设计中不建议这样做。在Golang中，recover完全可以终止异常展开过程，省时省力。 我们在调用recover的延迟函数中以最合理的方式响应该异常： 打印堆栈的异常调用信息和关键的业务信息，以便这些问题保留可见； 将异常转换为错误，以便调用者让程序恢复到健康状态并继续安全运行。 我们看一个简单的例子： 12345678910111213141516171819202122232425func funcA() error &#123; defer func() &#123; if p := recover(); p != nil &#123; fmt.Printf(&quot;panic recover! p: %v&quot;, p) debug.PrintStack() &#125; &#125;() return funcB()&#125;func funcB() error &#123; // simulation panic(&quot;foo&quot;) return errors.New(&quot;success&quot;)&#125;func test() &#123; err := funcA() if err == nil &#123; fmt.Printf(&quot;err is nil\\\\n&quot;) &#125; else &#123; fmt.Printf(&quot;err is %v\\\\n&quot;, err) &#125;&#125; 我们期望test函数的输出是： 12err is foo 实际上test函数的输出是： 12err is nil 原因是panic异常处理机制不会自动将错误信息传递给error，所以要在funcA函数中进行显式的传递，代码如下所示： 12345678910111213141516func funcA() (err error) &#123; defer func() &#123; if p := recover(); p != nil &#123; fmt.Println(&quot;panic recover! p:&quot;, p) str, ok := p.(string) if ok &#123; err = errors.New(str) &#125; else &#123; err = errors.New(&quot;panic&quot;) &#125; debug.PrintStack() &#125; &#125;() return funcB()&#125; 姿势三：对于不应该出现的分支，使用异常处理 当某些不应该发生的场景发生时，我们就应该调用panic函数来触发异常。比如，当程序到达了某条逻辑上不可能到达的路径： 12345678910111213switch s := suit(drawCard()); s &#123; case &quot;Spades&quot;: // ... case &quot;Hearts&quot;: // ... case &quot;Diamonds&quot;: // ... case &quot;Clubs&quot;: // ... default: panic(fmt.Sprintf(&quot;invalid suit %v&quot;, s))&#125; 姿势四：针对入参不应该有问题的函数，使用panic设计 入参不应该有问题一般指的是硬编码，我们先看这两个函数（Compile和MustCompile），其中MustCompile函数是对Compile函数的包装： 12345678func MustCompile(str string) *Regexp &#123; regexp, error := Compile(str) if error != nil &#123; panic(`regexp: Compile(` + quote(str) + `): ` + error.Error()) &#125; return regexp&#125; 所以，对于同时支持用户输入场景和硬编码场景的情况，一般支持硬编码场景的函数是对支持用户输入场景函数的包装。对于只支持硬编码单一场景的情况，函数设计时直接使用panic，即返回值类型列表中不会有error，这使得函数的调用处理非常方便（没有了乏味的”if err != nil {/ 打印 &amp;&amp; 错误处理 /}”代码块）。 本文部分内容引自https://www.jianshu.com/p/f30da01eea97 Go语言中包的使用 @author：韩茹 版权所有：北京千锋互联科技有限公司 Go语言使用包（package）这种语法元素来组织源码，所有语法可见性均定义在package这个级别，与Java 、python等语言相比，这算不上什么创新，但与C传统的include相比，则是显得“先进”了许多。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465myblog├── conf│ └── app.conf├── controllers│ ├── aboutme_controller.go│ ├── add_article_controller.go│ ├── album_controller.go│ ├── base_controller.go│ ├── default.go│ ├── delete_article_controller.go│ ├── exit_controller.go│ ├── home_controller.go│ ├── login_controller.go│ ├── register_controller.go│ ├── show_article_controller.go│ ├── tags_controller.go│ ├── update_article_controller.go│ └── upload_controller.go├── main.go├── models│ ├── album_model.go│ ├── article_model.go│ ├── home_model.go│ ├── tags_model.go│ └── user_model.go├── myblogweb├── routers│ └── router.go├── static│ ├── css│ │ ├── blogsheet.css│ │ └── lib│ │ ├── highlight.css│ │ └── login.css│ ├── img│ ├── js│ │ ├── blog.js│ │ ├── lib│ │ │ ├── jquery-3.3.1.min.js│ │ │ └── jquery.url.js│ │ └── reload.min.js│ └── upload│ └── img│ └── 2018│ └── 12│ └── 11│ ├── 1544511378-bee2.png├── tests│ └── default_test.go├── utils│ ├── myUtils.go│ └── mysqlUtils.go└── views ├── aboultme.html ├── album.html ├── block │ ├── home_block.html │ └── nav.html ├── home.html ├── index.tpl ├── login.html ├── register.html ├── show_article.html ├── tags.html └── write_article.html Go 语言的源码复用建立在包（package）基础之上。包通过 package, import, GOPATH 操作完成。 1、 main包Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，需要import导入！ 2、 packagesrc 目录是以代码包的形式组织并保存 Go 源码文件的。每个代码包都和 src 目录下的文件夹一一对应。每个子目录都是一个代码包。 代码包包名和文件目录名，不要求一致。比如文件目录叫 hello，但是代码包包名可以声明为 “main”，但是同一个目录下的源码文件第一行声明的所属包，必须一致！ 同一个目录下的所有.go文件的第一行添加 包定义，以标记该文件归属的包，演示语法： 1package 包名 包需要满足： 一个目录下的同级文件归属一个包。也就是说，在同一个包下面的所有文件的package名，都是一样的。 在同一个包下面的文件package名都建议设为是该目录名，但也可以不是。也就是说，包名可以与其目录不同名。 包名为 main 的包为应用程序的入口包，其他包不能使用。 在同一个包下面的文件属于同一个工程文件，不用import包，可以直接使用 包可以嵌套定义，对应的就是嵌套目录，但包名应该与所在的目录一致，例如： 12345678// 文件：qf/ruby/tool.go中package ruby// 可以被导出的函数func FuncPublic() &#123;&#125;// 不可以被导出的函数func funcPrivate() &#123;&#125; 包中，通过标识符首字母是否大写，来确定是否可以被导出。首字母大写才可以被导出，视为 public 公共的资源。 3、 import要引用其他包，可以使用 import 关键字，可以单个导入或者批量导入，语法演示： A：通常导入 1234567// 单个导入import &quot;package&quot;// 批量导入import ( &quot;package1&quot; &quot;package2&quot; ) B：点操作我们有时候会看到如下的方式导入包 123import( . &quot;fmt&quot;) 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调 用的fmt.Println(&quot;hello world&quot;)可以省略的写成Println(&quot;hello world&quot;) C：起别名 别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字。导入时，可以为包定义别名，语法演示： 123456import ( p1 &quot;package1&quot; p2 &quot;package2&quot; )// 使用时：别名操作，调用包函数时前缀变成了我们的前缀p1.Method() D：_操作如果仅仅需要导入包时执行初始化操作，并不需要使用包内的其他函数，常量等资源。则可以在导入包时，匿名导入。 这个操作经常是让很多人费解的一个操作符，请看下面这个import： 1234import ( &quot;database/sql&quot; _ &quot;github.com/ziutek/mymysql/godrv&quot; ) _操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。也就是说，使用下划线作为包的别名，会仅仅执行init()。 导入的包的路径名，可以是相对路径也可以是绝对路径，推荐使用绝对路径（起始于工程根目录）。 4、GOPATH环境变量import导入时，会从GO的安装目录（也就是GOROOT环境变量设置的目录）和GOPATH环境变量设置的目录中，检索 src/package 来导入包。如果不存在，则导入失败。GOROOT，就是GO内置的包所在的位置。GOPATH，就是我们自己定义的包的位置。 通常我们在开发Go项目时，调试或者编译构建时，需要设置GOPATH指向我们的项目目录，目录中的src目录中的包就可以被导入了。 5、init() 包初始化下面我们详细的来介绍一下这两个函数：init()、main() 是 go 语言中的保留函数。我们可以在源码中，定义 init() 函数。此函数会在包被导入时执行，例如如果是在 main 中导入包，包中存在 init()，那么 init() 中的代码会在 main() 函数执行前执行，用于初始化包所需要的特定资料。例如：包源码： 1234567src/userPackage/tool.gopackage userPackageimport &quot;fmt&quot;func init() &#123; fmt.Println(&quot;tool init&quot;)&#125; 主函数源码： 1234567891011src/main.gopackage mainimport ( &quot;userPackage&quot; )func main() &#123; fmt.Println(&quot;main run&quot;) // 使用userPackage userPackage.SomeFunc()&#125; 执行时，会先输出 “tool init”，再输出 “main run”。 下面我们详细的来介绍一下init()、main() 这两个函数。在 go 语言中的区别如下：相同点： 两个函数在定义时不能有任何的参数和返回值。该函数只能由 go 程序自动调用，不可以被引用。 不同点： init 可以应用于任意包中，且可以重复定义多个。main 函数只能用于 main 包中，且只能定义一个。 两个函数的执行顺序： 在 main 包中的 go 文件默认总是会被执行。 对同一个 go 文件的 init( ) 调用顺序是从上到下的。 对同一个 package 中的不同文件，将文件名按字符串进行“从小到大”排序，之后顺序调用各文件中的init()函数。 对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数。 如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main，一次执行对应的 init 方法。main 包总是被最后一个初始化，因为它总是依赖别的包 图片引自网络 避免出现循环 import，例如：A –&gt; B –&gt; C –&gt; A。 一个包被其它多个包 import，但只能被初始化一次 6、管理外部包go允许import不同代码库的代码。对于import要导入的外部的包，可以使用 go get 命令取下来放到GOPATH对应的目录中去。 举个例子，比如说我们想通过go语言连接mysql数据库，那么需要先下载mysql的数据包，打开终端并输入以下命令： 1localhost:~ ruby$ go get github.com/go-sql-driver/mysql 安装之后，就可以在gopath目录的src下，看到对应的文件包目录： 也就是说，对于go语言来讲，其实并不关心你的代码是内部还是外部的，总之都在GOPATH里，任何import包的路径都是从GOPATH开始的；唯一的区别，就是内部依赖的包是开发者自己写的，外部依赖的包是go get下来的。 扩展我们可以通过go install 来编译包文件。 我们知道一个非main包在编译后会生成一个.a文件（在临时目录下生成，除非使用go install安装到$GOROOT或​$GOPATH下，否则你看不到.a），用于后续可执行程序链接使用。 比如Go标准库中的包对应的源码部分路径在：$GOROOT/src，而标准库中包编译后的.a文件路径在$GOROOT/pkg/darwin_amd64下。","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shadowbynl.github.io/tags/Go/"}]},{"title":"go-study-3","slug":"go-study-3","date":"2020-06-20T09:18:37.000Z","updated":"2020-06-23T11:27:42.959Z","comments":true,"path":"2020/06/20/go-study-3/","link":"","permalink":"https://shadowbynl.github.io/2020/06/20/go-study-3/","excerpt":"Go基础学习其三","text":"Go基础学习其三 2020.6.20-21 学习了go复合类型中的数组Array、切片Slice、集合Map、函数function，此外还学习了基本类型string相关的包中的函数。先记录一下我在学习时觉得需要注意的点，然后copy千锋的笔记和代码。个人笔记一、数组 数组的创建方式 遍历方式 for index, value := range 数组变量 {} 数组是值类型，与c类似，与java、python不同。但注意数组类型就是[n]type类型，而非像c一样的指针之类的。 数组作为值类型，可以在类型、元素个数相等的情况下进行比较，逐位比较。 go的数组元素交换方式，可以写成 a, b = b, a 二、切片（列表） 切片的创建方式，一种是类似数组但不知道元素个数，一种是使用内置make函数。make函数可用来创建go中的引用类型（不包括自定义）。 内置函数append用于给切片追加元素。 遍历方式同数组。 切片的底层实际即为数组，切片变量作为引用类型，存放着底层数组的地址，通过fmt.Printf(“%p”, s)可直接打印其底层数组的地址，而数组作为值类型，打印地址还需取地址&amp;a。切片每次扩容时不超过底层数组的长度，其指向的底层数组不变，若超过，会创建一个新的数组。 在已有数组上创建切片，切面的属性与元素值与数组的关系。 切片作为引用类型，默认为浅拷贝。实现切片深拷贝的方法：逐一拷贝元素，使用内置函数copy。 三、集合Map Map创建时不初始化其值为nil，即其他语言中的null，此后也无法存放键值对。因此使用map关键字创建时必须同时初始化map[key_type]value_type{xxx:xx}，或者采用推荐的做法由make函数创建。 map的使用：存储、获取（返回value,ok）、修改、删除（使用内置函数delete）。 遍历方式。无序遍历：for k, v := range map{}。实现按键有序遍历，就需要先把键都取出来，然后用sort包中的方法排序后进行map遍历。 四、字符串相关包 内置函数 len()获得的是字节数 strings包 strconv包 五、函数function 函数定义在调用处上下均可，不需额外声明。 参数 n type 多个参数的类型一致，可以简写。 可变参 arg ..type 切片s… 表示切片中的全部元素。一个函数的参数列表只能有一个可变参数，且位置应在最后。 返回值：位置类似于js。可以只给出类型，也可以指定名称，这样在return时，不用专门return xxx。空白标识符_用来舍弃返回值。 全局变量不支持简短定义。 递归函数。看源代码 发现go的一个包下即便是不同文件也不能定义名字相同的函数，这与导包时以包为单位而非以文件为单位的做法一致。 defer延迟函数。先被defer的函数后执行。注意defer是延迟执行而非延迟调用延迟传参。 函数的数据类型：func(参数列表的数据类型)(返回值列表的数据类型)。函数的本质：函数名：指向函数体的内存地址；函数名()：将函数进行调用，函数中的代码会全部执行，然后将return的结果返回给调用处。 匿名函数 go语言支持函数式编程的两个体现：支持将一个函数作为另一个函数的参数即回调函数；支持将一个函数作为另一个函数的返回值即闭包。 笔记 一、数组(Array) @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是数组Go 语言提供了数组类型的数据结构。数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。 数组元素可以通过索引（位置）来读取（或者修改），索引从0开始，第一个元素索引为 0，第二个索引为 1，以此类推。数组的下标取值范围是从0开始，到长度减1。 数组一旦定义后，大小不能更改。 1.2 数组的语法声明和初始化数组 需要指明数组的大小和存储的数据类型。 1var variable_name [SIZE] variable_type 示例代码： 12var balance [10] float32var balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; 初始化数组中 {} 中的元素个数不能大于 [] 中的数字。如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小： 1var balance = []float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; 1balance[4] = 50.0 数组的其他创建方式： 123456789101112var a [4] float32 // 等价于：var arr2 = [4]float32&#123;&#125;fmt.Println(a) // [0 0 0 0]var b = [5] string&#123;&quot;ruby&quot;, &quot;王二狗&quot;, &quot;rose&quot;&#125;fmt.Println(b) // [ruby 王二狗 rose ]var c = [5] int&#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;&#125; // bytefmt.Println(c) // [65 66 67 68 69]d := [...] int&#123;1,2,3,4,5&#125;// 根据元素的个数，设置数组的大小fmt.Println(d)//[1 2 3 4 5]e := [5] int&#123;4: 100&#125; // [0 0 0 0 100]fmt.Println(e)f := [...] int&#123;0: 1, 4: 1, 9: 1&#125; // [1 0 0 0 1 0 0 0 0 1]fmt.Println(f) 访问数组元素 1float32 salary = balance[9] 示例代码： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; var n [10]int /* n 是一个长度为 10 的数组 */ var i,j int /* 为数组 n 初始化元素 */ for i = 0; i &lt; 10; i++ &#123; n[i] = i + 100 /* 设置元素为 i + 100 */ &#125; /* 输出每个数组元素的值 */ for j = 0; j &lt; 10; j++ &#123; fmt.Printf(&quot;Element[%d] = %d\\n&quot;, j, n[j] ) &#125;&#125; 运行结果： 12345678910Element[0] = 100Element[1] = 101Element[2] = 102Element[3] = 103Element[4] = 104Element[5] = 105Element[6] = 106Element[7] = 107Element[8] = 108Element[9] = 109 数组的长度 通过将数组作为参数传递给len函数，可以获得数组的长度。 示例代码： 123456789package mainimport &quot;fmt&quot;func main() &#123; a := [...]float64&#123;67.7, 89.8, 21, 78&#125; fmt.Println(&quot;length of a is&quot;,len(a))&#125; 运行结果： 1length of a is 4 您甚至可以忽略声明中数组的长度并将其替换为…让编译器为你找到长度。这是在下面的程序中完成的。 示例代码： 12345678910package mainimport ( &quot;fmt&quot;)func main() &#123; a := [...]int&#123;12, 78, 50&#125; // ... makes the compiler determine the length fmt.Println(a)&#125; 遍历数组： 12345678910package mainimport &quot;fmt&quot;func main() &#123; a := [...]float64&#123;67.7, 89.8, 21, 78&#125; for i := 0; i &lt; len(a); i++ &#123; //looping from 0 to the length of the array fmt.Printf(&quot;%d th element of a is %.2f\\n&quot;, i, a[i]) &#125;&#125; 使用range遍历数组： 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; a := [...]float64&#123;67.7, 89.8, 21, 78&#125; sum := float64(0) for i, v := range a &#123;//range returns both the index and value fmt.Printf(&quot;%d the element of a is %.2f\\n&quot;, i, v) sum += v &#125; fmt.Println(&quot;\\nsum of all elements of a&quot;,sum)&#125; 如果您只需要值并希望忽略索引，那么可以通过使用_ blank标识符替换索引来实现这一点。 12for _, v := range a &#123; //ignores index &#125; 1.3 多维数组Go 语言支持多维数组，以下为常用的多维数组声明语法方式： 1var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type 1var threedim [5][10][4]int 三维数组 12345a = [3][4]int&#123; &#123;0, 1, 2, 3&#125; , /* 第一行索引为 0 */ &#123;4, 5, 6, 7&#125; , /* 第二行索引为 1 */ &#123;8, 9, 10, 11&#125; /* 第三行索引为 2 */&#125; 1.4 数组是值类型数组是值类型Go中的数组是值类型，而不是引用类型。这意味着当它们被分配给一个新变量时，将把原始数组的副本分配给新变量。如果对新变量进行了更改，则不会在原始数组中反映。 123456789101112package mainimport &quot;fmt&quot;func main() &#123; a := [...]string&#123;&quot;USA&quot;, &quot;China&quot;, &quot;India&quot;, &quot;Germany&quot;, &quot;France&quot;&#125; b := a // a copy of a is assigned to b b[0] = &quot;Singapore&quot; fmt.Println(&quot;a is &quot;, a) fmt.Println(&quot;b is &quot;, b) &#125; 运行结果： 123a is [USA China India Germany France] b is [Singapore China India Germany France] 数组的大小是类型的一部分。因此[5]int和[25]int是不同的类型。因此，数组不能被调整大小。不要担心这个限制，因为切片的存在是为了解决这个问题。 12345678package mainfunc main() &#123; a := [3]int&#123;5, 78, 8&#125; var b [5]int b = a //not possible since [3]int and [5]int are distinct types&#125; 一、切片(Slice) @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是切片Go 语言切片是对数组的抽象。Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大 切片是一种方便、灵活且强大的包装器。切片本身没有任何数据。它们只是对现有数组的引用。 切片与数组相比，不需要设定长度，在[]中不用设定值，相对来说比较自由 从概念上面来说slice像一个结构体，这个结构体包含了三个元素： 指针，指向数组中slice指定的开始位置 长度，即slice的长度 最大长度，也就是slice开始位置到数组的最后位置的长度 1.2 切片的语法定义切片 1var identifier []type 切片不需要说明长度。或使用make()函数来创建切片: 123var slice1 []type = make([]type, len)也可以简写为slice1 := make([]type, len) 1make([]T, length, capacity) 初始化 123s[0] = 1s[1] = 2s[2] = 3 1s :=[] int &#123;1,2,3 &#125; 1s := arr[startIndex:endIndex] 将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片（前闭后开），长度为endIndex-startIndex 1s := arr[startIndex:] 缺省endIndex时将表示一直到arr的最后一个元素 1s := arr[:endIndex] 缺省startIndex时将表示从arr的第一个元素开始 1234567891011package mainimport ( &quot;fmt&quot;)func main() &#123; a := [5]int&#123;76, 77, 78, 79, 80&#125; var b []int = a[1:4] //creates a slice from a[1] to a[3] fmt.Println(b)&#125; 1.3 修改切片slice没有自己的任何数据。它只是底层数组的一个表示。对slice所做的任何修改都将反映在底层数组中。 示例代码： 123456789101112131415package mainimport ( &quot;fmt&quot;)func main() &#123; darr := [...]int&#123;57, 89, 90, 82, 100, 78, 67, 69, 59&#125; dslice := darr[2:5] fmt.Println(&quot;array before&quot;,darr) for i := range dslice &#123; dslice[i]++ &#125; fmt.Println(&quot;array after&quot;,darr) &#125; 运行结果： 12array before [57 89 90 82 100 78 67 69 59] array after [57 89 91 83 101 78 67 69 59] 当多个片共享相同的底层数组时，每个元素所做的更改将在数组中反映出来。 示例代码： 12345678910111213141516package mainimport ( &quot;fmt&quot;)func main() &#123; numa := [3]int&#123;78, 79 ,80&#125; nums1 := numa[:] //creates a slice which contains all elements of the array nums2 := numa[:] fmt.Println(&quot;array before change 1&quot;,numa) nums1[0] = 100 fmt.Println(&quot;array after modification to slice nums1&quot;, numa) nums2[1] = 101 fmt.Println(&quot;array after modification to slice nums2&quot;, numa)&#125; 运行结果： 123array before change 1 [78 79 80] array after modification to slice nums1 [100 79 80] array after modification to slice nums2 [100 101 80] 1.4 len() 和 cap() 函数切片的长度是切片中元素的数量。切片的容量是从创建切片的索引开始的底层数组中元素的数量。 切片是可索引的，并且可以由 len() 方法获取长度切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; var numbers = make([]int,3,5) printSlice(numbers)&#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125; 运行结果 1len=3 cap=5 slice=[0 0 0] 空切片 一个切片在未初始化之前默认为 nil，长度为 0 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; var numbers []int printSlice(numbers) if(numbers == nil)&#123; fmt.Printf(&quot;切片是空的&quot;) &#125;&#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125; 运行结果 123len=0 cap=0 slice=[]切片是空的 1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func main() &#123; /* 创建切片 */ numbers := []int&#123;0,1,2,3,4,5,6,7,8&#125; printSlice(numbers) /* 打印原始切片 */ fmt.Println(&quot;numbers ==&quot;, numbers) /* 打印子切片从索引1(包含) 到索引4(不包含)*/ fmt.Println(&quot;numbers[1:4] ==&quot;, numbers[1:4]) /* 默认下限为 0*/ fmt.Println(&quot;numbers[:3] ==&quot;, numbers[:3]) /* 默认上限为 len(s)*/ fmt.Println(&quot;numbers[4:] ==&quot;, numbers[4:]) numbers1 := make([]int,0,5) printSlice(numbers1) /* 打印子切片从索引 0(包含) 到索引 2(不包含) */ number2 := numbers[:2] printSlice(number2) /* 打印子切片从索引 2(包含) 到索引 5(不包含) */ number3 := numbers[2:5] printSlice(number3)&#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125; 运行结果 123456789len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]numbers == [0 1 2 3 4 5 6 7 8]numbers[1:4] == [1 2 3]numbers[:3] == [0 1 2]numbers[4:] == [4 5 6 7 8]len=0 cap=5 slice=[]len=2 cap=9 slice=[0 1]len=3 cap=7 slice=[2 3 4] 1.5 append() 和 copy() 函数append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slicecopy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数 append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即(cap-len) == 0）时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响 下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() &#123; var numbers []int printSlice(numbers) /* 允许追加空切片 */ numbers = append(numbers, 0) printSlice(numbers) /* 向切片添加一个元素 */ numbers = append(numbers, 1) printSlice(numbers) /* 同时添加多个元素 */ numbers = append(numbers, 2,3,4) printSlice(numbers) /* 创建切片 numbers1 是之前切片的两倍容量*/ numbers1 := make([]int, len(numbers), (cap(numbers))*2) /* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) printSlice(numbers1) &#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125; 运行结果 123456len=0 cap=0 slice=[]len=1 cap=2 slice=[0]len=2 cap=2 slice=[0 1]len=5 cap=8 slice=[0 1 2 3 4]len=5 cap=12 slice=[0 1 2 3 4] numbers1与numbers两者不存在联系，numbers发生变化时，numbers1是不会随着变化的。也就是说copy方法是不会建立两个切片的联系的 一、集合(Map) @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是Mapmap是Go中的内置类型，它将一个值与一个键关联起来。可以使用相应的键检索值。 Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的，也是引用类型 使用map过程中需要注意的几点： map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取 map的长度是不固定的，也就是和slice一样，也是一种引用类型 内置的len函数同样适用于map，返回map拥有的key的数量 map的key可以是所有可比较的类型，如布尔型、整数型、浮点型、复杂型、字符串型……也可以键。 1.2 Map的使用1.2.1 使用make()创建map可以使用内建函数 make 也可以使用 map 关键字来定义 Map: 12345/* 声明变量，默认 map 是 nil */var map_variable map[key_data_type]value_data_type/* 使用 make 函数 */map_variable = make(map[key_data_type]value_data_type) 1rating := map[string]float32 &#123;&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 &#125; 如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;func main() &#123; var countryCapitalMap map[string]string /* 创建集合 */ countryCapitalMap = make(map[string]string) /* map 插入 key-value 对，各个国家对应的首都 */ countryCapitalMap[&quot;France&quot;] = &quot;Paris&quot; countryCapitalMap[&quot;Italy&quot;] = &quot;Rome&quot; countryCapitalMap[&quot;Japan&quot;] = &quot;Tokyo&quot; countryCapitalMap[&quot;India&quot;] = &quot;New Delhi&quot; /* 使用 key 输出 map 值 */ for country := range countryCapitalMap &#123; fmt.Println(&quot;Capital of&quot;,country,&quot;is&quot;,countryCapitalMap[country]) &#125; /* 查看元素在集合中是否存在 */ captial, ok := countryCapitalMap[&quot;United States&quot;] /* 如果 ok 是 true, 则存在，否则不存在 */ if(ok)&#123; fmt.Println(&quot;Capital of United States is&quot;, captial) &#125;else &#123; fmt.Println(&quot;Capital of United States is not present&quot;) &#125;&#125; 运行结果： 12345Capital of France is ParisCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New DelhiCapital of United States is not present 1.2.2 delete() 函数delete(map, key) 函数用于删除集合的元素, 参数为 map 和其对应的 key。删除函数不返回任何值。 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func main() &#123; /* 创建 map */ countryCapitalMap := map[string] string &#123;&quot;France&quot;:&quot;Paris&quot;,&quot;Italy&quot;:&quot;Rome&quot;,&quot;Japan&quot;:&quot;Tokyo&quot;,&quot;India&quot;:&quot;New Delhi&quot;&#125; fmt.Println(&quot;原始 map&quot;) /* 打印 map */ for country := range countryCapitalMap &#123; fmt.Println(&quot;Capital of&quot;,country,&quot;is&quot;,countryCapitalMap[country]) &#125; /* 删除元素 */ delete(countryCapitalMap,&quot;France&quot;); fmt.Println(&quot;Entry for France is deleted&quot;) fmt.Println(&quot;删除元素后 map&quot;) /* 打印 map */ for country := range countryCapitalMap &#123; fmt.Println(&quot;Capital of&quot;,country,&quot;is&quot;,countryCapitalMap[country]) &#125;&#125; 运行结果： 12345678910原始 mapCapital of France is ParisCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New DelhiEntry for France is deleted删除元素后 mapCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New Delhi 1.2.3 ok-idiom我们可以通过key获取map中对应的value值。语法为： 1map[key] 但是当key如果不存在的时候，我们会得到该value值类型的默认值，比如string类型得到空字符串，int类型得到0。但是程序不会报错。 所以我们可以使用ok-idiom获取值，可知道key/value是否存在 1value, ok := map[key] 示例代码： 123456789101112131415package mainimport ( &quot;fmt&quot;)func main() &#123; m := make(map[string]int) m[&quot;a&quot;] = 1 x, ok := m[&quot;b&quot;] fmt.Println(x, ok) x, ok = m[&quot;a&quot;] fmt.Println(x, ok)&#125; 运行结果： 120 false1 true 1.2.4 map的长度使用len函数可以确定map的长度。 1len(map) // 可以得到map的长度 1.2.5 map是引用类型的与切片相似，映射是引用类型。当将映射分配给一个新变量时，它们都指向相同的内部数据结构。因此，一个的变化会反映另一个。 示例代码： 123456789101112131415161718package mainimport ( &quot;fmt&quot;)func main() &#123; personSalary := map[string]int&#123; &quot;steve&quot;: 12000, &quot;jamie&quot;: 15000, &#125; personSalary[&quot;mike&quot;] = 9000 fmt.Println(&quot;Original person salary&quot;, personSalary) newPersonSalary := personSalary newPersonSalary[&quot;mike&quot;] = 18000 fmt.Println(&quot;Person salary changed&quot;, personSalary)&#125; 运行结果： 12Original person salary map[steve:12000 jamie:15000 mike:9000] Person salary changed map[steve:12000 jamie:15000 mike:18000] map不能使用==操作符进行比较。==只能用来检查map是否为空。否则会报错：invalid operation: map1 == map2 (map can only be comparedto nil) 一、字符串(string) @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是stringGo中的字符串是一个字节的切片。可以通过将其内容封装在“”中来创建字符串。Go中的字符串是Unicode兼容的，并且是UTF-8编码的。 示例代码： 12345678910package mainimport ( &quot;fmt&quot;)func main() &#123; name := &quot;Hello World&quot; fmt.Println(name)&#125; 1.2 string的使用1.2.1 访问字符串中的单个字节12345678910111213141516package mainimport ( &quot;fmt&quot;)func main() &#123; name := &quot;Hello World&quot; for i:= 0; i &lt; len(s); i++ &#123; fmt.Printf(&quot;%d &quot;, s[i]) &#125; fmt.Printf(&quot;\\n&quot;) for i:= 0; i &lt; len(s); i++ &#123; fmt.Printf(&quot;%c &quot;,s[i]) &#125;&#125; 运行结果： 72 101 108 108 111 32 87 111 114 108 100H e l l o W o r l d 1.3 strings包访问strings包，可以有很多操作string的函数。 1.4 strconv包访问strconv包，可以实现string和其他数值类型之间的转换。 一、函数的概念 @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是函数函数是执行特定任务的代码块。 1.2 函数的声明go语言至少有一个main函数 语法格式： 12345func funcName(parametername type1, parametername type2) (output1 type1, output2 type2) &#123;//这里是处理逻辑代码//返回多个值return value1, value2&#125; func：函数由 func 开始声明 funcName：函数名称，函数名和参数列表一起构成了函数签名。 parametername type：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 output1 type1, output2 type2：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 上面返回值声明了两个变量output1和output2，如果你不想声明也可以，直接就两个类型。 如果只有一个返回值且不声明返回值变量，那么你可以省略包括返回值的括号（即一个返回值可以不声明返回类型） 函数体：函数定义的代码集合。 1.3 函数的使用示例代码： 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() &#123; /* 定义局部变量 */ var a int = 100 var b int = 200 var ret int /* 调用函数并返回最大值 */ ret = max(a, b) fmt.Printf( &quot;最大值是 : %d\\n&quot;, ret )&#125;/* 函数返回两个数的最大值 */func max(num1, num2 int) int &#123; /* 定义局部变量 */ var result int if (num1 &gt; num2) &#123; result = num1 &#125; else &#123; result = num2 &#125; return result &#125; 运行结果： 1最大值是 : 200 二、函数的参数2.1 参数的使用形式参数：定义函数时，用于接收外部传入的数据，叫做形式参数，简称形参。 实际参数：调用函数时，传给形参的实际的数据，叫做实际参数，简称实参。 函数调用： A：函数名称必须匹配 B：实参与形参必须一一对应：顺序，个数，类型2.2 可变参Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参： 1func myfunc(arg ...int) &#123;&#125; arg ...int告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是int。在函数体中，变量arg是一个int的slice： 123for _, n := range arg &#123;fmt.Printf(&quot;And the number is: %d\\n&quot;, n)&#125; 2.3 参数传递go语言函数的参数也是存在值传递和引用传递 函数运用场景 值传递 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;math&quot;)func main()&#123; /* 声明函数变量 */ getSquareRoot := func(x float64) float64 &#123; return math.Sqrt(x) &#125; /* 使用函数 */ fmt.Println(getSquareRoot(9))&#125; 引用传递 这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&amp;x传入函数，并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子 1234567891011121314package mainimport &quot;fmt&quot;//简单的一个函数，实现了参数+1的操作func add1(a *int) int &#123; // 请注意，*a = *a+1 // 修改了a的值return *a // 返回新值&#125; func main() &#123;x := 3fmt.Println(&quot;x = &quot;, x) // 应该输出 &quot;x = 3&quot;x1 := add1(&amp;x) // 调用 add1(&amp;x) 传x的地址fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出 &quot;x+1 = 4&quot;fmt.Println(&quot;x = &quot;, x) // 应该输出 &quot;x = 4&quot;&#125; 传指针使得多个函数能操作同一个对象。 传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。 Go语言中slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针） 三、函数的返回值3.1 什么是函数的返回值一个函数被调用后，返回给调用处的执行结果，叫做函数的返回值。 调用处需要使用变量接收该结果 3.2 一个函数可以返回多个值一个函数可以没有返回值，也可以有一个返回值，也可以有返回多个值。 123456789101112package mainimport &quot;fmt&quot;func swap(x, y string) (string, string) &#123; return y, x&#125;func main() &#123; a, b := swap(&quot;Mahesh&quot;, &quot;Kumar&quot;) fmt.Println(a, b)&#125; 12345func SumAndProduct(A, B int) (add int, Multiplied int) &#123;add = A+BMultiplied = A*Breturn&#125; 3.3 空白标识符_是Go中的空白标识符。它可以代替任何类型的任何值。让我们看看这个空白标识符的用法。 比如rectProps函数返回的结果是面积和周长，如果我们只要面积，不要周长，就可以使用空白标识符。 示例代码： 123456789101112131415package mainimport ( &quot;fmt&quot;)func rectProps(length, width float64) (float64, float64) &#123; var area = length * width var perimeter = (length + width) * 2 return area, perimeter&#125;func main() &#123; area, _ := rectProps(10.8, 5.6) // perimeter is discarded fmt.Printf(&quot;Area %f &quot;, area)&#125; 四、函数的作用域作用域：变量可以使用的范围。 4.1 局部变量一个函数内部定义的变量，就叫做局部变量 变量在哪里定义，就只能在哪个范围使用，超出这个范围，我们认为变量就被销毁了。 4.2 全局变量一个函数外部定义的变量，就叫做全局变量 所有的函数都可以使用，而且共享这一份数据 五、函数的本质函数也是Go语言中的一种数据类型，可以作为另一个函数的参数，也可以作为另一个函数的返回值。 六、defer函数6.1 延迟是什么?即延迟（defer）语句，延迟语句被用于执行一个函数调用，在这个函数之前，延迟语句返回。 6.2 延迟函数你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题 如果有很多调用defer，那么defer是采用后进先出模式 在离开所在的方法时，执行（报错的时候也会执行） 1234567891011func ReadWrite() bool &#123; file.Open(&quot;file&quot;) defer file.Close() if failureX &#123; return false &#125; i f failureY &#123; return false &#125; return true&#125; 最后才执行file.Close() 示例代码： 12345678910package mainimport &quot;fmt&quot;func main() &#123; a := 1 b := 2 defer fmt.Println(b) fmt.Println(a)&#125; 运行结果： 1212 示例代码： 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot;)func finished() &#123; fmt.Println(&quot;Finished finding largest&quot;)&#125;func largest(nums []int) &#123; defer finished() fmt.Println(&quot;Started finding largest&quot;) max := nums[0] for _, v := range nums &#123; if v &gt; max &#123; max = v &#125; &#125; fmt.Println(&quot;Largest number in&quot;, nums, &quot;is&quot;, max)&#125;func main() &#123; nums := []int&#123;78, 109, 2, 563, 300&#125; largest(nums)&#125; 运行结果： 123Started finding largest Largest number in [78 109 2 563 300] is 563 Finished finding largest 6.3 延迟方法延迟并不仅仅局限于函数。延迟一个方法调用也是完全合法的。让我们编写一个小程序来测试这个。 示例代码： 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)type person struct &#123; firstName string lastName string&#125;func (p person) fullName() &#123; fmt.Printf(&quot;%s %s&quot;,p.firstName,p.lastName)&#125;func main() &#123; p := person &#123; firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, &#125; defer p.fullName() fmt.Printf(&quot;Welcome &quot;) &#125; 运行结果： 12Welcome John Smith 6.4 延迟参数延迟函数的参数在执行延迟语句时被执行，而不是在执行实际的函数调用时执行。 让我们通过一个例子来理解这个问题。 示例代码： 1234567891011121314151617package mainimport ( &quot;fmt&quot;)func printA(a int) &#123; fmt.Println(&quot;value of a in deferred function&quot;, a)&#125;func main() &#123; a := 5 defer printA(a) a = 10 fmt.Println(&quot;value of a before deferred function call&quot;, a)&#125; 运行结果： 123value of a before deferred function call 10 value of a in deferred function 5 6.5 堆栈的推迟当一个函数有多个延迟调用时，它们被添加到一个堆栈中，并在Last In First Out（LIFO）后进先出的顺序中执行。 我们将编写一个小程序，它使用一堆defers打印一个字符串。示例代码： 123456789101112131415package mainimport ( &quot;fmt&quot;)func main() &#123; name := &quot;Naveen&quot; fmt.Printf(&quot;Orignal String: %s\\n&quot;, string(name)) fmt.Printf(&quot;Reversed String: &quot;) for _, v := range []rune(name) &#123; defer fmt.Printf(&quot;%c&quot;, v) &#125;&#125; 运行结果： 123Orignal String: Naveen Reversed String: neevaN 6.6 defer注意点12345defer函数：当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。当执行外围函数中的return语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。 代码数组相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286package mainimport &quot;fmt&quot;func main() &#123; /* 数据类型： 基本类型：整数，浮点，布尔，字符串 复合类型：array，slice，map，struct，pointer，function，channel。。。 数组： 1.概念：存储一组相同数据类型的数据结构 理解为容器，存储一组数据 2.语法： var 数组名 [长度] 数据类型 var 数组名 = [长度] 数据类型&#123;元素1，元素2.。。&#125; 数组名 := [...]数据类型&#123;元素。。。&#125; 3.通过下标访问 下标，也叫索引：index， 默认从0开始的整数，直到长度减1 数组名[index] 赋值 取值 不能越界：[0,长度-1] 4.长度和容量：go语言的内置函数 len(array/map/slice/string)，长度 cap()，容量 */ var num1 int num1 = 100 num1 = 200 fmt.Println(num1) fmt.Printf(&quot;%p\\n&quot;,&amp;num1) //step1：创建数组 var arr1 [4] int fmt.Printf(&quot;%p\\n&quot;,&amp;arr1) //step2：数组的访问 arr1[0] = 1 arr1[1] = 2 arr1[2] = 3 arr1[3] = 4 fmt.Println(arr1[0])//打印第一个数值 fmt.Println(arr1[2])//打印第三个数值 //fmt.Println(arr1[4]) //invalid array index 4 (out of bounds for 4-element array) fmt.Println(&quot;数组的长度：&quot;,len(arr1)) //容器中实际存储的数据量 fmt.Println(&quot;数组的容量：&quot;,cap(arr1)) //容器中能够存储的最大的数量 //因为数组定长，长度和容量相同 arr1[0] = 100 fmt.Println(arr1[0]) //数组的其他创建方式 var a [4] int //同 var a= [4] int fmt.Println(a) var b = [4]int&#123;1,2,3,4&#125; fmt.Println(b) var c = [5]int&#123;1,2,4&#125; fmt.Println(c) var d = [5]int&#123;1:1,3:2&#125; fmt.Println(d) var e = [5]string&#123;&quot;rose&quot;,&quot;王二狗&quot;,&quot;ruby&quot;&#125; fmt.Println(e) f := [...]int&#123;1,2,3,4,5&#125; fmt.Println(f) fmt.Println(len(f)) g:=[...]int&#123;1:3,6:5&#125; fmt.Println(g) fmt.Println(len(g))&#125;package mainimport &quot;fmt&quot;func main() &#123; /* 一维数组：存储的多个数据是数值本身 a1 :=[3]int&#123;1,2,3&#125; 二维数组：存储的是一维的一维 a2 := [3][4]int&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125; 该二维数组的长度，就是3。 存储的元素是一维数组，一维数组的元素是数值，每个一维数组长度为4。 多维数组：。。。 */ a2 := [3][4]int&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;&#125; fmt.Println(a2) fmt.Printf(&quot;二维数组的地址：%p\\n&quot;, &amp;a2) fmt.Printf(&quot;二维数组的长度：%d\\n&quot;, len(a2)) fmt.Printf(&quot;一维数组的长度：%d\\n&quot;, len(a2[0])) fmt.Println(a2[0][3]) // 4 fmt.Println(a2[1][2]) //7 fmt.Println(a2[2][1]) // 10 //遍历二维数组 for i:=0;i&lt;len(a2);i++&#123; for j:=0;j&lt;len(a2[i]);j++&#123; fmt.Print(a2[i][j],&quot;\\t&quot;) &#125; fmt.Println() &#125; fmt.Println(&quot;---------------------&quot;) //for range 遍历二维数组 for _,arr := range a2&#123; for _,val := range arr&#123; fmt.Print(val,&quot;\\t&quot;) &#125; fmt.Println() &#125;&#125;package mainimport &quot;fmt&quot;func main() &#123; /* 数组的遍历： 依次访问数组中的元素 方法一：arr[0],arr[1],arr[2].... 方法二：通过循环，配合下标 for i:=0;i&lt;len(arr);i++&#123; arr[i] &#125; 方法三：使用range range，词义&quot;范围&quot; 不需要操作数组的下标，到达数组的末尾，自动结束for range循环。 每次都数组中获取下标和对应的数值。 */ arr1 := [5]int&#123;1,2,3,4,5&#125; fmt.Println(arr1[0]) fmt.Println(arr1[1]) fmt.Println(arr1[2]) fmt.Println(arr1[3]) fmt.Println(arr1[4]) fmt.Println(&quot;---------------&quot;) for i:=0;i&lt;len(arr1);i++&#123; arr1[i] = i*2+1 fmt.Println(arr1[i]) &#125; fmt.Println(arr1) fmt.Println(&quot;----------------&quot;) for index,value := range arr1&#123; fmt.Printf(&quot;下标是：%d,数值是:%d\\n&quot;,index,value) &#125; sum := 0 for _,v:=range arr1&#123; sum += v &#125; fmt.Println(sum)&#125;package mainimport &quot;fmt&quot;func main() &#123; /* 数组的排序： 让数组中的元素具有一定的顺序。 arr :=[5]int&#123;15,23,8,10,7&#125; 升序：[7,8,10,15,23] 将序：[23,15,10,8,7] 排序算法： 冒泡排序，插入排序，选择排序，希尔排序，堆排序，快速排序。。。。 冒泡排序：（Bubble Sort） 依次比较两个相邻的元素，如果他们的顺序（如从大到小）就把他们交换过来。 */ arr := [5]int&#123;15, 23, 8, 10, 7&#125; ////第一轮排序 //for j := 0; j &lt; 4; j++ &#123; // if arr[j] &gt; arr[j+1] &#123; // arr[j], arr[j+1] = arr[j+1], arr[j] // &#125; //&#125; //fmt.Println(arr) // ////第二轮排序 //for j:=0;j&lt;3;j++&#123; // if arr[j] &gt; arr[j+1] &#123; // arr[j], arr[j+1] = arr[j+1], arr[j] // &#125; //&#125; //fmt.Println(arr) for i:=1;i&lt;len(arr);i++&#123; for j := 0; j &lt; len(arr)-i; j++ &#123; if arr[j] &gt; arr[j+1] &#123; arr[j], arr[j+1] = arr[j+1], arr[j] &#125; &#125; fmt.Println(arr) &#125;&#125;package mainimport &quot;fmt&quot;func main() &#123; /* 数据类型： 基本类型：int，float，string，bool。。 复合类型：array，slice，map，function，pointer，channel。。 数组的数据类型： [size]type 值类型：理解为存储的数值本身 将数据传递给其他的变量，传递的是数据的副本(备份) int,float,string,bool,array 引用类型：理解为存储的数据的内存地址 slice，map。。 */ //1.数据类型 num := 10 fmt.Printf(&quot;%T\\n&quot;, num) arr1 := [4]int&#123;1, 2, 3, 4&#125; arr2 := [3]float64&#123;2.15, 3.18, 6.19&#125; arr3 := [4]int&#123;5, 6, 7, 8&#125; arr4 := [2]string&#123;&quot;hello&quot;, &quot;world&quot;&#125; fmt.Printf(&quot;%T\\n&quot;, arr1) //[4]int fmt.Printf(&quot;%T\\n&quot;, arr2) //[3]float64 fmt.Printf(&quot;%T\\n&quot;, arr3) //[4]int fmt.Printf(&quot;%T\\n&quot;, arr4) //[2]string //2.赋值 num2 := num //值传递 fmt.Println(num, num2) //10 10 num2 = 20 fmt.Println(num, num2) //10 20 //数组呢 arr5 := arr1 //值传递 fmt.Println(arr1) fmt.Println(arr5) arr5[0] =1 fmt.Println(arr1) fmt.Println(arr5) a := 3 b := 4 fmt.Println(a==b) //比较a和b的数值是否相等 fmt.Println(arr5 == arr1) //比较数组的对应下标位置的数值是否相等 //fmt.Println(arr1 == arr2) //invalid operation: arr1 == arr2 (mismatched types [4]int and [3]float64)&#125; 切片相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286package mainimport &quot;fmt&quot;func main() &#123; /* 数组array： 存储一组相同数据类型的数据结构。 特点：定长 切片slice： 同数组类似，也叫做变长数组或者动态数组。 特点：变长 是一个引用类型的容器，指向了一个底层数组。 make() func make(t Type, size ...IntegerType) Type 第一个参数：类型 slice，map，chan 第二个参数：长度len 实际存储元素的数量 第三个参数：容量cap 最多能够存储的元素的数量 append()，专门用于向切片的尾部追加元素 slice = append(slice, elem1, elem2) slice = append(slice, anotherSlice...) */ //1.数组 arr := [4]int&#123;1,2,3,4&#125;//定长 fmt.Println(arr) //2.切片 var s1 []int fmt.Println(s1) s2 := []int&#123;1,2,3,4&#125; //变长 fmt.Println(s2) fmt.Printf(&quot;%T,%T\\n&quot;,arr,s2) //[4]int,[]int s3 := make([]int,3,8) fmt.Println(s3) fmt.Printf(&quot;容量：%d,长度：%d\\n&quot;,cap(s3),len(s3)) s3[0] = 1 s3[1] = 2 s3[2] = 3 fmt.Println(s3) //fmt.Println(s3[3]) //panic: runtime error: index out of range //append() s4 := make([]int,0,5) fmt.Println(s4) s4 = append(s4,1,2) fmt.Println(s4) s4 = append(s4,3,4,5,6,7) fmt.Println(s4) s4 = append(s4,s3...) fmt.Println(s4) //遍历切片 for i:=0;i&lt;len(s4);i++&#123; fmt.Println(s4[i]) &#125; for i,v :=range s4&#123; fmt.Printf(&quot;%d--&gt;%d\\n&quot;,i,v) &#125;&#125;package mainimport &quot;fmt&quot;func main() &#123; /* 切片Slice： 1.每一个切片引用了一个底层数组 2.切片本身不存储任何数据，都是这个底层数组存储，所以修改切片也就是修改这个数组中的数据 3.当向切片中添加数据时，如果没有超过容量，直接添加，如果超过容量，自动扩容(成倍增长) 4.切片一旦扩容，就是重新指向一个新的底层数组 s1:3---&gt;6---&gt;12---&gt;24 s2:4---&gt;8---&gt;16---&gt;32.... */ s1 := []int&#123;1, 2, 3&#125; fmt.Println(s1) fmt.Printf(&quot;len:%d,cap:%d\\n&quot;, len(s1), cap(s1)) //len:3,cap:3 fmt.Printf(&quot;%p\\n&quot;, s1) s1 = append(s1, 4, 5) fmt.Println(s1) fmt.Printf(&quot;len:%d,cap:%d\\n&quot;, len(s1), cap(s1)) //len:5,cap:6 fmt.Printf(&quot;%p\\n&quot;, s1) s1 = append(s1,6,7,8) fmt.Println(s1) fmt.Printf(&quot;len:%d,cap:%d\\n&quot;, len(s1), cap(s1)) //len:8,cap:12 fmt.Printf(&quot;%p\\n&quot;, s1) s1 = append(s1,9,10) fmt.Println(s1) fmt.Printf(&quot;len:%d,cap:%d\\n&quot;, len(s1), cap(s1)) //len:10,cap:12 fmt.Printf(&quot;%p\\n&quot;, s1) s1 = append(s1,11,12,13,14,15) fmt.Println(s1) fmt.Printf(&quot;len:%d,cap:%d\\n&quot;, len(s1), cap(s1)) //len:15,cap:24 fmt.Printf(&quot;%p\\n&quot;, s1)&#125;package mainimport &quot;fmt&quot;func main() &#123; /* slice := arr[start:end] 切片中的数据：[start,end) arr[:end],从头到end arr[start:]从start到末尾 从已有的数组上，直接创建切片，该切片的底层数组就是当前的数组。 长度是从start到end切割的数据量。 但是容量从start到数组的末尾。 */ a := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; fmt.Println(&quot;----------1.已有数组直接创建切片--------------------&quot;) s1 := a[:5] //1-5 s2 := a[3:8] //4-8 s3 := a[5:] // 6-10 s4 := a[:] // 1-10 fmt.Println(&quot;a:&quot;, a) fmt.Println(&quot;s1:&quot;, s1) fmt.Println(&quot;s2:&quot;, s2) fmt.Println(&quot;s3:&quot;, s3) fmt.Println(&quot;s4:&quot;, s4) fmt.Printf(&quot;%p\\n&quot;,&amp;a) fmt.Printf(&quot;%p\\n&quot;,s1) fmt.Println(&quot;----------2.长度和容量--------------------&quot;) fmt.Printf(&quot;s1 len:%d,cap:%d\\n&quot;,len(s1),cap(s1)) //s1 len:5,cap:10 fmt.Printf(&quot;s2 len:%d,cap:%d\\n&quot;,len(s2),cap(s2)) //s2 len:5,cap:7 fmt.Printf(&quot;s3 len:%d,cap:%d\\n&quot;,len(s3),cap(s3)) //s3 len:5,cap:5 fmt.Printf(&quot;s4 len:%d,cap:%d\\n&quot;,len(s4),cap(s4)) //s4 len:10,cap:10 fmt.Println(&quot;----------3.更改数组的内容--------------------&quot;) a[4] =100 fmt.Println(a) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(&quot;----------4.更改切片的内容--------------------&quot;) s2[2] =200 fmt.Println(a) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(&quot;----------4.更改切片的内容--------------------&quot;) s1 = append(s1,1,1,1,1) fmt.Println(a) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(&quot;----------5.添加元素切片扩容--------------------&quot;) fmt.Println(len(s1),cap(s1)) s1 = append(s1,2,2,2,2,2) fmt.Println(a) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(len(s1),cap(s1)) fmt.Printf(&quot;%p\\n&quot;,s1) fmt.Printf(&quot;%p\\n&quot;,&amp;a)&#125;package mainimport &quot;fmt&quot;func main() &#123; /* 按照类型来分： 基本类型：int，float，string，bool 复合类型：array，slice，map，struct，pointer，function，chan 按照特点来分： 值类型：int，float，string，bool，array 传递的是数据副本 引用类型：Slice 传递的地址,多个变量指向了同一块内存地址， 所以：切片是引用类型的数据，存储了底层数组的引用 */ //1.数组：值类型 a1 := [4]int&#123;1,2,3,4&#125; a2 := a1 //值传递：传递的是数据 fmt.Println(a1,a1) a1[0] =100 fmt.Println(a1,a2) //2.切片：引用类型 s1 :=[]int&#123;1,2,3,4&#125; s2 := s1 fmt.Println(s1,s2) s1[0] =100 fmt.Println(s1,s2) fmt.Printf(&quot;%p\\n&quot;,s1) fmt.Printf(&quot;%p\\n&quot;,s2) fmt.Printf(&quot;%p\\n&quot;,&amp;s1) fmt.Printf(&quot;%p\\n&quot;,&amp;s2)&#125;package mainimport &quot;fmt&quot;func main() &#123; /* 深拷贝：拷贝的是数据本身。 值类型的数据，默认都是深拷贝：array，int，float，string，bool，struct 浅拷贝：拷贝的是数据 地址。 导致多个变量指向同一块内存 引用类型的数据，默认都是浅拷贝：slice，map， 因为切片是引用类型的数据，直接拷贝的是地址。 func copy(dst, src []Type) int 可以实现切片的拷贝 */ s1 := []int&#123;1,2,3,4&#125; s2 := make([]int,0) //len:0,cap:0 for i:=0;i&lt;len(s1);i++&#123; s2 = append(s2,s1[i]) &#125; fmt.Println(s1) fmt.Println(s2) s1[0] = 100 fmt.Println(s1) fmt.Println(s2) //copy() s3 := []int&#123;7,8,9&#125; fmt.Println(s2) fmt.Println(s3) //copy(s2,s3) //将s3中的元素，拷贝到s2中 //copy(s3,s2) //将s2中的元素，拷贝到s3中 copy(s3[1:],s2[2:]) fmt.Println(s2) fmt.Println(s3)&#125; 集合相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296package mainimport &quot;fmt&quot;func main() &#123; /* map：映射，是一种专门用于存储键值对的集合。属于引用类型 存储特点： A：存储的是无序的键值对 B：键不能重复，并且和value值一一对应的。 map中的key不能重复，如果重复，那么新的value会覆盖原来的，程序不会报错。 语法结构： 1.创建map var map1 map[key类型]value类型 nil map，无法直接使用 var map2 = make(map[key类型])value类型 var map3 = map[key类型]value类型&#123;key:value,key:value,key:value...&#125; 2.添加/修改 map[key]=value 如果key不存在，就是添加数据 如果key存在，就是修改数据 3.获取 map[key]--&gt;value value,ok := map[key] 根据key获取对应的value 如果key存在，value就是对应的数据，ok为true 如果key不存在，value就是值类型的默认值，ok为false 4.删除数据： delete(map，key) 如果key存在，就可以直接删除 如果key不存在，删除失败 5.长度： len() 每种数据类型： int：0 float：0.0--&gt;0 string:&quot;&quot; array:[00000] slice：nil map：nil */ //1.创建map var map1 map[int]string //没有初始化，nil var map2 = make(map[int]string) //创建 var map3 = map[string]int&#123;&quot;Go&quot;: 98, &quot;Python&quot;: 87, &quot;Java&quot;: 79, &quot;Html&quot;: 93&#125; fmt.Println(map1) fmt.Println(map2) fmt.Println(map3) fmt.Println(map1 == nil) fmt.Println(map2 == nil) fmt.Println(map3 == nil) //2.nil map if map1 == nil &#123; map1 = make(map[int]string) fmt.Println(map1 == nil) &#125; //3.存储键值对到map中 //map1[key] = value map1[1] = &quot;hello&quot; //panic: assignment to entry in nil map map1[2] = &quot;world&quot; map1[3] = &quot;memeda&quot; map1[4] = &quot;王二狗&quot; map1[5] = &quot;ruby&quot; map1[6] = &quot;三胖思密达&quot; map1[7] = &quot;&quot; //4.获取数据，根据key获取对应的value值 //根据key获取对应的value，如果key存在，获取数值，如果key不存在，获取的是value值类型的零值 fmt.Println(map1) fmt.Println(map1[4]) //根据key为4，获取对应的value值 fmt.Println(map1[40]) //&quot;&quot; v1,ok :=map1[40] if ok &#123; fmt.Println(&quot;对应的数值是：&quot;,v1) &#125;else&#123; fmt.Println(&quot;操作的key不存在，获取到的是零值：&quot;,v1) &#125; //5.修改数据 fmt.Println(map1) map1[3] = &quot;如花&quot; fmt.Println(map1) //6.删除数据 delete(map1,3) fmt.Println(map1) delete(map1,30) fmt.Println(map1) //7.长度 fmt.Println(len(map1))&#125;package mainimport ( &quot;fmt&quot; &quot;sort&quot;)func main() &#123; /* map的遍历： 使用：for range 数组，切片：index，value map：key，value */ map1 := make(map[int]string) map1[1] = &quot;红孩儿&quot; map1[2] = &quot;小钻风&quot; map1[3] = &quot;白骨精&quot; map1[4] = &quot;白素贞&quot; map1[5] = &quot;金角大王&quot; map1[6] = &quot;王二狗&quot; //1.遍历map for k, v := range map1 &#123; fmt.Println(k, v) &#125; fmt.Println(&quot;----------------------&quot;) for i:=1;i&lt;=len(map1);i++&#123; fmt.Println(i,&quot;---&gt;&quot;,map1[i]) &#125; /* 1.获取所有的key，--&gt;切片/数组 2.进行排序 3.遍历key，---&gt;map[key] */ keys :=make([]int,0,len(map1)) fmt.Println(keys) for k,_:=range map1&#123; keys = append(keys,k) &#125; fmt.Println(keys) //冒泡排序，或者使用sort包下的排序方法 sort.Ints(keys) fmt.Println(keys) for _,key :=range keys&#123; fmt.Println(key,map1[key]) &#125; s1 :=[]string&#123;&quot;Apple&quot;,&quot;Windows&quot;,&quot;Orange&quot;,&quot;abc&quot;,&quot;王二狗&quot;,&quot;acd&quot;,&quot;acc&quot;&#125; fmt.Println(s1) sort.Strings(s1) fmt.Println(s1)&#125;package mainimport &quot;fmt&quot;func main() &#123; /* map和slice的结合使用： 1.创建map用于存储人的信息 name，age，sex，address 2.每个map存储一个人的信息 3.将这些map存入到slice中 4.打印遍历输出 */ //1.创建map存储第一个人的信息 map1 := make(map[string]string) map1[&quot;name&quot;]= &quot;王二狗&quot; map1[&quot;age&quot;] = &quot;30&quot; map1[&quot;sex&quot;] = &quot;男性&quot; map1[&quot;address&quot;] = &quot;北京市XX路XX号&quot; fmt.Println(map1) //2.第二个人 map2 := make(map[string]string) map2[&quot;name&quot;] = &quot;李小花&quot; map2[&quot;age&quot;] = &quot;20&quot; map2[&quot;sex&quot;] = &quot;女性&quot; map2[&quot;address&quot;] = &quot;上海市。。。&quot; fmt.Println(map2) //3. map3 := map[string]string&#123;&quot;name&quot;:&quot;ruby&quot;,&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;女性&quot;,&quot;address&quot;:&quot;杭州市&quot;&#125; fmt.Println(map3) //将map存入到slice中 s1 := make([]map[string]string ,0,3) s1 = append(s1,map1) s1 = append(s1,map2) s1= append(s1,map3) //遍历切片 for i,val :=range s1 &#123; //val ：map1，map2，map3 fmt.Printf(&quot;第 %d 个人的信息是：\\n&quot;,i+1) fmt.Printf(&quot;\\t姓名：%s\\n&quot;,val[&quot;name&quot;]) fmt.Printf(&quot;\\t年龄：%s\\n&quot;,val[&quot;age&quot;]) fmt.Printf(&quot;\\t性别：%s\\n&quot;,val[&quot;sex&quot;]) fmt.Printf(&quot;\\t地址：%s\\n&quot;,val[&quot;address&quot;]) &#125;&#125;package mainimport &quot;fmt&quot;func main() &#123; /* 一：数据类型： 基本数据类型：int，float，string，bool 复合数据类型：array，slice，map，function，pointer，struct。。。 array：[size]数据类型 slice：[]数据类型 map：map[key的类型]value的类型 二：存储特点： 值类型：int，float，string，bool，array，struct 引用类型：slice，map make()，slice，map，chan */ map1 := make(map[int]string) map2 :=make(map[string]float64) fmt.Printf(&quot;%T\\n&quot;,map1) fmt.Printf(&quot;%T\\n&quot;,map2) map3 := make(map[string]map[string]string) //map[string]map[string]string m1 :=make(map[string]string) m1[&quot;name&quot;] = &quot;王二狗&quot; m1[&quot;age&quot;] = &quot;30&quot; m1[&quot;salary&quot;] = &quot;3000&quot; map3[&quot;hr&quot;] = m1 m2 :=make(map[string]string) m2[&quot;name&quot;]=&quot;ruby&quot; m2[&quot;age&quot;]=&quot;28&quot; m2[&quot;salary&quot;]=&quot;8000&quot; map3[&quot;总经理&quot;]= m2 fmt.Println(map3) fmt.Println(&quot;---------------&quot;) map4 := make(map[string]string) map4[&quot;王二狗&quot;] = &quot;矮矬穷&quot; map4[&quot;李小花&quot;] = &quot;白富美&quot; map4[&quot;ruby&quot;] = &quot;住在隔壁&quot; fmt.Println(map4) map5 := map4 fmt.Println(map5) map5[&quot;王二狗&quot;]= &quot;高富帅&quot; fmt.Println(map4) fmt.Println(map5)&#125; string相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package mainimport &quot;fmt&quot;func main() &#123; /* Go中的字符串是一个字节的切片。 可以通过将其内容封装在“”中来创建字符串。Go中的字符串是Unicode兼容的，并且是UTF-8编码的。 字符串是一些字节的集合。 理解为一个字符的序列。 每个字符都有固定的位置(索引，下标，index：从0开始，到长度减1) 语法：&quot;&quot;，`` &quot;&quot; &quot;a&quot;,&quot;b&quot;,&quot;中&quot; &quot;abc&quot;,&quot;hello&quot; 字符：---&gt;对应编码表中的编码值 A--&gt;65 B--&gt;66 a--&gt;97 ... 字节：byte--&gt;uint8 utf8 */ //1.定义字符串 s1 := &quot;hello中国&quot; s2 := `hello world` fmt.Println(s1) fmt.Println(s2) //2.字符串的长度：返回的是字节的个数 fmt.Println(len(s1)) fmt.Println(len(s2)) //3.获取某个字节 fmt.Println(s2[0])//获取字符串中的第一个字节 a := &#x27;h&#x27; b := 104 fmt.Printf(&quot;%c,%c,%c\\n&quot;,s2[0],a,b) //4.字符串的遍历 for i:=0;i&lt;len(s2);i++&#123; //fmt.Println(s2[i]) fmt.Printf(&quot;%c\\t&quot;,s2[i]) &#125; fmt.Println() //for range for _,v := range s2&#123; //fmt.Println(i,v) fmt.Printf(&quot;%c&quot;,v) &#125; fmt.Println() //5.字符串是字节的集合 slice1 := []byte&#123;65,66,67,68,69&#125; s3 := string(slice1) //根据一个字节切片，构建字符串 fmt.Println(s3) s4 := &quot;abcdef&quot; slice2 := []byte(s4) //根据字符串，获取对应的字节切片 fmt.Println(slice2) //6.字符串不能修改 fmt.Println(s4) //s4[2] = &#x27;B&#x27;&#125;package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() &#123; /* strings包下的关于字符串的函数 */ s1 := &quot;helloworld&quot; //1.是否包含指定的内容--&gt;bool fmt.Println(strings.Contains(s1, &quot;abc&quot;)) //2.是否包含chars中任意的一个字符即可 fmt.Println(strings.ContainsAny(s1, &quot;abcd&quot;)) //3.统计substr在s中出现的次数 fmt.Println(strings.Count(s1, &quot;lloo&quot;)) //4.以xxx前缀开头，以xxx后缀结尾 s2 := &quot;20190525课堂笔记.txt&quot; if strings.HasPrefix(s2, &quot;201905&quot;) &#123; fmt.Println(&quot;19年5月的文件。。&quot;) &#125; if strings.HasSuffix(s2, &quot;.txt&quot;) &#123; fmt.Println(&quot;文本文档。。&quot;) &#125; //索引 //helloworld fmt.Println(strings.Index(s1, &quot;lloo&quot;)) //查找substr在s中的位置，如果不存在就返回-1 fmt.Println(strings.IndexAny(s1, &quot;abcdh&quot;)) //查找chars中任意的一个字符，出现在s中的位置 fmt.Println(strings.LastIndex(s1, &quot;l&quot;)) //查找substr在s中最后一次出现的位置 //字符串的拼接 ss1 := []string&#123;&quot;abc&quot;,&quot;world&quot;,&quot;hello&quot;,&quot;ruby&quot;&#125; s3 := strings.Join(ss1,&quot;-&quot;) fmt.Println(s3) //切割 s4 := &quot;123,4563,aaa,49595,45&quot; ss2 := strings.Split(s4,&quot;,&quot;) //fmt.Println(ss2) for i := 0;i&lt;len(ss2);i++&#123; fmt.Println(ss2[i]) &#125; //重复，自己拼接自己count次 s5 :=strings.Repeat(&quot;hello&quot;,5) fmt.Println(s5) //替换 //helloworld s6 := strings.Replace(s1,&quot;l&quot;,&quot;*&quot;,-1) fmt.Println(s6) //fmt.Println(strings.Repeat(&quot;hello&quot;,5)) s7:=&quot;heLLo WOrlD**123..&quot; fmt.Println(strings.ToLower(s7)) fmt.Println(strings.ToUpper(s7)) /* 截取子串： substring(start,end)--&gt;substr str[start:end]--&gt;substr 包含start，不包含end下标 */ fmt.Println(s1) s8 := s1[:5] fmt.Println(s8) fmt.Println(s1[5:])&#125;package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)func main() &#123; /* strconv包：字符串和基本类型之前的转换 string convert */ //fmt.Println(&quot;aa&quot;+100) //1.bool类型 s1 := &quot;true&quot; b1,err := strconv.ParseBool(s1) if err != nil&#123; fmt.Println(err) return &#125; fmt.Printf(&quot;%T,%t\\n&quot;,b1,b1) ss1 := strconv.FormatBool(b1) fmt.Printf(&quot;%T,%s\\n&quot;,ss1,ss1) //2.整数 s2 := &quot;100&quot; i2,err := strconv.ParseInt(s2,2,64) if err != nil&#123; fmt.Println(err) return &#125; fmt.Printf(&quot;%T,%d\\n&quot;,i2,i2) ss2 := strconv.FormatInt(i2,10) fmt.Printf(&quot;%T,%s\\n&quot;,ss2,ss2) //itoa(),atoi() i3,err := strconv.Atoi(&quot;-42&quot;) //转为int类型 fmt.Printf(&quot;%T,%d\\n&quot;,i3,i3) ss3:=strconv.Itoa(-42) fmt.Printf(&quot;%T,%s\\n&quot;,ss3,ss3)&#125;","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shadowbynl.github.io/tags/Go/"}]},{"title":"go-study-2","slug":"go-study-2","date":"2020-06-19T09:05:04.000Z","updated":"2020-06-19T09:33:21.182Z","comments":true,"path":"2020/06/19/go-study-2/","link":"","permalink":"https://shadowbynl.github.io/2020/06/19/go-study-2/","excerpt":"Go基础学习其二","text":"Go基础学习其二 2020.6.18-19 搭建了go的环境，了解了go的特点和一些机制的特点，学习了基本语法：基本数据类型、运算符、控制语句，总体来说和c java等语言类似，但go给我的感觉是糅合了多个语言的特点，也有着自己的特别之处，因此本篇先总结一下我感觉和其他语言的差异之处，然后再copy千锋的笔记。个人总结一、文件结构与编译方式 go对项目文件的类型要求较严，应该和c的类似的，以包为划分单位和java包也类似，源码文件分为命令（程序入口）、库、测试三种，命令源码文件作为入口，必须package main并且有func main的，各种源码文件编译后的存放目录有区别，在前篇有说明。 go的导入其他包的方式，导包分为标准库、自写、第三方三种，使用import依次导入，类似java，但多个包导入的方式应该是go独有了。12345import ( &quot;math/rand&quot; &quot;fmt&quot; &quot;time&quot;) go源码文件的编译和c的类似的。 可以说，因为go的在c基础上发展的，应该和c最为类似，包括结构体、指针等，还有输入输出的方式（暂时看到的一些类似的地方）。 二、代码风格 注释和c的一样的 //单行注释 /**/多行注释 行尾不需写分号的特点和python js类似 go特别地对花括号的位置要求很严格 go函数的定义 func 函数名(形参) 的方式和js类似 三、基本语法 go变量的声明类似js，但也有明显区别，还有一种独有的简短定义方式，多变量声明方式也较特别。 go的整型可以指定位数 int8 int32 int64 go的单精度浮点为 float32 双精度为 float64 go的常量命名严格为大写，有一个特殊的iota关键字 go的运算符整体和java类似 go的输入输出方式和c类似 fmt.Printf fmt.Scanf go的if的特有的写法123456789101112/* if语句的其他写法： if 初始化语句; 条件&#123; //注意变量的作用域问题 &#125; */ if num := 4; num &gt; 0&#123; fmt.Println(&quot;正数。。&quot;,num) &#125;else if num &lt; 0&#123; fmt.Println(&quot;负数。。&quot;,num) &#125; go的switch有和if类似的特有的初始化、case跟多值、fallthrough贯通case三个特殊之处。 go的循环只有for。 笔记 基本语法——变量 @author：韩茹 版权所有：北京千锋互联科技有限公司 一、变量的使用1.1 什么是变量变量是为存储特定类型的值而提供给内存位置的名称。在go中声明变量有多种语法。 所以变量的本质就是一小块内存，用于存储数据，在程序运行过程中数值可以改变 1.2 声明变量var名称类型是声明单个变量的语法。 以字母或下划线开头，由一个或多个字母、数字、下划线组成 声明一个变量 第一种，指定变量类型，声明后若不赋值，使用默认值 12var name typename = value 第二种，根据值自行判定变量类型(类型推断Type inference) 如果一个变量有一个初始值，Go将自动能够使用初始值来推断该变量的类型。因此，如果变量具有初始值，则可以省略变量声明中的类型。 1var name = value 第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的(多个变量同时声明时，至少保证一个是新变量)，否则会导致编译错误(简短声明) 123456name := value// 例如var a int = 10var b = 10c : = 10 这种方式它只能被用在函数体内，而不可以用于全局变量的声明与赋值 示例代码： 12345678package mainvar a = &quot;Hello&quot;var b string = &quot;World&quot;var c boolfunc main()&#123; println(a, b, c)&#125; 运行结果： 1Hello World false 多变量声明第一种，以逗号分隔，声明与赋值分开，若不赋值，存在默认值 12var name1, name2, name3 typename1, name2, name3 = v1, v2, v3 第二种，直接赋值，下面的变量类型可以是不同的类型 1var name1, name2, name3 = v1, v2, v3 第三种，集合类型 1234var ( name1 type1 name2 type2) 1.3 注意事项 变量必须先定义才能使用 go语言是静态语言，要求变量的类型和赋值的类型必须一致。 变量名不能冲突。(同一个作用于域内不能冲突) 简短定义方式，左边的变量名至少有一个是新的 简短定义方式，不能定义全局变量。 变量的零值。也叫默认值。 变量定义了就要使用，否则无法通过编译。 如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。 如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a： 1234func main() &#123; var a string = &quot;abc&quot; fmt.Println(&quot;hello, world&quot;)&#125; 尝试编译这段代码将得到错误 a declared and not used 此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用 在同一个作用域中，已存在同名的变量，则之后的声明初始化，则退化为赋值操作。但这个前提是，最少要有一个新的变量被定义，且在同一作用域，例如，下面的y就是新定义的变量 12345678910111213package mainimport ( &quot;fmt&quot;)func main() &#123; x := 140 fmt.Println(&amp;x) x, y := 200, &quot;abc&quot; fmt.Println(&amp;x, x) fmt.Print(y)&#125; 运行结果： 1230xc04200a2b00xc04200a2b0 200abc 基本语法——常量constant一、常量的使用1.1 常量声明常量是一个简单值的标识符，在程序运行时，不会被修改的量。 1const identifier [type] = value 12显式类型定义： const b string = &quot;abc&quot;隐式类型定义： const b = &quot;abc&quot; 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; const LENGTH int = 10 const WIDTH int = 5 var area int const a, b, c = 1, false, &quot;str&quot; //多重赋值 area = LENGTH * WIDTH fmt.Printf(&quot;面积为 : %d&quot;, area) println() println(a, b, c) &#125; 运行结果： 12面积为 : 501 false str 常量可以作为枚举，常量组 12345const ( Unknown = 0 Female = 1 Male = 2) 常量组中如不指定类型和初始化值，则与上一行非空常量右值相同 12345678910111213141516package mainimport ( &quot;fmt&quot;)func main() &#123; const ( x uint16 = 16 y s = &quot;abc&quot; z ) fmt.Printf(&quot;%T,%v\\n&quot;, y, y) fmt.Printf(&quot;%T,%v\\n&quot;, z, z)&#125; 运行结果： 12uint16,16string,abc 常量的注意事项： 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型 不曾使用的常量，在编译的时候，是不会报错的 显示指定类型的时候，必须确保常量左右值类型一致，需要时可做显示类型转换。这与变量就不一样了，变量是可以是不同的类型值 1.2 iotaiota，特殊常量，可以认为是一个可以被编译器修改的常量 iota 可以被用作枚举值： 123456const ( a = iota b = iota c = iota) 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式： 123456const ( a = iota b c) iota 用法 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; const ( a = iota //0 b //1 c //2 d = &quot;ha&quot; //独立值，iota += 1 e //&quot;ha&quot; iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i)&#125; 运行结果： 120 1 2 ha ha 100 100 7 8 如果中断iota自增，则必须显式恢复。且后续自增值按行序递增 自增默认是int类型，可以自行进行显示指定类型 数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址 千锋Go语言的学习群：784190273 作者B站： https://space.bilibili.com/353694001 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation 键盘输入和打印输出 作者：韩茹 出处：千锋教育 一、打印输出1.1 fmt包fmt包实现了类似C语言printf和scanf的格式化I/O。格式化verb（’verb’）源自C语言但更简单。 详见官网fmt的API：https://golang.google.cn/pkg/fmt/ 1.2 导入包1import &quot;fmt&quot; 1.3 常用打印函数打印： func Print(a …interface{}) (n int, err error) 格式化打印： func Printf(format string, a …interface{}) (n int, err error) 打印后换行 func Println(a …interface{}) (n int, err error) 格式化打印中的常用占位符： 123456789101112131415格式化打印占位符： %v,原样输出 %T，打印类型 %t,bool类型 %s，字符串 %f，浮点 %d，10进制的整数 %b，2进制的整数 %o，8进制 %x，%X，16进制 %x：0-9，a-f %X：0-9，A-F %c，打印字符 %p，打印地址 。。。 示例代码： 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot;)func main() &#123; a := 100 //int b := 3.14 //float64 c := true // bool d := &quot;Hello World&quot; //string e := `Ruby` //string f := &#x27;A&#x27; fmt.Printf(&quot;%T,%b\\n&quot;, a, a) fmt.Printf(&quot;%T,%f\\n&quot;, b, b) fmt.Printf(&quot;%T,%t\\n&quot;, c, c) fmt.Printf(&quot;%T,%s\\n&quot;, d, d) fmt.Printf(&quot;%T,%s\\n&quot;, e, e) fmt.Printf(&quot;%T,%d,%c\\n&quot;, f, f, f) fmt.Println(&quot;-----------------------&quot;) fmt.Printf(&quot;%v\\n&quot;, a) fmt.Printf(&quot;%v\\n&quot;, b) fmt.Printf(&quot;%v\\n&quot;, c) fmt.Printf(&quot;%v\\n&quot;, d) fmt.Printf(&quot;%v\\n&quot;, e) fmt.Printf(&quot;%v\\n&quot;, f)&#125; 运行结果： 二、键盘输入2.1 fmt包读取键盘输入常用方法： func Scan(a …interface{}) (n int, err error) func Scanf(format string, a …interface{}) (n int, err error) func Scanln(a …interface{}) (n int, err error) 12345678910111213141516package mainimport ( &quot;fmt&quot;)func main() &#123; var x int var y float64 fmt.Println(&quot;请输入一个整数，一个浮点类型：&quot;) fmt.Scanln(&amp;x,&amp;y)//读取键盘的输入，通过操作地址，赋值给x和y 阻塞式 fmt.Printf(&quot;x的数值：%d，y的数值：%f\\n&quot;,x,y) fmt.Scanf(&quot;%d,%f&quot;,&amp;x,&amp;y) fmt.Printf(&quot;x:%d,y:%f\\n&quot;,x,y)&#125; 运行结果： 2.2 bufio包读取https://golang.google.cn/pkg/bufio/ bufio包中都是IO操作的方法： 先创建Reader对象： 然后就可以各种读取了： 示例代码： 123456789101112131415package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;bufio&quot;)func main() &#123; fmt.Println(&quot;请输入一个字符串：&quot;) reader := bufio.NewReader(os.Stdin) s1, _ := reader.ReadString(&#x27;\\n&#x27;) fmt.Println(&quot;读到的数据：&quot;, s1)&#125; 运行效果： 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation 基本语法——数据类型 @author：韩茹 版权所有：北京千锋互联科技有限公司 一、基本数据类型以下是go中可用的基本数据类型 1.1 布尔型bool布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true 1.2 数值型1、整数型 int8有符号 8 位整型 (-128 到 127)长度：8bit int16有符号 16 位整型 (-32768 到 32767) int32有符号 32 位整型 (-2147483648 到 2147483647) int64有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) uint8无符号 8 位整型 (0 到 255)8位都用于表示数值： uint16无符号 16 位整型 (0 到 65535) uint32无符号 32 位整型 (0 到 4294967295) uint64无符号 64 位整型 (0 到 18446744073709551615) int和uint:根据底层平台，表示32或64位整数。除非需要使用特定大小的整数，否则通常应该使用int来表示整数。大小:32位系统32位，64位系统64位。范围:-2147483648到2147483647的32位系统和-9223372036854775808到9223372036854775807的64位系统。 2、浮点型 float32 IEEE-754 32位浮点型数 float64 IEEE-754 64位浮点型数 complex64 32 位实数和虚数 complex128 64 位实数和虚数 3、其他 byte 类似 uint8 rune 类似 int32 uint 32 或 64 位 int 与 uint 一样大小 uintptr 无符号整型，用于存放一个指针 1.3 字符串型字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本 12var str stringstr = &quot;Hello World&quot; 1.4 数据类型转换：Type Convert语法格式：Type(Value) 常数：在有需要的时候，会自动转型 变量：需要手动转型 T(V) 注意点：兼容类型可以转换 二、 复合类型(派生类型)1、指针类型（Pointer）2、数组类型3、结构化类型(struct)4、Channel 类型5、函数类型6、切片类型7、接口类型（interface）8、Map 类型 运算符表达式：(a + b) * c a,b,c叫做操作数 +，*，叫做运算符一、运算符1.1 算术运算符1+ - * / %(求余) ++ -- 1.2 关系运算符1== != &gt; &lt; &gt;= &lt;= 1.3 逻辑运算符 运算符 描述 &amp;&amp; 所谓逻辑与运算符。如果两个操作数都非零，则条件变为真 || 所谓的逻辑或操作。如果任何两个操作数是非零，则条件变为真 ! 所谓逻辑非运算符。使用反转操作数的逻辑状态。如果条件为真，那么逻辑非操后结果为假 1.4 位运算符 A B A&amp;B A|B A^B 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 这里最难理解的就是^了，只要认为AB两者都相同的时候，为0，其他都为1 假设A为60，B为13 运算 描述 示例 &amp; 二进制与操作副本位的结果，如果它存在于两个操作数 (A &amp; B) = 12, 也就是 0000 1100 | 二进制或操作副本，如果它存在一个操作数 (A | B) = 61, 也就是 0011 1101 ^ 二进制异或操作副本，如果它被设置在一个操作数就是按位取非 (A ^ B) = 49, 也就是 0011 0001 &amp;^ 二进制位清空&amp;^ (A&amp;^B)=48，也就是110000 &lt;&lt; 二进制左移位运算符。左边的操作数的值向左移动由右操作数指定的位数 A &lt;&lt; 2 =240 也就是 1111 0000 &gt;&gt; 二进制向右移位运算符。左边的操作数的值由右操作数指定的位数向右移动 A &gt;&gt; 2 = 15 也就是 0000 1111 1.5 赋值运算符 运算符 描述 示例 = 简单的赋值操作符，分配值从右边的操作数左侧的操作数 C = A + B 将分配A + B的值到C += 相加并赋值运算符，它增加了右操作数左操作数和分配结果左操作数 C += A 相当于 C = C + A -= 减和赋值运算符，它减去右操作数从左侧的操作数和分配结果左操作数 C -= A 相当于 C = C - A *= 乘法和赋值运算符，它乘以右边的操作数与左操作数和分配结果左操作数 C *= A 相当于 C = C * A /= 除法赋值运算符，它把左操作数与右操作数和分配结果左操作数 C /= A 相当于 C = C / A %= 模量和赋值运算符，它需要使用两个操作数的模量和分配结果左操作数 C %= A 相当于 C = C % A &lt;&lt;= 左移位并赋值运算符 C &lt;&lt;= 2 相同于 C = C &lt;&lt; 2 &gt;&gt;= 向右移位并赋值运算符 C &gt;&gt;= 2 相同于 C = C &gt;&gt; 2 &amp;= 按位与赋值运算符 C &amp;= 2 相同于 C = C &amp; 2 ^= 按位异或并赋值运算符 C ^= 2 相同于 C = C ^ 2 |= 按位或并赋值运算符 C |= 2 相同于 C = C | 2 1.6优先级运算符优先级有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 优先级 运算符 7 ~ ! ++ – 6 * / % &lt;&lt; &gt;&gt; &amp; &amp;^ 5 + - ^ 4 == != &lt; &lt;= &gt;= &gt; 3 &lt;- 2 &amp;&amp; 1 || 当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。 千锋Go语言的学习群：784190273 作者B站： https://space.bilibili.com/353694001 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation 一、程序的流程结构 @author：韩茹 版权所有：北京千锋互联科技有限公司 程序的流程控制结构一共有三种：顺序结构，选择结构，循环结构。 顺序结构：从上向下，逐行执行。 选择结构：条件满足，某些代码才会执行。0-1次 ​ 分支语句：if，switch，select 循环结构：条件满足，某些代码会被反复的执行多次。0-N次 ​ 循环语句：for 二、条件语句2.1 if 语句语法格式： 123if 布尔表达式 &#123; /* 在布尔表达式为 true 时执行 */&#125; 12345if 布尔表达式 &#123; /* 在布尔表达式为 true 时执行 */&#125; else &#123; /* 在布尔表达式为 false 时执行 */&#125; 1234567if 布尔表达式1 &#123; /* 在布尔表达式1为 true 时执行 */&#125; else if 布尔表达式2&#123; /* 在布尔表达式1为 false ,布尔表达式2为true时执行 */&#125; else&#123; /* 在上面两个布尔表达式都为false时，执行*/&#125; 示例代码： 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; /* 定义局部变量 */ var a int = 10 /* 使用 if 语句判断布尔表达式 */ if a &lt; 20 &#123; /* 如果条件为 true 则执行以下语句 */ fmt.Printf(&quot;a 小于 20\\n&quot; ) &#125; fmt.Printf(&quot;a 的值为 : %d\\n&quot;, a)&#125; 2.2 if 变体如果其中包含一个可选的语句组件(在评估条件之前执行)，则还有一个变体。它的语法是 1234567if statement; condition &#123; &#125;if condition&#123; &#125; 示例代码： 12345678910111213package mainimport ( &quot;fmt&quot;)func main() &#123; if num := 10; num % 2 == 0 &#123; //checks if number is even fmt.Println(num,&quot;is even&quot;) &#125; else &#123; fmt.Println(num,&quot;is odd&quot;) &#125;&#125; 需要注意的是，num的定义在if里，那么只能够在该if..else语句块中使用，否则编译器会报错的。 2.3 switch语句：“开关”switch是一个条件语句，它计算表达式并将其与可能匹配的列表进行比较，并根据匹配执行代码块。它可以被认为是一种惯用的方式来写多个if else子句。 switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break。 而如果switch没有表达式，它会匹配true Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。 12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; 示例代码： 123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main() &#123; /* 定义局部变量 */ var grade string = &quot;B&quot; var marks int = 90 switch marks &#123; case 90: grade = &quot;A&quot; case 80: grade = &quot;B&quot; case 50,60,70 : grade = &quot;C&quot; //case 后可以由多个数值 default: grade = &quot;D&quot; &#125; switch &#123; case grade == &quot;A&quot; : fmt.Printf(&quot;优秀!\\n&quot; ) case grade == &quot;B&quot;, grade == &quot;C&quot; : fmt.Printf(&quot;良好\\n&quot; ) case grade == &quot;D&quot; : fmt.Printf(&quot;及格\\n&quot; ) case grade == &quot;F&quot;: fmt.Printf(&quot;不及格\\n&quot; ) default: fmt.Printf(&quot;差\\n&quot; ); &#125; fmt.Printf(&quot;你的等级是 %s\\n&quot;, grade ); &#125; 2.4 fallthrough如需贯通后续的case，就添加fallthrough 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot;)type data [2]intfunc main() &#123; switch x := 5; x &#123; default: fmt.Println(x) case 5: x += 10 fmt.Println(x) fallthrough case 6: x += 20 fmt.Println(x) &#125;&#125; 运行结果： 121535 case中的表达式是可选的，可以省略。如果该表达式被省略，则被认为是switch true，并且每个case表达式都被计算为true，并执行相应的代码块。 示例代码： 123456789101112131415161718package mainimport ( &quot;fmt&quot;)func main() &#123; num := 75 switch &#123; // expression is omitted case num &gt;= 0 &amp;&amp; num &lt;= 50: fmt.Println(&quot;num is greater than 0 and less than 50&quot;) case num &gt;= 51 &amp;&amp; num &lt;= 100: fmt.Println(&quot;num is greater than 51 and less than 100&quot;) case num &gt;= 101: fmt.Println(&quot;num is greater than 100&quot;) &#125;&#125; switch的注意事项 case后的常量值不能重复 case后可以有多个常量值 fallthrough应该是某个case的最后一行。如果它出现在中间的某个地方，编译器就会抛出错误。 2.5 Type Switchswitch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。 123456789switch x.(type)&#123; case type: statement(s); case type: statement(s); /* 你可以定义任意个数的case */ default: /* 可选 */ statement(s);&#125; 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; var x interface&#123;&#125; switch i := x.(type) &#123; case nil: fmt.Printf(&quot; x 的类型 :%T&quot;,i) case int: fmt.Printf(&quot;x 是 int 型&quot;) case float64: fmt.Printf(&quot;x 是 float64 型&quot;) case func(int) float64: fmt.Printf(&quot;x 是 func(int) 型&quot;) case bool, string: fmt.Printf(&quot;x 是 bool 或 string 型&quot; ) default: fmt.Printf(&quot;未知型&quot;) &#125; &#125; 运行结果： 1x 的类型 :&lt;nil&gt; 千锋Go语言的学习群：784190273 作者B站： https://space.bilibili.com/353694001 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation 一、程序的流程结构 @author：韩茹 版权所有：北京千锋互联科技有限公司 程序的流程控制结构一共有三种：顺序结构，选择结构，循环结构。 顺序结构：代码从上向下逐行的执行 选择结构：条件满足，某些代码才会被执行。0-1次 ​ if语句，switch语句 循环结构：条件满足，某些代码会被反复的多次执行。0-n次 ​ for语句 二、循环语句循环语句表示条件满足，可以反复的执行某段代码。 for是唯一的循环语句。(Go没有while循环) ##2.1 for语句 语法结构： 1for init; condition; post &#123; &#125; 初始化语句只执行一次。在初始化循环之后，将检查该条件。如果条件计算为true，那么{}中的循环体将被执行，然后是post语句。post语句将在循环的每次成功迭代之后执行。在执行post语句之后，该条件将被重新检查。如果它是正确的，循环将继续执行，否则循环终止。 示例代码： 1234567891011package mainimport ( &quot;fmt&quot;)func main() &#123; for i := 1; i &lt;= 10; i++ &#123; fmt.Printf(&quot; %d&quot;,i) &#125;&#125; 在for循环中声明的变量仅在循环范围内可用。因此，i不能在外部访问循环。 2.2 for循环变体所有的三个组成部分，即初始化、条件和post都是可选的。 1for condition &#123; &#125; 效果与while相似 1for &#123; &#125; 效果与for(;;) 一样 for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环 123for key, value := range oldMap &#123; newMap[key] = value&#125; 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() &#123; var b int = 15 var a int numbers := [6]int&#123;1, 2, 3, 5&#125; /* for 循环 */ for a := 0; a &lt; 10; a++ &#123; fmt.Printf(&quot;a 的值为: %d\\n&quot;, a) &#125; for a &lt; b &#123; a++ fmt.Printf(&quot;a 的值为: %d\\n&quot;, a) &#125; for i,x:= range numbers &#123; fmt.Printf(&quot;第 %d 位 x 的值 = %d\\n&quot;, i,x) &#125; &#125; 运行结果： 12345678910111213141516171819202122232425262728293031a 的值为: 0a 的值为: 1a 的值为: 2a 的值为: 3a 的值为: 4a 的值为: 5a 的值为: 6a 的值为: 7a 的值为: 8a 的值为: 9a 的值为: 1a 的值为: 2a 的值为: 3a 的值为: 4a 的值为: 5a 的值为: 6a 的值为: 7a 的值为: 8a 的值为: 9a 的值为: 10a 的值为: 11a 的值为: 12a 的值为: 13a 的值为: 14a 的值为: 15第 0 位 x 的值 = 1第 1 位 x 的值 = 2第 2 位 x 的值 = 3第 3 位 x 的值 = 5第 4 位 x 的值 = 0第 5 位 x 的值 = 0 2.2 多层for循环for循环中又有循环嵌套，就表示多层循环了。 三、跳出循环的语句 @author：韩茹版权所有：北京千锋互联科技有限公司 1、 break语句break：跳出循环体。break语句用于在结束其正常执行之前突然终止for循环 示例代码： 123456789101112131415package mainimport ( &quot;fmt&quot;)func main() &#123; for i := 1; i &lt;= 10; i++ &#123; if i &gt; 5 &#123; break //loop is terminated if i &gt; 5 &#125; fmt.Printf(&quot;%d &quot;, i) &#125; fmt.Printf(&quot;\\nline after for loop&quot;)&#125; 2、continue语句continue：跳出一次循环。continue语句用于跳过for循环的当前迭代。在continue语句后面的for循环中的所有代码将不会在当前迭代中执行。循环将继续到下一个迭代。 示例代码： 1234567891011121314package mainimport ( &quot;fmt&quot;)func main() &#123; for i := 1; i &lt;= 10; i++ &#123; if i%2 == 0 &#123; continue &#125; fmt.Printf(&quot;%d &quot;, i) &#125;&#125; 四、goto语句goto：可以无条件地转移到过程中指定的行。 语法结构： 1234goto label;....label: statement; 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; /* 定义局部变量 */ var a int = 10 /* 循环 */ LOOP: for a &lt; 20 &#123; if a == 15 &#123; /* 跳过迭代 */ a = a + 1 goto LOOP &#125; fmt.Printf(&quot;a的值为 : %d\\n&quot;, a) a++ &#125; &#125; 统一错误处理多处错误处理存在代码重复时是非常棘手的，例如： 12345678910111213141516 err := firstCheckError() if err != nil &#123; goto onExit &#125; err = secondCheckError() if err != nil &#123; goto onExit &#125; fmt.Println(&quot;done&quot;) returnonExit: fmt.Println(err) exitProcess() 本文图片来源于网络 千锋Go语言的学习群：784190273 作者B站： https://space.bilibili.com/353694001 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shadowbynl.github.io/tags/Go/"}]},{"title":"移动布局基础","slug":"移动布局基础","date":"2020-06-18T10:24:09.000Z","updated":"2020-06-23T11:27:37.009Z","comments":true,"path":"2020/06/18/移动布局基础/","link":"","permalink":"https://shadowbynl.github.io/2020/06/18/%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80/","excerpt":"移动布局在设置视口标签为随设备调整的基础上，有两种实现方式，其一是编写专门的移动端界面，其二是将界面实现为响应式界面。专门的移动端界面的布局方式有流式布局（百分比布局）、flex布局、rem布局三种，响应式布局可以使用BootStrap框架实现。","text":"移动布局在设置视口标签为随设备调整的基础上，有两种实现方式，其一是编写专门的移动端界面，其二是将界面实现为响应式界面。专门的移动端界面的布局方式有流式布局（百分比布局）、flex布局、rem布局三种，响应式布局可以使用BootStrap框架实现。 移动web开发流式布局1.0 移动端基础1.1浏览器现状 PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器。 移动端常见浏览器：UC浏览器，QQ浏览器，欧朋浏览器，百度手机浏览器，360安全浏览器，谷歌浏览器，搜狗手机浏览器，猎豹浏览器，以及其他杂牌浏览器。 国内的UC和QQ，百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于Android修改开发的一样。 总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可。 1.2 手机屏幕的现状 移动端设备屏幕尺寸非常多，碎片化严重。 Android设备有多种分辨率：480x800, 480x854, 540x960, 720x1280，1080x1920等，还有传说中的2K，4k屏。 近年来iPhone的碎片化也加剧了，其设备的主要分辨率有：640x960, 640x1136, 750x1334, 1242x2208等。 作为开发者无需关注这些分辨率，因为我们常用的尺寸单位是 px 。 1.3常见移动端屏幕尺寸 1.4移动端调试方法 Chrome DevTools（谷歌浏览器）的模拟手机调试 搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器 使用外网服务器，直接IP或域名访问 2.0 视口视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口 2.1 布局视口 layout viewport一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。 iOS, Android基本都将这个视口分辨率设置为 980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。 2.2视觉视口 visual viewport字面意思，它是用户正在看到的网站的区域。注意：是网站的区域。 我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。 2.3理想视口 ideal viewport为了使网站在移动端有最理想的浏览和阅读宽度而设定 理想视口，对设备来讲，是最理想的视口尺寸 需要手动添写meta视口标签通知浏览器操作 meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽 总结：我们开发最终会用理想视口，而理想视口就是将布局视口的宽度修改为视觉视口 2.4meta标签 最标准的viewport设置 视口宽度和设备保持一致 视口的默认缩放比例1.0 不允许用户自行缩放 最大允许的缩放比例1.0 最小允许的缩放比例1.0 3.0二倍图####3.1物理像素&amp;物理像素比 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果6 是 750* 1334 我们开发时候的1px 不是一定等于1个物理像素的 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比 如果把1张100*100的图片放到手机里面会按照物理像素比给我们缩放 lRetina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。 对于一张 50px * 50px 的图片,在手机或 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊 在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题 通常使用二倍图， 因为iPhone 6 的影响背景图片 注意缩放问题 3.2背景缩放background-sizebackground-size 属性规定背景图像的尺寸 1background-size: 背景图片宽度 背景图片高度; 单位： 长度|百分比|cover|contain; cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 4.0 移动开发选择和技术解决方案####4.1移动端主流方案 1.单独制作移动端页面（主流） 通常情况下，网址域名前面加 m(mobile)可以打开移动端。通过判断设备，如果是移动设备打开，则跳到移动端页面。 也就是说，PC端和移动端为两套网站，pc端是pc断的样式，移动端在写一套，专门针对移动端适配的一套网站 2.响应式页面兼容移动端（其次） 响应式网站：即pc和移动端共用一套网站，只不过在不同屏幕下，样式会自动适配 4.2 移动端技术解决方案1.移动端浏览器兼容问题 移动端浏览器基本以 webkit 内核为主，因此我们就考虑webkit兼容性问题。 我们可以放心使用 H5 标签和 CSS3 样式。 同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可 2.移动端公共样式 移动端 CSS 初始化推荐使用 normalize.css/ Normalize.css：保护了有价值的默认值 Normalize.css：修复了浏览器的bug Normalize.css：是模块化的 Normalize.css：拥有详细的文档 官网地址： http://necolas.github.io/normalize.css/ 4.3 移动端大量使用 CSS3盒子模型box-sizin传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding CSS3盒子模型： 盒子的宽度= CSS中设置的宽度width 里面包含了 border 和 padding 也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了 12345/*CSS3盒子模型*/box-sizing: border-box;/*传统盒子模型*/box-sizing: content-box; 移动端可以全部CSS3 盒子模型 PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型 4.4移动端特殊样式12345678910/*CSS3盒子模型*/box-sizing: border-box;-webkit-box-sizing: border-box;/*点击高亮我们需要清除清除 设置为transparent 完成透明*/-webkit-tap-highlight-color: transparent;/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/-webkit-appearance: none;/*禁用长按页面时的弹出菜单*/img,a &#123; -webkit-touch-callout: none; &#125; 5.0移动端常见布局移动端单独制作 流式布局（百分比布局） flex 弹性布局（强烈推荐） less+rem+媒体查询布局 混合布局 响应式 媒体查询 bootstarp 流式布局： 流式布局，就是百分比布局，也称非固定像素布局。 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。 流式布局方式是移动web开发使用的比较常见的布局方式。 移动web开发——flex布局1.0传统布局和flex布局对比1.1传统布局 兼容性好 布局繁琐 局限性，不能再移动端很好的布局 1.2 flex布局 操作方便，布局极其简单，移动端使用比较广泛 pc端浏览器支持情况比较差 IE11或更低版本不支持flex或仅支持部分 1.3 建议 如果是pc端页面布局，还是采用传统方式 如果是移动端或者是不考虑兼容的pc则采用flex 2.0 flex布局原理 flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 flex布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flexitem），简称”项目”。 总结：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式 3.0 父项常见属性 flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-content：设置侧轴上的子元素的排列方式（多行） align-items：设置侧轴上的子元素排列方式（单行） flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap 3.1 flex-direction设置主轴的方向 在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴 默认主轴方向就是 x 轴方向，水平向右 默认侧轴方向就是 y 轴方向，水平向下 注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的 3.2 justify-content 设置主轴上的子元素排列方式 3.3 flex-wrap设置是否换行 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，flex布局中默认是不换行的。 nowrap 不换行 wrap 换行 3.4 align-items 设置侧轴上的子元素排列方式（单行 ） 该属性是控制子项在侧轴（默认是y轴）上的排列方式 在子项为单项（单行）的时候使用 flex-start 从头部开始 flex-end 从尾部开始 center 居中显示 stretch 拉伸 3.5 align-content 设置侧轴上的子元素的排列方式（多行）设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。 3.6 align-content 和align-items区别 align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸 align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。 总结就是单行找align-items 多行找 align-content 3.7 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性1flex-flow:row wrap; 4.0 flex布局子项常见属性 flex子项目占的份数 align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序） 4.1 flex 属性flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。 1234.item &#123; flex: &lt;number&gt;; /* 默认值 0 */&#125; 4.2 align-self控制子项自己在侧轴上的排列方式align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 12345span:nth-child(2) &#123; /* 设置自己在侧轴上的排列方式 */ align-self: flex-end;&#125; 4.3 order 属性定义项目的排列顺序数值越小，排列越靠前，默认为0。 注意：和 z-index 不一样。 123.item &#123; order: &lt;number&gt;;&#125; 5.0 携程网首页案例制作携程网链接：http://m.ctrip.com 1.技术选型 方案：我们采取单独制作移动页面方案 技术：布局采取flex布局 2.搭建相关文件夹 3.设置视口标签以及引入初始化样式 1234&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt; 4.常用初始化样式 1234567891011body &#123; max-width: 540px; min-width: 320px; margin: 0 auto; font: normal 14px/1.5 Tahoma,&quot;Lucida Grande&quot;,Verdana,&quot;Microsoft Yahei&quot;,STXihei,hei; color: #000; background: #f2f2f2; overflow-x: hidden; -webkit-tap-highlight-color: transparent;&#125; 5.模块名字划分","categories":[{"name":"移动布局","slug":"移动布局","permalink":"https://shadowbynl.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://shadowbynl.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"go-study-1","slug":"go-study-1","date":"2020-06-18T10:23:40.000Z","updated":"2020-06-19T09:03:21.007Z","comments":true,"path":"2020/06/18/go-study-1/","link":"","permalink":"https://shadowbynl.github.io/2020/06/18/go-study-1/","excerpt":"Go基础学习其一","text":"Go基础学习其一 Go语言的核心特性 @author：韩茹版权所有：北京千锋互联科技有限公司 Go语言，作为编程语言的后生，站在巨人的肩膀上，吸收了其他一些编程语言的特点。 Go 编程语言是一个开源项目，它使程序员更具生产力。Go 语言具有很强的表达能力，它简洁、清晰而高效。得益于其并发机制， 用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。 Go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。 它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。(摘取自官网) 一、思想Less can be more 大道至简,小而蕴真 让事情变得复杂很容易，让事情变得简单才难 深刻的工程文化 二、核心特性Go语言之所以厉害，是因为它在服务端的开发中，总能抓住程序员的痛点，以最直接、简单、高效、稳定的方式来解决问题。这里我们并不会深入讨论GO语言的具体语法，只会将语言中关键的、对简化编程具有重要意义的方面介绍给大家，体验Go的核心特性。 2.1 并发编程Go语言在并发编程方面比绝大多数语言要简洁不少，这一点是其最大亮点之一，也是其在未来进入高并发高性能场景的重要筹码。 不同于传统的多进程或多线程，golang的并发执行单元是一种称为goroutine的协程。 由于在共享数据场景中会用到锁，再加上GC，其并发性能有时不如异步复用IO模型，因此相对于大多数语言来说，golang的并发编程简单比并发性能更具卖点。 在当今这个多核时代，并发编程的意义不言而喻。当然，很多语言都支持多线程、多进程编程，但遗憾的是，实现和控制起来并不是那么令人感觉轻松和愉悦。Golang不同的是，语言级别支持协程(goroutine)并发（协程又称微线程，比线程更轻量、开销更小，性能更高），操作起来非常简单，语言级别提供关键字（go）用于启动协程，并且在同一台机器上可以启动成千上万个协程。协程经常被理解为轻量级线程，一个线程可以包含多个协程，共享堆不共享栈。协程间一般由应用程序显式实现调度，上下文切换无需下到内核层，高效不少。协程间一般不做同步通讯，而golang中实现协程间通讯有两种：1）共享内存型，即使用全局变量+mutex锁来实现数据共享；2）消息传递型，即使用一种独有的channel机制进行异步通讯。 对比JAVA的多线程和GO的协程实现，明显更直接、简单。这就是GO的魅力所在，以简单、高效的方式解决问题，关键字go，或许就是GO语言最重要的标志。 高并发是Golang语言最大的亮点 2.2 内存回收(GC)从C到C++，从程序性能的角度来考虑，这两种语言允许程序员自己管理内存，包括内存的申请和释放等。因为没有垃圾回收机制所以C/C++运行起来速度很快，但是随着而来的是程序员对内存使用上的很谨小慎微的考虑。因为哪怕一点不小心就可能会导致“内存泄露”使得资源浪费或者“野指针”使得程序崩溃等，尽管C++11后来使用了智能指针的概念，但是程序员仍然需要很小心的使用。后来为了提高程序开发的速度以及程序的健壮性，java和C#等高级语言引入了GC机制，即程序员不需要再考虑内存的回收等，而是由语言特性提供垃圾回收器来回收内存。但是随之而来的可能是程序运行效率的降低。 GC过程是：先stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来，接着立即start the world，恢复服务，同时起一个专门gorountine回收内存到空闲list中以备复用，不物理释放。物理释放由专门线程定期来执行。 GC瓶颈在于每次都要扫描所有对象来判活，待收集的对象数目越多，速度越慢。一个经验值是扫描10w个对象需要花费1ms，所以尽量使用对象少的方案，比如我们同时考虑链表、map、slice、数组来进行存储，链表和map每个元素都是一个对象，而slice或数组是一个对象，因此slice或数组有利于GC。 GC性能可能随着版本不断更新会不断优化，这块没仔细调研，团队中有HotSpot开发者，应该会借鉴jvm gc的设计思想，比如分代回收、safepoint等。 内存自动回收，再也不需要开发人员管理内存 开发人员专注业务实现，降低了心智负担 只需要new分配内存，不需要释放 2.3 内存分配初始化阶段直接分配一块大内存区域，大内存被切分成各个大小等级的块，放入不同的空闲list中，对象分配空间时从空闲list中取出大小合适的内存块。内存回收时，会把不用的内存重放回空闲list。空闲内存会按照一定策略合并，以减少碎片。 2.4 编译编译涉及到两个问题：编译速度和依赖管理 目前Golang具有两种编译器，一种是建立在GCC基础上的Gccgo，另外一种是分别针对64位x64和32位x86计算机的一套编译器(6g和8g)。 依赖管理方面，由于golang绝大多数第三方开源库都在github上，在代码的import中加上对应的github路径就可以使用了，库会默认下载到工程的pkg目录下。 另外，编译时会默认检查代码中所有实体的使用情况，凡是没使用到的package或变量，都会编译不通过。这是golang挺严谨的一面。 2.5 网络编程由于golang诞生在互联网时代，因此它天生具备了去中心化、分布式等特性，具体表现之一就是提供了丰富便捷的网络编程接口，比如socket用net.Dial(基于tcp/udp，封装了传统的connect、listen、accept等接口)、http用http.Get/Post()、rpc用client.Call(‘class_name.method_name’, args, &amp;reply)，等等。 高性能HTTP Server 2.6 函数多返回值在C，C++中，包括其他的一些高级语言是不支持多个函数返回值的。但是这项功能又确实是需要的，所以在C语言中一般通过将返回值定义成一个结构体，或者通过函数的参数引用的形式进行返回。而在Go语言中，作为一种新型的语言，目标定位为强大的语言当然不能放弃对这一需求的满足，所以支持函数多返回值是必须的。 函数定义时可以在入参后面再加(a,b,c)，表示将有3个返回值a、b、c。这个特性在很多语言都有，比如python。 这个语法糖特性是有现实意义的，比如我们经常会要求接口返回一个三元组（errno,errmsg,data），在大多数只允许一个返回值的语言中，我们只能将三元组放入一个map或数组中返回，接收方还要写代码来检查返回值中包含了三元组，如果允许多返回值，则直接在函数定义层面上就做了强制，使代码更简洁安全。 2.7 语言交互性语言交互性指的是本语言是否能和其他语言交互，比如可以调用其他语言编译的库。 在Go语言中直接重用了大部份的C模块，这里称为Cgo.Cgo允许开发者混合编写C语言代码，然后Cgo工具可以将这些混合的C代码提取并生成对于C功能的调用包装代码。开发者基本上可以完全忽略这个Go语言和C语言的边界是如何跨越的。 golang可以和C程序交互，但不能和C++交互。可以有两种替代方案：1）先将c++编译成动态库，再由go调用一段c代码，c代码通过dlfcn库动态调用动态库（记得export LD_LIBRARY_PATH）；2）使用swig(没玩过) 2.8 异常处理golang不支持try…catch这样的结构化的异常解决方式，因为觉得会增加代码量，且会被滥用，不管多小的异常都抛出。golang提倡的异常处理方式是： 普通异常：被调用方返回error对象，调用方判断error对象。 严重异常：指的是中断性panic（比如除0），使用defer…recover…panic机制来捕获处理。严重异常一般由golang内部自动抛出，不需要用户主动抛出，避免传统try…catch写得到处都是的情况。当然，用户也可以使用panic(‘xxxx’)主动抛出，只是这样就使这一套机制退化成结构化异常机制了。 2.9 其他一些有趣的特性 类型推导：类型定义：支持var abc = 10这样的语法，让golang看上去有点像动态类型语言，但golang实际上时强类型的，前面的定义会被自动推导出是int类型。 作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。 简单来说，Go是一门写起来像动态语言，有着动态语言开发效率的静态语言。 一个类型只要实现了某个interface的所有方法，即可实现该interface，无需显式去继承。 Go编程规范推荐每个Interface只提供一到两个的方法。这样使得每个接口的目的非常清晰。另外Go的隐式推导也使得我们组织程序架构的时候更加灵活。在写JAVA／C++程序的时候，我们一开始就需要把父类／子类／接口设计好，因为一旦后面有变更，修改起来会非常痛苦。而Go不一样，当你在实现的过程中发现某些方法可以抽象成接口的时候，你直接定义好这个接口就OK了，其他代码不需要做任何修改，编译器的自动推导会帮你做好一切。 不能循环引用：即如果a.go中import了b，则b.go要是import a会报import cycle not allowed。好处是可以避免一些潜在的编程危险，比如a中的func1()调用了b中的func2()，如果func2()也能调用func1()，将会导致无限循环调用下去。 defer机制：在Go语言中，提供关键字defer，可以通过该关键字指定需要延迟执行的逻辑体，即在函数体return前或出现panic时执行。这种机制非常适合善后逻辑处理，比如可以尽早避免可能出现的资源泄漏问题。 可以说，defer是继goroutine和channel之后的另一个非常重要、实用的语言特性，对defer的引入，在很大程度上可以简化编程，并且在语言描述上显得更为自然，极大的增强了代码的可读性。 “包”的概念：和python一样，把相同功能的代码放到一个目录，称之为包。包可以被其他包引用。main包是用来生成可执行文件，每个程序只有一个main包。包的主要用途是提高代码的可复用性。通过package可以引入其他包。 编程规范：GO语言的编程规范强制集成在语言中，比如明确规定花括号摆放位置，强制要求一行一句，不允许导入没有使用的包，不允许定义没有使用的变量，提供gofmt工具强制格式化代码等等。奇怪的是，这些也引起了很多程序员的不满，有人发表GO语言的XX条罪状，里面就不乏对编程规范的指责。要知道，从工程管理的角度，任何一个开发团队都会对特定语言制定特定的编程规范，特别像Google这样的公司，更是如此。GO的设计者们认为，与其将规范写在文档里，还不如强制集成在语言里，这样更直接，更有利用团队协作和工程管理。 交叉编译：比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！ 三、功能此处我们说个小段子：(引自网上某篇文章，具体是哪一篇想不起来了) 很久以前，有一个IT公司，这公司有个传统，允许员工拥有20%自由时间来开发实验性项目。在2007的某一天，公司的几个大牛，正在用c++开发一些比较繁琐但是核心的工作，主要包括庞大的分布式集群，大牛觉得很闹心，后来c++委员会来他们公司演讲，说c++将要添加大概35种新特性。这几个大牛的其中一个人，名为：Rob Pike，听后心中一万个xxx飘过，“c++特性还不够多吗？简化c++应该更有成就感吧”。于是乎，Rob Pike和其他几个大牛讨论了一下，怎么解决这个问题，过了一会，Rob Pike说要不我们自己搞个语言吧，名字叫“go”，非常简短，容易拼写。其他几位大牛就说好啊，然后他们找了块白板，在上面写下希望能有哪些功能。接下来的时间里，大牛们开心的讨论设计这门语言的特性，经过漫长的岁月，他们决定，以c语言为原型，以及借鉴其他语言的一些特性，来解放程序员，解放自己，然后在2009年，go语言诞生。 以下就是这些大牛所罗列出的Go要有的功能： 规范的语法（不需要符号表来解析） 垃圾回收（独有） 无头文件 明确的依赖 无循环依赖 常量只能是数字 int和int32是两种类型 字母大小写设置可见性（letter case sets visibility） 任何类型（type）都有方法（不是类型） 没有子类型继承（不是子类） 包级别初始化以及明确的初始化顺序 文件被编译到一个包里 包package-level globals presented in any order 没有数值类型转换（常量起辅助作用） 接口隐式实现（没有“implement”声明） 嵌入（不会提升到超类） 方法按照函数声明（没有特别的位置要求） 方法即函数 接口只有方法（没有数据） 方法通过名字匹配（而非类型） 没有构造函数和析构函数 postincrement（如++i）是状态，不是表达式 没有preincrement(i++)和predecrement 赋值不是表达式 明确赋值和函数调用中的计算顺序（没有“sequence point”） 没有指针运算 内存一直以零值初始化 局部变量取值合法 方法中没有“this” 分段的堆栈 没有静态和其它类型的注释 没有模板 内建string、slice和map 数组边界检查 大牛真身最大牌的当属B和C语言设计者、Unix和Plan 9创始人、1983年图灵奖获得者Ken Thompson，这份名单中还包括了Unix核心成员Rob Pike（go语言之父）、java HotSpot虚拟机和js v8引擎的开发者Robert Griesemer、Memcached作者Brad Fitzpatrick，等等。 本文图片来自网络，侵删 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av47467197 https://www.bilibili.com/video/av56018934/ 源代码： https://github.com/rubyhan1314/go_foundation Go语言和其他语言的对比 @author：韩茹版权所有：北京千锋互联科技有限公司 一、Go语言设计初衷1、设计Go语言是为了解决当时Google开发遇到的问题： 大量的C++代码，同时又引入了Java和Python 成千上万的工程师 数以万计行的代码 分布式的编译系统 数百万的服务器 2、Google开发中的痛点： 编译慢 失控的依赖 每个工程师只是用了一个语言里面的一部分 程序难以维护（可读性差、文档不清晰等） 更新的花费越来越长 交叉编译困难 3、如何解决当前的问题和痛点？ Go希望成为互联网时代的C语言。多数系统级语言（包括Java和C#）的根本编程哲学来源于C++，将C++的面向对象进一步发扬光大。但是Go语言的设计者却有不同的看法，他们认为值得学习的是C语言。C语言经久不衰的根源是它足够简单。因此，Go语言也是足够简单。 所以，他们当时设计Go的目标是为了消除各种缓慢和笨重、改进各种低效和扩展性。Go是由那些开发大型系统的人设计的，同时也是为了这些人服务的；它是为了解决工程上的问题，不是为了研究语言设计；它还是为了让我们的编程变得更舒适和方便。 但是结合Google当时内部的一些现实情况，如很多工程师都是C系的，所以新设计的语言一定要易学习，最好是类似C的语言；20年没有出新的语言了，所以新设计的语言必须是现代化的（例如内置GC）等情况。最后根据实战经验，他们向着目标设计了Go这个语言。 4、Go语言的特色： 没有继承多态的面向对象 强一致类型 interface不需要显式声明(Duck Typing) 没有异常处理(Error is value) 基于首字母的可访问特性 不用的import或者变量引起编译错误 完整而卓越的标准库包 Go内置runtime（作用是性能监控、垃圾回收等） 二、Go语言的优势1、学习曲线容易 ​ Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。 ​ Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。 2、效率：快速的编译时间，开发效率和运行效率高 ​ 开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。 C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。 3、出身名门、血统纯正 ​ 之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。 4、自由高效：组合的思想、无侵入式的接口 ​ Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。 ​ 5、强大的标准库 ​ 这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。Go 语言的 lib 库麻雀虽小五脏俱全。Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。 6、部署方便：二进制文件，Copy部署 ​ 这一点是很多人选择Go的最大理由，因为部署太方便了，所以现在也有很多人用Go开发运维程序。 7、简单的并发 并行和异步编程几乎无痛点。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。 Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。 创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。 8、稳定性 ​ Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。 三、对比其他语言Go的很多语言特性借鉴与它的三个祖先：C，Pascal和CSP。Go的语法、数据类型、控制流等继承于C，Go的包、面对对象等思想来源于Pascal分支，而Go最大的语言特色，基于管道通信的协程并发模型，则借鉴于CSP分支。 Java编译语言，速度适中（2.67s），目前的大型网站都是拿java写的，比如淘宝、京东等。主要特点是稳定，开源性好，具有自己的一套编写规范，开发效率适中，目前最主流的语言。 作为编程语言中的大腕。具有最大的知名度和用户群。无论风起云涌，我自巍然不动。他强任他强，清风拂山岗；他横由他横，明月照大江。 c#执行速度快（4.28），学习难度适中，开发速度适中。但是由于c#存在很多缺点，京东、携程等大型网站前身都是用c#开发的，但是现在都迁移到了java上。 C/C++现存编程语言中的老祖，其他语言皆由此而生。执行速度最快无人能及。但是写起来最为复杂，开发难度大。 Javascript编程语言中特立独行的傲娇美女。前端处理能力是其它语言无法比拟。发展中的js后端处理能力也是卓越不凡。前后端通吃，舍我其谁？ Python脚本语言，速度最慢（258s），代码简洁、学习进度短，开发速度快。豆瓣就是拿python写的。Python著名的服务器框架有django，flask。但是python在大型项目上不太稳定，因此有些用python的企业后来迁移到了java上。 scala编译语言，比python快十倍，和java差不多，但是学习进度慢，而且在实际编程中，如果对语言不够精通，很容易造成性能严重下降。，后来比如Yammer就从scala迁移到了java上。微服务框架有lagom等。 Go编程界的小鲜肉。高并发能力无人能及。即具有像Python一样的简洁代码、开发速度，又具有C语言一样的执行效率，优势突出。 四、最后因为Go的语法和Erlang、Python类似，所以我们将这三门语言做个详细的对比。 相比于Python的40个特性，Go只有31个，可以说Go在语言设计上是相当克制的。比如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。 但是Go的特点也很鲜明，比如，它拥有协程、自动垃圾回收、包管理系统、一等公民的函数、栈空间管理等。 Go作为静态类型语言，保证了Go在运行效率、内存用量、类型安全都要强于Python和Erlang。 Go的数据类型也更加丰富，除了支持表、字典等复杂的数据结构，还支持指针和接口类型，这是Python和Erlang所没有的。特别是接口类型特别强大，它提供了管理类型系统的手段。而指针类型提供了管理内存的手段，这让Go进入底层软件开发提供了强有力的支持。 Go在面对对象的特性支持上做了很多反思和取舍，它没有类、虚函数、继承、泛型等特性。Go语言中面向对象编程的核心是组合和方法(function)。组合很类似于C语言的struct结构体的组合方式，方法类似于Java的接口(Interface)，但是使用方法上与对象更加解耦，减少了对对象内部的侵入。Erlang则不支持面对对象编程范式，相比而言，Python对面对对象范式的支持最为全面。 在函数式编程的特性支持上，Erlang作为函数式语言，支持最为全面。但是基本的函数式语言特性，如lambda、高阶函数、curry等，三种语言都支持。 控制流的特性支持上，三种语言都差不多。Erlang支持尾递归优化，这给它在函数式编程上带来便利。而Go在通过动态扩展协程栈的方式来支持深度递归调用。Python则在深度递归调用上经常被爆栈。 Go和Erlang的并发模型都来源于CSP，但是Erlang是基于actor和消息传递（mailbox）的并发实现，Go是基于goroutine和管道（channel）的并发实现。不管Erlang的actor还是Go的goroutine，都满足协程的特点：由编程语言实现和调度，切换在用户态完成，创建销毁开销很小。至于Python，其多线程的切换和调度是基于操作系统实现，而且因为GIL的大坑级存在，无法真正做到并行。 而且从笔者的并发编程体验上看，Erlang的函数式编程语法风格和其OTP behavior框架提供的晦涩的回调（callback）使用方法，对大部分的程序员，如C/C++和Java出身的程序员来说，有一定的入门门槛和挑战。而被称为“互联网时代的C”的Go，其类C的语法和控制流，以及面对对象的编程范式，编程体验则好很多。 本文图片来自网络，侵删 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av47467197 https://www.bilibili.com/video/av56018934/ 源代码： https://github.com/rubyhan1314/go_foundation Go语言能做什么 @author：韩茹版权所有：北京千锋互联科技有限公司 一、我们为什么选择Go语言选择Go语言的原因可能会有很多，关于Go语言的特性、优势等，我们在之前的文档中也已经介绍了很多了。但是最主要的原因，应该是基于以下两方面的考虑： 执行性能 缩短API的响应时长，解决批量请求访问超时的问题。在Uwork的业务场景下，一次API批量请求，往往会涉及对另外接口服务的多次调用，而在之前的PHP实现模式下，要做到并行调用是非常困难的，串行处理却不能从根本上提高处理性能。而GO语言不一样，通过协程可以方便的实现API的并行处理，达到处理效率的最大化。 依赖Golang的高性能HTTP Server，提升系统吞吐能力，由PHP的数百级别提升到数千里甚至过万级别。 开发效率 GO语言使用起来简单、代码描述效率高、编码规范统一、上手快。 通过少量的代码，即可实现框架的标准化，并以统一的规范快速构建API业务逻辑。 能快速的构建各种通用组件和公共类库，进一步提升开发效率，实现特定场景下的功能量产。 二、Go语言能做什么Go 语言从发布 1.0 版本以来备受众多开发者关注并得到广泛使用，Go 语言的简单、高效、并发特性吸引了众多传统语言开发者的加入，而且人数越来越多。 鉴于Go语言的特点和设计的初衷，Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web 应用、API应用、下载应用等；除此之外，Go语言还适用于内存数据库和云平台领域，目前国外很多云平台都是采用Go开发。 服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。 分布式系统、数据库代理器、中间件等，例如Etcd。 网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用，而且Go内置的net/http包基本上把我们平常用到的网络功能都实现了。 数据库操作 开发云平台，目前国外很多云平台在采用Go开发 三、国内外有哪些企业或项目使用Go语言Go发布之后，很多公司特别是云计算公司开始用Go重构他们的基础架构，很多都是直接采用Go进行了开发，最近热火朝天的Docker就是采用Go开发的。 使用 Go 语言开发的开源项目非常多。早期的 Go 语言开源项目只是通过 Go 语言与传统项目进行C语言库绑定实现，例如 Qt、Sqlite 等；后期的很多项目都使用 Go 语言进行重新原生实现，这个过程相对于其他语言要简单一些，这也促成了大量使用 Go 语言原生开发项目的出现。 云计算基础设施领域 代表项目：docker、kubernetes、etcd、consul、cloudflare CDN、七牛云存储等。 基础软件 代表项目：tidb、influxdb、cockroachdb等。 微服务 代表项目：go-kit、micro、monzo bank的typhon、bilibili等。 互联网基础设施 代表项目：以太坊、hyperledger等。 采用Go的一些国外公司，如Google、Docker、Apple、Cloud Foundry、CloudFlare、Couchbase、CoreOS、Dropbox、MongoDB、AWS等公司； 采用Go开发的国内企业：如阿里云CDN、百度、小米、七牛、PingCAP、华为、金山软件、猎豹移动、饿了么等公司。 DockerDocker 是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间进行隔离，也可以称之为容器。Docker 可以在一台物理服务器上快速运行一个或多个实例。基于lxc的一个虚拟打包工具，能够实现PAAS平台的组建。例如，启动一个 CentOS 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。 项目链接： https://github.com/docker/docker go语言Go 语言自己的早期源码使用C语言和汇编语言写成。从 Go 1.5 版本后，完全使用 Go 语言自身进行编写。Go 语言的源码对了解 Go 语言的底层调度有极大的参考意义，建议希望对 Go 语言有深入了解的读者读一读。 项目链接： https://github.com/golang/go KubernetesGoogle 公司开发的构建于 Docker 之上的容器调度服务，用户可以通过 Kubernetes 集群进行云端容器集群管理。 项目链接： https://github.com/kubernetes/kubernetes etcd一款分布式、可靠的 KV 存储系统，可以快速进行云配置。 项目链接： https://github.com/coreos/etcd beegobeego 是一个类似 Python的 Tornado 框架，采用了 RESTFul 的设计思路，使用 Go 语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架。 项目链接： https://github.com/astaxie/beego martini一款快速构建模块化的 Web 应用的 Web 框架。 项目链接： https://github.com/go-martini/martini codis国产的优秀分布式 Redis 解决方案。 项目链接： https://github.com/CodisLabs/codis delveGo语言 强大的调试器，被很多集成环境和编辑器整合。 项目链接： https://github.com/derekparker/delve FacebookFacebook也在用，为此他们还专门在Github上建立了一个开源组织facebookgo，大家可以通过https://github.com/facebookgo访问查看facebook开源的项目，比如著名的是平滑升级的grace。 Uber腾讯腾讯作为国内的大公司，还是敢于尝试的，尤其是Docker容器化这一块，他们在15年已经做了docker万台规模的实践，具体可以参考http://www.infoq.com/cn/articles/tencent-millions-scale-docker-application-practice 。 百度目前所知的百度的使用是在运维这边，是百度运维的一个BFE项目，负责前端流量的接入。他们的负责人在2016年有分享，大家可以看下这个 http://www.infoq.com/cn/presentations/application-of-golang-in-baidu-frontend 。 其次就是百度的消息系统。负责公司手百消息通讯系统服务器端开发及维护。 京东京东云消息推送系统、云存储，以及京东商城等都有使用Go做开发。 小米小米对Golang的支持，莫过于运维监控系统的开源，也就是 http://open-falcon.com/ 。 此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Golang。 360360对Golang的使用也不少，一个是开源的日志搜索系统Poseidon，托管在Github上，https://github.com/Qihoo360/poseidon. 还有360的推送团队也在使用，他们还写了篇博文在Golang的官方博客上 https://blog.golang.org/qihoo。 七牛云七牛云用了近50万行代码，来实现整个产品。七牛云存储产品网址：http://qiniu.com/。上线时间：2011-9-1。应用范围：整个产品（包括基础服务、Web端、统计平台、各类小工具等等）Go代码行数占比：99.9%日 PV：保密 美团美团后台流量支撑程序。应用范围：支撑主站后台流量（排序，推荐，搜索等），提供负载均衡，cache，容错，按条件分流，统计运行指标（qps，latency）等功能。 滴滴基础服务平台。 ###金山微看 应用范围：服务接口，后台流程服务，消息系统，图片系统 搜狗搜狗推送系统。Push系统中用于维持与客户端连接的部分。 QOR - 模块化的电商系统 QOR官网: QOR: E-commerce &amp; CMS SDK written in Go github地址: qor/qor · GitHub 应用范围: 整个产品 weico产品名：weico 3.0， 服务端所有代码都是用Go实现。 仙侠道 产品网址：[仙侠道官网 - 心动游戏](仙侠道官网 - 心动游戏) 应用范围： 游戏服务端（通讯、逻辑、数据存储） 快玩游戏 网址：快玩小游戏,单机游戏,网页游戏,快玩游戏,快玩游戏盒 应用范围：实时消息系统、用户认证、用户会话、统一统计接口 盛大云CDN 网址：盛大云计算 应用范围：CDN的调度系统、分发系统、监控系统、短域名服务，CDN内部开放平台、运营报表系统以及其他一些小工具等 Bmob移动后端云服务平台 产品网址：Bmob移动后端云服务平台 应用范围：Restful API(使用Beego)、统计分析平台、常用服务如发邮件、队列异步处理、统计用户空间和接口请求 群策 网址：[群策 - 统一团队沟通，高效完成工作](群策 - 统一团队沟通，高效完成工作) 应用范围：全系统 BiddingX DSP广告投放系统 网址：BiddingX_专业的DSP解决方案供应商 应用范围：竞价投放、曝光统计、点击跳转 街坊四邻 网址：首页 - 街坊四邻 应用范围：后台服务 Leanote 网址：Leanote Bearychat 网址：BearyChat 宅豆 网址：宅豆网 - 自筑最美家，宅豆随你搭 白板- 设计图讨论工具 网址：白板 实验楼 网址：实验楼 - 第一家以实验为核心的IT在线教育平台 新浪微博中间件和弹性调度用 Java 和 Go 编写，微博视频转码及存储服务用 Go 编写。 爱奇艺VR 后台系统中间件，VR 端的 HTTP 接口。 猎豹移动消息推送 网易网易蜂巢容器公有云。 哔哩哔哩弹幕 巨人网络部分手机游戏的服务端。 今日头条Nsq：Nsq 是由Go语言开发的高性能、高可用消息队列系统，性能非常高，每天能处理数十亿条的消息； Packer:用来生成不同平台的镜像文件，例如VM、vbox、AWS等，作者是vagrant的作者 Skynet：分布式调度框架 Doozer：分布式同步工具，类似ZooKeeper Heka：mazila开源的日志处理系统 Cbfs：couchbase开源的分布式文件系统 Tsuru：开源的PAAS平台，和SAE实现的功能一模一样 Groupcache：memcahe作者写的用于Google下载系统的缓存系统 God：类似redis的缓存系统，但是支持分布式和扩展性 Gor：网络流量抓包和重放工具 还有很多，比如阿里中间件、聚美优品、高升控股、探探、斗鱼直播、人人车、亚信、Udesk、方付通、招财猫、三一集团、美餐网等。一般的选择，都是选择用于自己公司合适的产品系统来做，比如消息推送的、监控的、容器的等，Golang特别适合做网络并发的服务，这是他的强项，所以也是被优先用于这些项目。Go语言作为一门大型项目开发语言，在很多大公司相继使用，甚至完全转向Go开发。 四、写在最后当然，一个技术能不能发展起来，关键还要看三点。(以下观点引自https://www.cnblogs.com/qwangxiao/p/8318894.html) 有没有一个比较好的社区。像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。 有没有一个工业化的标准。像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。 有没有一个或多个杀手级应用。C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。 上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如： 学习曲线是否低，上手是否快。这点非常重要，C++ 在这点上越做越不好了。 有没有一个不错的提高开发效率的开发框架。如：Java 的 Spring 框架，C++ 的 STL 等。 是否有一个或多个巨型的技术公司作为后盾。如：Java 和 Linux 后面的 IBM、Sun…… 有没有解决软件开发中的痛点。如：Java 解决了 C 和 C++ 的内存管理问题。 用这些标尺来量一下 Go 语言，我们可以清楚地看到： Go 语言容易上手； Go 语言解决了并发编程和写底层应用开发效率的痛点； Go 语言有 Google 这个世界一流的技术公司在后面； Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。 所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。 也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。 好了，我们再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。 Docker 上手很容易。 Docker 解决了运维中的环境问题以及服务调度的痛点。 Docker 的生态圈中有大公司在后面助力。比如 Google。 Docker 产出了工业界标准 OCI。 Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。 …… 所以，虽然几年前的 Docker ，当时的坑儿还很多，但是，相对于这些大的因素来说，那些小坑儿都不是问题。只是需要一些时间，这些小坑儿在未来 5-10 年就可以完全被填平了。 同样，我们可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。 最后，我还要说一下，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。 技术的发展过程非常重要。因为你可以清楚地看到了这种新技术的生态圈发展过程。让我们收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。 从中，我们看到了非常具体的各种思潮和思路，这些东西比起 技术本身来说更有价值。因为，这不但让我们重新思考已经掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。不但有了技术优势，而且这些知识还让我们的技术生涯多了很多的可能性。 这些关键新技术，可以让你拿到技术的先机。这些对一个需要技术领导力的个人或公司来说都是非常重要的。 一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地产生经济利益。 Go的应用范围一直在扩大，云计算，微服务，区块链，哪里都有用Go写的重量级项目。docker/kubernetes生态圈，几百/千万行代码，基本统治了云原生应用市场。去年大热的区块链，以太坊的geth，比特币的btcd，闪电网络的lnd，都是Go语言开发。还是那句话，多看看各种语言的生态，或许都并没有你想象的那么不堪。。。Go语言设计上确实不够“先进”，但也是另一种“务实”。其实go不管在国内还是国外已经很受待见了，国外google用的很多，uber也在用，国内有著名的今日头条，每日千亿级的访问妥妥的。多少语言终其一生都没有这么大的应用场景。 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av47467197 https://www.bilibili.com/video/av56018934/ 源代码： https://github.com/rubyhan1314/go_foundationhttps://www.bilibili.com/video/av47467197/?p=6 第一个程序：HelloWorld @author：韩茹 版权所有：北京千锋互联科技有限公司 一、go项目工程结构配置好工作目录后，就可以编码开发了，在这之前，我们看下go的通用项目结构，这里的结构主要是源代码相应地资源文件存放目录结构。 1.1 gopath目录gopath目录就是我们存储我们所编写源代码的目录。该目录下往往要有3个子目录：src，bin，pkg。 src —- 里面每一个子目录，就是一个包。包内是Go的源码文件 pkg —- 编译后生成的，包的目标文件 bin —- 生成的可执行文件。 1.2 编写第一个程序每个编程语言的学习，都是从一个”Hello, World.”程序开始的，这个例子首次出现于1978年出版的C语言圣经《The C Programming Language》。关于”Hello, World.”还有一个很美好的故事，那就是所有的程序员期待着计算机有一天能拥有真正的智能，然后对创造他的人们”发自内心”的说一句，Hello, World。 1.在HOME/go的目录下，(就是GOPATH目录里)，创建一个目录叫src，然后再该目录下创建一个文件夹叫hello，在该目录下创建一个文件叫helloworld.go，并双击打开，输入以下内容： 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125; 2.执行go程序 执行go程序由几种方式 方式一：使用go run命令 ​ step1：打开终端： ​ window下使用快捷键win+R，输入cmd打开命令行提示符 ​ linux下可以使用快捷键：ctrl+alt+T ​ mac下command+空格，输入termainl ​ step2：进入helloworld.go所在的目录 ​ step3：输入go run helloworld.go命令并观察运行结果。 方式二：使用go build命令 ​ step1：打开终端：在任意文件路径下，运行:​ go install hello ​ 也可以进入项目(应用包)的路径，然后运行：​ go install 注意，在编译生成go程序的时，go实际上会去两个地方找程序包：GOROOT下的src文件夹下，以及GOPATH下的src文件夹下。 在程序包里，自动找main包的main函数作为程序入口，然后进行编译。 ​ step2：运行go程序​ 在/home/go/bin/下(如果之前没有bin目录则会自动创建)，会发现出现了一个hello的可执行文件，用如下命令运行:​ ./hello ​ 1.3 第一个程序的解释说明3.2.1 package 在同一个包下面的文件属于同一个工程文件，不用import包，可以直接使用 在同一个包下面的所有文件的package名，都是一样的 在同一个包下面的文件package名都建议设为是该目录名，但也可以不是 3.2.2 importimport “fmt” 告诉 Go 编译器这个程序需要使用 fmt 包的函数，fmt 包实现了格式化 IO（输入/输出）的函数 可以是相对路径也可以是绝对路径，推荐使用绝对路径（起始于工程根目录） 点操作我们有时候会看到如下的方式导入包 123import( . &quot;fmt&quot;) 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调 用的fmt.Println(&quot;hello world&quot;)可以省略的写成Println(&quot;hello world&quot;) 别名操作别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字 123import( f &quot;fmt&quot;) 别名操作的话调用包函数时前缀变成了我们的前缀，即f.Println(&quot;hello world&quot;) _操作这个操作经常是让很多人费解的一个操作符，请看下面这个import 1234import ( &quot;database/sql&quot; _ &quot;github.com/ziutek/mymysql/godrv&quot;) _操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数 3.3.3 mainmain(),是程序运行的入口。 1.4 包的说明我们知道源代码都是存放在GOPATH的src目录下，那么多个多个项目的时候，怎么区分呢？答案是通过包，使用包来组织我们的项目目录结构。有过java开发的都知道，使用包进行组织代码，包以网站域名开头就不会有重复，比如千锋的网站是http://www.mobiletrain.org，我们就可以以mobiletrain.org的名字创建一个文件夹，我自己的go项目都放在这个文件夹里，这样就不会和其他人的项目冲突，包名也是唯一的。 如果有自己的域名，那也可以使用自己的域名。如果没有个人域名，现在流行的做法是使用你个人的github名，因为每个人的是唯一的，所以也不会有重复。 如上，src目录下跟着一个个域名命名的文件夹。再以github.com文件夹为例，它里面又是以github用户名命名的文件夹，用于存储属于这个github用户编写的go源代码。 千锋Go语言的学习群：784190273 作者B站： https://space.bilibili.com/353694001 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation Go的执行原理以及Go的命令 @author：韩茹版权所有：北京千锋互联科技有限公司 一、Go的源码文件 Go 的源码文件分类： 如上图，分为三类： 1、命令源码文件： 声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。 命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。 命令源码文件是 Go 程序的入口。 同一个代码包中最好也不要放多个命令源码文件。多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。 我们先打开上次课的hello目录，然后复制helloworld.go为helloworld2.go文件，并修改里面的内容： 123456package mainimport &quot;fmt&quot;func main()&#123; fmt.Println(&quot;我是第二个helloworld文件&quot;) fmt.Print(&quot;Go Go Go !!!&quot;)&#125; hello目录下有两个go文件了，一个是helloworld.go，一个是helloworld2.go。先说明一下，在上述文件夹中放了两个命令源码文件，同时都声明自己属于 main 代码包。 打开终端，进入hello这个目录，也可以看到这两个文件： 123localhost:~ ruby cd go/src/hellolocalhost:hello ruby lshelloworld.go helloworld2.go 然后我们分别执行go run命令，可以看到两个go文件都可以被执行： 12345localhost:hello ruby$ go run helloworld.goHelloWorldGo Go Go !!!localhost:hello ruby$ go run helloworld2.go我是第二个helloworld文件Go Go Go !!! 接下来执行 go build 和 go install ，看看会发生什么： 123456789localhost:hello ruby$ go build # hello./helloworld2.go:3:6: main redeclared in this block previous declaration at ./helloworld.go:3:6localhost:hello ruby$ go install# hello./helloworld2.go:3:6: main redeclared in this block previous declaration at ./helloworld.go:3:6localhost:hello ruby$ 运行效果图： 这也就证明了多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。 同理，如果命令源码文件和库源码文件也会出现这样的问题，库源码文件不能通过 go build 和 go install 这种常规的方法编译和安装。具体例子和上述类似，这里就不再贴代码了。 所以命令源码文件应该是被单独放在一个代码包中。 2、库源码文件 库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。 库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。 3、测试源码文件 名称以 _test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数： 123func TestXXX( t *testing.T) &#123;&#125; 名称以 Test 为名称前缀的函数，只能接受 *testing.T 的参数，这种测试函数是功能测试函数。 1234func BenchmarkXXX( b *testing.B) &#123;&#125; 名称以 Benchmark 为名称前缀的函数，只能接受 *testing.B 的参数，这种测试函数是性能测试函数。 现在答案就很明显了： 命令源码文件是可以单独运行的。可以使用 go run 命令直接运行，也可以通过 go build 或 go install 命令得到相应的可执行文件。所以命令源码文件是可以在机器的任何目录下运行的。 举个栗子： 比如平时我们在 LeetCode 上刷算法题，这时候写的就是一个程序，这就是命令源码文件，可以在电脑的任意一个文件夹新建一个 go 文件就可以开始刷题了，写完就可以运行，对比执行结果，答案对了就可以提交代码。 但是公司项目里面的代码就不能这样了，只能存放在 GOPATH 目录下。因为公司项目不可能只有命令源码文件的，肯定是包含库源码文件，甚至包含测试源码文件的。 二、Go的命令目前Go的最新版1.12里面基本命令有以下17个。 我们可以打开终端输入：go help即可看到Go的这些命令以及简介。 1234567891011121314151617bug start a bug reportbuild compile packages and dependenciesclean remove object files and cached filesdoc show documentation for package or symbolenv print Go environment informationfix update packages to use new APIsfmt gofmt (reformat) package sourcesgenerate generate Go files by processing sourceget download and install packages and dependenciesinstall compile and install packages and dependencieslist list packages or modulesmod module maintenancerun compile and run Go programtest test packagestool run specified go toolversion print Go versionvet report likely mistakes in packages 其中和编译相关的有build、get、install、run这4个。接下来就依次看看这四个的作用。 在详细分析这4个命令之前，先罗列一下通用的命令标记，以下这些命令都可适用的： 名称 说明 -a 用于强制重新编译所有涉及的 Go 语言代码包（包括 Go 语言标准库中的代码包），即使它们已经是最新的了。该标记可以让我们有机会通过改动底层的代码包做一些实验。 -n 使命令仅打印其执行过程中用到的所有命令，而不去真正执行它们。如果不只想查看或者验证命令的执行过程，而不想改变任何东西，使用它正好合适。 -race 用于检测并报告指定 Go 语言程序中存在的数据竞争问题。当用 Go 语言编写并发程序的时候，这是很重要的检测手段之一。 -v 用于打印命令执行过程中涉及的代码包。这一定包括我们指定的目标代码包，并且有时还会包括该代码包直接或间接依赖的那些代码包。这会让你知道哪些代码包被执行过了。 -work 用于打印命令执行时生成和使用的临时工作目录的名字，且命令执行完成后不删除它。这个目录下的文件可能会对你有用，也可以从侧面了解命令的执行过程。如果不添加此标记，那么临时工作目录会在命令执行完毕前删除。 -x 使命令打印其执行过程中用到的所有命令，并同时执行它们。 1. go run专门用来运行命令源码文件的命令，注意，这个命令不是用来运行所有 Go 的源码文件的！ go run 命令只能接受一个命令源码文件以及若干个库源码文件（必须同属于 main 包）作为文件参数，且不能接受测试源码文件。它在执行时会检查源码文件的类型。如果参数中有多个或者没有命令源码文件，那么 go run 命令就只会打印错误提示信息并退出，而不会继续执行。 这个命令具体干了些什么事情呢？来分析分析，我们先重新创建一个新文件：mytest.go，并加入以下代码： 123456package mainimport &quot;fmt&quot;func main()&#123; fmt.Println(&quot;HelloWorld&quot;) fmt.Println(&quot;你好，Go!!!&quot;)&#125; 执行go run 配合-n： 123456789101112131415161718192021222324localhost:hello ruby$ go run -n mytest.go ## command-line-arguments#mkdir -p $WORK/b001/cat &gt;$WORK/b001/importcfg &lt;&lt; &#x27;EOF&#x27; # internal# import configpackagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.apackagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.aEOFcd /Users/ruby/go/src/hello/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/b001/_pkg_.a -trimpath $WORK/b001 -p main -complete -buildid ieg41NOobNF0eqq3xgnP/ieg41NOobNF0eqq3xgnP -dwarf=false -goversion go1.12.1 -D _/Users/ruby/go/src/hello -importcfg $WORK/b001/importcfg -pack -c=4 ./mytest.go/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/_pkg_.a # internalcat &gt;$WORK/b001/importcfg.link &lt;&lt; &#x27;EOF&#x27; # internal... # 此处省略EOFmkdir -p $WORK/b001/exe/cd ./usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/mytest -importcfg $WORK/b001/importcfg.link -s -w -buildmode=exe -buildid=vpgT856LhbZPXp6WeHib/ieg41NOobNF0eqq3xgnP/ieg41NOobNF0eqq3xgnP/vpgT856LhbZPXp6WeHib -extld=clang $WORK/b001/_pkg_.a$WORK/b001/exe/mytestlocalhost:hello ruby$ 运行效果图： 这里可以看到创建了两个临时文件夹 b001 和 exe，先执行了 compile 命令，然后 link，生成了归档文件.a 和 最终可执行文件，最终的可执行文件放在 exe 文件夹里面。命令的最后一步就是执行了可执行文件。 总结一下如下图： 举个例子，生成的临时文件可以用go run -work看到，比如当前生成的临时文件夹是如下的路径： 12345localhost:hello ruby$ go run -work mytest.go WORK=/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/go-build593750496HelloWorld你好，Go!!!localhost:hello ruby$ 我们进入：/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/go-build593750496目录，可以看到如下目录结构： 可以看到，最终go run命令是生成了2个文件，一个是归档文件，一个是可执行文件。 go run 命令在第二次执行的时候，如果发现导入的代码包没有发生变化，那么 go run 不会再次编译这个导入的代码包。直接静态链接进来。 12345678910111213localhost:hello ruby$ go run -n mytest.go mkdir -p $WORK/b001/cat &gt;$WORK/b001/importcfg.link &lt;&lt; &#x27;EOF&#x27; # internalpackagefile command-line-arguments=/Users/ruby/Library/Caches/go-build/6b/6b9577027c8da20b0ae6da790267f558b3b71eea1feb44039fb933b35eaef6f9-dpackagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.a...EOFmkdir -p $WORK/b001/exe/cd ./usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/mytest -importcfg $WORK/b001/importcfg.link -s -w -buildmode=exe -buildid=goiqf_1cemqljgOYzSRA/ieg41NOobNF0eqq3xgnP/MVbHdxOky1BGK6Aq_4bM/goiqf_1cemqljgOYzSRA -extld=clang /Users/ruby/Library/Caches/go-build/6b/6b9577027c8da20b0ae6da790267f558b3b71eea1feb44039fb933b35eaef6f9-d$WORK/b001/exe/mytestlocalhost:hello ruby$ 2. go buildgo build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。 如果是普通包，当你执行go build命令后，不会产生任何文件。 如果是main包，当只执行go build命令后，会在当前目录下生成一个可执行文件。如果需要在$GOPATH/bin目录下生成相应的exe文件，需要执行go install 或者使用 go build -o 路径/可执行文件。 如果某个文件夹下有多个文件，而你只想编译其中某一个文件，可以在 go build 之后加上文件名，例如 go build a.go；go build 命令默认会编译当前目录下的所有go文件。 你也可以指定编译输出的文件名。比如，我们可以指定go build -o 可执行文件名，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。 go build 会忽略目录下以”_”或者”.”开头的go文件。 如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。 当代码包中有且仅有一个命令源码文件的时候，在文件夹所在目录中执行 go build 命令，会在该目录下生成一个与目录同名的可执行文件。 123456789// 假设当前文件夹名叫 hellolocalhost:hello ruby$ pwd/Users/ruby/go/src/hellolocalhost:hello ruby$ lshelloworld.golocalhost:hello ruby$ go buildlocalhost:hello ruby$ lshello helloworld.golocalhost:hello ruby$ 于是在当前目录直接生成了以当前文件夹为名的可执行文件（ 在 Mac 平台下是 Unix executable 文件，在 Windows 平台下是 exe 文件） 但是这种情况下，如果使用 go install 命令，如果 GOPATH 里面只有一个工作区，就会在当前工作区的 bin 目录下生成相应的可执行文件。如果 GOPATH 下有多个工作区，则是在 GOBIN 下生成对应的可执行文件。 123localhost:hello ruby$ go installgo install hello: open /usr/local/go/bin/hello: permission deniedlocalhost:hello ruby$ 这个问题是因为它需要创建bin目录，然后把可刚才的可执行文件放进去，而目前我们在gopath下还没有bin目录，那么就需要先创建这个文件，而普通用户没有直接创建文件夹的权限，这个和Go语言的命令是没有关系的。我们可以加上sodu 来执行这个命令，表示使用管理员的身份执行，然后输入密码，那么就可以创建bin这个文件夹了。 再次执行： 1234localhost:hello ruby$ sudo go installPassword:localhost:hello ruby$ 执行完 go install 会发现可执行文件不见了！去哪里了呢？其实是被移动到了 bin 目录下了（如果 GOPATH 下有多个工作区，就会放在GOBIN 目录下）。 查看目录： 那 go build 和 go install 究竟干了些什么呢？ 先来说说 go build。go build 用于编译我们指定的源码文件或代码包以及它们的依赖包。但是注意如果用来编译非命令源码文件，即库源码文件，go build 执行完是不会产生任何结果的。这种情况下，go build 命令只是检查库源码文件的有效性，只会做检查性的编译，而不会输出任何结果文件。 go build 编译命令源码文件，则会在该命令的执行目录中生成一个可执行文件，上面的例子也印证了这个过程。 go build 后面不追加目录路径的话，它就把当前目录作为代码包并进行编译。go build 命令后面如果跟了代码包导入路径作为参数，那么该代码包及其依赖都会被编译。 go build 命令究竟做了些什么呢？我们可以执行-n这个命令来查看： 1234567891011121314151617181920212223242526localhost:hello ruby$ go build -n## hello#mkdir -p $WORK/b001/cat &gt;$WORK/b001/importcfg &lt;&lt; &#x27;EOF&#x27; # internal# import configpackagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.apackagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.aEOFcd /Users/ruby/go/src/hello/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/b001/_pkg_.a -trimpath $WORK/b001 -p main -complete -buildid PXDetO1R1NhLFMK5QGUc/PXDetO1R1NhLFMK5QGUc -goversion go1.12.1 -D &quot;&quot; -importcfg $WORK/b001/importcfg -pack -c=4 ./helloworld.go/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/_pkg_.a # internalcat &gt;$WORK/b001/importcfg.link &lt;&lt; &#x27;EOF&#x27; # internalpackagefile hello=$WORK/b001/_pkg_.a...EOFmkdir -p $WORK/b001/exe/cd ./usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/a.out -importcfg $WORK/b001/importcfg.link -buildmode=exe -buildid=diTh1q6kcbGRIX3aj3mU/PXDetO1R1NhLFMK5QGUc/PXDetO1R1NhLFMK5QGUc/diTh1q6kcbGRIX3aj3mU -extld=clang $WORK/b001/_pkg_.a/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/exe/a.out # internalmv $WORK/b001/exe/a.out hellolocalhost:hello ruby$ 可以看到，执行过程和 go run 大体相同，唯一不同的就是在最后一步，go run 是执行了可执行文件，但是 go build 命令，只是把库源码文件编译了一遍，然后把可执行文件移动到了当前目录的文件夹中。 总结一下如下图： 最后： 3. go installgo install 命令是用来编译并安装代码包或者源码文件的。 go install 命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者​$GOPATH/bin。 可执行文件： 一般是 go install 带main函数的go文件产生的，有函数入口，所有可以直接运行。 .a应用包： 一般是 go install 不包含main函数的go文件产生的，没有函数入口，只能被调用。 go install 用于编译并安装指定的代码包及它们的依赖包。当指定的代码包的依赖包还没有被编译和安装时，该命令会先去处理依赖包。与 go build 命令一样，传给 go install 命令的代码包参数应该以导入路径的形式提供。并且，go build 命令的绝大多数标记也都可以用于实际上，go install 命令只比 go build 命令多做了一件事，即：安装编译后的结果文件到指定目录。 安装代码包会在当前工作区的 pkg 的平台相关目录下生成归档文件（即 .a 文件）。安装命令源码文件会在当前工作区的 bin 目录（如果 GOPATH 下有多个工作区，就会放在 GOBIN 目录下）生成可执行文件。 同样，go install 命令如果后面不追加任何参数，它会把当前目录作为代码包并安装。这和 go build 命令是完全一样的。 go install 命令后面如果跟了代码包导入路径作为参数，那么该代码包及其依赖都会被安装。 go install 命令后面如果跟了命令源码文件以及相关库源码文件作为参数的话，只有这些文件会被编译并安装。 go install 命令究竟做了些什么呢？ 12345678910111213141516171819202122232425262728localhost:hello ruby$ go install -n## hello#mkdir -p $WORK/b001/cat &gt;$WORK/b001/importcfg &lt;&lt; &#x27;EOF&#x27; # internal# import configpackagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.apackagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.aEOFcd /Users/ruby/go/src/hello/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/b001/_pkg_.a -trimpath $WORK/b001 -p main -complete -buildid E1CTs4eXkD5M28s_FQXT/E1CTs4eXkD5M28s_FQXT -goversion go1.12.1 -D &quot;&quot; -importcfg $WORK/b001/importcfg -pack -c=4 ./helloworld.go/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/_pkg_.a # internalcat &gt;$WORK/b001/importcfg.link &lt;&lt; &#x27;EOF&#x27; # internalpackagefile hello=$WORK/b001/_pkg_.apackagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.a...EOFmkdir -p $WORK/b001/exe/cd ./usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/a.out -importcfg $WORK/b001/importcfg.link -buildmode=exe -buildid=FJ6kJTmN9rcWcwLhqfiQ/E1CTs4eXkD5M28s_FQXT/E1CTs4eXkD5M28s_FQXT/FJ6kJTmN9rcWcwLhqfiQ -extld=clang $WORK/b001/_pkg_.a/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/exe/a.out # internalmkdir -p /usr/local/go/bin/mv $WORK/b001/exe/a.out /usr/local/go/bin/hellolocalhost:hello ruby$ 前面几步依旧和 go run 、go build 完全一致，只是最后一步的差别，go install 会把命令源码文件安装到当前工作区的 bin 目录（如果 GOPATH 下有多个工作区，就会放在 GOBIN 目录下）。如果是库源码文件，就会被安装到当前工作区的 pkg 的平台相关目录下。 总结一下如下图： 在安装多个库源码文件时有可能遇到如下的问题： 123localhost:hello ruby$ go install envir.go fpath.go ipath.go pnode.go util.gogo install: no install location for .go files listed on command line (GOBIN not set) 而且，在我们为环境变量 GOBIN 设置了正确的值之后，这个错误提示信息仍然会出现。这是因为，只有在安装命令源码文件的时候，命令程序才会将环境变量 GOBIN 的值作为结果文件的存放目录。而在安装库源码文件时，在命令程序内部的代表结果文件存放目录路径的那个变量不会被赋值。最后，命令程序会发现它依然是个无效的空值。所以，命令程序会同样返回一个关于“无安装位置”的错误。这就引出一个结论，我们只能使用安装代码包的方式来安装库源码文件，而不能在 go install 命令罗列并安装它们。另外，go install 命令目前无法接受标记-o以自定义结果文件的存放位置。这也从侧面说明了 go install 命令不支持针对库源码文件的安装操作。 4. go getgo get 命令用于从远程代码仓库（比如 Github ）上下载并安装代码包。注意，go get 命令会把当前的代码包下载到 $GOPATH 中的第一个工作区的 src 目录中，并安装。 使用 go get 下载第三方包的时候，依旧会下载到 $GOPATH 的第一个工作空间，而非 vendor 目录。当前工作链中并没有真正意义上的包依赖管理，不过好在有不少第三方工具可选。 如果在 go get 下载过程中加入-d 标记，那么下载操作只会执行下载动作，而不执行安装动作。比如有些非常特殊的代码包在安装过程中需要有特殊的处理，所以我们需要先下载下来，所以就会用到-d 标记。 还有一个很有用的标记是-u标记，加上它可以利用网络来更新已有的代码包及其依赖包。如果已经下载过一个代码包，但是这个代码包又有更新了，那么这时候可以直接用-u标记来更新本地的对应的代码包。如果不加这个-u标记，执行 go get 一个已有的代码包，会发现命令什么都不执行。只有加了-u标记，命令会去执行 git pull 命令拉取最新的代码包的最新版本，下载并安装。 命令 go get 还有一个很值得称道的功能——智能下载。在使用它检出或更新代码包之后，它会寻找与本地已安装 Go 语言的版本号相对应的标签（tag）或分支（branch）。比如，本机安装 Go 语言的版本是1.x，那么 go get 命令会在该代码包的远程仓库中寻找名为 “go1” 的标签或者分支。如果找到指定的标签或者分支，则将本地代码包的版本切换到此标签或者分支。如果没有找到指定的标签或者分支，则将本地代码包的版本切换到主干的最新版本。 go get 常用的一些标记如下： 标记名称 标记描述 -d 让命令程序只执行下载动作，而不执行安装动作。 -f 仅在使用-u标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里 Fork 过来的，那么这样做就尤为重要了。 -fix 让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。 -insecure 允许命令程序使用非安全的 scheme（如 HTTP ）去下载指定的代码包。如果你用的代码仓库（如公司内部的 Gitlab ）没有HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它。 -t 让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。 -u 让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。 go get 命令究竟做了些什么呢？我们还是来打印一下每一步的执行过程。 123456789101112localhost:hello ruby$ go get -x github.com/go-errors/errorscd .git clone https://github.com/go-errors/errors /Users/ruby/go/src/github.com/go-errors/errorscd /Users/ruby/go/src/github.com/go-errors/errorsgit submodule update --init --recursivecd /Users/ruby/go/src/github.com/go-errors/errorsgit show-refcd /Users/ruby/go/src/github.com/go-errors/errorsgit submodule update --init --recursiveWORK=/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/go-build188558329localhost:hello ruby$ 效果图： 这里可以很明显的看到，执行完 go get 命令以后，会调用 git clone 方法下载源码，并编译，最终会把库源码文件编译成归档文件安装到 pkg 对应的相关平台目录下。 总结一下如下图： 5. 其他命令go clean go clean 命令是用来移除当前源码包里面编译生成的文件，这些文件包括 _obj/ 旧的object目录，由Makefiles遗留 _test/ 旧的test目录，由Makefiles遗留 _testmain.go 旧的gotest文件，由Makefiles遗留 test.out 旧的test记录，由Makefiles遗留 build.out 旧的test记录，由Makefiles遗留 *.[568ao] object文件，由Makefiles遗留 DIR(.exe) 由 go build 产生 DIR.test(.exe) 由 go test -c 产生 MAINFILE(.exe) 由 go build MAINFILE.go产生 go fmt go fmt 命令主要是用来帮你格式化所写好的代码文件。 比如我们写了一个格式很糟糕的 test.go 文件，我们只需要使用 fmt go test.go 命令，就可以让go帮我们格式化我们的代码文件。但是我们一般很少使用这个命令，因为我们的开发工具一般都带有保存时自动格式化功能，这个功能底层其实就是调用了 go fmt 命令而已。 使用go fmt命令，更多时候是用gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w src，可以格式化整个项目。 go test go test 命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag go doc go doc 命令其实就是一个很强大的文档工具。 如何查看相应package的文档呢？ 例如builtin包，那么执行go doc builtin；如果是http包，那么执行go doc net/http；查看某一个包里面的函数，那么执行go doc fmt Printf；也可以查看相应的代码，执行go doc -src fmt Printf； 1234567# 查看net/http包localhost:hello ruby$ go doc net/http# 查看time包localhost:hello ruby$ go doc time# 查看某个包里的指定函数localhost:hello ruby$ go doc fmt Printf 通过命令在命令行执行 go doc -http=:端口号，比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被限制访问的用户来说是一个不错的选择。 12localhost:hello ruby$ godoc -http=:9527 go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1 go version 查看go当前的版本 go env 查看当前go的环境变量 go list 列出当前全部安装的package 本文部门文字和图片引自：https://www.jianshu.com/p/35a4ec1b3067 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation 编码规范 @author：韩茹版权所有：北京千锋互联科技有限公司 本规范旨在为日常Go项目开发提供一个代码的规范指导，方便团队形成一个统一的代码风格，提高代码的可读性，规范性和统一性。本规范将从命名规范，注释规范，代码风格和 Go 语言提供的常用的工具这几个方面做一个说明。该规范参考了 go 语言官方代码的风格制定。 一、 命名规范命名是代码规范中很重要的一部分，统一的命名规则有利于提高的代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。 Go在命名时以字母a到Z或a到Z或下划线开头，后面跟着零或更多的字母、下划线和数字(0到9)。Go不允许在命名时中使用@、$和%等标点符号。Go是一种区分大小写的编程语言。因此，Manpower和manpower是两个不同的命名。 当命名（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）； 命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ） 1、包命名：package保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为小写单词，不要使用下划线或者混合大小写。 123package demopackage main 2、 文件命名尽量采取有意义的文件名，简短，有意义，应该为小写单词，使用下划线分隔各个单词。 1my_test.go 3、 结构体命名 采用驼峰命名法，首字母根据访问控制大写或者小写 struct 申明和初始化格式采用多行，例如下面： 123456789101112// 多行申明type User struct&#123; Username string Email string&#125;// 多行初始化u := User&#123; Username: &quot;astaxie&quot;, Email: &quot;astaxie@gmail.com&quot;,&#125; 4、 接口命名 命名规则基本和上面的结构体类型 单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。 1234type Reader interface &#123; Read(p []byte) (n int, err error)&#125; 5、变量命名 和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则： 如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient 其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID 错误示例：UrlArray，应该写成 urlArray 或者 URLArray 若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头 1234var isExist boolvar hasConflict boolvar canManage boolvar allowGitHook bool 6、常量命名常量均需使用全部大写字母组成，并使用下划线分词 1const APP_VER = &quot;1.0&quot; 如果是枚举类型的常量，需要先创建相应类型： 1234567type Scheme stringconst ( HTTP Scheme = &quot;http&quot; HTTPS Scheme = &quot;https&quot;) 7、 关键字下面的列表显示了Go中的保留字。这些保留字不能用作常量或变量或任何其他标识符名称。 二、注释Go提供C风格的/* */块注释和C ++风格的//行注释。行注释是常态；块注释主要显示为包注释，但在表达式中很有用或禁用大量代码。 单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释 多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段 go 语言自带的 godoc 工具可以根据注释生成文档，生成可以自动生成对应的网站（ golang.org 就是使用 godoc 工具直接生成的），注释的质量决定了生成的文档的质量。每个包都应该有一个包注释，在package子句之前有一个块注释。对于多文件包，包注释只需要存在于一个文件中，任何一个都可以。包评论应该介绍包，并提供与整个包相关的信息。它将首先出现在godoc页面上，并应设置下面的详细文档。 详细的如何写注释可以参考：http://golang.org/doc/effective_go.html#commentary 1、包注释每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中（一般是和包同名的文件）即可。 包注释应该包含下面基本信息(请严格按照这个顺序，简介，创建人，创建时间）： 包的基本简介（包名，简介） 创建者，格式： 创建人： rtx 名 创建时间，格式：创建时间： yyyyMMdd 例如 util 包的注释示例如下 123// util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。// 创建人： hanru// 创建时间： 20190419 2、结构（接口）注释每个自定义的结构体或者接口都应该有注释说明，该注释对结构进行简要介绍，放在结构体定义的前一行，格式为： 结构体名， 结构体说明。同时结构体内的每个成员变量都要有说明，该说明放在成员变量的后面（注意对齐），实例如下： 12345// User ， 用户对象，定义了用户的基础信息type User struct&#123; Username string // 用户名 Email string // 邮箱&#125; 3、函数（方法）注释每个函数，或者方法（结构体或者接口下的函数称为方法）都应该有注释说明，函数的注释应该包括三个方面（严格按照此顺序撰写）： 简要说明，格式说明：以函数名开头，“，”分隔说明部分 参数列表：每行一个参数，参数名开头，“，”分隔说明部分 返回值： 每行一个返回值 示例如下： 1234567// NewtAttrModel ， 属性数据层操作类的工厂方法// 参数：// ctx ： 上下文信息// 返回值：// 属性操作类指针func NewAttrModel(ctx *common.Context) *AttrModel &#123;&#125; 4、代码逻辑注释对于一些关键位置的代码逻辑，或者局部较为复杂的逻辑，需要有相应的逻辑说明，方便其他开发者阅读该段代码，实例如下： 1234// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取xxxxxxxxxxxxxxxxxxx 5、注释风格统一使用中文注释，对于中英文字符之间严格使用空格分隔， 这个不仅仅是中文和英文之间，英文和中文标点之间也都要使用空格分隔，例如： 1// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取 上面 Redis 、 id 、 DB 和其他中文字符之间都是用了空格分隔。 建议全部使用单行注释 和代码的规范一样，单行注释不要过长，禁止超过 120 字符。 三、代码风格1、缩进和折行 缩进直接使用 gofmt 工具格式化即可（gofmt 是使用 tab 缩进的）； 折行方面，一行最长不超过120个字符，超过的请使用换行展示，尽量保持格式优雅。 我们使用Goland开发工具，可以直接使用快捷键：ctrl+alt+L，即可。 2、语句的结尾Go语言中是不需要类似于Java需要冒号结尾，默认一行就是一条数据 如果你打算将多个语句写在同一行，它们则必须使用 ; 3、括号和空格括号和空格方面，也可以直接使用 gofmt 工具格式化（go 会强制左大括号不换行，换行会报语法错误），所有的运算符和操作数之间要留空格。 1234567891011// 正确的方式if a &gt; 0 &#123;&#125; // 错误的方式if a&gt;0 // a ，0 和 &gt; 之间应该空格&#123; // 左大括号不可以换行，会报语法错误&#125; 4、import 规范import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式： 123import ( &quot;fmt&quot;) 如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包： 1234567891011import ( &quot;encoding/json&quot; &quot;strings&quot; &quot;myproject/models&quot; &quot;myproject/controller&quot; &quot;myproject/utils&quot; &quot;github.com/astaxie/beego&quot; &quot;github.com/go-sql-driver/mysql&quot;) 有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。 在项目中不要使用相对路径引入包： 12345// 这是不好的导入import “../net”// 这是正确的做法import “github.com/repo/proj/src/net” 但是如果是引入本项目中的其他包，最好使用相对路径。 5、错误处理 错误处理的原则就是不能丢弃任何有返回err的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回err，或者使用log记录下来 尽早return：一旦有错误发生，马上返回 尽量不要使用panic，除非你知道你在做什么 错误描述如果是英文必须为小写，不需要标点结尾 采用独立的错误流进行处理 1234567891011121314// 错误写法if err != nil &#123; // error handling&#125; else &#123; // normal code&#125;// 正确写法if err != nil &#123; // error handling return // or continue, etc.&#125;// normal code 6、测试单元测试文件名命名规范为 example_test.go测试用例的函数名称必须以 Test 开头，例如：TestExample每个重要的函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试 四、常用工具上面提到了很过规范， go 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范， gofmt大部分的格式问题可以通过gofmt解决， gofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。 goimport我们强烈建议使用 goimport ，该工具在 gofmt 的基础上增加了自动删除和引入包. 1go get golang.org/x/tools/cmd/goimports go vetvet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。 12go get golang.org/x/tools/cmd/vet 使用如下： 12go vet . 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://shadowbynl.github.io/tags/Go/"}]},{"title":"java-spider-1","slug":"java-spider-1","date":"2020-06-16T12:52:02.000Z","updated":"2020-06-16T14:58:20.571Z","comments":true,"path":"2020/06/16/java-spider-1/","link":"","permalink":"https://shadowbynl.github.io/2020/06/16/java-spider-1/","excerpt":"本文总结刚学习的两种java实现爬虫的方式：HttpClient获取网页内容 + Jsoup/Xpath/正则解析和使用WebMagic框架实现解析。需要注意的是，无论哪种实现方式，除了单独写爬虫外，都可以直接嵌入web框架中，嵌入SpringBoot框架可以直接启动运行，也可以嵌入ssm写的web项目中。","text":"本文总结刚学习的两种java实现爬虫的方式：HttpClient获取网页内容 + Jsoup/Xpath/正则解析和使用WebMagic框架实现解析。需要注意的是，无论哪种实现方式，除了单独写爬虫外，都可以直接嵌入web框架中，嵌入SpringBoot框架可以直接启动运行，也可以嵌入ssm写的web项目中。 （一）不使用框架的以HttpClient为基础的实现方式相关依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!-- HttpClient --&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;!-- jsoup解析 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.10.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 文件处理相关 --&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 字符串处理相关 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.dom4j/dom4j --&gt; &lt;!-- xpath解析 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; 一、HttpClientHttpClient是Java爬虫实现的底层基础，拥有按照需要设置请求方式、参数、信息、配置的功能，获取响应内容，供其他类进行解析。 get请求1234567891011121314151617181920212223242526272829303132333435public class HttpGetTest &#123; public static void main(String[] args) &#123; //创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); //创建HttpGet对象，设置url访问地址 HttpGet httpGet = new HttpGet(&quot;http://www.itcast.cn&quot;); //设置User-Agent httpGet.setHeader(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36&quot;); CloseableHttpResponse response = null; try &#123; //使用HttpClient发起请求，获取response response = httpClient.execute(httpGet); //解析响应 if (response.getStatusLine().getStatusCode() == 200) &#123; String content = EntityUtils.toString(response.getEntity(), &quot;utf8&quot;); System.out.println(content.length()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //关闭response try &#123; response.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 带参数的get请求12345678//设置请求地址是：http://yun.itheima.com/search?keys=Java//创建URIBuilderURIBuilder uriBuilder = new URIBuilder(&quot;http://yun.itheima.com/search&quot;);//设置参数uriBuilder.setParameter(&quot;keys&quot;,&quot;Java&quot;);//创建HttpGet对象，设置url访问地址HttpGet httpGet = new HttpGet(uriBuilder.build());System.out.println(&quot;发起请求的信息：&quot;+httpGet); post请求12//创建HttpPost对象，设置url访问地址HttpPost httpPost = new HttpPost(&quot;http://www.itcast.cn&quot;); 带参数的post请求12345678910//创建HttpPost对象，设置url访问地址HttpPost httpPost = new HttpPost(&quot;http://yun.itheima.com/search&quot;);//声明List集合，封装表单中的参数List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();//设置请求地址是：http://yun.itheima.com/search?keys=Javaparams.add(new BasicNameValuePair(&quot;keys&quot;,&quot;Java&quot;));//创建表单的Entity对象,第一个参数就是封装好的表单数据，第二个参数就是编码UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(params,&quot;utf8&quot;);//设置表单的Entity对象到Post请求中httpPost.setEntity(formEntity); 请求配置12345678//创建HttpGet对象，设置url访问地址HttpGet httpGet = new HttpGet(&quot;http://www.itcast.cn&quot;);//配置请求信息RequestConfig config = RequestConfig.custom().setConnectTimeout(1000) //创建连接的最长时间，单位是毫秒 .setConnectionRequestTimeout(500) //设置获取连接的最长时间，单位是毫秒 .setSocketTimeout(10*1000) //设置数据传输的最长时间，单位是毫秒 .build();//给请求设置请求信息 连接池将HttpClient交给连接池管理，注意和多线程区分。1234567891011121314151617181920212223242526272829303132333435363738394041public class HttpClientPoolTest &#123; public static void main(String[] args) &#123; //创建连接池管理器 PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager(); //设置最大连接数 cm.setMaxTotal(100); //设置每个主机的最大连接数 cm.setDefaultMaxPerRoute(10); //使用连接池管理器发起请求 doGet(cm); doGet(cm); &#125; private static void doGet(PoolingHttpClientConnectionManager cm) &#123; //不是每次创建新的HttpClient，而是从连接池中获取HttpClient对象 CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build(); HttpGet httpGet = new HttpGet(&quot;http://www.itcast.cn&quot;); CloseableHttpResponse response = null; try &#123; response = httpClient.execute(httpGet); if (response.getStatusLine().getStatusCode() == 200) &#123; String content = EntityUtils.toString(response.getEntity(), &quot;utf8&quot;); System.out.println(content.length()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //不能关闭HttpClient，由连接池管理HttpClient //httpClient.close(); &#125; &#125; &#125;&#125; 二、Jsoup参考： https://www.jianshu.com/p/24b2cfc415adjsoup首先是可以由url、字符串或文件解析获取dom对象，然后使用两类方法获取元素，其一是类似于js的document对象的一些方法，其二是类似于jquery的select相关的方法。1.介绍 123456jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。jsoup的主要功能如下：从一个URL，文件或字符串中解析HTML；使用DOM或CSS选择器来查找、取出数据；可操作HTML元素、属性、文本； 2.api（1）解析url、字符串、文件 123456789101112131415161718192021222324252627282930313233343536373839404142解析urlJsoup可以直接输入url，它会发起请求并获取数据，封装为Document对象@Testpublic void testJsoupUrl() throws Exception &#123; // 解析url地址 Document document = Jsoup.parse(new URL(&quot;http://www.itcast.cn/&quot;), 1000); //获取title的内容 Element title = document.getElementsByTag(&quot;title&quot;).first(); System.out.println(title.text());&#125;PS：虽然使用Jsoup可以替代HttpClient直接发起请求解析数据，但是往往不会这样用，因为实际的开发过程中，需要使用到多线程，连接池，代理等等方式，而jsoup对这些的支持并不是很好，所以我们一般把jsoup仅仅作为Html解析工具使用解析字符串Jsoup可以直接输入字符串，并封装为Document对象@Testpublic void testJsoupString() throws Exception &#123; //读取文件获取 String html = FileUtils.readFileToString(new File(&quot;D:\\\\jsoup.html&quot;), &quot;UTF-8&quot;); // 解析字符串 Document document = Jsoup.parse(html); //获取title的内容 Element title = document.getElementsByTag(&quot;title&quot;).first(); System.out.println(title.text());&#125;解析文件Jsoup可以直接解析文件，并封装为Document对象@Testpublic void testJsoupHtml() throws Exception &#123; // 解析文件 Document document = Jsoup.parse(new File(&quot;D:\\\\jsoup.html&quot;),&quot;UTF-8&quot;); //获取title的内容 Element title = document.getElementsByTag(&quot;title&quot;).first(); System.out.println(title.text());&#125; （2）dom 123456789101112131415161718192021222324252627282930313233343536373839404142434445元素获取1. 根据id查询元素getElementById2. 根据标签获取元素getElementsByTag3. 根据class获取元素getElementsByClass4. 根据属性获取元素getElementsByAttribute//1. 根据id查询元素getElementByIdElement element = document.getElementById(&quot;city_bj&quot;);//2. 根据标签获取元素getElementsByTagelement = document.getElementsByTag(&quot;title&quot;).first();//3. 根据class获取元素getElementsByClasselement = document.getElementsByClass(&quot;s_name&quot;).last();//4. 根据属性获取元素getElementsByAttributeelement = document.getElementsByAttribute(&quot;abc&quot;).first();element = document.getElementsByAttributeValue(&quot;class&quot;, &quot;city_con&quot;).first(); 元素中获取数据1. 从元素中获取id2. 从元素中获取className3. 从元素中获取属性的值attr4. 从元素中获取所有属性attributes5. 从元素中获取文本内容text//获取元素Element element = document.getElementById(&quot;test&quot;);//1. 从元素中获取idString str = element.id();//2. 从元素中获取classNamestr = element.className();//3. 从元素中获取属性的值attrstr = element.attr(&quot;id&quot;);//4. 从元素中获取所有属性attributesstr = element.attributes().toString();//5. 从元素中获取文本内容textstr = element.text(); （3）使用选择器语法查找元素jsoup elements对象支持类似于CSS (或jquery)的选择器语法，来实现非常强大和灵活的查找功能。这个select 方法在Document, Element,或Elements对象中都可以使用。且是上下文相关的，因此可实现指定元素的过滤，或者链式选择访问。Select方法将返回一个Elements集合，并提供一组方法来抽取和处理结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Selector选择器概述tagname: 通过标签查找元素，比如：span#id: 通过ID查找元素，比如：# city_bj.class: 通过class名称查找元素，比如：.class_a[attribute]: 利用属性查找元素，比如：[abc][attr=value]: 利用属性值来查找元素，比如：[class=s_name]//tagname: 通过标签查找元素，比如：spanElements span = document.select(&quot;span&quot;);for (Element element : span) &#123; System.out.println(element.text());&#125;//#id: 通过ID查找元素，比如：#city_bjjString str = document.select(&quot;#city_bj&quot;).text();//.class: 通过class名称查找元素，比如：.class_astr = document.select(&quot;.class_a&quot;).text();//[attribute]: 利用属性查找元素，比如：[abc]str = document.select(&quot;[abc]&quot;).text();//[attr=value]: 利用属性值来查找元素，比如：[class=s_name]str = document.select(&quot;[class=s_name]&quot;).text();Selector选择器组合使用el#id: 元素+ID，比如： h3#city_bjel.class: 元素+class，比如： li.class_ael[attr]: 元素+属性名，比如： span[abc]任意组合: 比如：span[abc].s_nameancestor child: 查找某个元素下子元素，比如：.city_con li 查找&quot;city_con&quot;下的所有liparent &gt; child: 查找某个父元素下的直接子元素，比如：.city_con &gt; ul &gt; li 查找city_con第一级（直接子元素）的ul，再找所有ul下的第一级liparent &gt; *: 查找某个父元素下所有直接子元素//el#id: 元素+ID，比如： h3#city_bjString str = document.select(&quot;h3#city_bj&quot;).text();//el.class: 元素+class，比如： li.class_astr = document.select(&quot;li.class_a&quot;).text();//el[attr]: 元素+属性名，比如： span[abc]str = document.select(&quot;span[abc]&quot;).text();//任意组合，比如：span[abc].s_namestr = document.select(&quot;span[abc].s_name&quot;).text();//ancestor child: 查找某个元素下子元素，比如：.city_con li 查找&quot;city_con&quot;下的所有listr = document.select(&quot;.city_con li&quot;).text();//parent &gt; child: 查找某个父元素下的直接子元素，//比如：.city_con &gt; ul &gt; li 查找city_con第一级（直接子元素）的ul，再找所有ul下的第一级listr = document.select(&quot;.city_con &gt; ul &gt; li&quot;).text();//parent &gt; * 查找某个父元素下所有直接子元素.city_con &gt; *str = document.select(&quot;.city_con &gt; *&quot;).text(); 3.注意 jsoup还可与htmlcleaner使用xpath解析参考：https://blog.csdn.net/baidu_36336788/article/details/89875926 jsoup解析推荐的做法是，jsoup parse获得dom对象后，使用select，具体内容通过在网页选择元素–检查–右键–copy selector获取 三、HttpClient + Jsoup 案例案例由SpringBoot + SpringData JPA + HttpClient + Jsoup写成，将爬虫嵌入了应用中，实现了爬取结果保存在数据库中。1.核心代码HttpClient封装类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package cn.itcast.jd.util;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.util.EntityUtils;import org.springframework.stereotype.Component;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.UUID;@Componentpublic class HttpUtils &#123; private PoolingHttpClientConnectionManager cm; public HttpUtils() &#123; this.cm = new PoolingHttpClientConnectionManager(); //设置最大连接数 this.cm.setMaxTotal(100); //设置每个主机的最大连接数 this.cm.setDefaultMaxPerRoute(10); &#125; /** * 根据请求地址下载页面数据 * * @param url * @return 页面数据 */ public String doGetHtml(String url) &#123; //获取HttpClient对象 CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(this.cm).build(); //创建httpGet请求对象，设置url地址 HttpGet httpGet = new HttpGet(url); //设置请求信息 httpGet.setConfig(this.getConfig()); httpGet.setHeader(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36&quot;); CloseableHttpResponse response = null; try &#123; //使用HttpClient发起请求，获取响应 response = httpClient.execute(httpGet); //解析响应，返回结果 if (response.getStatusLine().getStatusCode() == 200) &#123; //判断响应体Entity是否不为空，如果不为空就可以使用EntityUtils if (response.getEntity() != null) &#123; String content = EntityUtils.toString(response.getEntity(), &quot;utf8&quot;); return content; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭response if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //返回空串 return &quot;&quot;; &#125; /** * 下载图片 * * @param url * @return 图片名称 */ public String doGetImage(String url) &#123; //获取HttpClient对象 CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(this.cm).build(); //创建httpGet请求对象，设置url地址 HttpGet httpGet = new HttpGet(url); //设置请求信息 httpGet.setConfig(this.getConfig()); //设置User-Agent httpGet.setHeader(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36&quot;); CloseableHttpResponse response = null; try &#123; //使用HttpClient发起请求，获取响应 response = httpClient.execute(httpGet); //解析响应，返回结果 if (response.getStatusLine().getStatusCode() == 200) &#123; //判断响应体Entity是否不为空 if (response.getEntity() != null) &#123; //下载图片 //获取图片的后缀 String extName = url.substring(url.lastIndexOf(&quot;.&quot;)); //创建图片名，重命名图片 String picName = UUID.randomUUID().toString() + extName; //下载图片 //声明OutPutStream OutputStream outputStream = new FileOutputStream(new File(&quot;C:\\\\images\\\\&quot; + picName)); response.getEntity().writeTo(outputStream); //返回图片名称 return picName; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭response if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //如果下载失败，返回空串 return &quot;&quot;; &#125; //设置请求信息 private RequestConfig getConfig() &#123; RequestConfig config = RequestConfig.custom() .setConnectTimeout(1000) //创建连接的最长时间 .setConnectionRequestTimeout(500) // 获取连接的最长时间 .setSocketTimeout(10000) //数据传输的最长时间 .build(); return config; &#125;&#125; 解析代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package cn.itcast.jd.task;import cn.itcast.jd.pojo.Item;import cn.itcast.jd.service.ItemService;import cn.itcast.jd.util.HttpUtils;import com.fasterxml.jackson.databind.ObjectMapper;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;@Componentpublic class ItemTask &#123; @Autowired private HttpUtils httpUtils; @Autowired private ItemService itemService; private static final ObjectMapper MAPPER = new ObjectMapper(); //当下载任务完成后，间隔多长时间进行下一次的任务。 @Scheduled(fixedDelay = 100 * 1000) public void itemTask() throws Exception &#123; //声明需要解析的初始地址 String url = &quot;https://search.jd.com/Search?keyword=手机&amp;wq=手机&amp;page=&quot;; //按照页面对手机的搜索结果进行遍历解析 for (int i = 1; i &lt; 10; i = i + 2) &#123; String html = httpUtils.doGetHtml(url + i); System.out.println(html); //解析页面，获取商品数据并存储 this.parse(html); &#125; System.out.println(&quot;手机数据抓取完成！&quot;); &#125; //解析页面，获取商品数据并存储 private void parse(String html) throws Exception &#123; //解析html获取Document Document doc = Jsoup.parse(html); //获取spu信息 Elements spuEles = doc.select(&quot;div#J_goodsList &gt; ul &gt; li&quot;); for (Element spuEle : spuEles) &#123; if (spuEle.attr(&quot;data-spu&quot;) == null || spuEle.attr(&quot;data-spu&quot;).length() == 0) &#123; continue; &#125; //获取spu long spu = Long.parseLong(spuEle.attr(&quot;data-spu&quot;)); //获取sku信息 Elements skuEles = spuEle.select(&quot;li.ps-item&quot;); for (Element skuEle : skuEles) &#123; //获取sku long sku = Long.parseLong(skuEle.select(&quot;[data-sku]&quot;).attr(&quot;data-sku&quot;)); //根据sku查询商品数据 Item item = new Item(); item.setSku(sku); List&lt;Item&gt; list = this.itemService.findAll(item); if(list.size()&gt;0) &#123; //如果商品存在，就进行下一个循环，该商品不保存，因为已存在 continue; &#125; //设置商品的spu item.setSpu(spu); //获取商品的详情的url String itemUrl = &quot;https://item.jd.com/&quot; + sku + &quot;.html&quot;; item.setUrl(itemUrl); //获取商品的图片 String picUrl =&quot;https:&quot;+ skuEle.select(&quot;img[data-sku]&quot;).first().attr(&quot;data-lazy-img&quot;); picUrl = picUrl.replace(&quot;/n9/&quot;,&quot;/n1/&quot;); String picName = this.httpUtils.doGetImage(picUrl); item.setPic(picName); //获取商品的价格 String priceJson = this.httpUtils.doGetHtml(&quot;https://p.3.cn/prices/mgets?skuIds=J_&quot; + sku); double price = MAPPER.readTree(priceJson).get(0).get(&quot;p&quot;).asDouble(); item.setPrice(price); //获取商品的标题 String itemInfo = this.httpUtils.doGetHtml(item.getUrl()); String title = Jsoup.parse(itemInfo).select(&quot;div.sku-name&quot;).text(); item.setTitle(title); item.setCreated(new Date()); item.setUpdated(item.getCreated()); //保存商品数据到数据库中 this.itemService.save(item); &#125; &#125; &#125;&#125; 2.细节 springboot中定时任务的设置 使用了json相关的解析方法 四、其他解析方法针对不同页面数据，可以考虑其他的解析方式。1.xpath 使用dom4j参考 https://www.jianshu.com/p/806bb1bdc06f https://blog.csdn.net/xf_zhen/article/details/90440330https://www.cnblogs.com/ifme/p/12402570.htmlhttps://blog.csdn.net/zz13995900221/article/details/79826173https://blog.csdn.net/qq_40374604/article/details/84327419https://blog.csdn.net/qq_33371372/article/details/82318540?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-10.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-10.nonecase 2.正则参考 https://www.cnblogs.com/jingmoxukong/p/6026474.htmlhttps://www.cnblogs.com/jingmoxukong/p/6030197.htmlhttps://www.cnblogs.com/jingmoxukong/p/6040572.html （二）WebMagic相关依赖 123456789101112131415161718&lt;!-- https://mvnrepository.com/artifact/us.codecraft/webmagic-core --&gt; &lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-core&lt;/artifactId&gt; &lt;version&gt;0.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/us.codecraft/webmagic-extension --&gt; &lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt; &lt;version&gt;0.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--WebMagic对布隆过滤器的支持--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;16.0&lt;/version&gt; &lt;/dependency&gt; 一、介绍1.概述WebMagic项目代码分为核心和扩展两部分。核心部分(webmagic-core)是一个精简的、模块化的爬虫实现，而扩展部分则包括一些便利的、实用性的功能。WebMagic的设计目标是尽量的模块化，并体现爬虫的功能特点。这部分提供非常简单、灵活的API，在基本不改变开发模式的情况下，编写一个爬虫。扩展部分(webmagic-extension)提供一些便捷的功能，例如注解模式编写爬虫等。同时内置了一些常用的组件，便于爬虫开发。2.架构 WebMagic的结构分为Downloader、PageProcessor、Scheduler、Pipeline四大组件，并由Spider将它们彼此组织起来。这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。WebMagic的设计参考了Scapy，但是实现方式更Java化一些。而Spider则将这几个组件组织起来，让它们可以互相交互，流程化的执行，可以认为Spider是一个大的容器，它也是WebMagic逻辑的核心。3.四大组件 123456789101112131415161.DownloaderDownloader负责从互联网上下载页面，以便后续处理。WebMagic默认使用了Apache HttpClient作为下载工具。2.PageProcessorPageProcessor负责解析页面，抽取有用信息，以及发现新的链接。WebMagic使用Jsoup作为HTML解析工具，并基于其开发了解析XPath的工具Xsoup。在这四个组件中，PageProcessor对于每个站点每个页面都不一样，是需要使用者定制的部分。3.SchedulerScheduler负责管理待抓取的URL，以及一些去重的工作。WebMagic默认提供了JDK的内存队列来管理URL，并用集合来进行去重。也支持使用Redis进行分布式管理。4.PipelinePipeline负责抽取结果的处理，包括计算、持久化到文件、数据库等。WebMagic默认提供了“输出到控制台”和“保存到文件”两种结果处理方案。Pipeline定义了结果保存的方式，如果你要保存到指定数据库，则需要编写对应的Pipeline。对于一类需求一般只需编写一个Pipeline。 4.三个数据流转对象 12345678910111213141. RequestRequest是对URL地址的一层封装，一个Request对应一个URL地址。它是PageProcessor与Downloader交互的载体，也是PageProcessor控制Downloader唯一方式。除了URL本身外，它还包含一个Key-Value结构的字段extra。你可以在extra中保存一些特殊的属性，然后在其他地方读取，以完成不同的功能。例如附加上一个页面的一些信息等。2. PagePage代表了从Downloader下载到的一个页面——可能是HTML，也可能是JSON或者其他文本格式的内容。Page是WebMagic抽取过程的核心对象，它提供一些方法可供抽取、结果保存等。3. ResultItemsResultItems相当于一个Map，它保存PageProcessor处理的结果，供Pipeline使用。它的API与Map很类似，值得注意的是它有一个字段skip，若设置为true，则不应被Pipeline处理。 二、功能1.实现PageProcessor抽取元素Selectable 123456789101112131415161718WebMagic里主要使用了三种抽取技术：XPath、正则表达式和CSS选择器。另外，对于JSON格式的内容，可使用JsonPath进行解析。1. XPath以上是获取属性class=mt的div标签，里面的h1标签的内容page.getHtml().xpath(&quot;//div[@class=mt]/h1/text()&quot;)也可以参考课堂资料的W3School离线手册(2017.03.11版).chm2. CSS选择器CSS选择器是与XPath类似的语言。它比XPath写起来要简单一些，但是如果写复杂一点的抽取规则，就相对要麻烦一点。div.mt&gt;h1表示class为mt的div标签下的直接子元素h1标签page.getHtml().css(&quot;div.mt&gt;h1&quot;).toString()可使用:nth-child(n)选择第几个元素，如下选择第一个元素page.getHtml().css(&quot;div#news_div &gt; ul &gt; li:nth-child(1) a&quot;).toString()注意：需要使用&gt;，就是直接子元素才可以选择第几个元素3. 正则表达式正则表达式则是一种通用的文本抽取语言。在这里一般用于获取url地址。 抽取元素APISelectable相关的抽取元素链式API是WebMagic的一个核心功能。使用Selectable接口，可以直接完成页面元素的链式抽取，也无需去关心抽取的细节。page.getHtml()返回的是一个Html对象，它实现了Selectable接口。这个接口包含的方法分为两类：抽取部分和获取结果部分。获取结果API当链式调用结束时，我们一般都想要拿到一个字符串类型的结果。这时候就需要用到获取结果的API了。我们知道，一条抽取规则，无论是XPath、CSS选择器或者正则表达式，总有可能抽取到多条元素。WebMagic对这些进行了统一，可以通过不同的API获取到一个或者多个元素。)这里selectable.toString()采用了toString()这个接口，是为了在输出以及和一些框架结合的时候，更加方便。因为一般情况下，我们都只需要选择一个元素！selectable.all()则会获取到所有元素。获取链接 12345678910111213141516有了处理页面的逻辑，我们的爬虫就接近完工了，但是现在还有一个问题：一个站点的页面是很多的，一开始我们不可能全部列举出来，于是如何发现后续的链接，是一个爬虫不可缺少的一部分。下面的例子就是获取https://www.jd.com/moreSubject.aspx这个页面中所有符合https://www.jd.com/news.\\\\w+?.*正则表达式的url地址并将这些链接加入到待抓取的队列中去。public void process(Page page) &#123; page.addTargetRequests(page.getHtml().links() .regex(&quot;(https://www.jd.com/news.\\\\w+?.*)&quot;).all()); System.out.println(page.getHtml().css(&quot;div.mt&gt;h1&quot;).all());&#125;public static void main(String[] args) &#123; Spider.create(new JobProcessor()) .addUrl(&quot;https://www.jd.com/moreSubject.aspx&quot;) .run();&#125; 2.使用Pipeline保存结果 123456789101112WebMagic用于保存结果的组件叫做Pipeline。我们现在通过“控制台输出结果”这件事也是通过一个内置的Pipeline完成的，它叫做ConsolePipeline。那么，我现在想要把结果用保存到文件中，怎么做呢？只将Pipeline的实现换成&quot;FilePipeline&quot;就可以了。public static void main(String[] args) &#123; Spider.create(new JobProcessor()) //初始访问url地址 .addUrl(&quot;https://www.jd.com/moreSubject.aspx&quot;) .addPipeline(new FilePipeline(&quot;D:/webmagic/&quot;)) .thread(5)//设置线程数 .run();&#125; 3.爬虫的启动、配置、终止入口SpiderSpider是爬虫启动的入口。在启动爬虫之前，我们需要使用一个PageProcessor创建一个Spider对象，然后使用run()进行启动。同时Spider的其他组件（Downloader、Scheduler、Pipeline）都可以通过set方法来进行设置。爬虫配置Site 12345678Site.me()可以对爬虫进行一些配置配置，包括编码、抓取间隔、超时时间、重试次数等。在这里我们先简单设置一下：重试次数为3次，抓取间隔为一秒。private Site site = Site.me() .setCharset(&quot;UTF-8&quot;)//编码 .setSleepTime(1)//抓取间隔时间 .setTimeOut(1000*10)//超时时间 .setRetrySleepTime(3000)//重试时间 .setRetryTimes(3);//重试次数站点本身的一些配置信息，例如编码、HTTP头、超时时间、重试策略等、代理等，都可以通过设置Site对象来进行配置。 4.Scheduler组件在解析页面的时候，很可能会解析出相同的url地址(例如商品标题和商品图片超链接，而且url一样)，如果不进行处理，同样的url会解析处理多次，浪费资源。所以我们需要有一个url去重的功能。WebMagic提供了Scheduler可以帮助我们解决以上问题。Scheduler是WebMagic中进行URL管理的组件。一般来说，Scheduler包括两个作用：对待抓取的URL队列进行管理；对已抓取的URL进行去重。WebMagic内置了几个常用的Scheduler。如果你只是在本地执行规模比较小的爬虫，那么基本无需定制Scheduler，但是了解一下已经提供的几个Scheduler还是有意义的。去重部分被单独抽象成了一个接口：DuplicateRemover，从而可以为同一个Scheduler选择不同的去重方式，以适应不同的需要，目前提供了两种去重方式。 123456789101112131415161718192021RedisScheduler是使用Redis的set进行去重，其他的Scheduler默认都使用HashSetDuplicateRemover来进行去重。如果要使用BloomFilter，必须要加入以下依赖：&lt;!--WebMagic对布隆过滤器的支持--&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;16.0&lt;/version&gt;&lt;/dependency&gt;修改代码，添加布隆过滤器public static void main(String[] args) &#123; Spider.create(new JobProcessor()) //初始访问url地址 .addUrl(&quot;https://www.jd.com/moreSubject.aspx&quot;) .addPipeline(new FilePipeline(&quot;D:/webmagic/&quot;)) .setScheduler(new QueueScheduler() .setDuplicateRemover(new BloomFilterDuplicateRemover(10000000))) //参数设置需要对多少条数据去重 .thread(1)//设置线程数 .run();&#125; 三种去重方式 1234567891011HashSet使用java中的HashSet不能重复的特点去重。优点是容易理解。使用方便。缺点：占用内存大，性能较低。Redis去重使用Redis的set进行去重。优点是速度快（Redis本身速度就很快），而且去重不会占用爬虫服务器的资源，可以处理更大数据量的数据爬取。缺点：需要准备Redis服务器，增加开发和使用成本。布隆过滤器（BloomFilter）使用布隆过滤器也可以实现去重。优点是占用的内存要比使用HashSet要小的多，也适合大量数据的去重操作。缺点：有误判的可能。没有重复可能会判定重复，但是重复数据一定会判定重复。 4.使用和定制Pipeline在WebMagic中，Pileline是抽取结束后，进行处理的部分，它主要用于抽取结果的保存，也可以定制Pileline可以实现一些通用的功能。在这里我们会定制Pipeline实现数据导入到数据库中。Pipeline输出 123456789101112131415161718192021Pipeline的接口定义如下：public interface Pipeline &#123; // ResultItems保存了抽取结果，它是一个Map结构， // 在page.putField(key,value)中保存的数据， //可以通过ResultItems.get(key)获取 public void process(ResultItems resultItems, Task task);&#125;可以看到，Pipeline其实就是将PageProcessor抽取的结果，继续进行了处理的，其实在Pipeline中完成的功能，你基本上也可以直接在PageProcessor实现，那么为什么会有Pipeline？有几个原因：* 为了模块分离“页面抽取”和“后处理、持久化”是爬虫的两个阶段，将其分离开来，一个是代码结构比较清晰，另一个是以后也可能将其处理过程分开，分开在独立的线程以至于不同的机器执行。* Pipeline的功能比较固定，更容易做成通用组件每个页面的抽取方式千变万化，但是后续处理方式则比较固定，例如保存到文件、保存到数据库这种操作，这些对所有页面都是通用的。在WebMagic里，一个Spider可以有多个Pipeline，使用Spider.addPipeline()即可增加一个Pipeline。这些Pipeline都会得到处理，例如可以使用spider.addPipeline(new ConsolePipeline()).addPipeline(new FilePipeline())实现输出结果到控制台，并且保存到文件的目标。 已有的PipelineWebMagic中就已经提供了控制台输出、保存到文件、保存为JSON格式的文件几种通用的Pipeline。 三、爬虫分类 123456789101112131415161718192021网络爬虫按照系统结构和实现技术，大致可以分为以下几种类型：通用网络爬虫、聚焦网络爬虫、增量式网络爬虫、深层网络爬虫。 实际的网络爬虫系统通常是几种爬虫技术相结合实现的3.1. 通用网络爬虫通用网络爬虫又称全网爬虫（Scalable Web Crawler），爬行对象从一些种子 URL 扩充到整个 Web，主要为门户站点搜索引擎和大型 Web 服务提供商采集数据。 这类网络爬虫的爬行范围和数量巨大，对于爬行速度和存储空间要求较高，对于爬行页面的顺序要求相对较低，同时由于待刷新的页面太多，通常采用并行工作方式，但需要较长时间才能刷新一次页面。 简单的说就是互联网上抓取所有数据。3.2. 聚焦网络爬虫聚焦网络爬虫（Focused Crawler），又称主题网络爬虫（Topical Crawler），是指选择性地爬行那些与预先定义好的主题相关页面的网络爬虫。和通用网络爬虫相比，聚焦爬虫只需要爬行与主题相关的页面，极大地节省了硬件和网络资源，保存的页面也由于数量少而更新快，还可以很好地满足一些特定人群对特定领域信息的需求 。简单的说就是互联网上只抓取某一种数据。3.3. 增量式网络爬虫增量式网络爬虫（Incremental Web Crawler）是 指 对 已 下 载 网 页 采 取 增量式更新和只爬行新产生的或者已经发生变化网页的爬虫，它能够在一定程度上保证所爬行的页面是尽可能新的页面。和周期性爬行和刷新页面的网络爬虫相比，增量式爬虫只会在需要的时候爬行新产生或发生更新的页面 ，并不重新下载没有发生变化的页面，可有效减少数据下载量，及时更新已爬行的网页，减小时间和空间上的耗费，但是增加了爬行算法的复杂度和实现难度。简单的说就是互联网上只抓取刚刚更新的数据。3.4. Deep Web 爬虫Web 页面按存在方式可以分为表层网页（Surface Web）和深层网页（Deep Web，也称 Invisible Web Pages 或 Hidden Web）。 表层网页是指传统搜索引擎可以索引的页面，以超链接可以到达的静态网页为主构成的 Web 页面。Deep Web 是那些大部分内容不能通过静态链接获取的、隐藏在搜索表单后的，只有用户提交一些关键词才能获得的 Web 页面。 四、案例1. url解析功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Componentpublic class JobProcessor implements PageProcessor &#123; @Autowired private SpringDataPipeline springDataPipeline; @Scheduled(initialDelay = 1000, fixedDelay = 1000 * 100) public void process() &#123; //访问入口url地址 String url = &quot;https://search.51job.com/list/000000,000000,0000,01%252C32,9,99,java,2,1.html?lang=c&amp;stype=&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;providesalary=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=&quot;; Spider.create(new JobProcessor()) .addUrl(url) .setScheduler(new QueueScheduler() .setDuplicateRemover(new BloomFilterDuplicateRemover(10000000))) .thread(5) .run(); &#125; @Override public void process(Page page) &#123; //获取页面数据 List&lt;Selectable&gt; nodes = page.getHtml().$(&quot;div#resultList div.el&quot;).nodes(); //判断nodes是否为空 if (nodes.isEmpty()) &#123; try &#123; //如果为空，表示这是招聘信息详情页保存信息详情 this.saveJobInfo(page); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else &#123; //如果有值，表示这是招聘信息列表页 for (Selectable node : nodes) &#123; //获取招聘信息详情页url String jobUrl = node.links().toString(); //添加到url任务列表中，等待下载 page.addTargetRequest(jobUrl); //获取翻页按钮的超链接 List&lt;String&gt; listUrl = page.getHtml().$(&quot;div.p_in li.bk&quot;).links().all(); //添加到任务列表中 page.addTargetRequests(listUrl); &#125; &#125; &#125; 2.页面解析功能 123456789101112131415161718192021222324252627282930313233343536/** * 解析页面，获取招聘详情 * * @param */private void saveJobInfo(Page page) &#123; //创建招聘信息对象 JobInfo jobInfo = new JobInfo(); Html html = page.getHtml(); //公司名称 jobInfo.setCompanyName(html.$(&quot;div.tHeader p.cname a&quot;, &quot;text&quot;).toString()); //公司地址 jobInfo.setCompanyAddr(html.$(&quot;div.tBorderTop_box:nth-child(3) p.fp&quot;, &quot;text&quot;).toString()); //公司信息 jobInfo.setCompanyInfo(html.$(&quot;div.tmsg&quot;, &quot;text&quot;).toString()); //职位名称 jobInfo.setJobName(html.$(&quot;div.tHeader &gt; div.in &gt; div.cn &gt; h1&quot;, &quot;text&quot;).toString()); //工作地点 jobInfo.setJobAddr(html.$(&quot;div.tHeader &gt; div.in &gt; div.cn &gt; span.lname&quot;, &quot;text&quot;).toString()); //职位信息 jobInfo.setJobInfo(Jsoup.parse(html.$(&quot;div.tBorderTop_box:nth-child(2)&quot;).toString()).text()); //工资范围 String salaryStr = html.$(&quot;div.tHeader &gt; div.in &gt; div.cn &gt; strong&quot;, &quot;text&quot;).toString(); jobInfo.setSalaryMin(MathSalary.getSalary(salaryStr)[0]); jobInfo.setSalaryMax(MathSalary.getSalary(salaryStr)[1]); //职位详情url jobInfo.setUrl(page.getUrl().toString()); //职位发布时间 String time = html.$(&quot;div.jtag &gt; div.t1 &gt; span.sp4&quot;, &quot;text&quot;).regex(&quot;.*发布&quot;).toString(); jobInfo.setTime(time.substring(0, time.length() - 2));//保存数据page.putField(&quot;jobInfo&quot;, jobInfo);&#125; 3.案例自定义Pipeline导入数据 12345678910111213141516171819202122232425262728293031323334//自定义SpringDataPipeline@Componentpublic class SpringDataPipeline implements Pipeline &#123; @Autowired private JobInfoService jobInfoService; @Override public void process(ResultItems resultItems, Task task) &#123; //获取需要保存到MySQL的数据 JobInfo jobInfo = resultItems.get(&quot;jobInfo&quot;); //判断获取到的数据不为空 if(jobInfo!=null) &#123; //如果有值则进行保存 this.jobInfoService.save(jobInfo); &#125; &#125;&#125;在JobProcessor中修改process()启动的逻辑，添加代码@Autowiredprivate SpringDataPipeline springDataPipeline;public void process() &#123; Spider.create(new JobProcessor()) .addUrl(url) .addPipeline(this.springDataPipeline) .setScheduler(new QueueScheduler() .setDuplicateRemover(new BloomFilterDuplicateRemover(10000000))) .thread(5) .run();&#125;","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://shadowbynl.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"}]},{"title":"flask-study-4","slug":"flask-study-4","date":"2020-06-14T14:44:42.000Z","updated":"2020-06-14T15:42:28.497Z","comments":true,"path":"2020/06/14/flask-study-4/","link":"","permalink":"https://shadowbynl.github.io/2020/06/14/flask-study-4/","excerpt":"黑马ihome项目 其三","text":"黑马ihome项目 其三 总结一下项目中实现的功能和技术点，按视图函数模块进行划分。 （一） api一、注册登录之一： verify_code模块 获取图片验证码 get_image_code 获取短信验证码 get_sms_code 二、注册登录之二： passport模块 注册 register 登录 login 检查登录状态 check_login 退出登录 logout 三、用户信息： profile模块 设置用户头像 set_user_avatar 修改用户名 change_user_name 获取用户信息 get_user_profile 设置实名认证信息 set_user_auth 获取实名认证信息 get_user_auth 四、房屋信息： houses模块 获取地区信息 get_area_info 保存发布房源的信息 save_house_info 保存发布房源的图片 save_house_image 获取用户拥有的房源的信息 get_user_houses 获取首页的房屋信息 get_house_index 获取房源详情 get_house_detail 获取经筛选后的房屋列表 get_house_list 五、订单支付之一： orders模块 保存订单 save_order 查询用户的订单信息 get_user_orders 接单拒单 accept_reject_order 保存订单评论信息 save_order_comment 六、订单支付之二： pay模块 发起支付宝支付 order_pay 保存订单支付结果 save_order_payment_result （二）前端请求一、注册登录 register.js 获取图片验证码 短信验证码 发送注册请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// js读取cookie的方法function getCookie(name) &#123; var r = document.cookie.match(&quot;\\\\b&quot; + name + &quot;=([^;]*)\\\\b&quot;); return r ? r[1] : undefined;&#125;// 保存图片验证码编号var imageCodeId = &quot;&quot;;function generateUUID() &#123; var d = new Date().getTime(); if(window.performance &amp;&amp; typeof window.performance.now === &quot;function&quot;)&#123; d += performance.now(); //use high-precision timer if available &#125; var uuid = &#x27;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#x27;.replace(/[xy]/g, function(c) &#123; var r = (d + Math.random()*16)%16 | 0; d = Math.floor(d/16); return (c==&#x27;x&#x27; ? r : (r&amp;0x3|0x8)).toString(16); &#125;); return uuid;&#125;function generateImageCode() &#123; // 形成图片验证码的后端地址， 设置到页面中，让浏览请求验证码图片 // 1. 生成图片验证码编号 imageCodeId = generateUUID(); // 是指图片url var url = &quot;/api/v1.0/image_codes/&quot; + imageCodeId; $(&quot;.image-code img&quot;).attr(&quot;src&quot;, url);&#125;function sendSMSCode() &#123; // 点击发送短信验证码后被执行的函数 $(&quot;.phonecode-a&quot;).removeAttr(&quot;onclick&quot;); var mobile = $(&quot;#mobile&quot;).val(); if (!mobile) &#123; $(&quot;#mobile-err span&quot;).html(&quot;请填写正确的手机号！&quot;); $(&quot;#mobile-err&quot;).show(); $(&quot;.phonecode-a&quot;).attr(&quot;onclick&quot;, &quot;sendSMSCode();&quot;); return; &#125; var imageCode = $(&quot;#imagecode&quot;).val(); if (!imageCode) &#123; $(&quot;#image-code-err span&quot;).html(&quot;请填写验证码！&quot;); $(&quot;#image-code-err&quot;).show(); $(&quot;.phonecode-a&quot;).attr(&quot;onclick&quot;, &quot;sendSMSCode();&quot;); return; &#125; // 构造向后端请求的参数 var req_data = &#123; image_code: imageCode, // 图片验证码的值 image_code_id: imageCodeId // 图片验证码的编号，（全局变量） &#125;; // 向后端发送请求 $.get(&quot;/api/v1.0/sms_codes/&quot;+ mobile, req_data, function (resp) &#123; // resp是后端返回的响应值，因为后端返回的是json字符串， // 所以ajax帮助我们把这个json字符串转换为js对象，resp就是转换后对象 if (resp.errno == &quot;0&quot;) &#123; var num = 60; // 表示发送成功 var timer = setInterval(function () &#123; if (num &gt;= 1) &#123; // 修改倒计时文本 $(&quot;.phonecode-a&quot;).html(num + &quot;秒&quot;); num -= 1; &#125; else &#123; $(&quot;.phonecode-a&quot;).html(&quot;获取验证码&quot;); $(&quot;.phonecode-a&quot;).attr(&quot;onclick&quot;, &quot;sendSMSCode();&quot;); clearInterval(timer); &#125; &#125;, 1000, 60) &#125; else &#123; alert(resp.errmsg); $(&quot;.phonecode-a&quot;).attr(&quot;onclick&quot;, &quot;sendSMSCode();&quot;); &#125; &#125;);&#125;$(document).ready(function() &#123; generateImageCode(); $(&quot;#mobile&quot;).focus(function()&#123; $(&quot;#mobile-err&quot;).hide(); &#125;); $(&quot;#imagecode&quot;).focus(function()&#123; $(&quot;#image-code-err&quot;).hide(); &#125;); $(&quot;#phonecode&quot;).focus(function()&#123; $(&quot;#phone-code-err&quot;).hide(); &#125;); $(&quot;#password&quot;).focus(function()&#123; $(&quot;#password-err&quot;).hide(); $(&quot;#password2-err&quot;).hide(); &#125;); $(&quot;#password2&quot;).focus(function()&#123; $(&quot;#password2-err&quot;).hide(); &#125;); // 为表单的提交补充自定义的函数行为 （提交事件e） $(&quot;.form-register&quot;).submit(function(e)&#123; // 阻止浏览器对于表单的默认自动提交行为 e.preventDefault(); var mobile = $(&quot;#mobile&quot;).val(); var phoneCode = $(&quot;#phonecode&quot;).val(); var passwd = $(&quot;#password&quot;).val(); var passwd2 = $(&quot;#password2&quot;).val(); if (!mobile) &#123; $(&quot;#mobile-err span&quot;).html(&quot;请填写正确的手机号！&quot;); $(&quot;#mobile-err&quot;).show(); return; &#125; if (!phoneCode) &#123; $(&quot;#phone-code-err span&quot;).html(&quot;请填写短信验证码！&quot;); $(&quot;#phone-code-err&quot;).show(); return; &#125; if (!passwd) &#123; $(&quot;#password-err span&quot;).html(&quot;请填写密码!&quot;); $(&quot;#password-err&quot;).show(); return; &#125; if (passwd != passwd2) &#123; $(&quot;#password2-err span&quot;).html(&quot;两次密码不一致!&quot;); $(&quot;#password2-err&quot;).show(); return; &#125; // 调用ajax向后端发送注册请求 var req_data = &#123; mobile: mobile, sms_code: phoneCode, password: passwd, password2: passwd2, &#125;; var req_json = JSON.stringify(req_data); $.ajax(&#123; url: &quot;/api/v1.0/users&quot;, type: &quot;post&quot;, data: req_json, contentType: &quot;application/json&quot;, dataType: &quot;json&quot;, headers: &#123; &quot;X-CSRFToken&quot;: getCookie(&quot;csrf_token&quot;) &#125;, // 请求头，将csrf_token值放到请求中，方便后端csrf进行验证 success: function (resp) &#123; if (resp.errno == &quot;0&quot;) &#123; // 注册成功，跳转到主页 location.href = &quot;/index.html&quot;; &#125; else &#123; alert(resp.errmsg); &#125; &#125; &#125;) &#125;);&#125;) login.js 发送登录请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function getCookie(name) &#123; var r = document.cookie.match(&quot;\\\\b&quot; + name + &quot;=([^;]*)\\\\b&quot;); return r ? r[1] : undefined;&#125;$(document).ready(function() &#123; $(&quot;#mobile&quot;).focus(function()&#123; $(&quot;#mobile-err&quot;).hide(); &#125;); $(&quot;#password&quot;).focus(function()&#123; $(&quot;#password-err&quot;).hide(); &#125;); $(&quot;.form-login&quot;).submit(function(e)&#123; e.preventDefault(); mobile = $(&quot;#mobile&quot;).val(); passwd = $(&quot;#password&quot;).val(); if (!mobile) &#123; $(&quot;#mobile-err span&quot;).html(&quot;请填写正确的手机号！&quot;); $(&quot;#mobile-err&quot;).show(); return; &#125; if (!passwd) &#123; $(&quot;#password-err span&quot;).html(&quot;请填写密码!&quot;); $(&quot;#password-err&quot;).show(); return; &#125; // 将表单的数据存放到对象data中 var data = &#123; mobile: mobile, password: passwd &#125;; // 将data转为json字符串 var jsonData = JSON.stringify(data); $.ajax(&#123; url:&quot;/api/v1.0/sessions&quot;, type:&quot;post&quot;, data: jsonData, contentType: &quot;application/json&quot;, dataType: &quot;json&quot;, headers:&#123; &quot;X-CSRFToken&quot;:getCookie(&quot;csrf_token&quot;) &#125;, success: function (data) &#123; if (data.errno == &quot;0&quot;) &#123; // 登录成功，跳转到主页 location.href = &quot;/&quot;; &#125; else &#123; // 其他错误信息，在页面中展示 $(&quot;#password-err span&quot;).html(data.errmsg); $(&quot;#password-err&quot;).show(); &#125; &#125; &#125;); &#125;);&#125;) 二、用户信息 profile.js 设置用户头像 修改用户名123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687function showSuccessMsg() &#123; $(&#x27;.popup_con&#x27;).fadeIn(&#x27;fast&#x27;, function() &#123; setTimeout(function()&#123; $(&#x27;.popup_con&#x27;).fadeOut(&#x27;fast&#x27;,function()&#123;&#125;); &#125;,1000) &#125;);&#125;function getCookie(name) &#123; var r = document.cookie.match(&quot;\\\\b&quot; + name + &quot;=([^;]*)\\\\b&quot;); return r ? r[1] : undefined;&#125;$(document).ready(function () &#123; $(&quot;#form-avatar&quot;).submit(function (e) &#123; // 阻止表单的默认行为 e.preventDefault(); // 利用jquery.form.min.js提供的ajaxSubmit对表单进行异步提交 $(this).ajaxSubmit(&#123; url: &quot;/api/v1.0/users/avatar&quot;, type: &quot;post&quot;, dataType: &quot;json&quot;, headers: &#123; &quot;X-CSRFToken&quot;: getCookie(&quot;csrf_token&quot;) &#125;, success: function (resp) &#123; if (resp.errno == &quot;0&quot;) &#123; // 上传成功 var avatarUrl = resp.data.avatar_url; $(&quot;#user-avatar&quot;).attr(&quot;src&quot;, avatarUrl); &#125; else if (resp.errno == &quot;4101&quot;) &#123; location.href = &quot;/login.html&quot;; &#125; else &#123; alert(resp.errmsg); &#125; &#125; &#125;) &#125;); // 在页面加载是向后端查询用户的信息 $.get(&quot;/api/v1.0/user&quot;, function(resp)&#123; // 用户未登录 if (&quot;4101&quot; == resp.errno) &#123; location.href = &quot;/login.html&quot;; &#125; // 查询到了用户的信息 else if (&quot;0&quot; == resp.errno) &#123; $(&quot;#user-name&quot;).val(resp.data.name); if (resp.data.avatar) &#123; $(&quot;#user-avatar&quot;).attr(&quot;src&quot;, resp.data.avatar); &#125; &#125; &#125;, &quot;json&quot;); $(&quot;#form-name&quot;).submit(function(e)&#123; e.preventDefault(); // 获取参数 var name = $(&quot;#user-name&quot;).val(); if (!name) &#123; alert(&quot;请填写用户名！&quot;); return; &#125; $.ajax(&#123; url:&quot;/api/v1.0/users/name&quot;, type:&quot;PUT&quot;, data: JSON.stringify(&#123;name: name&#125;), contentType: &quot;application/json&quot;, dataType: &quot;json&quot;, headers:&#123; &quot;X-CSRFTOKEN&quot;:getCookie(&quot;csrf_token&quot;) &#125;, success: function (data) &#123; if (&quot;0&quot; == data.errno) &#123; $(&quot;.error-msg&quot;).hide(); showSuccessMsg(); &#125; else if (&quot;4001&quot; == data.errno) &#123; $(&quot;.error-msg&quot;).show(); &#125; else if (&quot;4101&quot; == data.errno) &#123; location.href = &quot;/login.html&quot;; &#125; &#125; &#125;); &#125;)&#125;) my.js 退出登录 获取用户信息123456789101112131415161718192021222324252627282930313233343536373839function getCookie(name) &#123; var r = document.cookie.match(&quot;\\\\b&quot; + name + &quot;=([^;]*)\\\\b&quot;); return r ? r[1] : undefined;&#125;// 点击推出按钮时执行的函数function logout() &#123; $.ajax(&#123; url: &quot;/api/v1.0/session&quot;, type: &quot;delete&quot;, headers: &#123; &quot;X-CSRFToken&quot;: getCookie(&quot;csrf_token&quot;) &#125;, dataType: &quot;json&quot;, success: function (resp) &#123; if (&quot;0&quot; == resp.errno) &#123; location.href = &quot;/index.html&quot;; &#125; &#125; &#125;);&#125;$(document).ready(function()&#123; $.get(&quot;/api/v1.0/user&quot;, function(resp)&#123; // 用户未登录 if (&quot;4101&quot; == resp.errno) &#123; location.href = &quot;/login.html&quot;; &#125; // 查询到了用户的信息 else if (&quot;0&quot; == resp.errno) &#123; $(&quot;#user-name&quot;).html(resp.data.name); $(&quot;#user-mobile&quot;).html(resp.data.mobile); if (resp.data.avatar) &#123; $(&quot;#user-avatar&quot;).attr(&quot;src&quot;, resp.data.avatar); &#125; &#125; &#125;, &quot;json&quot;);&#125;) auth.js 设置与获取实名认证信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function showSuccessMsg() &#123; $(&#x27;.popup_con&#x27;).fadeIn(&#x27;fast&#x27;, function() &#123; setTimeout(function()&#123; $(&#x27;.popup_con&#x27;).fadeOut(&#x27;fast&#x27;,function()&#123;&#125;); &#125;,1000) &#125;);&#125;function getCookie(name) &#123; var r = document.cookie.match(&quot;\\\\b&quot; + name + &quot;=([^;]*)\\\\b&quot;); return r ? r[1] : undefined;&#125;$(document).ready(function()&#123; // 查询用户的实名认证信息 $.get(&quot;/api/v1.0/users/auth&quot;, function(resp)&#123; // 4101代表用户未登录 if (&quot;4101&quot; == resp.errno) &#123; location.href = &quot;/login.html&quot;; &#125; else if (&quot;0&quot; == resp.errno) &#123; // 如果返回的数据中real_name与id_card不为null，表示用户有填写实名信息 if (resp.data.real_name &amp;&amp; resp.data.id_card) &#123; $(&quot;#real-name&quot;).val(resp.data.real_name); $(&quot;#id-card&quot;).val(resp.data.id_card); // 给input添加disabled属性，禁止用户修改 $(&quot;#real-name&quot;).prop(&quot;disabled&quot;, true); $(&quot;#id-card&quot;).prop(&quot;disabled&quot;, true); // 隐藏提交保存按钮 $(&quot;#form-auth&gt;input[type=submit]&quot;).hide(); &#125; &#125; else &#123; alert(resp.errmsg); &#125; &#125;, &quot;json&quot;); // 管理实名信息表单的提交行为 $(&quot;#form-auth&quot;).submit(function(e)&#123; e.preventDefault(); // 如果用户没有填写完整，展示错误信息 var realName = $(&quot;#real-name&quot;).val(); var idCard = $(&quot;#id-card&quot;).val(); if (realName == &quot;&quot; || idCard == &quot;&quot;) &#123; $(&quot;.error-msg&quot;).show(); &#125; // 将表单的数据转换为json字符串 var data = &#123; real_name: realName, id_card: idCard &#125;; var jsonData = JSON.stringify(data); // 向后端发送请求 $.ajax(&#123; url:&quot;/api/v1.0/users/auth&quot;, type:&quot;post&quot;, data: jsonData, contentType: &quot;application/json&quot;, dataType: &quot;json&quot;, headers: &#123; &quot;X-CSRFTOKEN&quot;: getCookie(&quot;csrf_token&quot;) &#125;, success: function (resp) &#123; if (0 == resp.errno) &#123; $(&quot;.error-msg&quot;).hide(); // 显示保存成功的提示信息 showSuccessMsg(); $(&quot;#real-name&quot;).prop(&quot;disabled&quot;, true); $(&quot;#id-card&quot;).prop(&quot;disabled&quot;, true); $(&quot;#form-auth&gt;input[type=submit]&quot;).hide(); &#125; &#125; &#125;); &#125;)&#125;) 三、房屋信息 index.js 检查用户的登录状态以控制不同显示 获取幻灯片要展示的房屋基本信息 获取城区信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//模态框居中的控制function centerModals()&#123; $(&#x27;.modal&#x27;).each(function(i)&#123; //遍历每一个模态框 var $clone = $(this).clone().css(&#x27;display&#x27;, &#x27;block&#x27;).appendTo(&#x27;body&#x27;); var top = Math.round(($clone.height() - $clone.find(&#x27;.modal-content&#x27;).height()) / 2); top = top &gt; 0 ? top : 0; $clone.remove(); $(this).find(&#x27;.modal-content&#x27;).css(&quot;margin-top&quot;, top-30); //修正原先已经有的30个像素 &#125;);&#125;function setStartDate() &#123; var startDate = $(&quot;#start-date-input&quot;).val(); if (startDate) &#123; $(&quot;.search-btn&quot;).attr(&quot;start-date&quot;, startDate); $(&quot;#start-date-btn&quot;).html(startDate); $(&quot;#end-date&quot;).datepicker(&quot;destroy&quot;); $(&quot;#end-date-btn&quot;).html(&quot;离开日期&quot;); $(&quot;#end-date-input&quot;).val(&quot;&quot;); $(&quot;.search-btn&quot;).attr(&quot;end-date&quot;, &quot;&quot;); $(&quot;#end-date&quot;).datepicker(&#123; language: &quot;zh-CN&quot;, keyboardNavigation: false, startDate: startDate, format: &quot;yyyy-mm-dd&quot; &#125;); $(&quot;#end-date&quot;).on(&quot;changeDate&quot;, function() &#123; $(&quot;#end-date-input&quot;).val( $(this).datepicker(&quot;getFormattedDate&quot;) ); &#125;); $(&quot;.end-date&quot;).show(); &#125; $(&quot;#start-date-modal&quot;).modal(&quot;hide&quot;);&#125;function setEndDate() &#123; var endDate = $(&quot;#end-date-input&quot;).val(); if (endDate) &#123; $(&quot;.search-btn&quot;).attr(&quot;end-date&quot;, endDate); $(&quot;#end-date-btn&quot;).html(endDate); &#125; $(&quot;#end-date-modal&quot;).modal(&quot;hide&quot;);&#125;function goToSearchPage(th) &#123; var url = &quot;/search.html?&quot;; url += (&quot;aid=&quot; + $(th).attr(&quot;area-id&quot;)); url += &quot;&amp;&quot;; var areaName = $(th).attr(&quot;area-name&quot;); if (undefined == areaName) areaName=&quot;&quot;; url += (&quot;aname=&quot; + areaName); url += &quot;&amp;&quot;; url += (&quot;sd=&quot; + $(th).attr(&quot;start-date&quot;)); url += &quot;&amp;&quot;; url += (&quot;ed=&quot; + $(th).attr(&quot;end-date&quot;)); location.href = url;&#125;$(document).ready(function()&#123; // 检查用户的登录状态 $.get(&quot;/api/v1.0/session&quot;, function(resp) &#123; if (&quot;0&quot; == resp.errno) &#123; $(&quot;.top-bar&gt;.user-info&gt;.user-name&quot;).html(resp.data.name); $(&quot;.top-bar&gt;.user-info&quot;).show(); &#125; else &#123; $(&quot;.top-bar&gt;.register-login&quot;).show(); &#125; &#125;, &quot;json&quot;); // 获取幻灯片要展示的房屋基本信息 $.get(&quot;/api/v1.0/houses/index&quot;, function(resp)&#123; if (&quot;0&quot; == resp.errno) &#123; $(&quot;.swiper-wrapper&quot;).html(template(&quot;swiper-houses-tmpl&quot;, &#123;houses:resp.data&#125;)); // 设置幻灯片对象，开启幻灯片滚动 var mySwiper = new Swiper (&#x27;.swiper-container&#x27;, &#123; loop: true, autoplay: 2000, autoplayDisableOnInteraction: false, pagination: &#x27;.swiper-pagination&#x27;, paginationClickable: true &#125;); &#125; &#125;); // 获取城区信息 $.get(&quot;/api/v1.0/areas&quot;, function(resp)&#123; if (&quot;0&quot; == resp.errno) &#123; $(&quot;.area-list&quot;).html(template(&quot;area-list-tmpl&quot;, &#123;areas:resp.data&#125;)); $(&quot;.area-list a&quot;).click(function(e)&#123; $(&quot;#area-btn&quot;).html($(this).html()); $(&quot;.search-btn&quot;).attr(&quot;area-id&quot;, $(this).attr(&quot;area-id&quot;)); $(&quot;.search-btn&quot;).attr(&quot;area-name&quot;, $(this).html()); $(&quot;#area-modal&quot;).modal(&quot;hide&quot;); &#125;); &#125; &#125;); $(&#x27;.modal&#x27;).on(&#x27;show.bs.modal&#x27;, centerModals); //当模态框出现的时候 $(window).on(&#x27;resize&#x27;, centerModals); //当窗口大小变化的时候 $(&quot;#start-date&quot;).datepicker(&#123; language: &quot;zh-CN&quot;, keyboardNavigation: false, startDate: &quot;today&quot;, format: &quot;yyyy-mm-dd&quot; &#125;); $(&quot;#start-date&quot;).on(&quot;changeDate&quot;, function() &#123; var date = $(this).datepicker(&quot;getFormattedDate&quot;); $(&quot;#start-date-input&quot;).val(date); &#125;);&#125;) detail.js 获取房屋的具体信息12345678910111213141516171819202122232425262728293031323334353637383940function hrefBack() &#123; history.go(-1);&#125;// 解析提取url中的查询字符串参数function decodeQuery()&#123; var search = decodeURI(document.location.search); return search.replace(/(^\\?)/, &#x27;&#x27;).split(&#x27;&amp;&#x27;).reduce(function(result, item)&#123; values = item.split(&#x27;=&#x27;); result[values[0]] = values[1]; return result; &#125;, &#123;&#125;);&#125;$(document).ready(function()&#123; // 获取详情页面要展示的房屋编号 var queryData = decodeQuery(); var houseId = queryData[&quot;id&quot;]; // 获取该房屋的详细信息 $.get(&quot;/api/v1.0/houses/&quot; + houseId, function(resp)&#123; if (&quot;0&quot; == resp.errno) &#123; $(&quot;.swiper-container&quot;).html(template(&quot;house-image-tmpl&quot;, &#123;img_urls:resp.data.house.img_urls, price:resp.data.house.price&#125;)); $(&quot;.detail-con&quot;).html(template(&quot;house-detail-tmpl&quot;, &#123;house:resp.data.house&#125;)); // resp.user_id为访问页面用户,resp.data.user_id为房东 if (resp.data.user_id != resp.data.house.user_id) &#123; $(&quot;.book-house&quot;).attr(&quot;href&quot;, &quot;/booking.html?hid=&quot;+resp.data.house.hid); $(&quot;.book-house&quot;).show(); &#125; var mySwiper = new Swiper (&#x27;.swiper-container&#x27;, &#123; loop: true, autoplay: 2000, autoplayDisableOnInteraction: false, pagination: &#x27;.swiper-pagination&#x27;, paginationType: &#x27;fraction&#x27; &#125;); &#125; &#125;)&#125;) myhouse.js 获取用户拥有的房源信息1234567891011121314151617181920212223$(document).ready(function()&#123; // 对于发布房源，只有认证后的用户才可以，所以先判断用户的实名认证状态 $.get(&quot;/api/v1.0/users/auth&quot;, function(resp)&#123; if (&quot;4101&quot; == resp.errno) &#123; // 用户未登录 location.href = &quot;/login.html&quot;; &#125; else if (&quot;0&quot; == resp.errno) &#123; // 未认证的用户，在页面中展示 &quot;去认证&quot;的按钮 if (!(resp.data.real_name &amp;&amp; resp.data.id_card)) &#123; $(&quot;.auth-warn&quot;).show(); return; &#125; // 已认证的用户，请求其之前发布的房源信息 $.get(&quot;/api/v1.0/user/houses&quot;, function(resp)&#123; if (&quot;0&quot; == resp.errno) &#123; $(&quot;#houses-list&quot;).html(template(&quot;houses-list-tmpl&quot;, &#123;houses:resp.data.houses&#125;)); &#125; else &#123; $(&quot;#houses-list&quot;).html(template(&quot;houses-list-tmpl&quot;, &#123;houses:[]&#125;)); &#125; &#125;); &#125; &#125;);&#125;) newhouse.js 获取城区信息 上传房源基本信息 上传房源图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889function getCookie(name) &#123; var r = document.cookie.match(&quot;\\\\b&quot; + name + &quot;=([^;]*)\\\\b&quot;); return r ? r[1] : undefined;&#125;$(document).ready(function()&#123; // 向后端获取城区信息 $.get(&quot;/api/v1.0/areas&quot;, function (resp) &#123; if (resp.errno == &quot;0&quot;) &#123; var areas = resp.data; // for (i=0; i&lt;areas.length; i++) &#123; // var area = areas[i]; // $(&quot;#area-id&quot;).append(&#x27;&lt;option value=&quot;&#x27;+ area.aid +&#x27;&quot;&gt;&#x27;+ area.aname +&#x27;&lt;/option&gt;&#x27;); // &#125; // 使用js模板 var html = template(&quot;areas-tmpl&quot;, &#123;areas: areas&#125;) $(&quot;#area-id&quot;).html(html); &#125; else &#123; alert(resp.errmsg); &#125; &#125;, &quot;json&quot;); $(&quot;#form-house-info&quot;).submit(function (e) &#123; e.preventDefault(); // 处理表单数据 var data = &#123;&#125;; $(&quot;#form-house-info&quot;).serializeArray().map(function(x) &#123; data[x.name]=x.value &#125;); // 收集设置id信息 var facility = []; $(&quot;:checked[name=facility]&quot;).each(function(index, x)&#123;facility[index] = $(x).val()&#125;); data.facility = facility; // 向后端发送请求 $.ajax(&#123; url: &quot;/api/v1.0/houses/info&quot;, type: &quot;post&quot;, contentType: &quot;application/json&quot;, data: JSON.stringify(data), dataType: &quot;json&quot;, headers: &#123; &quot;X-CSRFToken&quot;: getCookie(&quot;csrf_token&quot;) &#125;, success: function (resp) &#123; if (resp.errno == &quot;4101&quot;) &#123; // 用户未登录 location.href = &quot;/login.html&quot;; &#125; else if (resp.errno == &quot;0&quot;) &#123; // 隐藏基本信息表单 $(&quot;#form-house-info&quot;).hide(); // 显示图片表单 $(&quot;#form-house-image&quot;).show(); // 设置图片表单中的house_id $(&quot;#house-id&quot;).val(resp.data.house_id); &#125; else &#123; alert(resp.errmsg); &#125; &#125; &#125;) &#125;); $(&quot;#form-house-image&quot;).submit(function (e) &#123; e.preventDefault(); $(this).ajaxSubmit(&#123; url: &quot;/api/v1.0/houses/image&quot;, type: &quot;post&quot;, dataType: &quot;json&quot;, headers: &#123; &quot;X-CSRFToken&quot;: getCookie(&quot;csrf_token&quot;), &#125;, success: function (resp) &#123; if (resp.errno == &quot;4101&quot;) &#123; location.href = &quot;/login.html&quot;; &#125; else if (resp.errno == &quot;0&quot;) &#123; $(&quot;.house-image-cons&quot;).append(&#x27;&lt;img src=&quot;&#x27; + resp.data.image_url +&#x27;&quot;&gt;&#x27;); &#125; else &#123; alert(resp.errmsg); &#125; &#125; &#125;) &#125;)&#125;) 四、订单支付因未实现支付宝接入支付，故此处仅列查询订单的js。 orders.js 获取房客订单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//模态框居中的控制function centerModals()&#123; $(&#x27;.modal&#x27;).each(function(i)&#123; //遍历每一个模态框 var $clone = $(this).clone().css(&#x27;display&#x27;, &#x27;block&#x27;).appendTo(&#x27;body&#x27;); var top = Math.round(($clone.height() - $clone.find(&#x27;.modal-content&#x27;).height()) / 2); top = top &gt; 0 ? top : 0; $clone.remove(); $(this).find(&#x27;.modal-content&#x27;).css(&quot;margin-top&quot;, top-30); //修正原先已经有的30个像素 &#125;);&#125;function getCookie(name) &#123; var r = document.cookie.match(&quot;\\\\b&quot; + name + &quot;=([^;]*)\\\\b&quot;); return r ? r[1] : undefined;&#125;$(document).ready(function()&#123; $(&#x27;.modal&#x27;).on(&#x27;show.bs.modal&#x27;, centerModals); //当模态框出现的时候 $(window).on(&#x27;resize&#x27;, centerModals); // 查询房客订单 $.get(&quot;/api/v1.0/user/orders?role=custom&quot;, function(resp)&#123; if (&quot;0&quot; == resp.errno) &#123; $(&quot;.orders-list&quot;).html(template(&quot;orders-list-tmpl&quot;, &#123;orders:resp.data.orders&#125;)); $(&quot;.order-pay&quot;).on(&quot;click&quot;, function () &#123; var orderId = $(this).parents(&quot;li&quot;).attr(&quot;order-id&quot;); $.ajax(&#123; url: &quot;/api/v1.0/orders/&quot; + orderId + &quot;/payment&quot;, type: &quot;post&quot;, dataType: &quot;json&quot;, headers: &#123; &quot;X-CSRFToken&quot;: getCookie(&quot;csrf_token&quot;), &#125;, success: function (resp) &#123; if (&quot;4101&quot; == resp.errno) &#123; location.href = &quot;/login.html&quot;; &#125; else if (&quot;0&quot; == resp.errno) &#123; // 引导用户跳转到支付宝连接 location.href = resp.data.pay_url; &#125; &#125; &#125;); &#125;); $(&quot;.order-comment&quot;).on(&quot;click&quot;, function()&#123; var orderId = $(this).parents(&quot;li&quot;).attr(&quot;order-id&quot;); $(&quot;.modal-comment&quot;).attr(&quot;order-id&quot;, orderId); &#125;); $(&quot;.modal-comment&quot;).on(&quot;click&quot;, function()&#123; var orderId = $(this).attr(&quot;order-id&quot;); var comment = $(&quot;#comment&quot;).val() if (!comment) return; var data = &#123; order_id:orderId, comment:comment &#125;; // 处理评论 $.ajax(&#123; url:&quot;/api/v1.0/orders/&quot;+orderId+&quot;/comment&quot;, type:&quot;PUT&quot;, data:JSON.stringify(data), contentType:&quot;application/json&quot;, dataType:&quot;json&quot;, headers:&#123; &quot;X-CSRFTOKEN&quot;:getCookie(&quot;csrf_token&quot;), &#125;, success:function (resp) &#123; if (&quot;4101&quot; == resp.errno) &#123; location.href = &quot;/login.html&quot;; &#125; else if (&quot;0&quot; == resp.errno) &#123; $(&quot;.orders-list&gt;li[order-id=&quot;+ orderId +&quot;]&gt;div.order-content&gt;div.order-text&gt;ul li:eq(4)&gt;span&quot;).html(&quot;已完成&quot;); $(&quot;ul.orders-list&gt;li[order-id=&quot;+ orderId +&quot;]&gt;div.order-title&gt;div.order-operate&quot;).hide(); $(&quot;#comment-modal&quot;).modal(&quot;hide&quot;); &#125; &#125; &#125;); &#125;); &#125; &#125;);&#125;); lorder,js 获取房主订单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//模态框居中的控制function centerModals()&#123; $(&#x27;.modal&#x27;).each(function(i)&#123; //遍历每一个模态框 var $clone = $(this).clone().css(&#x27;display&#x27;, &#x27;block&#x27;).appendTo(&#x27;body&#x27;); var top = Math.round(($clone.height() - $clone.find(&#x27;.modal-content&#x27;).height()) / 2); top = top &gt; 0 ? top : 0; $clone.remove(); $(this).find(&#x27;.modal-content&#x27;).css(&quot;margin-top&quot;, top-30); //修正原先已经有的30个像素 &#125;);&#125;function getCookie(name) &#123; var r = document.cookie.match(&quot;\\\\b&quot; + name + &quot;=([^;]*)\\\\b&quot;); return r ? r[1] : undefined;&#125;$(document).ready(function()&#123; $(&#x27;.modal&#x27;).on(&#x27;show.bs.modal&#x27;, centerModals); //当模态框出现的时候 $(window).on(&#x27;resize&#x27;, centerModals); // 查询房东的订单 $.get(&quot;/api/v1.0/user/orders?role=landlord&quot;, function(resp)&#123; if (&quot;0&quot; == resp.errno) &#123; $(&quot;.orders-list&quot;).html(template(&quot;orders-list-tmpl&quot;, &#123;orders:resp.data.orders&#125;)); $(&quot;.order-accept&quot;).on(&quot;click&quot;, function()&#123; var orderId = $(this).parents(&quot;li&quot;).attr(&quot;order-id&quot;); $(&quot;.modal-accept&quot;).attr(&quot;order-id&quot;, orderId); &#125;); // 接单处理 $(&quot;.modal-accept&quot;).on(&quot;click&quot;, function()&#123; var orderId = $(this).attr(&quot;order-id&quot;); $.ajax(&#123; url:&quot;/api/v1.0/orders/&quot;+orderId+&quot;/status&quot;, type:&quot;PUT&quot;, data:&#x27;&#123;&quot;action&quot;:&quot;accept&quot;&#125;&#x27;, contentType:&quot;application/json&quot;, dataType:&quot;json&quot;, headers:&#123; &quot;X-CSRFTOKEN&quot;:getCookie(&quot;csrf_token&quot;), &#125;, success:function (resp) &#123; if (&quot;4101&quot; == resp.errno) &#123; location.href = &quot;/login.html&quot;; &#125; else if (&quot;0&quot; == resp.errno) &#123; $(&quot;.orders-list&gt;li[order-id=&quot;+ orderId +&quot;]&gt;div.order-content&gt;div.order-text&gt;ul li:eq(4)&gt;span&quot;).html(&quot;已接单&quot;); $(&quot;ul.orders-list&gt;li[order-id=&quot;+ orderId +&quot;]&gt;div.order-title&gt;div.order-operate&quot;).hide(); $(&quot;#accept-modal&quot;).modal(&quot;hide&quot;); &#125; &#125; &#125;) &#125;); $(&quot;.order-reject&quot;).on(&quot;click&quot;, function()&#123; var orderId = $(this).parents(&quot;li&quot;).attr(&quot;order-id&quot;); $(&quot;.modal-reject&quot;).attr(&quot;order-id&quot;, orderId); &#125;); // 处理拒单 $(&quot;.modal-reject&quot;).on(&quot;click&quot;, function()&#123; var orderId = $(this).attr(&quot;order-id&quot;); var reject_reason = $(&quot;#reject-reason&quot;).val(); if (!reject_reason) return; var data = &#123; action: &quot;reject&quot;, reason:reject_reason &#125;; $.ajax(&#123; url:&quot;/api/v1.0/orders/&quot;+orderId+&quot;/status&quot;, type:&quot;PUT&quot;, data:JSON.stringify(data), contentType:&quot;application/json&quot;, headers: &#123; &quot;X-CSRFTOKEN&quot;:getCookie(&quot;csrf_token&quot;) &#125;, dataType:&quot;json&quot;, success:function (resp) &#123; if (&quot;4101&quot; == resp.errno) &#123; location.href = &quot;/login.html&quot;; &#125; else if (&quot;0&quot; == resp.errno) &#123; $(&quot;.orders-list&gt;li[order-id=&quot;+ orderId +&quot;]&gt;div.order-content&gt;div.order-text&gt;ul li:eq(4)&gt;span&quot;).html(&quot;已拒单&quot;); $(&quot;ul.orders-list&gt;li[order-id=&quot;+ orderId +&quot;]&gt;div.order-title&gt;div.order-operate&quot;).hide(); $(&quot;#reject-modal&quot;).modal(&quot;hide&quot;); &#125; &#125; &#125;); &#125;) &#125; &#125;);&#125;); （三）技术点 一、第三方sdk的接入使用 生成图片验证码 发送短信 www.yuntongxun.com 图片存储 七牛 支付宝 python-alipay-sdk https://github.com/fzlee/alipay 二、前端界面显示模板/插件 art-templatehttps://aui.github.io/art-template/zh-cn/index.html jquery表单插件 swiper轮播图插件 三、ajax请求的构成 请求参数/请求体的设置 响应回调 四、redis缓存的各种设置 有效期逻辑 存储数据类型 五、模型类属性设置与自定义方法 转换为字典的方法 属性装饰器 六、返回json数据的构造 jsonify json.dumps redis存取 七、sqlalchemy进行数据库操作 复杂查询条件的设置 优化 八、视图函数获取参数、检验参数、业务逻辑处理、返回结果的整体流程与逻辑细节处理","categories":[{"name":"Flask","slug":"Flask","permalink":"https://shadowbynl.github.io/categories/Flask/"}],"tags":[{"name":"PythonWeb","slug":"PythonWeb","permalink":"https://shadowbynl.github.io/tags/PythonWeb/"}]},{"title":"flask-study-3","slug":"flask-study-3","date":"2020-06-14T13:28:55.000Z","updated":"2020-06-14T14:44:35.093Z","comments":true,"path":"2020/06/14/flask-study-3/","link":"","permalink":"https://shadowbynl.github.io/2020/06/14/flask-study-3/","excerpt":"黑马ihome项目 其二","text":"黑马ihome项目 其二 一、城区信息与发布房源 为将Area对象的列表转为json字符串，先在对应模型类中定义了to_dict方法，可调用将对象转为字典（高度自定义）。 对于城区信息这种一般不会变化的数据，需要存入缓存，存入的是由errno、errmsg、area_dict_li转成的json字符串，先传入dict又传入json.dumps。这样的处理就需要在返回时添加200, {“Content-Type”: “application/json”}，这是dumps和jsonify的一个显著区别。 缓存数据同步的问题 使用前端js模板 art-templatehttps://aui.github.io/art-template/zh-cn/index.html 填写房源信息时，注意如何处理表单中的基本信息和设施信息。设施信息由于复选可能有多个，使用id数组存储，需要单独处理。1234567// 处理表单数据var data = &#123;&#125;;$(&quot;#form-house-info&quot;).serializeArray().map(function(x) &#123; data[x.name]=x.value &#125;);// 收集设置id信息var facility = [];$(&quot;:checked[name=facility]&quot;).each(function(index, x)&#123;facility[index] = $(x).val()&#125;); 上传图片表单。为了通过ajax自定义含图片表单的提交，需要使用插件。1&lt;script src=&quot;/static/js/jquery.form.min.js&quot;&gt;&lt;/script&gt; 二、celery 说明Celery是一个功能完备即插即用的任务队列。celery适用异步处理问题，当发送邮件、或者文件上传, 图像处理等等一些比较耗时的操作，我们可将其异步执行，这样用户不需要等待很久，提高用户体验。 celery的特点是：简单，易于使用和维护，有丰富的文档；高效，单个celery进程每分钟可以处理数百万个任务；灵活，celery中几乎每个部分都可以自定义扩展。celery非常易于集成到一些web开发框架中. 使用流程 定义任务（函数） 调用发布任务delay 启动celery 三、房屋管理 获取房东发布的房源信息条目get_user_houses 获取主页幻灯片展示的房屋基本信息get_house_index 获取房屋详情get_house_detail 以上三个方法都是显示房屋信息的。其逻辑关系是，在访问首页时，会有一个幻灯片/轮播图显示订单量最高的房源图片的效果，点击某张时，会进入对应的详情页；在个人信息页选择自己的房源可以查看自己发布的房源信息。 以上三个方法为控制对象的序列化，定义了几个不同的to_dict方法，用于不同详略程度信息的转换获取。 首页的轮播效果使用了swiper插件结合模板实现。 四、房屋列表（搜索筛选） 参数处理与判断 start_date和end_date这两个参数传过来是字符串，数据库字段类型是datetime，需要转换。python中的datetime模块，可以进行字符串和datetime类型的相互转换。123strptime 字符串转datetimestrftime datetime转字符串start_date = datetime.strptime(start_date, &quot;%Y-%m-%d&quot;) 区域、页数、排序关键字 查询条件 设置了存放查询条件的容器 时间条件 区域条件 排序方式 分页 分页实现方式 paginate redis的pipeline使用 多个操作一次提交的情形 列表页数据设置的两种方式：条件改变时的清空重设，滚动时页数增加发送请求追加。 五、订单与支付宝接入 保存订单 save_order 查询用户的订单信息 get_user_orders 接单拒单 accept_reject_order 保存订单评论信息 save_order_comment 支付宝支付使用流程与接入方法 六、项目优化数据库优化方法 关系数据库的三范式https://blog.csdn.net/zhouhuakang/article/details/51153309https://www.cnblogs.com/wsg25/p/9615100.htmlhttps://www.cnblogs.com/knowledgesea/p/3667395.html 索引https://www.jianshu.com/p/2b541c028157 慢查询工具https://flyerboy.github.io/2016/12/23/mysql_slow/https://yemengying.com/2016/05/24/mysql-tuning/ 读写分离 分库分表","categories":[{"name":"Flask","slug":"Flask","permalink":"https://shadowbynl.github.io/categories/Flask/"}],"tags":[{"name":"PythonWeb","slug":"PythonWeb","permalink":"https://shadowbynl.github.io/tags/PythonWeb/"}]},{"title":"Echarts","slug":"Echarts","date":"2020-06-13T12:37:13.000Z","updated":"2020-06-13T12:49:16.839Z","comments":true,"path":"2020/06/13/Echarts/","link":"","permalink":"https://shadowbynl.github.io/2020/06/13/Echarts/","excerpt":"使用Echarts绘制柱形图、折线图、饼状图等的基本流程和设置，以及如何利用ajax请求获取数据后，由Echarts显示数据。","text":"使用Echarts绘制柱形图、折线图、饼状图等的基本流程和设置，以及如何利用ajax请求获取数据后，由Echarts显示数据。 官网：https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts一、几种常见图的写法柱形图1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 柱状图模块1(function() &#123; // 1实例化对象 var myChart = echarts.init(document.querySelector(&quot;.bar .chart&quot;)); // 2. 指定配置项和数据 var option = &#123; color: [&quot;#2f89cf&quot;], tooltip: &#123; trigger: &quot;axis&quot;, axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: &quot;shadow&quot; // 默认为直线，可选为：&#x27;line&#x27; | &#x27;shadow&#x27; &#125; &#125;, // 修改图表的大小 grid: &#123; left: &quot;0%&quot;, top: &quot;10px&quot;, right: &quot;0%&quot;, bottom: &quot;4%&quot;, containLabel: true &#125;, xAxis: [ &#123; type: &quot;category&quot;, data: [ &quot;旅游行业&quot;, &quot;教育培训&quot;, &quot;游戏行业&quot;, &quot;医疗行业&quot;, &quot;电商行业&quot;, &quot;社交行业&quot;, &quot;金融行业&quot; ], axisTick: &#123; alignWithLabel: true &#125;, // 修改刻度标签 相关样式 axisLabel: &#123; color: &quot;rgba(255,255,255,.6) &quot;, fontSize: &quot;8&quot; &#125;, // 不显示x坐标轴的样式 axisLine: &#123; show: false &#125; &#125; ], yAxis: [ &#123; type: &quot;value&quot;, // 修改刻度标签 相关样式 axisLabel: &#123; color: &quot;rgba(255,255,255,.6) &quot;, fontSize: 12 &#125;, // y轴的线条改为了 2像素 axisLine: &#123; lineStyle: &#123; color: &quot;rgba(255,255,255,.1)&quot;, width: 2 &#125; &#125;, // y轴分割线的颜色 splitLine: &#123; lineStyle: &#123; color: &quot;rgba(255,255,255,.1)&quot; &#125; &#125; &#125; ], series: [ &#123; name: &quot;直接访问&quot;, type: &quot;bar&quot;, barWidth: &quot;35%&quot;, data: [200, 300, 300, 900, 1500, 1200, 600], itemStyle: &#123; // 修改柱子圆角 barBorderRadius: 5 &#125; &#125; ] &#125;; // 3. 把配置项给实例对象 myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(&quot;resize&quot;, function() &#123; myChart.resize(); &#125;);&#125;)(); 柱形图2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 柱状图2(function() &#123; var myColor = [&quot;#1089E7&quot;, &quot;#F57474&quot;, &quot;#56D0E3&quot;, &quot;#F8B448&quot;, &quot;#8B78F6&quot;]; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(&quot;.bar2 .chart&quot;)); // 2. 指定配置和数据 var option = &#123; grid: &#123; top: &quot;10%&quot;, left: &quot;22%&quot;, bottom: &quot;10%&quot; // containLabel: true &#125;, // 不显示x轴的相关信息 xAxis: &#123; show: false &#125;, yAxis: [ &#123; type: &quot;category&quot;, inverse: true, data: [&quot;HTML5&quot;, &quot;CSS3&quot;, &quot;javascript&quot;, &quot;VUE&quot;, &quot;NODE&quot;], // 不显示y轴的线 axisLine: &#123; show: false &#125;, // 不显示刻度 axisTick: &#123; show: false &#125;, // 把刻度标签里面的文字颜色设置为白色 axisLabel: &#123; color: &quot;#fff&quot; &#125; &#125;, &#123; data: [702, 350, 610, 793, 664], inverse: true, // 不显示y轴的线 axisLine: &#123; show: false &#125;, // 不显示刻度 axisTick: &#123; show: false &#125;, // 把刻度标签里面的文字颜色设置为白色 axisLabel: &#123; color: &quot;#fff&quot; &#125; &#125; ], series: [ &#123; name: &quot;条&quot;, type: &quot;bar&quot;, data: [70, 34, 60, 78, 69], yAxisIndex: 0, // 修改第一组柱子的圆角 itemStyle: &#123; barBorderRadius: 20, // 此时的color 可以修改柱子的颜色 color: function(params) &#123; // params 传进来的是柱子对象 // console.log(params); // dataIndex 是当前柱子的索引号 return myColor[params.dataIndex]; &#125; &#125;, // 柱子之间的距离 barCategoryGap: 50, //柱子的宽度 barWidth: 10, // 显示柱子内的文字 label: &#123; show: true, position: &quot;inside&quot;, // &#123;c&#125; 会自动的解析为 数据 data里面的数据 formatter: &quot;&#123;c&#125;%&quot; &#125; &#125;, &#123; name: &quot;框&quot;, type: &quot;bar&quot;, barCategoryGap: 50, barWidth: 15, yAxisIndex: 1, data: [100, 100, 100, 100, 100], itemStyle: &#123; color: &quot;none&quot;, borderColor: &quot;#00c1de&quot;, borderWidth: 3, barBorderRadius: 15 &#125; &#125; ] &#125;; // 3. 把配置给实例对象 myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(&quot;resize&quot;, function() &#123; myChart.resize(); &#125;);&#125;)(); 折线图1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 折线图1模块制作(function() &#123; var yearData = [ &#123; year: &quot;2020&quot;, // 年份 data: [ // 两个数组是因为有两条线 [24, 40, 101, 134, 90, 230, 210, 230, 120, 230, 210, 120], [40, 64, 191, 324, 290, 330, 310, 213, 180, 200, 180, 79] ] &#125;, &#123; year: &quot;2021&quot;, // 年份 data: [ // 两个数组是因为有两条线 [123, 175, 112, 197, 121, 67, 98, 21, 43, 64, 76, 38], [143, 131, 165, 123, 178, 21, 82, 64, 43, 60, 19, 34] ] &#125; ]; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(&quot;.line .chart&quot;)); // 2.指定配置 var option = &#123; // 通过这个color修改两条线的颜色 color: [&quot;#00f2f1&quot;, &quot;#ed3f35&quot;], tooltip: &#123; trigger: &quot;axis&quot; &#125;, legend: &#123; // 如果series 对象有name 值，则 legend可以不用写data // 修改图例组件 文字颜色 textStyle: &#123; color: &quot;#4c9bfd&quot; &#125;, // 这个10% 必须加引号 right: &quot;10%&quot; &#125;, grid: &#123; top: &quot;20%&quot;, left: &quot;3%&quot;, right: &quot;4%&quot;, bottom: &quot;3%&quot;, show: true, // 显示边框 borderColor: &quot;#012f4a&quot;, // 边框颜色 containLabel: true // 包含刻度文字在内 &#125;, xAxis: &#123; type: &quot;category&quot;, boundaryGap: false, data: [ &quot;1月&quot;, &quot;2月&quot;, &quot;3月&quot;, &quot;4月&quot;, &quot;5月&quot;, &quot;6月&quot;, &quot;7月&quot;, &quot;8月&quot;, &quot;9月&quot;, &quot;10月&quot;, &quot;11月&quot;, &quot;12月&quot; ], axisTick: &#123; show: false // 去除刻度线 &#125;, axisLabel: &#123; color: &quot;#4c9bfd&quot; // 文本颜色 &#125;, axisLine: &#123; show: false // 去除轴线 &#125; &#125;, yAxis: &#123; type: &quot;value&quot;, axisTick: &#123; show: false // 去除刻度线 &#125;, axisLabel: &#123; color: &quot;#4c9bfd&quot; // 文本颜色 &#125;, axisLine: &#123; show: false // 去除轴线 &#125;, splitLine: &#123; lineStyle: &#123; color: &quot;#012f4a&quot; // 分割线颜色 &#125; &#125; &#125;, series: [ &#123; name: &quot;新增粉丝&quot;, type: &quot;line&quot;, // true 可以让我们的折线显示带有弧度 smooth: true, data: yearData[0].data[0] &#125;, &#123; name: &quot;新增游客&quot;, type: &quot;line&quot;, smooth: true, data: yearData[0].data[1] &#125; ] &#125;; // 3. 把配置给实例对象 myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(&quot;resize&quot;, function() &#123; myChart.resize(); &#125;); // 5.点击切换效果 $(&quot;.line h2&quot;).on(&quot;click&quot;, &quot;a&quot;, function() &#123; // alert(1); // console.log($(this).index()); // 点击 a 之后 根据当前a的索引号 找到对应的 yearData的相关对象 // console.log(yearData[$(this).index()]); var obj = yearData[$(this).index()]; option.series[0].data = obj.data[0]; option.series[1].data = obj.data[1]; // 需要重新渲染 myChart.setOption(option); &#125;);&#125;)(); 折线图2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259// 折线图2 模块制作(function() &#123; var myChart = echarts.init(document.querySelector(&quot;.line2 .chart&quot;)); var option = &#123; tooltip: &#123; trigger: &quot;axis&quot; &#125;, legend: &#123; top: &quot;0%&quot;, data: [&quot;邮件营销&quot;, &quot;联盟广告&quot;, &quot;视频广告&quot;, &quot;直接访问&quot;, &quot;搜索引擎&quot;], textStyle: &#123; color: &quot;rgba(255,255,255,.5)&quot;, fontSize: &quot;12&quot; &#125; &#125;, grid: &#123; left: &quot;10&quot;, top: &quot;30&quot;, right: &quot;10&quot;, bottom: &quot;10&quot;, containLabel: true &#125;, xAxis: [ &#123; type: &quot;category&quot;, boundaryGap: false, // x轴更换数据 data: [ &quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;26&quot;, &quot;28&quot;, &quot;29&quot;, &quot;30&quot; ], // 文本颜色为rgba(255,255,255,.6) 文字大小为 12 axisLabel: &#123; textStyle: &#123; color: &quot;rgba(255,255,255,.6)&quot;, fontSize: 12 &#125; &#125;, // x轴线的颜色为 rgba(255,255,255,.2) axisLine: &#123; lineStyle: &#123; color: &quot;rgba(255,255,255,.2)&quot; &#125; &#125; &#125; ], yAxis: [ &#123; type: &quot;value&quot;, axisTick: &#123; show: false &#125;, axisLine: &#123; lineStyle: &#123; color: &quot;rgba(255,255,255,.1)&quot; &#125; &#125;, axisLabel: &#123; textStyle: &#123; color: &quot;rgba(255,255,255,.6)&quot;, fontSize: 12 &#125; &#125;, // 修改分割线的颜色 splitLine: &#123; lineStyle: &#123; color: &quot;rgba(255,255,255,.1)&quot; &#125; &#125; &#125; ], series: [ &#123; name: &quot;邮件营销&quot;, type: &quot;line&quot;, smooth: true, // 单独修改当前线条的样式 lineStyle: &#123; color: &quot;#0184d5&quot;, width: &quot;2&quot; &#125;, // 填充颜色设置 areaStyle: &#123; color: new echarts.graphic.LinearGradient( 0, 0, 0, 1, [ &#123; offset: 0, color: &quot;rgba(1, 132, 213, 0.4)&quot; // 渐变色的起始颜色 &#125;, &#123; offset: 0.8, color: &quot;rgba(1, 132, 213, 0.1)&quot; // 渐变线的结束颜色 &#125; ], false ), shadowColor: &quot;rgba(0, 0, 0, 0.1)&quot; &#125;, // 设置拐点 symbol: &quot;circle&quot;, // 拐点大小 symbolSize: 8, // 开始不显示拐点， 鼠标经过显示 showSymbol: false, // 设置拐点颜色以及边框 itemStyle: &#123; color: &quot;#0184d5&quot;, borderColor: &quot;rgba(221, 220, 107, .1)&quot;, borderWidth: 12 &#125;, data: [ 30, 40, 30, 40, 30, 40, 30, 60, 20, 40, 30, 40, 30, 40, 30, 40, 30, 60, 20, 40, 30, 40, 30, 40, 30, 40, 20, 60, 50, 40 ] &#125;, &#123; name: &quot;联盟广告&quot;, type: &quot;line&quot;, smooth: true, lineStyle: &#123; normal: &#123; color: &quot;#00d887&quot;, width: 2 &#125; &#125;, areaStyle: &#123; normal: &#123; color: new echarts.graphic.LinearGradient( 0, 0, 0, 1, [ &#123; offset: 0, color: &quot;rgba(0, 216, 135, 0.4)&quot; &#125;, &#123; offset: 0.8, color: &quot;rgba(0, 216, 135, 0.1)&quot; &#125; ], false ), shadowColor: &quot;rgba(0, 0, 0, 0.1)&quot; &#125; &#125;, // 设置拐点 小圆点 symbol: &quot;circle&quot;, // 拐点大小 symbolSize: 5, // 设置拐点颜色以及边框 itemStyle: &#123; color: &quot;#00d887&quot;, borderColor: &quot;rgba(221, 220, 107, .1)&quot;, borderWidth: 12 &#125;, // 开始不显示拐点， 鼠标经过显示 showSymbol: false, data: [ 130, 10, 20, 40, 30, 40, 80, 60, 20, 40, 90, 40, 20, 140, 30, 40, 130, 20, 20, 40, 80, 70, 30, 40, 30, 120, 20, 99, 50, 20 ] &#125; ] &#125;; myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(&quot;resize&quot;, function() &#123; myChart.resize(); &#125;);&#125;)(); 饼状图1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 饼形图1(function() &#123; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(&quot;.pie .chart&quot;)); // 2.指定配置 var option = &#123; color: [&quot;#065aab&quot;, &quot;#066eab&quot;, &quot;#0682ab&quot;, &quot;#0696ab&quot;, &quot;#06a0ab&quot;], tooltip: &#123; trigger: &quot;item&quot;, formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&quot; &#125;, legend: &#123; bottom: &quot;0%&quot;, // 修改小图标的大小 itemWidth: 10, itemHeight: 10, // 修改图例组件的文字为 12px textStyle: &#123; color: &quot;rgba(255,255,255,.5)&quot;, fontSize: &quot;12&quot; &#125; &#125;, series: [ &#123; name: &quot;年龄分布&quot;, type: &quot;pie&quot;, // 这个radius可以修改饼形图的大小 // radius 第一个值是内圆的半径 第二个值是外圆的半径 radius: [&quot;40%&quot;, &quot;60%&quot;], center: [&quot;50%&quot;, &quot;45%&quot;], avoidLabelOverlap: false, // 图形上的文字 label: &#123; show: false, position: &quot;center&quot; &#125;, // 链接文字和图形的线是否显示 labelLine: &#123; show: false &#125;, data: [ &#123; value: 1, name: &quot;0岁以下&quot; &#125;, &#123; value: 4, name: &quot;20-29岁&quot; &#125;, &#123; value: 2, name: &quot;30-39岁&quot; &#125;, &#123; value: 2, name: &quot;40-49岁&quot; &#125;, &#123; value: 1, name: &quot;50岁以上&quot; &#125; ] &#125; ] &#125;; // 3. 把配置给实例对象 myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(&quot;resize&quot;, function() &#123; myChart.resize(); &#125;);&#125;)(); 饼状图2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 饼形图2 地区分布模块(function() &#123; var myChart = echarts.init(document.querySelector(&quot;.pie2 .chart&quot;)); var option = &#123; color: [ &quot;#006cff&quot;, &quot;#60cda0&quot;, &quot;#ed8884&quot;, &quot;#ff9f7f&quot;, &quot;#0096ff&quot;, &quot;#9fe6b8&quot;, &quot;#32c5e9&quot;, &quot;#1d9dff&quot; ], tooltip: &#123; trigger: &quot;item&quot;, formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot; &#125;, legend: &#123; bottom: &quot;0%&quot;, itemWidth: 10, itemHeight: 10, textStyle: &#123; color: &quot;rgba(255,255,255,.5)&quot;, fontSize: &quot;12&quot; &#125; &#125;, series: [ &#123; name: &quot;地区分布&quot;, type: &quot;pie&quot;, radius: [&quot;10%&quot;, &quot;70%&quot;], center: [&quot;50%&quot;, &quot;50%&quot;], roseType: &quot;radius&quot;, // 图形的文字标签 label: &#123; fontSize: 10 &#125;, // 链接图形和文字的线条 labelLine: &#123; // length 链接图形的线条 length: 6, // length2 链接文字的线条 length2: 8 &#125;, data: [ &#123; value: 20, name: &quot;云南&quot; &#125;, &#123; value: 26, name: &quot;北京&quot; &#125;, &#123; value: 24, name: &quot;山东&quot; &#125;, &#123; value: 25, name: &quot;河北&quot; &#125;, &#123; value: 20, name: &quot;江苏&quot; &#125;, &#123; value: 25, name: &quot;浙江&quot; &#125;, &#123; value: 30, name: &quot;四川&quot; &#125;, &#123; value: 42, name: &quot;湖北&quot; &#125; ] &#125; ] &#125;; myChart.setOption(option); // 监听浏览器缩放，图表对象调用缩放resize函数 window.addEventListener(&quot;resize&quot;, function() &#123; myChart.resize(); &#125;);&#125;)(); 社区的飞行图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313// 模拟飞行路线模块地图模块(function() &#123; var myChart = echarts.init(document.querySelector(&quot;.map .chart&quot;)); var geoCoordMap = &#123; 上海: [121.4648, 31.2891], 东莞: [113.8953, 22.901], 东营: [118.7073, 37.5513], 中山: [113.4229, 22.478], 临汾: [111.4783, 36.1615], 临沂: [118.3118, 35.2936], 丹东: [124.541, 40.4242], 丽水: [119.5642, 28.1854], 乌鲁木齐: [87.9236, 43.5883], 佛山: [112.8955, 23.1097], 保定: [115.0488, 39.0948], 兰州: [103.5901, 36.3043], 包头: [110.3467, 41.4899], 北京: [116.4551, 40.2539], 北海: [109.314, 21.6211], 南京: [118.8062, 31.9208], 南宁: [108.479, 23.1152], 南昌: [116.0046, 28.6633], 南通: [121.1023, 32.1625], 厦门: [118.1689, 24.6478], 台州: [121.1353, 28.6688], 合肥: [117.29, 32.0581], 呼和浩特: [111.4124, 40.4901], 咸阳: [108.4131, 34.8706], 哈尔滨: [127.9688, 45.368], 唐山: [118.4766, 39.6826], 嘉兴: [120.9155, 30.6354], 大同: [113.7854, 39.8035], 大连: [122.2229, 39.4409], 天津: [117.4219, 39.4189], 太原: [112.3352, 37.9413], 威海: [121.9482, 37.1393], 宁波: [121.5967, 29.6466], 宝鸡: [107.1826, 34.3433], 宿迁: [118.5535, 33.7775], 常州: [119.4543, 31.5582], 广州: [113.5107, 23.2196], 廊坊: [116.521, 39.0509], 延安: [109.1052, 36.4252], 张家口: [115.1477, 40.8527], 徐州: [117.5208, 34.3268], 德州: [116.6858, 37.2107], 惠州: [114.6204, 23.1647], 成都: [103.9526, 30.7617], 扬州: [119.4653, 32.8162], 承德: [117.5757, 41.4075], 拉萨: [91.1865, 30.1465], 无锡: [120.3442, 31.5527], 日照: [119.2786, 35.5023], 昆明: [102.9199, 25.4663], 杭州: [119.5313, 29.8773], 枣庄: [117.323, 34.8926], 柳州: [109.3799, 24.9774], 株洲: [113.5327, 27.0319], 武汉: [114.3896, 30.6628], 汕头: [117.1692, 23.3405], 江门: [112.6318, 22.1484], 沈阳: [123.1238, 42.1216], 沧州: [116.8286, 38.2104], 河源: [114.917, 23.9722], 泉州: [118.3228, 25.1147], 泰安: [117.0264, 36.0516], 泰州: [120.0586, 32.5525], 济南: [117.1582, 36.8701], 济宁: [116.8286, 35.3375], 海口: [110.3893, 19.8516], 淄博: [118.0371, 36.6064], 淮安: [118.927, 33.4039], 深圳: [114.5435, 22.5439], 清远: [112.9175, 24.3292], 温州: [120.498, 27.8119], 渭南: [109.7864, 35.0299], 湖州: [119.8608, 30.7782], 湘潭: [112.5439, 27.7075], 滨州: [117.8174, 37.4963], 潍坊: [119.0918, 36.524], 烟台: [120.7397, 37.5128], 玉溪: [101.9312, 23.8898], 珠海: [113.7305, 22.1155], 盐城: [120.2234, 33.5577], 盘锦: [121.9482, 41.0449], 石家庄: [114.4995, 38.1006], 福州: [119.4543, 25.9222], 秦皇岛: [119.2126, 40.0232], 绍兴: [120.564, 29.7565], 聊城: [115.9167, 36.4032], 肇庆: [112.1265, 23.5822], 舟山: [122.2559, 30.2234], 苏州: [120.6519, 31.3989], 莱芜: [117.6526, 36.2714], 菏泽: [115.6201, 35.2057], 营口: [122.4316, 40.4297], 葫芦岛: [120.1575, 40.578], 衡水: [115.8838, 37.7161], 衢州: [118.6853, 28.8666], 西宁: [101.4038, 36.8207], 西安: [109.1162, 34.2004], 贵阳: [106.6992, 26.7682], 连云港: [119.1248, 34.552], 邢台: [114.8071, 37.2821], 邯郸: [114.4775, 36.535], 郑州: [113.4668, 34.6234], 鄂尔多斯: [108.9734, 39.2487], 重庆: [107.7539, 30.1904], 金华: [120.0037, 29.1028], 铜川: [109.0393, 35.1947], 银川: [106.3586, 38.1775], 镇江: [119.4763, 31.9702], 长春: [125.8154, 44.2584], 长沙: [113.0823, 28.2568], 长治: [112.8625, 36.4746], 阳泉: [113.4778, 38.0951], 青岛: [120.4651, 36.3373], 韶关: [113.7964, 24.7028] &#125;; var XAData = [ [&#123; name: &quot;西安&quot; &#125;, &#123; name: &quot;拉萨&quot;, value: 100 &#125;], [&#123; name: &quot;西安&quot; &#125;, &#123; name: &quot;上海&quot;, value: 100 &#125;], [&#123; name: &quot;西安&quot; &#125;, &#123; name: &quot;广州&quot;, value: 100 &#125;], [&#123; name: &quot;西安&quot; &#125;, &#123; name: &quot;西宁&quot;, value: 100 &#125;], [&#123; name: &quot;西安&quot; &#125;, &#123; name: &quot;银川&quot;, value: 100 &#125;] ]; var XNData = [ [&#123; name: &quot;西宁&quot; &#125;, &#123; name: &quot;北京&quot;, value: 100 &#125;], [&#123; name: &quot;西宁&quot; &#125;, &#123; name: &quot;上海&quot;, value: 100 &#125;], [&#123; name: &quot;西宁&quot; &#125;, &#123; name: &quot;广州&quot;, value: 100 &#125;], [&#123; name: &quot;西宁&quot; &#125;, &#123; name: &quot;西安&quot;, value: 100 &#125;], [&#123; name: &quot;西宁&quot; &#125;, &#123; name: &quot;银川&quot;, value: 100 &#125;] ]; var YCData = [ [&#123; name: &quot;拉萨&quot; &#125;, &#123; name: &quot;潍坊&quot;, value: 100 &#125;], [&#123; name: &quot;拉萨&quot; &#125;, &#123; name: &quot;哈尔滨&quot;, value: 100 &#125;], [&#123; name: &quot;银川&quot; &#125;, &#123; name: &quot;上海&quot;, value: 100 &#125;], [&#123; name: &quot;银川&quot; &#125;, &#123; name: &quot;西安&quot;, value: 100 &#125;], [&#123; name: &quot;银川&quot; &#125;, &#123; name: &quot;西宁&quot;, value: 100 &#125;] ]; var planePath = &quot;path://M1705.06,1318.313v-89.254l-319.9-221.799l0.073-208.063c0.521-84.662-26.629-121.796-63.961-121.491c-37.332-0.305-64.482,36.829-63.961,121.491l0.073,208.063l-319.9,221.799v89.254l330.343-157.288l12.238,241.308l-134.449,92.931l0.531,42.034l175.125-42.917l175.125,42.917l0.531-42.034l-134.449-92.931l12.238-241.308L1705.06,1318.313z&quot;; //var planePath = &#x27;arrow&#x27;; var convertData = function(data) &#123; var res = []; for (var i = 0; i &lt; data.length; i++) &#123; var dataItem = data[i]; var fromCoord = geoCoordMap[dataItem[0].name]; var toCoord = geoCoordMap[dataItem[1].name]; if (fromCoord &amp;&amp; toCoord) &#123; res.push(&#123; fromName: dataItem[0].name, toName: dataItem[1].name, coords: [fromCoord, toCoord], value: dataItem[1].value &#125;); &#125; &#125; return res; &#125;; var color = [&quot;#a6c84c&quot;, &quot;#ffa022&quot;, &quot;#46bee9&quot;]; //航线的颜色 var series = []; [ [&quot;西安&quot;, XAData], [&quot;西宁&quot;, XNData], [&quot;银川&quot;, YCData] ].forEach(function(item, i) &#123; series.push( &#123; name: item[0] + &quot; Top3&quot;, type: &quot;lines&quot;, zlevel: 1, effect: &#123; show: true, period: 6, trailLength: 0.7, color: &quot;red&quot;, //arrow箭头的颜色 symbolSize: 3 &#125;, lineStyle: &#123; normal: &#123; color: color[i], width: 0, curveness: 0.2 &#125; &#125;, data: convertData(item[1]) &#125;, &#123; name: item[0] + &quot; Top3&quot;, type: &quot;lines&quot;, zlevel: 2, symbol: [&quot;none&quot;, &quot;arrow&quot;], symbolSize: 10, effect: &#123; show: true, period: 6, trailLength: 0, symbol: planePath, symbolSize: 15 &#125;, lineStyle: &#123; normal: &#123; color: color[i], width: 1, opacity: 0.6, curveness: 0.2 &#125; &#125;, data: convertData(item[1]) &#125;, &#123; name: item[0] + &quot; Top3&quot;, type: &quot;effectScatter&quot;, coordinateSystem: &quot;geo&quot;, zlevel: 2, rippleEffect: &#123; brushType: &quot;stroke&quot; &#125;, label: &#123; normal: &#123; show: true, position: &quot;right&quot;, formatter: &quot;&#123;b&#125;&quot; &#125; &#125;, symbolSize: function(val) &#123; return val[2] / 8; &#125;, itemStyle: &#123; normal: &#123; color: color[i] &#125;, emphasis: &#123; areaColor: &quot;#2B91B7&quot; &#125; &#125;, data: item[1].map(function(dataItem) &#123; return &#123; name: dataItem[1].name, value: geoCoordMap[dataItem[1].name].concat([dataItem[1].value]) &#125;; &#125;) &#125; ); &#125;); var option = &#123; tooltip: &#123; trigger: &quot;item&quot;, formatter: function(params, ticket, callback) &#123; if (params.seriesType == &quot;effectScatter&quot;) &#123; return &quot;线路：&quot; + params.data.name + &quot;&quot; + params.data.value[2]; &#125; else if (params.seriesType == &quot;lines&quot;) &#123; return ( params.data.fromName + &quot;&gt;&quot; + params.data.toName + &quot;&lt;br /&gt;&quot; + params.data.value ); &#125; else &#123; return params.name; &#125; &#125; &#125;, legend: &#123; orient: &quot;vertical&quot;, top: &quot;bottom&quot;, left: &quot;right&quot;, data: [&quot;西安 Top3&quot;, &quot;西宁 Top3&quot;, &quot;银川 Top3&quot;], textStyle: &#123; color: &quot;#fff&quot; &#125;, selectedMode: &quot;multiple&quot; &#125;, geo: &#123; map: &quot;china&quot;, label: &#123; emphasis: &#123; show: true, color: &quot;#fff&quot; &#125; &#125;, // 把中国地图放大了1.2倍 zoom: 1.2, roam: true, itemStyle: &#123; normal: &#123; // 地图省份的背景颜色 areaColor: &quot;rgba(20, 41, 87,0.6)&quot;, borderColor: &quot;#195BB9&quot;, borderWidth: 1 &#125;, emphasis: &#123; areaColor: &quot;#2B91B7&quot; &#125; &#125; &#125;, series: series &#125;; myChart.setOption(option); // 监听浏览器缩放，图表对象调用缩放resize函数 window.addEventListener(&quot;resize&quot;, function() &#123; myChart.resize(); &#125;);&#125;)(); 二、由后端获取数据给Echarts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119$(document).ready(function() &#123; $.get(&quot;http://localhost:8080/video/findAll.do&quot;, function (data) &#123; var name_list = []; var num_list = []; for (var i = 0; i &lt; data.length; i++) &#123; var u = data[i]; for(var key in u)&#123; if (key == &quot;v_name&quot;) &#123; // alert(key); // alert(u[key]); name_list.push(u[key]) &#125; if (key == &quot;v_view&quot;) &#123; // alert(key); // alert(u[key]); num_list.push(u[key]) &#125; &#125; &#125; // alert(name_list[0]); // for (var name in name_list) &#123; 经过测试，发现数组不能使用这种遍历方式 // alert(name); // &#125; for (var i = 0; i &lt; name_list.length; i++) &#123; // alert(name_list[i]); &#125; // 柱状图模块1 (function() &#123; // 发现要用ajax取数据的话，应该写在响应回调里 alert(name_list.length) // 1实例化对象 var myChart = echarts.init(document.querySelector(&quot;.bar .chart&quot;)); // 2. 指定配置项和数据 var option = &#123; color: [&quot;#2f89cf&quot;], tooltip: &#123; trigger: &quot;axis&quot;, axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: &quot;shadow&quot; // 默认为直线，可选为：&#x27;line&#x27; | &#x27;shadow&#x27; &#125; &#125;, // 修改图表的大小 grid: &#123; left: &quot;0%&quot;, top: &quot;10px&quot;, right: &quot;0%&quot;, bottom: &quot;4%&quot;, containLabel: true &#125;, xAxis: [ &#123; type: &quot;category&quot;, data: name_list.slice(0, 7), axisTick: &#123; alignWithLabel: true &#125;, // 修改刻度标签 相关样式 axisLabel: &#123; color: &quot;rgba(255,255,255,.6) &quot;, fontSize: &quot;8&quot;, formatter: function (name) &#123; // do some thing return name.substring(0,3) &#125; &#125;, // 不显示x坐标轴的样式 axisLine: &#123; show: false &#125; &#125; ], yAxis: [ &#123; type: &quot;value&quot;, // 修改刻度标签 相关样式 axisLabel: &#123; color: &quot;rgba(255,255,255,.6) &quot;, fontSize: 12 &#125;, // y轴的线条改为了 2像素 axisLine: &#123; lineStyle: &#123; color: &quot;rgba(255,255,255,.1)&quot;, width: 2 &#125; &#125;, // y轴分割线的颜色 splitLine: &#123; lineStyle: &#123; color: &quot;rgba(255,255,255,.1)&quot; &#125; &#125; &#125; ], series: [ &#123; name: &quot;直接访问&quot;, type: &quot;bar&quot;, barWidth: &quot;35%&quot;, data: num_list.slice(0, 7), itemStyle: &#123; // 修改柱子圆角 barBorderRadius: 5 &#125; &#125; ] &#125;; // 3. 把配置项给实例对象 myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(&quot;resize&quot;, function() &#123; myChart.resize(); &#125;); &#125;)(); &#125;);&#125;) 把关于Echarts的代码写在ajax的响应回调中。 三、细节 如何格式化输出axisLabel参考： https://www.cnblogs.com/lxl0419/p/9081453.html","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"https://shadowbynl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://shadowbynl.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Ajax-Json","slug":"Ajax-Json","date":"2020-06-12T14:50:19.000Z","updated":"2020-06-13T08:52:53.045Z","comments":true,"path":"2020/06/12/Ajax-Json/","link":"","permalink":"https://shadowbynl.github.io/2020/06/12/Ajax-Json/","excerpt":"一、Json基础","text":"一、Json基础 基本规则123456789101112* 数据在名称/值对中：json数据是由键值对构成的 * 键用引号(单双都行)引起来，也可以不使用引号 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） &#123;&quot;persons&quot;:[&#123;&#125;,&#123;&#125;]&#125; 5. 对象（在花括号中） &#123;&quot;address&quot;:&#123;&quot;province&quot;：&quot;陕西&quot;....&#125;&#125; 6. null* 数据由逗号分隔：多个键值对由逗号分隔* 花括号保存对象：使用&#123;&#125;定义json 格式* 方括号保存数组：[] 获取数据1234567891011121314151617181920212223242526271. json对象.键名2. json对象[&quot;键名&quot;]3. 数组对象[索引]4. 遍历--------------------------------- //1.定义基本格式 var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &#x27;gender&#x27;: true&#125;; var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;]; //2.获取person对象中所有的键和值//for in 循环/* for(var key in person)&#123; //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]);&#125;*///3.获取ps中的所有值for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+&quot;:&quot;+p[key]); &#125;&#125; 三、Java中的Json解析 JSON解析器常见的解析器：Jsonlib，Gson，fastjson，jackson因为spring中集成了jackson，所以使用它进行json解析 转换方法12345678910111213141516171819201. 导入jackson的相关jar包2. 创建Jackson核心对象 ObjectMapper3. 调用ObjectMapper的相关方法进行转换1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致 测试代码与结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import domain.User;import org.junit.Test;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class JSONTest &#123; @Test public void test1() &#123; User user = new User(&quot;nnn&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;); ObjectMapper mapper = new ObjectMapper(); String result = &quot;&quot;; try &#123; // 测试java对象转换为json字符串 result = mapper.writeValueAsString(user); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; System.out.println(result); try &#123; // 测试json字符串转换为java对象 user = mapper.readValue(result, User.class); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(user.toString()); User user2 = user; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(user); userList.add(user2); try &#123; // 测试List&lt;Object&gt;转换为json字符串 System.out.println(mapper.writeValueAsString(userList)); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, &quot;张三&quot;); map.put(&quot;sex&quot;, &quot;男&quot;); try &#123; // 测试Map转换为json字符串 System.out.println(mapper.writeValueAsString(map)); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234&#123;&quot;status&quot;:0,&quot;message&quot;:null,&quot;id&quot;:null,&quot;username&quot;:&quot;nnn&quot;,&quot;password&quot;:&quot;1&quot;,&quot;phone&quot;:&quot;1&quot;,&quot;mail&quot;:&quot;1&quot;,&quot;createAt&quot;:&quot;2020年6月13日16时3分&quot;,&quot;updateAt&quot;:&quot;2020年6月13日16时3分&quot;&#125;User&#123;id=&#x27;null&#x27;, username=&#x27;nnn&#x27;, password=&#x27;1&#x27;, phone=&#x27;1&#x27;, mail=&#x27;1&#x27;, createAt=&#x27;2020年6月13日16时3分&#x27;, updateAt=&#x27;2020年6月13日16时3分&#x27;&#125;[&#123;&quot;status&quot;:0,&quot;message&quot;:null,&quot;id&quot;:null,&quot;username&quot;:&quot;nnn&quot;,&quot;password&quot;:&quot;1&quot;,&quot;phone&quot;:&quot;1&quot;,&quot;mail&quot;:&quot;1&quot;,&quot;createAt&quot;:&quot;2020年6月13日16时3分&quot;,&quot;updateAt&quot;:&quot;2020年6月13日16时3分&quot;&#125;,&#123;&quot;status&quot;:0,&quot;message&quot;:null,&quot;id&quot;:null,&quot;username&quot;:&quot;nnn&quot;,&quot;password&quot;:&quot;1&quot;,&quot;phone&quot;:&quot;1&quot;,&quot;mail&quot;:&quot;1&quot;,&quot;createAt&quot;:&quot;2020年6月13日16时3分&quot;,&quot;updateAt&quot;:&quot;2020年6月13日16时3分&quot;&#125;]&#123;&quot;sex&quot;:&quot;男&quot;,&quot;name&quot;:&quot;张三&quot;&#125; 测试过程中出现的问题与解决方法!!! JUnit version 3.8 or later expected:报错解决参考 https://blog.csdn.net/XYmar/article/details/96275926https://blog.csdn.net/niuniu1994/article/details/82814132将所用junit依赖上移 三、Java中 Ajax请求-Json响应在java这里，先说一下Ajax请求与Json响应的原理。注意Json的响应，必须是将数据转换为Json字符串的，java中利用springmvc的注解，可以使用注解标识，方法返回对象、列表类型均可，这是相对python处理的一个优点。为确定一般情况下的处理方式，进行了如下测试： 返回文本即dataType:”Text” 返回java对象 响应回调取值 返回java列表 响应回调遍历 1.测试代码 前端ajax请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 测试返回文本 url中无.do java&lt;input id=&quot;test&quot; url=&quot;http://localhost:8080/test/text&quot; type=&quot;button&quot; value=&quot;测试&quot;/&gt;测试返回java对象 java&lt;input id=&quot;test2&quot; url=&quot;http://localhost:8080/test/json&quot; type=&quot;button&quot; value=&quot;测试二&quot;/&gt;测试返回 返回列表对象 java&lt;input id=&quot;test3&quot; url=&quot;http://localhost:8080/test/json2&quot; type=&quot;button&quot; value=&quot;测试三&quot;/&gt;&lt;script src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function() &#123; $(&quot;#test&quot;).click(function () &#123; alert($(this).attr(&quot;url&quot;)); $.ajax(&#123; url:$(this).attr(&quot;url&quot;) , // 请求路径 type:&quot;GET&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 //data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(&quot;出错啦...&quot;) &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 &#125;); &#125;) $(&quot;#test2&quot;).click(function () &#123; alert($(this).attr(&quot;url&quot;)); var req_data = &#123; username: &quot;nnn&quot;, password: &quot;1&quot; &#125; $.get($(this).attr(&quot;url&quot;), req_data, function (data) &#123; for(var key in data)&#123; alert(key+&quot;:&quot;+data[key]); &#125; &#125;); &#125;) $(&quot;#test3&quot;).click(function () &#123; alert($(this).attr(&quot;url&quot;)); $.get($(this).attr(&quot;url&quot;), function (data) &#123; for (var i = 0; i &lt; data.length; i++) &#123; var u = data[i]; for(var key in u)&#123; alert(key+&quot;:&quot;+u[key]); &#125; &#125; &#125;); &#125;)&#125;)&lt;/script&gt; 后端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package controller;import dao.IUserDao;import domain.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.nio.charset.Charset;import java.util.List;@Controller@RequestMapping(&quot;/test&quot;)@CrossOriginpublic class AJTestController &#123; @Autowired private IUserDao userDao; @ResponseBody @RequestMapping(&quot;/text&quot;) public ResponseEntity&lt;String&gt; testText() throws Exception&#123; String content = &quot;测试返回文本&quot;; HttpHeaders responseHeaders = new HttpHeaders(); responseHeaders.setContentType(new MediaType(&quot;text&quot;,&quot;html&quot;, Charset.forName(&quot;UTF-8&quot;))); return new ResponseEntity&lt;String&gt;(content, responseHeaders, HttpStatus.OK); &#125; @ResponseBody @RequestMapping(&quot;/json&quot;) public User testJson(String username, String password) throws Exception&#123; User user = userDao.findUserByName(username); if (user == null) &#123; return new User(); &#125; System.out.println(user.getUsername()); return user; &#125; @ResponseBody @RequestMapping(&quot;/json2&quot;) public List&lt;User&gt; testJson2() throws Exception&#123; return userDao.findAll(); &#125;&#125;2.细节 当用$.ajax设置data或设置$.get的第二个参数时，注意无论是采用字典的方式或是”&amp;”连接串的方式，设置的都是请求参数，和Content-Type无关，和json处理无关。 当ajax请求中未指明dataType即响应数据类型时，具体响应数据类型由后端决定，是纯文本还是json由具体响应结果决定，即不设置dataType，后端代码中使用了@ResponseBody响应体就是json类型；但一旦设置为”text”或”json”，后端就必须响应相应类型的数据，否则是无法获取响应数据的。 3.总结由于springmvc注解的存在，使java对象转换为json字符串很容易，这是相对python处理的一个显著优点。 四、python中的json解析这里统一说一下python中json解析的一般方法和flask中的做法，以及flask为何采用自定的方法。1.python中的json模块json模块提供了四个功能：dumps、dump、loads、load，用于字符串 和 python数据类型间进行转换 json.loads()把Json格式字符串解码转换成Python对象 从json到python的类型转化对照如下： 1234567import jsonstrList = &#x27;[1, 2, 3, 4]&#x27;strDict = &#x27;&#123;&quot;city&quot;: &quot;北京&quot;, &quot;name&quot;: &quot;范爷&quot;&#125;&#x27;json.loads(strList) # [1, 2, 3, 4]json.loads(strDict) # json数据自动按Unicode存储# &#123;u&#x27;city&#x27;: u&#x27;\\u5317\\u4eac&#x27;, u&#x27;name&#x27;: u&#x27;\\u5927\\u732b&#x27;&#125; json.dumps()实现python类型转化为json字符串，返回一个str对象 把一个Python对象编码转换成Json字符串从python原始类型向json类型的转化对照如下： 1234567891011121314151617181920import jsonlistStr = [1, 2, 3, 4]tupleStr = (1, 2, 3, 4)dictStr = &#123;&quot;city&quot;: &quot;北京&quot;, &quot;name&quot;: &quot;范爷&quot;&#125;json.dumps(listStr)# &#x27;[1, 2, 3, 4]&#x27;json.dumps(tupleStr)# &#x27;[1, 2, 3, 4]&#x27;# 注意：json.dumps() 序列化时默认使用的ascii编码# 添加参数 ensure_ascii=False 禁用ascii编码，按utf-8编码json.dumps(dictStr) # &#x27;&#123;&quot;city&quot;: &quot;\\\\u5317\\\\u4eac&quot;, &quot;name&quot;: &quot;\\\\u5927\\\\u5218&quot;&#125;&#x27;print(json.dumps(dictStr, ensure_ascii=False))# &#123;&quot;city&quot;: &quot;北京&quot;, &quot;name&quot;: &quot;范爷&quot;&#125; json.dump()将Python内置类型序列化为json对象后写入文件 1234567import jsonlistStr = [&#123;&quot;city&quot;: &quot;北京&quot;&#125;, &#123;&quot;name&quot;: &quot;范爷&quot;&#125;]json.dump(listStr, open(&quot;listStr.json&quot;,&quot;w&quot;), ensure_ascii=False)dictStr = &#123;&quot;city&quot;: &quot;北京&quot;, &quot;name&quot;: &quot;范爷&quot;&#125;json.dump(dictStr, open(&quot;dictStr.json&quot;,&quot;w&quot;), ensure_ascii=False) json.load()读取文件中json形式的字符串元素 转化成python类型 12345678910import jsonstrList = json.load(open(&quot;listStr.json&quot;))print(strList)# [&#123;u&#x27;city&#x27;: u&#x27;\\u5317\\u4eac&#x27;&#125;, &#123;u&#x27;name&#x27;: u&#x27;\\u5927\\u5218&#x27;&#125;]strDict = json.load(open(&quot;dictStr.json&quot;))print(strDict)# &#123;u&#x27;city&#x27;: u&#x27;\\u5317\\u4eac&#x27;, u&#x27;name&#x27;: u&#x27;\\u5927\\u5218&#x27;&#125; 2.使用JsonPath解析Json字符串具体在数据解析篇中介绍。 1234567JsonPath 是一种信息抽取类库，是从JSON文档中抽取指定信息的工具，提供多种语言实现版本，包括：Javascript, Python， PHP 和 Java。JsonPath 对于 JSON 来说，相当于 XPATH 对于 XML。安装方法：`pip install jsonpath`官方文档：http://goessner.net/articles/JsonPath 3.flask中处理python的过程 123456789# jsonify 与 json.dumps 作用类似 把python json对象（字典）转换为 json字符串 但两者处理返回的 Content-Type不同# 前端请求时 contentType: &quot;application/json&quot; 实则请求体中的定义按字典来（这个说法是错的） 但后端接收的应该是json字符串# 后端处理时 需先用 request.get_json() 转换为字典对象 再取值# 经过测试 get请求设置的那些 data 不管是以 &amp; 拼接的 还是传入字典 其类似都和json无关 只是普通的请求参数 python后端通过request.args获取# 只有 post请求时 且 contentType: &quot;application/json&quot; 才为请求体中要求是 json数据 且一定注意 需要将字典对象 用 JSON.stringify 转换为json字符串# 综上 请求和响应的处理其实是一致的 传送的必须是 json 字符串 若想取里面的值需要转换成json对象（字典）# 后端flask需要用 get_json() 前端 当把 dataType设置为 json时 其即会自动处理为json对象# 其实根据 java的测试来看 dataType设置不是关键的 关键是后端如何响应 如果不设置 该返回什么还是会返回什么# 但一旦设置了dataType 就必须一致 4.对比 python中json模块的dumps方法和flask的jsonify方法https://www.jianshu.com/p/a25357f2d930 js中的stringify方法和上述两方法作用类似 python中json模块的loads方法和flask的request.get_json()方法 五、python中 Ajax请求-Json响应主要说明使用flask框架的情况。get方法和java类似，但post方法一定注意csrf验证的问题；且python flask相对ssm一个很大的缺陷就是没有方法将对象、列表之类的直接转换为json字符串，需要自行先对对象进行序列化处理。为确定一般情况下的处理方式，进行了如下测试： ajax get请求 ajax post请求 返回对象/列表的情况 1.测试代码前端ajax请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263测试 get python&lt;input id=&quot;test4&quot; url=&quot;http://localhost:5000/api/v1.0/test&quot; type=&quot;button&quot; value=&quot;测试四&quot;/&gt;测试 post python&lt;input id=&quot;test5&quot; url=&quot;http://localhost:5000/api/v1.0/test&quot; type=&quot;button&quot; value=&quot;测试五&quot;/&gt;测试 返回 对象/列表转成的json对象&lt;input id=&quot;test6&quot; url=&quot;http://localhost:5000/api/v1.0/test2&quot; type=&quot;button&quot; value=&quot;测试六&quot;/&gt;&lt;script src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function() &#123; $(&quot;#test4&quot;).click(function () &#123; alert($(this).attr(&quot;url&quot;)); var req_data = &#123; username: &quot;nnn&quot;, password: &quot;1&quot; &#125; $.get($(this).attr(&quot;url&quot;), req_data, function (data) &#123; alert(data); &#125;); &#125;) function getCookie(name) &#123; var r = document.cookie.match(&quot;\\\\b&quot; + name + &quot;=([^;]*)\\\\b&quot;); return r ? r[1] : undefined; &#125; $(&quot;#test5&quot;).click(function () &#123; alert($(this).attr(&quot;url&quot;)); var req_data = &#123; username: &quot;nnn&quot;, password: &quot;1&quot; &#125; var req_json = JSON.stringify(req_data); $.ajax(&#123; url: $(this).attr(&quot;url&quot;), type: &quot;post&quot;, data: req_json, contentType: &quot;application/json&quot;, // dataType: &quot;json&quot;, headers: &#123; &quot;X-CSRFToken&quot;: getCookie(&quot;csrf_token&quot;) &#125;, // 请求头，将csrf_token值放到请求中，方便后端csrf进行验证 success: function (resp) &#123; alert(resp); alert(resp.msg) &#125; &#125;) &#125;) $(&quot;#test6&quot;).click(function () &#123; alert($(this).attr(&quot;url&quot;)); $.get($(this).attr(&quot;url&quot;), function (data) &#123; for (var i = 0; i &lt; data.length; i++) &#123; var u = data[i]; for(var key in u)&#123; alert(key+&quot;:&quot;+u[key]); &#125; &#125; &#125;); &#125;) &#125;)&lt;/script&gt; 后端flask视图函数 12345678910111213141516171819202122232425262728293031323334from . import apifrom flask import jsonify, requestfrom ihome.models import User# jsonify 与 json.dumps 作用类似 把python json对象（字典）转换为 json字符串 但两者处理返回的 Content-Type不同# 前端请求时 contentType: &quot;application/json&quot; 实则请求体中的定义按字典来（这个说法是错的） 但后端接收的应该是json字符串# 后端处理时 需先用 request.get_json() 转换为字典对象 再取值# 经过测试 get请求设置的那些 data 不管是以 &amp; 拼接的 还是传入字典 其类似都和json无关 只是普通的请求参数 python后端通过request.args获取# 只有 post请求时 且 contentType: &quot;application/json&quot; 才为请求体中要求是 json数据 且一定注意 需要将字典对象 用 JSON.stringify 转换为json字符串# 综上 请求和响应的处理其实是一致的 传送的必须是 json 字符串 若想取里面的值需要转换成json对象（字典）# 后端flask需要用 get_json() 前端 当把 dataType设置为 json时 其即会自动处理为json对象# 其实根据 java的测试来看 dataType设置不是关键的 关键是后端如何响应 如果不设置 该返回什么还是会返回什么# 但一旦设置了dataType 就必须一致@api.route(&quot;/test&quot;, methods=[&quot;POST&quot;, &quot;GET&quot;])def test_json(): print(&quot;test&quot;) print(request.get_json()) # return &quot;hello&quot; return jsonify(msg=&quot;hello&quot;)# 序列化对象def serialize(model): from sqlalchemy.orm import class_mapper columns = [c.key for c in class_mapper(model.__class__).columns] return dict((c, getattr(model, c)) for c in columns)@api.route(&quot;/test2&quot;, methods=[&quot;POST&quot;, &quot;GET&quot;])def test_json_object(): user_list = User.query.all() for i in range(len(user_list)): user_list[i] = serialize(user_list[i]) print(user_list) return jsonify(user_list) 2.细节说明 java中的get和post请求参数和请求体的区别、dataType的设置等同 当请求方法为post，且contentType: “application/json”时，需要请求体中为json字符串，需将定义的字典用js中的JSON.stringify转换为json字符串 序列化python自定义类的方法 3.序列化python自定义对象的方法参考：https://www.baidu.com/s?wd=%E6%80%8E%E6%A0%B7%E5%B0%86python%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%BA%E5%8F%AFjson%E5%BA%8F%E5%88%97%E5%8C%96&amp;rsv_spt=1&amp;rsv_iqid=0xef52e02a0016d473&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=57&amp;rsv_sug1=16&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=23331&amp;rsv_sug4=24614https://blog.csdn.net/weixin_30670151/article/details/97388207https://blog.csdn.net/xuelians/article/details/79999275https://blog.csdn.net/weixin_41431904/article/details/80733600https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=flask%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1&amp;fenlei=256&amp;rsv_pq=9269d48900010ebb&amp;rsv_t=6d28cuzG5OZ6ZbTQBO2Uf9NWwP54HKc0OrWY1MrdcgcayGwRFoF82cTYQaE&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=17&amp;rsv_sug1=20&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=i&amp;prefixsug=flask%25E8%25BF%2594%25E5%259B%259E%25E5%25AF%25B9%25E8%25B1%25A1&amp;rsp=1&amp;inputT=10815&amp;rsv_sug4=10816https://blog.csdn.net/qq_43665151/article/details/103969991https://blog.csdn.net/u011205177/article/details/31775133https://blog.csdn.net/fanyunlei/article/details/31775133https://blog.csdn.net/weixin_33995481/article/details/89371518https://blog.csdn.net/baidu_30809315/article/details/86686413 https://www.baidu.com/s?wd=jsonify%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1&amp;rsv_spt=1&amp;rsv_iqid=0xc7fd38c0001541cb&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;oq=python%25E5%25AF%25B9%25E8%25B1%25A1%2520JSON%2520serializable&amp;rsv_btype=t&amp;inputT=17048&amp;rsv_t=54a2mgS05wbRRO0Tc7JK2a1HhOoF%2B5%2Fl3FA6f55WAx1J8YcodcspBzx6abZf0k6W2nbF&amp;rsv_sug3=74&amp;rsv_pq=c886278d0014b3a7&amp;rsv_sug1=24&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=18114https://blog.csdn.net/JENREY/article/details/87715651https://blog.csdn.net/t8116189520/article/details/91562915https://blog.csdn.net/u012887259/article/details/103345128https://www.jianshu.com/p/bf3f9078af74https://blog.csdn.net/qq_42226324/article/details/82989304https://www.baidu.com/s?wd=python%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90json&amp;rsv_spt=1&amp;rsv_iqid=0xbe54345400280b02&amp;issp=1&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=ts_1&amp;rsv_sug3=25&amp;rsv_sug1=18&amp;rsv_sug7=101&amp;rsv_sug2=1&amp;rsv_btype=i&amp;prefixsug=python%25E5%25B0%2586%25E5%25AF%25B9%25E8%25B1%25A1zhuan&amp;rsp=1&amp;inputT=9836&amp;rsv_sug4=10597https://www.cnblogs.com/qttblog/p/8615205.htmlhttps://www.cnblogs.com/qiumingcheng/p/11589657.html 最终参考：https://blog.csdn.net/baidu_30809315/article/details/86686413 代码： 123456def serialize(model): from sqlalchemy.orm import class_mapper columns = [c.key for c in class_mapper(model.__class__).columns] return dict((c, getattr(model, c)) for c in columns) # 参数为自定义类的对象","categories":[{"name":"写法","slug":"写法","permalink":"https://shadowbynl.github.io/categories/%E5%86%99%E6%B3%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://shadowbynl.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"flask-study-2","slug":"flask-study-2","date":"2020-06-09T09:14:14.000Z","updated":"2020-06-14T15:42:32.959Z","comments":true,"path":"2020/06/09/flask-study-2/","link":"","permalink":"https://shadowbynl.github.io/2020/06/09/flask-study-2/","excerpt":"黑马ihome项目 其一","text":"黑马ihome项目 其一 一、项目文件目录结构搭建1.单一全依赖manage.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# coding:utf-8from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyfrom flask_session import Sessionfrom flask_wtf import CSRFProtectimport redisapp = Flask(__name__)class Config: &quot;&quot;&quot;配置信息&quot;&quot;&quot; DEBUG = True SECRET_KEY = &quot;nlby33068080&quot; # 数据库 SQLALCHEMY_DATABASE_URI = &quot;mysql://root:6774258@127.0.0.1:3306/ihome_nlby&quot; SQLALCHEMY_TRACK_MODIFICATIONS = True # redis REDIS_HOST = &quot;127.0.0.1&quot; REDIS_PORT = 6379 # flask-session配置 SESSION_TYPE = &quot;redis&quot; SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) # 连接的redis实例 SESSION_USER_SIGNER = True # 对cookie中session_id进行隐藏处理 PERMANENT_SESSION_LIFETIME = 86400 # session数据的有效期 单位秒app.config.from_object(Config)# 数据库db = SQLAlchemy(app)# 创建redis连接对象redis_store = redis.StrictRedis(host=Config.REDIS_HOST, port=Config.REDIS_PORT)# 利用flask-session 将session数据保存到redis中Session(app)# 为flask补充csrf防护 只要有post请求 就需要crsf防护CSRFProtect(app)@app.route(&quot;/index&quot;)def index(): return &quot;hello&quot;if __name__ == &#x27;__main__&#x27;: app.run() 2.拆分–项目结构（一）工程根目录manage.py 工程入口模块 12345678910111213from ihome import create_app, dbfrom flask_script import Managerfrom flask_migrate import Migrate, MigrateCommand# 创建flask应用对象app = create_app(&quot;develop&quot;)manager = Manager(app)Migrate(app, db)manager.add_command(&quot;db&quot;, MigrateCommand)if __name__ == &#x27;__main__&#x27;: manager.run() config.py 配置类 123456789101112131415161718192021222324252627282930313233import redisclass Config: &quot;&quot;&quot;配置信息&quot;&quot;&quot; SECRET_KEY = &quot;nlby33068080&quot; # 数据库 SQLALCHEMY_DATABASE_URI = &quot;mysql://root:6774258@127.0.0.1:3306/ihome_nlby&quot; SQLALCHEMY_TRACK_MODIFICATIONS = True # redis REDIS_HOST = &quot;127.0.0.1&quot; REDIS_PORT = 6379 # flask-session配置 SESSION_TYPE = &quot;redis&quot; SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) # 连接的redis实例 SESSION_USER_SIGNER = True # 对cookie中session_id进行隐藏处理 PERMANENT_SESSION_LIFETIME = 86400 # session数据的有效期 单位秒class DevelopmentConfig(Config): &quot;&quot;&quot;开发环境的配置信息&quot;&quot;&quot; DEBUG = Trueclass ProductionConfig(Config): &quot;&quot;&quot;生产环境的配置信息&quot;&quot;&quot; passconfig_map = &#123; &quot;develop&quot;: DevelopmentConfig, &quot;product&quot;: ProductionConfig&#125; （二）工程实现包ihomeinit.py 进行所有的app初始化 设置用到的全局变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from flask import Flaskfrom config import *from flask_sqlalchemy import SQLAlchemyfrom flask_session import Sessionfrom flask_wtf import CSRFProtectimport redisimport loggingfrom logging.handlers import RotatingFileHandler# 数据库db = SQLAlchemy()# 创建redis连接对象redis_store = None# 配置日志信息# 创建日志记录器，指明日志保存的路径、每个日志文件的最大大小、保存的日志文件个数上限file_log_handler = RotatingFileHandler(&quot;logs/log&quot;, maxBytes=1024*1024*100, backupCount=10)# 创建日志记录的格式 日志等级 输入日志信息的文件名 行数 日志信息formatter = logging.Formatter(&#x27;%(levelname)s %(filename)s:%(lineno)d %(message)s&#x27;)# 为刚创建的日志记录器设置日志记录格式file_log_handler.setFormatter(formatter)# 为全局的日志工具对象（flask app使用的）添加日记录器logging.getLogger().addHandler(file_log_handler)# 设置日志的记录等级logging.basicConfig(level=logging.DEBUG) # 调试debug级logging.error(&quot;&quot;) # 错误级别logging.warn(&quot;&quot;) # 警告级别logging.info(&quot;&quot;) # 消息提示级别logging.debug(&quot;&quot;) # 调试级别# 工厂模式def create_app(config_name): &quot;&quot;&quot; 创建flask的应用对象 :param config_name: str 配置模式的名字 (&quot;develop&quot;, &quot;product&quot;) :return: &quot;&quot;&quot; app = Flask(__name__) # 根据配置模式的名字获取配置参数的类 config_class = config_map.get(config_name) app.config.from_object(config_class) # 使用app初始化db db.init_app(app) # 初始化redis工具 global redis_store redis_store = redis.StrictRedis(host=config_class.REDIS_HOST, port=config_class.REDIS_PORT) # 利用flask-session 将session数据保存到redis中 Session(app) # 为flask补充csrf防护 只要有post请求 就需要crsf防护 CSRFProtect(app) from ihome import api_1_0 # 注册蓝图 app.register_blueprint(api_1_0.api, url_prefix=&quot;/api/v1.0&quot;) return app models.py 模型类模块api_1_0 1.0蓝图的视图存放目录api_1_0/init.py 1.0版本蓝图的创建 12345678from flask import Blueprint# 创建蓝图对象api = Blueprint(&quot;api_1_0&quot;, __name__)# 导入蓝图的视图from . import demo api_1_0/views.py 1.0版本的视图函数模块 123456from . import api@api.route(&quot;/index&quot;)def index(): return &quot;hello&quot; libs 存放外界依赖的目录utils 工具包static 静态资源文件（三）logs 存放日志文件 二、数据库设计1.数据库设计2.根据设计创建模型类3.迁移 12345python manage.py db initpython manage.py db migrate -m &quot;init tables&quot;python manage.py db upgrade 三、静态文件接口1.前后端分离与不分离的方式2.静态文件蓝图3.csrf防护机制与生成 四、图片验证码1.生成图片验证码的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#!/usr/bin/env python# -*- coding: utf-8 -*-# refer to `https://bitbucket.org/akorn/wheezy.captcha`import randomimport stringimport os.pathfrom io import BytesIOfrom PIL import Imagefrom PIL import ImageFilterfrom PIL.ImageDraw import Drawfrom PIL.ImageFont import truetypeclass Bezier: def __init__(self): self.tsequence = tuple([t / 20.0 for t in range(21)]) self.beziers = &#123;&#125; def pascal_row(self, n): &quot;&quot;&quot; Returns n-th row of Pascal&#x27;s triangle &quot;&quot;&quot; result = [1] x, numerator = 1, n for denominator in range(1, n // 2 + 1): x *= numerator x /= denominator result.append(x) numerator -= 1 if n &amp; 1 == 0: result.extend(reversed(result[:-1])) else: result.extend(reversed(result)) return result def make_bezier(self, n): &quot;&quot;&quot; Bezier curves: http://en.wikipedia.org/wiki/B%C3%A9zier_curve#Generalization &quot;&quot;&quot; try: return self.beziers[n] except KeyError: combinations = self.pascal_row(n - 1) result = [] for t in self.tsequence: tpowers = (t ** i for i in range(n)) upowers = ((1 - t) ** i for i in range(n - 1, -1, -1)) coefs = [c * a * b for c, a, b in zip(combinations, tpowers, upowers)] result.append(coefs) self.beziers[n] = result return resultclass Captcha(object): def __init__(self): self._bezier = Bezier() self._dir = os.path.dirname(__file__) # self._captcha_path = os.path.join(self._dir, &#x27;..&#x27;, &#x27;static&#x27;, &#x27;captcha&#x27;) @staticmethod def instance(): if not hasattr(Captcha, &quot;_instance&quot;): Captcha._instance = Captcha() return Captcha._instance def initialize(self, width=200, height=75, color=None, text=None, fonts=None): # self.image = Image.new(&#x27;RGB&#x27;, (width, height), (255, 255, 255)) self._text = text if text else random.sample(string.ascii_uppercase + string.ascii_uppercase + &#x27;3456789&#x27;, 4) self.fonts = fonts if fonts else \\ [os.path.join(self._dir, &#x27;fonts&#x27;, font) for font in [&#x27;Arial.ttf&#x27;, &#x27;Georgia.ttf&#x27;, &#x27;actionj.ttf&#x27;]] self.width = width self.height = height self._color = color if color else self.random_color(0, 200, random.randint(220, 255)) @staticmethod def random_color(start, end, opacity=None): red = random.randint(start, end) green = random.randint(start, end) blue = random.randint(start, end) if opacity is None: return red, green, blue return red, green, blue, opacity # draw image def background(self, image): Draw(image).rectangle([(0, 0), image.size], fill=self.random_color(238, 255)) return image @staticmethod def smooth(image): return image.filter(ImageFilter.SMOOTH) def curve(self, image, width=4, number=6, color=None): dx, height = image.size dx /= number path = [(dx * i, random.randint(0, height)) for i in range(1, number)] bcoefs = self._bezier.make_bezier(number - 1) points = [] for coefs in bcoefs: points.append(tuple(sum([coef * p for coef, p in zip(coefs, ps)]) for ps in zip(*path))) Draw(image).line(points, fill=color if color else self._color, width=width) return image def noise(self, image, number=50, level=2, color=None): width, height = image.size dx = width / 10 width -= dx dy = height / 10 height -= dy draw = Draw(image) for i in range(number): x = int(random.uniform(dx, width)) y = int(random.uniform(dy, height)) draw.line(((x, y), (x + level, y)), fill=color if color else self._color, width=level) return image def text(self, image, fonts, font_sizes=None, drawings=None, squeeze_factor=0.75, color=None): color = color if color else self._color fonts = tuple([truetype(name, size) for name in fonts for size in font_sizes or (65, 70, 75)]) draw = Draw(image) char_images = [] for c in self._text: font = random.choice(fonts) c_width, c_height = draw.textsize(c, font=font) char_image = Image.new(&#x27;RGB&#x27;, (c_width, c_height), (0, 0, 0)) char_draw = Draw(char_image) char_draw.text((0, 0), c, font=font, fill=color) char_image = char_image.crop(char_image.getbbox()) for drawing in drawings: d = getattr(self, drawing) char_image = d(char_image) char_images.append(char_image) width, height = image.size offset = int((width - sum(int(i.size[0] * squeeze_factor) for i in char_images[:-1]) - char_images[-1].size[0]) / 2) for char_image in char_images: c_width, c_height = char_image.size mask = char_image.convert(&#x27;L&#x27;).point(lambda i: i * 1.97) image.paste(char_image, (offset, int((height - c_height) / 2)), mask) offset += int(c_width * squeeze_factor) return image # draw text @staticmethod def warp(image, dx_factor=0.27, dy_factor=0.21): width, height = image.size dx = width * dx_factor dy = height * dy_factor x1 = int(random.uniform(-dx, dx)) y1 = int(random.uniform(-dy, dy)) x2 = int(random.uniform(-dx, dx)) y2 = int(random.uniform(-dy, dy)) image2 = Image.new(&#x27;RGB&#x27;, (width + abs(x1) + abs(x2), height + abs(y1) + abs(y2))) image2.paste(image, (abs(x1), abs(y1))) width2, height2 = image2.size return image2.transform( (width, height), Image.QUAD, (x1, y1, -x1, height2 - y2, width2 + x2, height2 + y2, width2 - x2, -y1)) @staticmethod def offset(image, dx_factor=0.1, dy_factor=0.2): width, height = image.size dx = int(random.random() * width * dx_factor) dy = int(random.random() * height * dy_factor) image2 = Image.new(&#x27;RGB&#x27;, (width + dx, height + dy)) image2.paste(image, (dx, dy)) return image2 @staticmethod def rotate(image, angle=25): return image.rotate( random.uniform(-angle, angle), Image.BILINEAR, expand=1) def captcha(self, path=None, fmt=&#x27;JPEG&#x27;): &quot;&quot;&quot;Create a captcha. Args: path: save path, default None. fmt: image format, PNG / JPEG. Returns: A tuple, (name, text, StringIO.value). For example: (&#x27;fXZJN4AFxHGoU5mIlcsdOypa&#x27;, &#x27;JGW9&#x27;, &#x27;\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r...&#x27;) &quot;&quot;&quot; image = Image.new(&#x27;RGB&#x27;, (self.width, self.height), (255, 255, 255)) image = self.background(image) image = self.text(image, self.fonts, drawings=[&#x27;warp&#x27;, &#x27;rotate&#x27;, &#x27;offset&#x27;]) image = self.curve(image) image = self.noise(image) image = self.smooth(image) name = &quot;&quot;.join(random.sample(string.ascii_lowercase + string.ascii_uppercase + &#x27;3456789&#x27;, 24)) text = &quot;&quot;.join(self._text) out = BytesIO() image.save(out, format=fmt) if path: image.save(os.path.join(path, name), fmt) return name, text, out.getvalue() def generate_captcha(self): self.initialize() return self.captcha(&quot;&quot;)captcha = Captcha.instance()if __name__ == &#x27;__main__&#x27;: print (captcha.generate_captcha()) 2.获取图片验证码的逻辑 五、短信验证码1.云通讯sdk使用参考 https://blog.csdn.net/kk907528318/article/details/98250009https://www.yuntongxun.com/2.短信验证码相关的逻辑 六、注册登录 个人信息1.密码加密方法2.csrf设置3.登录验证装饰器4.使用七牛云sdk上传图片5.修改用户名6.获取个人资料7.实名认证","categories":[{"name":"Flask","slug":"Flask","permalink":"https://shadowbynl.github.io/categories/Flask/"}],"tags":[{"name":"PythonWeb","slug":"PythonWeb","permalink":"https://shadowbynl.github.io/tags/PythonWeb/"}]},{"title":"flask-study-1","slug":"flask-study-1","date":"2020-06-07T07:21:44.000Z","updated":"2020-06-07T07:55:06.491Z","comments":true,"path":"2020/06/07/flask-study-1/","link":"","permalink":"https://shadowbynl.github.io/2020/06/07/flask-study-1/","excerpt":"Flask的基本学习包括视图、模板、数据库、测试与部署四部分。","text":"Flask的基本学习包括视图、模板、数据库、测试与部署四部分。 大概看了一遍之后，感到用Python写，真的要简化很多，实现一些功能要快很多，而且其项目文件结构和模板语法乃至数据库迁移和springboot项目是类似的。 一、建立一个Flask项目的流程1.如果是一个很简单的，用单文件写的小项目第一步，通用配置 1234567891011121314151617181920212223from flask import Flask, render_template, request, redirect, url_for, jsonifyfrom flask_sqlalchemy import SQLAlchemyfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredapp = Flask(__name__)class Config(object): # sqlalchemy的配置参数 SQLALCHEMY_DATABASE_URI = &quot;mysql://root:mysql@127.0.0.1:3306/flask&quot; # 设置sqlalchemy自动更跟踪数据库 SQLALCHEMY_TRACK_MODIFICATIONS = True SECRET_KEY = &quot;doiso7fd89fyd9^(fsd&quot;app.config.from_object(Config)db = SQLAlchemy(app) 第二步，定义数据库模型类，并初始化数据库表 1234567891011121314151617181920# 定义数据库的模型class Author(db.Model): &quot;&quot;&quot;作者&quot;&quot;&quot; __tablename__ = &quot;tbl_authors&quot; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(32), unique=True) books = db.relationship(&quot;Book&quot;, backref=&quot;author&quot;)class Book(db.Model): &quot;&quot;&quot;书籍&quot;&quot;&quot; __tablename__ = &quot;tbl_books&quot; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) author_id = db.Column(db.Integer, db.ForeignKey(&quot;tbl_authors.id&quot;))db.drop_all()db.create_all() 第三步，定义视图函数框架，定义模板（可能需要定义表单模型类） 123456789101112131415161718192021222324# 创建表单模型类class AuthorBookForm(FlaskForm): &quot;&quot;&quot;作者数据表单模型类&quot;&quot;&quot; author_name = StringField(label=u&quot;作者&quot;, validators=[DataRequired(u&quot;作者必填&quot;)]) book_name = StringField(label=u&quot;书籍&quot;, validators=[DataRequired(u&quot;书籍必填&quot;)]) submit = SubmitField(label=u&quot;保存&quot;) &lt;form method=&quot;post&quot;&gt; &#123;&#123; form.csrf_token &#125;&#125; &#123;&#123; form.author_name.label &#125;&#125; &lt;p&gt;&#123;&#123;form.author_name&#125;&#125;&lt;/p&gt; &#123;% for msg in form.author_name.errors %&#125; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &#123;&#123; form.book_name.label &#125;&#125; &lt;p&gt;&#123;&#123;form.book_name&#125;&#125;&lt;/p&gt; &#123;% for msg in form.book_name.errors %&#125; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &#123;&#123; form.submit &#125;&#125; &lt;/form&gt; 第四步，完善视图函数逻辑。第五步，测试与部署。 2.如果是较复杂的，需要分为多个模块的项目，就要使用蓝图。根据设计确定好模块，则其后需要在每个模块中创建蓝图对象，创建相关视图对象，其他步骤类似。 12345678910111213141516# 在每个模块中创建蓝图对象from flask import Blueprint# 1. 创建蓝图对象app_goods = Blueprint(&quot;goods&quot;, __name__)# 2. 创建蓝图的视图函数@app_goods.route(&quot;/get_goods&quot;)def get_goods(): return &quot;get goods page&quot; # 在应用主文件中注册蓝图app.register_blueprint(app_goods, url_prefix=&quot;/goods&quot;) 二、几个关键点1.关于项目结构根目录下static 存放 js css img等静态资源文件templates 存放html模板文件 通过render_template渲染这两个都是默认目录，在创建app时可自定义2.关于部署使用 gunicorn3.关于模板模板语法4.flask模块、对象与扩展 Flask, render_template, request, redirect, url_for, jsonify, current_app, make_response, session config flask_script &emsp; flask_wtf &emsp; flask-sqlalchemy &emsp; flask_migrate &emsp; flask_mail 5.其他 用到表单和session需要在app.config中设置SECRET_KEY","categories":[{"name":"Flask","slug":"Flask","permalink":"https://shadowbynl.github.io/categories/Flask/"}],"tags":[{"name":"PythonWeb","slug":"PythonWeb","permalink":"https://shadowbynl.github.io/tags/PythonWeb/"}]},{"title":"css-study-1","slug":"css-study-1","date":"2020-06-01T08:09:10.000Z","updated":"2020-06-01T08:39:30.275Z","comments":true,"path":"2020/06/01/css-study-1/","link":"","permalink":"https://shadowbynl.github.io/2020/06/01/css-study-1/","excerpt":"黑马前端 学成在线案例（盒子+浮动）","text":"黑马前端 学成在线案例（盒子+浮动） 总体心得 首先，事先根据标准流在纵向分成大致几个部分，如案例中 的header banner goods box footer五个部分；然后对每个行细分列，这些列的排布都是浮动实现的；要仿制网站的话，首先要看情况切图，在visio上画好每个块。 css有一些通用的代码，如去除内外边距、清除浮动、去除链接下划线，可以事先写出来。实际编写时，先写好该部分的html代码，然后写最外层盒子的样式，写好后对其中的每个列块，直接先确定浮动方式、宽高，注意宽高除了内容需要动态变化的移动需要指定。这些确定后，大致布局确定，然后再具体写每个列小盒子内容的样式。 对我而言，一个难点是确定margin，并不能根据设计图准确地确定margin；还有就是当多个类型标签嵌套时，不清楚该给谁样式，如li套a，那么样式该给li还是a，不好确定。 局部问题 nav和subnav样式设置的区别1234567891011121314151617181920212223242526272829303132333435363738394041424344.nav &#123; float: left;&#125;.nav ul li &#123; float: left;&#125;.nav ul li a &#123; display: block; height: 40px; padding: 0 10px; margin-right: 20px; line-height: 40px; font-size: 18px; color: #050505; text-decoration: none;&#125;/*鼠标经过链接 才有底边框*/.nav ul li a:hover &#123; border-bottom: 2px solid #00a4ff;&#125;.subnav &#123; float: left; width: 150px; height: 420px; padding: 0 20px; /*背景半透明*/ background: rgba(0, 0, 0, .3);&#125;.subnav li &#123; height: 45px; line-height: 45px;&#125;.subnav li a &#123; color: #fff; font-size: 14px; text-decoration: none;&#125;.subnav li a:hover &#123; color: #00b4ff;&#125;.subnav span &#123; float: right;&#125; course中多行文本（不同标签）的显示1234567891011121314151617181920212223.course-bd &#123; /*没有宽度的盒子 padding 不会撑开盒子*/ padding: 0 15px;&#125;.course-bd ul &#123; /*外边距塌陷的问题 margin-top: 10px;*/ padding-top: 10px;&#125;.course-bd li &#123; /*行高等与高度 只能让单行文本垂直居中*/ height: 50px; border-bottom: 1px solid #ccc; margin-top: 10px;&#125;.course-bd li h4 &#123; font-size: 14px; color: #4e4e4e;&#125;.course-bd li p &#123; font-size: 12px; color: #a5a5a5;&#125; box-bd细节设置，为保证内容动态添加不设高度，因此必须清楚浮动1234567891011121314151617181920212223242526272829303132.box-bd &#123; /*这个盒子一定不要给高度 因为我们可能放一行 也可能是2行 或者n行*/ /*宽度呢？ 呵呵*/ /*box-bd 宽度 超过了 版心 1200 是可以的，就就解决了问题*/ width: 1215px;&#125;.box-bd li &#123; float: left; width: 228px; height: 270px; margin-right: 15px; margin-bottom: 15px; background-color: #fff; box-shadow: 2px 2px 2px rgba(0, 0, 0, .3);&#125;.box-bd li img &#123; width: 100%;&#125;.box-bd li h4 &#123; margin: 20px; font-size: 14px; color: #050505; font-weight: 400;&#125;.box-bd li p &#123; margin: 0 20px; font-size: 12px; color: #999;&#125;.box-bd p span &#123; color: orange;&#125; 父右子左 links12345678910111213141516171819.links &#123; float: right;&#125;.links dl &#123; float: left; margin-left: 100px;&#125;.links dt &#123; height: 35px; font-size: 16px; color: #333;&#125;.links dd a &#123; font-size: 12px; color: #333;&#125;.links dd a:hover &#123; color: #004aff;&#125; 一些通用写法 通用部分 1234567891011121314151617181920212223242526272829303132333435363738/*清除元素默认的内外边距*/* &#123; margin: 0; padding: 0;&#125;/*清除列表样式*/li &#123; list-style: none;&#125;/*去掉button 默认自带的边框*/button &#123; border: none;&#125;body &#123; background-color: #f3f5f7; /*方便写代码 一会别忘了删除*/ /*height: 3000px;*/&#125;a &#123; text-decoration: none;&#125;/*清除浮动的*/.clearfix:before,.clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125;/*版心 1200 水平居中*/.w &#123; width: 1200px; margin: auto;&#125; 盒子阴影1box-shadow: 2px 2px 2px rgba(0, 0, 0, .2); 透明背景1background: rgba(0, 0, 0, .3);","categories":[{"name":"css","slug":"css","permalink":"https://shadowbynl.github.io/categories/css/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://shadowbynl.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"android基本概念（六）","slug":"a-study-6","date":"2020-03-25T13:07:46.000Z","updated":"2021-10-07T08:24:47.449Z","comments":true,"path":"2020/03/25/a-study-6/","link":"","permalink":"https://shadowbynl.github.io/2020/03/25/a-study-6/","excerpt":"安卓常用画图类","text":"安卓常用画图类 一、概述 123• Bitmap：相当于我们绘制出来的图像，获取图像文件信息，对图像进行剪切、旋转、缩放，压缩等操作，并可以以指定格式保存图像文件。• Paint：相当于我们绘图所用的画笔，绘制几何，文本，位图的风格与颜色信息。• Canvas：相当于我们绘图所用的画布，调用方法进行图像绘制。 二、BITMAP1.作用 123• Bitmap在Android中指的是一张图片，可以是png，也可以是jpg等其他图片格式。• Bitmap是Android系统中的图像处理中最重要类之一。Bitmap可以获取图像文件信息，对图像进行剪切、旋转、缩放，压缩等操作，并可以以指定格式保存图像文件。• Bitmap是一个final类，因此不能被继承。Bitmap只有一个构造方法，且该构造方法是没有任何访问权限修饰符修饰，也就是说该构造方法是friendly。 2.内部枚举类 123456789101112• Bitmap中有两个内部枚举类：• Config是用来设置颜色配置信息的。• CompressFormat是用来设置压缩方式的。• Bitmap.Config.ALPHA_8：颜色信息只由透明度组成，占8位。• Bitmap.Config.ARGB_4444：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占4位，总共占16位。• Bitmap.Config.ARGB_8888：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置。• Bitmap.Config.RGB_565：颜色信息由R（Red），G（Green），B（Blue）三部分组成，R占5位，G占6位，B占5位，总共占16位。• Bitmap.CompressFormat.JPEG：表示以JPEG压缩算法进行图像压缩，压缩后的格式可以是&quot;.jpg&quot;或者&quot;.jpeg&quot;，是一种有损压缩。• Bitmap.CompressFormat.PNG：表示以PNG压缩算法进行图像压缩，压缩后的格式可以是&quot;.png&quot;，是一种无损压缩。• Bitmap.CompressFormat.WEBP：表示以WebP压缩算法进行图像压缩，压缩后的格式可以是&quot;.webp&quot;，是一种有损压缩，质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。美中不足的是，WebP格式图像的编码时间“比JPEG格式图像长8倍”。 3.构造 123456789101112131415161718• Bitmap的类构造函数是私有的，因此不能直接通过构造方法实例化。• 一般利用Bitmap的静态方法createBitmap()和BitmapFactory的decode系列静态方法创建Bitmap对象。• BitmapFactory类提供了4类方法用来加载Bitmap：• decodeFile()：从文件系统加载。• String sd_patch= “/sdcard/test.png”;• Bitmap bm= BitmapFactory.decodeFile(sd_path);• decodeResource()：以R.drawable.xxx的形式从本地资源中加载。• Bitmap bm = BitmapFactory.decodeResource(this.getContext().getResources(), R.drawable.pop);• decodeStream()：从输入流加载。• FileInputStream = new FileInputStream(“/sdcard/test.png”);• Bitmap bm= BitmapFactory.decodeStream(fis);• decodeByteArray()：从字节数组中加载。• Bitmap bm = BitmapFactory.decodeByteArray(myByte,0,myByte.length); 二、PAINT1.构造 1234567• Paint有3个构造方法，可以通过这3个构造方法创建Paint对象：• Paint()：用默认设置创建一个Paint对象。• Paint(int flags)：用特殊标记创建一个Paint对象：• Paint.FILTER_BITMAP_FLAG：使位图过滤的位掩码标志。• Paint.ANTI_ALIAS_FLAG：使位图抗锯齿的标志。• Paint.DITHER_FLAG：使位图进行有利的抖动的位掩码标志。• Paint(Paint paint)：用指定Paint对象的参数初始化一个新的Paint对象。 2.常用方法 123456789101112131415161718192021• Paint常用方法：• setARGB(int a, int r, int g, int b)：设置画笔颜色。• setAntiAlias(booleanaa)：设置是否抗锯齿。• setColor(int color)：设置画笔颜色。• setAlpha(int a)：设置画笔透明度。• setTextSize(float textSize)：设置字体大小。• setUnderlineText(booleanunderlineText)：设置文本带有下划线效果。• setStrikeThruText(booleanstrikeThruText)：设置文本带删除线效果。• setTextSkewX(float skewX)：设置文本倾斜度。• setTextScaleX(float scaleX)：设置文本缩放大小。• setTextAlign(Paint.Alignalign)：设置文本对齐方式。• setTypeface(Typeface typeface)：设置字体。• setStyle(Paint.Stylestyle)：设置画笔样式，画笔样式有3种：Paint.Style.FILL：默认值，用这种风格绘制的几何图与文本将被填充，它画出来的是实心图• Paint.Style.STROKE：用这种风格绘制的几何图与文本将被画出外边框，它画出来的是空心图• Paint.Style.FILL_AND_STROKE：用这种风格绘制的几何图与文本将被填充并被画出外边框，从表面看它画出来的也是实心图，不过比一般画出来的实心图多了一层外边框。• setStrokeWidth(float width)：设置画笔外边框的宽度，可以想象成画笔“画出线条的宽度”。• setXfermode(Xfermodexfermode)：设置图像重叠时的处理方式。• setShader(Shadershader)：设置着色器。• setPathEffect(PathEffecteffect)：设置或者清除路径效果。 三、CANVAS1.概述 123456• Canvas拥有“绘制”调用，可以调用方法进行图像绘制。• 画图时需要4个基本元素：• 拥有像素的Bitmap。• 可以进行绘制调用的Canvas。• 图元（比如：Rect, Path, text, Bitmap）。• 描述风格与颜色的Paint。 2.构造 123• Canvas有两个构造方法，可以通过这两个构造方法创建Canvas对象：• Canvas()：创建一个空的Canvas对象。• Canvas(Bitmap bitmap)：用指定的位图构造一个Canvas对象。 3.常用方法 12345678910111213141516• drawARGB()：用指定ARGB颜色填充画布上面的位图• drawRGB()：用指定RGB颜色填充画布上面的位图• drawColor()：用指定颜色填充画布上面的位图• drawArc()：画圆弧• drawBitmap()：画位图• drawCircle()：画圆• drawLine()：画直线• drawLines()：画折线• drawOval()：画椭圆• drawRect()：画矩形• drawRoundRect()：画圆角矩形• drawPoint()：画点• drawPoints()：画一组点• drawPath()：画路径• drawText()：画文本 ANIMATION一、概述Android Animation分为两类 12• 传统动画：包括帧动画（Frame Animation）和补间动画（Tween Animation），又称为DrawableAnimation和View Animation。• 属性动画（Property Animation）。 二、传统动画Frame Animation 123• Frame Animation（DrawableAnimation）是最容易实现的一种动画，这种动画更多的依赖于完善的UI资源。• Frame Animation的原理是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果。• 这种动画的实质其实是Drawable，所以这种动画的XML定义方式文件一般放在res/drawable/目录下。 TweenAnimation 12345678910111213141516171819202122232425262728293031323334• TweenAnimation（View Animation）可以在一个视图容器内执行一系列简单变换。譬如，有一个TextView对象，可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。• TweenAnimation 具体有4种形式：alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。• 补间动画通过XML或Android代码定义，建议使用XML文件定义，因为它更具可读性、可重用性。--------------------关于配置anime--------------------相关类名：• AlphaAnimation：渐变透明度动画效果，对应XML中的&lt;alpha&gt;，放置在res/anim/目录。• RotateAnimation：画面转移旋转动画效果，对应XML中的&lt;rotate&gt;，放置在res/anim/目录。• ScaleAnimation：渐变尺寸伸缩动画效果，对应XML中的&lt;scale&gt;，放置在res/anim/目录。• TranslateAnimation：画面转换位置移动动画效果，对应XML中的&lt;translate&gt; 放置在res/anim/目录。• AnimationSet：一个持有其它动画元素alpha、scale、translate、rotate或者其它set元素的容器，对应XML中的&lt;set&gt;，放置在res/anim/目录。Animation属性：• android:detachWallpaper：是否在壁纸上运行，对应setDetachWallpaper(boolean)。• android:duration：动画持续时间，毫秒为单位，对应setDuration(long)。• android:fillAfter：控件动画结束时是否保持动画最后的状态，对应setFillAfter(boolean) 。• android:fillBefore：控件动画结束时是否还原到开始动画前的状态，对应setFillBefore(boolean)。• android:fillEnabled：与android:fillBefore效果相同，对应setFillEnabled(boolean) 。• android:interpolator：设定插值器（指定的动画效果，譬如回弹等），对应setInterpolator(Interpolator)。• android:repeatCount：重复次数，对应setInterpolator(Interpolator)。• android:repeatMode：重复类型有两个值，reverse表示倒序回放，restart表示从头播放，对应setInterpolator(Interpolator) 。• android:startOffset：调用start函数之后等待开始运行的时间，单位为毫秒，对应setStartOffset(long)。• android:zAdjustment：表示被设置动画的内容运行时在Z轴上的位置（top/bottom/normal），默认为normal ，对应setZAdjustment(int)。• Interpolator 主要作用是可以控制动画的变化速率，就是动画进行的快慢节奏：• @android:anim/accelerate_decelerate_interpolator：动画始末速率较慢，中间加速。• @android:anim/accelerate_interpolator：动画开始速率较慢，之后慢慢加速。• AnticipateInterpolator@android:anim/anticipate_interpolator开始的时候从后向前甩。• @android:anim/anticipate_overshoot_interpolator类似上面AnticipateInterpolator。• @android:anim/bounce_interpolator：动画结束时弹起。• @android:anim/cycle_interpolator：循环播放速率改变为正弦曲线。• @android:anim/decelerate_interpolator：动画开始快然后慢。• @android:anim/linear_interpolator：动画匀速改变。• @android:anim/overshoot_interpolator：向前弹出一定值之后回到原来位置。 逐帧动画&amp; 补间动画存在一定的缺点： 123• 作用对象局限。有些情况下的动画效果只是视图的某个属性&amp; 对象而不是整个视图。• 没有改变View的属性，只是改变视觉效果。补间动画只是改变了View的视觉效果，而不会真正去改变View的属性。• 动画效果单一。补间动画只能实现平移、旋转、缩放&amp; 透明度这些简单的动画需求，一旦遇到相对复杂的动画效果，即超出了上述4种动画效果，那么补间动画则无法实现。 三、属性动画（Property Animation） 1234• 为了解决补间动画的缺陷，在Android 3.0（API 11）开始，系统提供了一种全新的动画模式：属性动画（Property Animation）。• 作用对象：任意Java 对象，不再局限于视图View对象。• 实现的动画效果：可自定义各种动画效果，不再局限于4种基本变换：平移、旋转、缩放&amp; 透明度。• 工作原理：在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果。 四、ANIMATION LISTENER 12345678910• anim.setAnimationListener(new AnimationListener() &#123;• @Override• public void onAnimationCancle(Animation animation) &#123;…&#125;• @Override• public void onAnimationStart(Animation animation) &#123;…&#125;• @Override• public void onAnimationRepeat(Animation animation) &#123;…&#125;• @Override• public void onAnimationEnd(Animation animation) &#123;…&#125;• &#125;); MEDIAPLAYER一、功能与设置源 123456789101112• Android可以通过Mediaplayer类提供的API，实现以下音频、视频文件的播放：• 自带resource资源：MediaPlayer.create(this, R.raw.test);• SD卡或其他文件路径下的媒体文件：mp.setDataSource(“/sdcard/test.mp3”);• 网络媒体文件：mp.setDataSource(&quot;http://www.citynorth.cn/music/confucius.mp3&quot;);• setDataSource一共四个方法：• setDataSource(String path) ；//文件系统路径• setDataSource(FileDescriptorfd)；//assets文件• setDataSource(Context context, Uri uri)；//网络虚拟路径• setDataSource(FileDescriptorfd, long offset, long length)；• 若URI中包含网络资源，需在AndroidManifest.xml中申请Internet访问权限：• &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 二、生命周期 123456789101112• Idle 状态：当使用new()方法创建一个MediaPlayer对象或者调用了其reset()方法时，该MediaPlayer对象处于idle状态。这两种方法的一个重要差别就是：如果在这个状态下调用了getDuration()等方法（相当于调用时机不正确），通过reset()方法进入idle状态的话会触发OnErrorListener.onError()，并且MediaPlayer会进入Error状态；如果是新创建的MediaPlayer对象，则并不会触发onError(),也不会进入Error状态。• End 状态：通过release()方法可以进入End状态，只要MediaPlayer对象不再被使用，就应当尽快将其通过release()方法释放掉，以释放相关的软硬件组件资源，这其中有些资源是只有一份的（相当于临界资源）。如果MediaPlayer对象进入了End状态，则不会在进入任何其他状态了。• Initialized 状态：这个状态比较简单，MediaPlayer调用setDataSource()方法就进入Initialized状态，表示此时要播放的文件已经设置好了。• Prepared 状态：初始化完成之后还需要通过调用prepare()或prepareAsync()方法，这两个方法一个是同步的一个是异步的，只有进入Prepared状态，才表明MediaPlayer到目前为止都没有错误，可以进行文件播放。• Preparing 状态：这个状态比较好理解，主要是和prepareAsync()配合，如果异步准备完成，会触发OnPreparedListener.onPrepared()，进而进入Prepared状态。MediaPlayer准备资源调用prepare()时，会执行一段稍长的时间，因为它在解码媒体数据，如果解码时间过长那么会出现主线程阻塞，从而触发ANR异常，导致程序运行很慢，所以框架提供了prepareAsync()异步准备方法并提供资源准备监听，当资源准备完成会触发MediaPlayer.OnPreparedListener的onPrepared()方法。• Stop 状态：Started或者Paused状态下均可调用stop()停止MediaPlayer，而处于Stop状态的MediaPlayer要想重新播放，需要通过prepareAsync()和prepare()回到先前的Prepared状态重新开始才可以。• PlaybackCompleted状态：文件正常播放完毕，而又没有设置循环播放的话就进入该状态，并会触发OnCompletionListener的onCompletion()方法。此时可以调用start()方法重新从头播放文件，也可以stop()停止MediaPlayer，或者也可以seekTo()来重新定位播放位置。• Error状态：如果由于某种原因MediaPlayer出现了错误，会触发OnErrorListener.onError()事件，此时MediaPlayer即进入Error状态，及时捕捉并妥善处理这些错误是很重要的，可以帮助我们及时释放相关的软硬件资源，也可以改善用户体验。• 通过setOnErrorListener(android.media.MediaPlayer.OnErrorListener)可以设置该监听器。如果MediaPlayer进入了Error状态，可以通过调用reset()来恢复，使得MediaPlayer重新返回到Idle状态。 三、常用方法 123456789101112131415161718192021• int getCurrentPosition()：获取当前播放的位置。• int getAudioSessionId()：返回音频的session ID。• int getDuration()：得到文件的时间。• TrackInfo[] getTrackInfo()：返回一个track信息的数组。• booleanisLooping()：是否循环播放。• booleanisPlaying()：是否正在播放。• void pause ()：暂停。• void start ()：开始。• void stop ()：停止。• void prepare()：同步的方式装载流媒体文件。• void prepareAsync()：异步的方式装载流媒体文件。• void reset()：重置MediaPlayer至未初始化状态。• void release ()：回收流媒体资源。• void seekTo(int msec)：指定播放的位置（以毫秒为单位时间）。• void setAudioStreamType(intstreamtype)：指定流媒体类型。• void setLooping(booleanlooping)：设置是否单曲循环。• void setNextMediaPlayer(MediaPlayernext)：当这个MediaPlayer播放完毕后，MediaPlayernext开始播放。• void setWakeMode(Context context, int mode)：设置CPU唤醒的状态。• void setScreenOnWhilePlaying(Boolean screenOn)：播放时是否保持屏幕常亮，是否阻止屏幕自动休眠。 四、展示控件–SurfaceView 1234567• View通过刷新来重绘视图，Android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的时间间隔为16ms。在一些需要频繁刷新，执行很多逻辑操作的时候，超过了16ms，就会导致卡顿.• SurfaceView继承自View，但拥有独立的绘制表面，即它不与其宿主窗口共享同一个绘图表面，可以单独在一个线程进行绘制，并不会占用主线程的资源。这样，绘制就会比较高效，游戏，视频播放，还有最近热门的直播，都可以用SurfaceView。SurfaceView和View的区别：• View主要适用于主动更新的情况下，而SurfaceView主要适用于被动更新，例如频繁地刷新。• View在主线程中对画面进行刷新，而SurfaceView通常会通过一个子线程来进行页面的刷新。• View在绘图时没有使用双缓冲机制，而SufaceView在底层实现机制中就已经实现了双缓冲机制。","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"android基本概念（五）","slug":"a-study-5","date":"2020-03-19T14:20:08.000Z","updated":"2021-10-07T08:24:42.140Z","comments":true,"path":"2020/03/19/a-study-5/","link":"","permalink":"https://shadowbynl.github.io/2020/03/19/a-study-5/","excerpt":"Android网络编程基础","text":"Android网络编程基础 一、基于TCP协议的网络通信1.ServerSocket建立服务端 1234567891011121314151617ServerSocket serverSocket = new ServerSocket(8888);while (true) &#123; try &#123; Socket socket = serverSocket.accept(); System.out.println(&quot;新增连接&quot; + server.getInetAddress() + &quot;:&quot; + socket.getPort()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.客户端程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.Socket;import java.net.SocketTimeoutException;public class Main2Activity extends AppCompatActivity &#123; private Context context; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; textView = (TextView)findViewById(R.id.textView); new Thread() &#123; @Override public void run() &#123; try &#123; Socket socket = new Socket(&quot;192.168.1.49&quot;, 9999); socket.setSoTimeout(3000); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String info = br.readLine(); textView.setText(&quot;Client received: &quot; + info); br.close(); socket.close(); &#125; catch (SocketTimeoutException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125;&#125; 3.服务端程序 12345678910111213141516171819package com.n;import java.io.IOException;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class help1 &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(9999); while (true) &#123; Socket socket = serverSocket.accept(); OutputStream os = socket.getOutputStream(); os.write(&quot;This is Server!&quot;.getBytes(&quot;utf-8&quot;)); os.close(); socket.close(); &#125; &#125;&#125; 二、使用URL访问网络1.访问URL网络资源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.os.Bundle;import android.widget.ImageView;import java.io.IOException;import java.io.InputStream;import java.net.MalformedURLException;import java.net.URL;public class Main3Activity extends AppCompatActivity &#123; private Context context; private ImageView imageView; private Bitmap bitmap; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; imageView = findViewById(R.id.imageView); showPicture(&quot;https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3063886216,124952448&amp;fm=26&amp;gp=0.jpg&quot;); &#125; public void showPicture(String url) &#123; new AsyncTask&lt;String, Void, String&gt;() &#123; @Override protected String doInBackground(String... strings) &#123; try &#123; URL url = new URL(strings[0]); InputStream is = url.openStream(); bitmap = BitmapFactory.decodeStream(is); is.close(); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); imageView.setImageBitmap(bitmap); &#125; &#125;.execute(url); &#125;&#125; 2.URLConnection + TomcatJavaWeb服务器端 123456789101112131415161718192021222324252627package servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class LoginServlet extends HttpServlet&#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html; charset=utf-8&quot;); req.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = resp.getWriter(); String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); if (username.equals(&quot;admin&quot;) &amp;&amp; password.equals(&quot;123&quot;)) &#123; out.print(&quot;登录成功&quot;); &#125; else &#123; out.print(&quot;登录失败&quot;); &#125; out.flush(); out.close(); &#125;&#125; 12345678&lt;servlet&gt; &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; URLConnection客户端（访问不成功） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.AsyncTask;import android.os.Bundle;import android.os.StrictMode;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class Main4Activity extends AppCompatActivity &#123; private Context context; private EditText editText, editText2; private TextView textView; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main4); context = this; editText = findViewById(R.id.editText); editText2 = findViewById(R.id.editText2); textView = findViewById(R.id.textView4); button = findViewById(R.id.button5); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; loginCheck(editText.getText().toString(), editText2.getText().toString()); &#125; &#125;); &#125; private void loginCheck(String username, String password) &#123; final String url = &quot;http://10.0.2.2:8080/servlet&quot;; final String param = &quot;username=&quot; + username + &quot;&amp;&quot; + &quot;password=&quot; + password; new AsyncTask&lt;String, Void, String&gt;() &#123; @Override protected String doInBackground(String... strings) &#123; PrintWriter out = null; BufferedReader in = null; String result = null; try &#123; URL url = new URL(strings[0]); URLConnection conn = url.openConnection(); conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36&quot;); conn.setDoInput(true); conn.setDoOutput(true); out = new PrintWriter(conn.getOutputStream()); out.print(param); in = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override protected void onPostExecute(String s) &#123; if (s != null) &#123; textView.setText(s); &#125; super.onPostExecute(s); &#125; &#125;.execute(url); &#125;&#125; 3.HttpURLConnection客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.AsyncTask;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class Main5Activity extends AppCompatActivity &#123; private Context context; private EditText editText, editText2; private TextView textView; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main5); context = this; editText = findViewById(R.id.editText); editText2 = findViewById(R.id.editText2); textView = findViewById(R.id.textView4); button = findViewById(R.id.button5); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; loginCheck(editText.getText().toString(), editText2.getText().toString()); &#125; &#125;); &#125; private void loginCheck(String username, String password) &#123; final String url = &quot;http://10.0.2.2:8080/servlet&quot;; final String param = &quot;username=&quot; + username + &quot;&amp;&quot; + &quot;password=&quot; + password; new AsyncTask&lt;String, Void, String&gt;() &#123; @Override protected String doInBackground(String... strings) &#123; PrintWriter out = null; BufferedReader in = null; String result = &quot;&quot;; try &#123; URL url = new URL(strings[0]); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36&quot;); conn.setDoInput(true); conn.setDoOutput(true); conn.setRequestMethod(&quot;POST&quot;); conn.setUseCaches(false); out = new PrintWriter(conn.getOutputStream()); out.print(param); out.flush(); out.close(); int responseCode = conn.getResponseCode(); System.out.println(responseCode); if (responseCode == HttpURLConnection.HTTP_OK) &#123; in = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override protected void onPostExecute(String s) &#123; if (s != null) &#123; textView.setText(s); &#125; super.onPostExecute(s); &#125; &#125;.execute(url); &#125;&#125; 4.注意点 123（1）Google在API23之后就不自带HttpClient了，原因是Apache不再维护HttpClient了，官方推荐使用的就是HttpURLConnection。（2）在对Tomcat的servlet进行访问时，暂时发现只有一级路由可以访问到，二级就找不到，原因未明。而且更奇怪的是，通用的路由，URLConnection访问不到，HttpURLConnection可以访问到。（3）Async有警告暂时不处理。 三、WebService 1234浏览器基本功能：地址栏 前进后退刷新 加载本地网页： file:///android_asset/与javascript交互：使用场景为加载本地网页，其中有与系统交互的逻辑网络编程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 private Context context; private WebView wv; private EditText editText; private String url; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main6); context = this; editText = findViewById(R.id.editText); initWeb(); &#125; private void initWeb() &#123; wv = findViewById(R.id.webView); //加载本地网页 wv.loadUrl(&quot;file:///android_asset/templates/all-admin-index.html&quot;); //覆盖默认通过第三方或系统浏览器打开网页的行为，使网页在WebView内打开 wv.setWebViewClient(new CustomWebViewClient()); WebSettings ws = wv.getSettings(); //启用支持JavaScript ws.setJavaScriptEnabled(true); //加载页面优先使用缓存 ws.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //设置可以访问文件 ws.setAllowFileAccess(true); //设置支持缩放 ws.setBuiltInZoomControls(true); &#125; //改写按键--返回的逻辑，实现页面的后退 @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (wv.canGoBack()) &#123; wv.goBack(); return true; &#125; else &#123; finish(); &#125; &#125; return super.onKeyDown(keyCode, event); &#125; //实现地址栏跳转、后退、前进、刷新功能 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button: &#123; url = editText.getText().toString(); editText.setText(&quot;&quot;); if (url != null &amp;&amp; url.length() &gt; 0) &#123; wv.loadUrl(url); &#125; break; &#125; case R.id.button2: &#123; wv.goBack(); break; &#125; case R.id.button3: &#123; wv.goForward(); break; &#125; case R.id.button4: &#123; wv.reload(); break; &#125; &#125; &#125; private class CustomWebViewClient extends WebViewClient &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;// view.loadUrl(url);// //返回为true是在wv中打开，false则使用其他浏览器// return true; if (url.endsWith(&quot;.apk&quot;)) &#123; return true; &#125; else if (url.startsWith(&quot;tel:&quot;)) &#123; return true; &#125; else if (url.startsWith(&quot;mailto:&quot;)) &#123; return true; &#125; else if (url.startsWith(&quot;baidu&quot;)) &#123; return true; &#125; view.loadUrl(url); return true; &#125; &#125;","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"android基本概念（四）","slug":"a-study-4","date":"2020-03-17T13:30:55.000Z","updated":"2021-10-07T08:24:35.823Z","comments":true,"path":"2020/03/17/a-study-4/","link":"","permalink":"https://shadowbynl.github.io/2020/03/17/a-study-4/","excerpt":"CONTENT PROVIDER","text":"CONTENT PROVIDER 一、ContentProvider内容提供者1.概述 123• ContentProvider即内容提供者，是Android四大组件之一。• ContentProvider为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。• Android内置的许多数据都是使用ContentProvider形式，供开发者调用的(如视频，音频，图片，通讯录等)。 123• ContentProvider提供了对底层数据存储方式的抽象。• Android框架中的一些类需要ContentProvider类型数据。• ContentProvider为应用间的数据交互提供了一个安全的环境。 2.方法 1234567• ContentProvider提供以下方法：• query：查询；• insert：插入；• update：更新；• delete：删除；• getType：得到数据类型；• onCreate：创建数据时调用的回调函数。 3.配置属性 123456789• 授权(android:authorities)：用于在系统内标识整个提供程序的符号名称。• 提供程序类名( android:name)：实现ContentProvider的类。• 启动和控制属性：这些属性决定Android 系统如何以及何时启动提供程序、提供程序的进程特性以及其他运行时设置：• android:enabled：允许系统启动提供程序的标志。• android:exported：允许其他应用使用此提供程序的标志。• android:initOrder：此提供程序相对于同一进程中其他提供程序的启动顺序。• android:multiProcess：允许系统在与调用客户端相同的进程中启动提供程序的标志。• android:process：应在其中运行提供程序的进程的名称。• android:syncable：指示提供程序的数据将与服务器上的数据同步的标志。 二、ContentResolver内容解析者1.概述 12• ContentResolver即内容解析器，程序通过ContentResolver可以访问ContentProvider提供的数据。• 使用ContentResolver对ContentProvider进行增、删、改、查的操作，应用程序开发者不需要知道ContentProvider的内部实现，ContentResolver可统一管理与不同ContentProvider间的操作。 2.URI 123• 每个ContentProvider都有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。• Android所提供的ContentProvider都存放在android.provider包当中。• ContentResolver通过URI来区别不同的ContentProvider。 12345• URI（Universal Resource Identifier, 统一资源定位符）代表要操作的数据，Android上可用的每种资源，图像、视频片段等都可以用URI来表示：• 所有联系人的URI ：content://contacts/people • 某个联系人的URI : content://contacts/people/5 • 所有图片URI : content://media/external • 某个图片的URI：content://media/external/images/media/4 三、案例代码1.自定义UserContentProvider，并用ContentResolver增加和获取数据UserContentProvider.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.example.app_data;import android.content.ContentProvider;import android.content.ContentUris;import android.content.ContentValues;import android.content.UriMatcher;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.net.Uri;import android.util.Log;public class UserContentProvider extends ContentProvider &#123; public UserContentProvider() &#123; &#125; //自定义uri private static final String TAG = &quot;UserContentProvider&quot;; static final String PROVIDER_NAME = &quot;com.example.app_data.UserContentProvider&quot;; static final String URL = &quot;content://&quot; + PROVIDER_NAME + &quot;/user&quot;; static final Uri CONTENT_URI = Uri.parse(URL); //定义uri匹配码 private static final UriMatcher MATCHER = new UriMatcher(UriMatcher.NO_MATCH); // 若不匹配采用UriMatcher.NO_MATCH(-1)返回 private static final int CODE_NOPARAM = 1; //无参 // 匹配码 private static final int CODE_PARAM = 2; //带参数 //自定义uri匹配模式 static &#123; // 对等待匹配的URI进行匹配操作，com.example.app_data.UserContentProvider/user格式 // 匹配返回CODE_NOPARAM，不匹配返回-1 无参的情况 MATCHER.addURI(&quot;com.example.app_data.UserContentProvider&quot;, &quot;user&quot;, CODE_NOPARAM); // #表示数字 com.example.app_data.UserContentProvider/user/10 // 匹配返回CODE_PARAM，不匹配返回-1 有参的情况 MATCHER.addURI(&quot;com.example.app_data.UserContentProvider&quot;, &quot;user/#&quot;, CODE_PARAM); &#125; //UserSQLiteOpenHelper中预先建好user表 private UserSQLiteOpenHelper helper; //操作数据库 private final String user_TABLE = &quot;user&quot;; //所用表名 @Override public boolean onCreate() &#123; // TODO Auto-generated method stub helper = new UserSQLiteOpenHelper(getContext(), &quot;userdb&quot;); //以上下文 和 所用数据库名为参数，此处写死了 return true; &#125; @Override public Uri insert(Uri uri, ContentValues cv) &#123; // TODO Auto-generated method stub Log.i(TAG, &quot;insert()&quot;); SQLiteDatabase db = helper.getWritableDatabase(); switch (MATCHER.match(uri)) &#123; //插入的uri无参才是正确情况 case CODE_NOPARAM: //调用sqlite的插入方法 long id = db.insert(user_TABLE, null, cv); //若主键是自增的，则返回主键值；否则为行号 Uri insertUri = ContentUris.withAppendedId(uri, id); return insertUri; default: throw new IllegalArgumentException(&quot;This is unknow uri: &quot; + uri); &#125; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub Log.i(TAG, &quot;delete()&quot;); SQLiteDatabase db = helper.getWritableDatabase(); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: //无参删除所有记录 return db.delete(user_TABLE, selection, selectionArgs); //删除所有记录 case CODE_PARAM: //有参删除uri指明的记录 long id = ContentUris.parseId(uri); //取得Uri后面的数字 String where = &quot;_id = &quot; + id; if(null != selection &amp;&amp; !(selection.trim()).equals(&quot;&quot;))&#123; where += &quot;and &quot; + selection; &#125; return db.delete(user_TABLE, where, selectionArgs); default: throw new IllegalArgumentException(&quot;This is unknow uri: &quot; + uri); &#125; &#125; @Override public int update(Uri uri, ContentValues cv, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub Log.i(TAG, &quot;update()&quot;); SQLiteDatabase db = helper.getWritableDatabase(); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: return db.update(user_TABLE, cv, selection, selectionArgs); //更新所有记录 case CODE_PARAM: long id = ContentUris.parseId(uri); //取得Uri后面的数字 String where = &quot;_id = &quot; + id; if(null != selection &amp;&amp; !(selection.trim()).equals(&quot;&quot;))&#123; where += &quot; and &quot; + selection; &#125; return db.update(user_TABLE, cv, where, selectionArgs); default: throw new IllegalArgumentException(&quot;This is unknow uri: &quot; + uri); &#125; &#125; /** * 返回对应的内容类型 * 如果返回集合的内容类型，必须以com.example.android.cursor.dir开头 * 如果是单个元素，必须以com.example.android.cursor.item开头 */ @Override public String getType(Uri uri) &#123; // TODO Auto-generated method stub Log.i(TAG, &quot;getType()&quot;); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: return &quot;com.example.android.cursor.dir/user&quot;; case CODE_PARAM: return &quot;com.example.android.cursor.item/user&quot;; default: throw new IllegalArgumentException(&quot;This is unknow uri: &quot; + uri); &#125; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String orderBy) &#123; // TODO Auto-generated method stub Log.i(TAG, &quot;query()&quot;); SQLiteDatabase db = helper.getReadableDatabase(); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: return db.query(user_TABLE, projection, selection, selectionArgs, null, null, orderBy); case CODE_PARAM: long id = ContentUris.parseId(uri); //取得Uri后面的数字 String where = &quot;_id = &quot; + id; if(null != selection &amp;&amp; !(selection.trim()).equals(&quot;&quot;))&#123; where += &quot;and &quot; + selection; &#125; return db.query(user_TABLE, projection, where, selectionArgs, null, null, orderBy); default: throw new IllegalArgumentException(&quot;This is unknow uri: &quot; + uri); &#125; &#125;&#125; UserSQLiteOpenHelper.java 123456789101112131415161718192021222324252627package com.example.app_data;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import androidx.annotation.Nullable;public class UserSQLiteOpenHelper extends SQLiteOpenHelper &#123; public UserSQLiteOpenHelper(Context context, String name) &#123; super(context, name, null, 1); &#125; public UserSQLiteOpenHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; @Override //首次创建数据库时调用，一般可写建表建库的操作 public void onCreate(SQLiteDatabase sqLiteDatabase) &#123; sqLiteDatabase.execSQL(&quot;create table if not exists user (_id integer primary key autoincrement, name text not null, password text not null)&quot;); &#125; @Override //当数据库的版本发生变化时，会自动执行 public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) &#123; &#125;&#125; Activity文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.app_data;import androidx.appcompat.app.AppCompatActivity;import android.content.ContentValues;import android.database.Cursor;import android.net.Uri;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.EditText;import android.widget.Toast;public class Main2Activity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); &#125; //增加用户 public void onClickAddUser(View view) &#123; ContentValues values = new ContentValues(); //以下的字段名是自定义表中写死的字段名，而系统提供的是static final String 需要通过相关provider调用（在里面定义） values.put(&quot;name&quot;, ((EditText)findViewById(R.id.editText)).getText().toString()); values.put(&quot;password&quot;, ((EditText)findViewById(R.id.editText2)).getText().toString()); //当前上下文的内容提供者通过uri与指定的provider建立联系 Uri uri = getContentResolver().insert(UserContentProvider.CONTENT_URI, values); Toast.makeText(getBaseContext(), uri.toString(), Toast.LENGTH_LONG * 3).show(); &#125; //获取用户信息 public void onClickRetrieveUser(View view) &#123; Cursor cursor = getContentResolver().query(UserContentProvider.CONTENT_URI , new String[]&#123;&quot;name&quot;, &quot;password&quot;&#125;, null, null, null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123;// Log.i(&quot;info&quot;, &quot;_id:&quot; + cursor.getInt(cursor.getColumnIndex(&quot;_id&quot;))); 此处绝对不能多写id 因为上面的projection就没写id字段，返回结果也不会有 Log.i(&quot;info&quot;, &quot;name:&quot; + cursor.getString(cursor.getColumnIndex(&quot;name&quot;))); Log.i(&quot;info&quot;, &quot;password:&quot; + cursor.getString(cursor.getColumnIndex(&quot;password&quot;))); &#125; cursor.close(); &#125; &#125;&#125; 2.动态获取权限 SharedPreferences一、概述 12• SharedPreferences对象指向包含键值对的文件并提供读写这些文件的简单方法。每个SharedPreferences文件由框架进行管理并且可以专用或共享。• SharedPreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/&lt;package name&gt;/shared_prefs目录下。 二、保存key-value对 步骤123• 使用Activity类的getSharedPreferences方法获取到SharedPreferences对象，指定文件名和访问权限。• 获得SharedPreferences.Editor对象，并使用该对象的putXXX方法保存key-value对。• 通过SharedPreferences.Editor的commit方法保存（提交）key-value对。 getSharedPreferences(String name, int mode)使用getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例，该方法第一个参数为实例名称（不带后缀），第二个参数为操作模式，共四种：1234• Context.MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中。可以使用Context.MODE_APPEND• Context.MODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。• MODE_WORLD_READABLE：表示当前文件可以被其他应用读取；• MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。 SharedPreferences.Editor1234567891011121314151617• 获取SharedPreferences实例之后，需要创建SharedPreferences.Editor以实现修改功能：• SharedPreferencespref = getSharedPreferences(&quot;myPref&quot;, MODE_PRIVATE);• SharedPreferences.Editoreditor = pref.edit();• 在SharedPreferences.Editor中使用putXXX方法存储键值对，并使用commit方法提交数据：• editor.putString(“name”, “刘全有&quot;);• editor.putInt(&quot;age&quot;, 25);• editor.putLong(&quot;time&quot;, System.currentTimeMillis());• editor.putBoolean(&quot;default&quot;, true);• …• editor.commit();• 使用remove方法删除SharedPreferences实例中某个键值对：• SharedPreferencespref = getSharedPreferences(&quot;myPref&quot;, MODE_PRIVATE);• SharedPreferences.Editoreditor = pref.edit();• Editor.remove(“name”);• editor.commit(); File一、Android系统文件路径说明Android应用可能访问以下文件系统路径 12345678910111213• /data/app：该文件夹存放着系统中安装的第三方应用的apk文件。Android 中应用的安装就是将应用的安装包原封不动地拷贝到/data/app 目录下，• 每个应用安装包本质上就是一个zip 格式的压缩文件。为了提升应用的启动效率，Android 会将解压出来的dex格式的应用代码文件解析提取后，缓存在/data/dalvik-cache 目录下。• /data/data：该文件夹存放存储包私有数据，对于设备中每一个安装的App，系统都会在内部存储空间的data/data 目录下以应用包名为名字自动创建与之对应的文件夹。• 用户卸载App 时，系统自动删除data/data 目录下对应包名的文件夹及其内容。• /system：通过Environment.getRootDirectory() 访问，该目录下也有一个app 目录，存放的是系统应用的apk文件。• /system/app 和/data/app 的区别为：• /system/app 里的软件获取了所有权限。• /system/app 只能root 后删除。• /system/app 文件夹有大小限制，卸载/system/app 目录下的文件并不会增加系统空间，即可用ROM 空间。• /mnt：这个目录专门用来当作挂载点挂在外部设备，如SD 卡，将会被系统视作一个文件夹，这个文件夹将会被系统嵌入到文件系统的mnt目录中，所以在/mnt目录下也会看到一个sdcard的快捷方式： 二、apk组成1.在Android APK中，除了被编译的代码以外，还可以允许存储两种资源文件： 123res：文件会被映射到R.java文件中，访问的时候直接通过资源ID即可访问，而且不能有目录结构，即不能再创建文件夹。assets：不会映射到R.java文件中，通过AssetManager来访问，能有目录结构，即可以自行创建文件夹。注意：res和assets只能读取，不能修改，每个文件大小不能超过1MB。 2.读文件 123456• 读res资源文件：• InputStreamis = getResources().openRawResource(R.drawable.pop);• 读assets资源文件：• AssetManageram = getAssets(); • InputStreamis = am.open(&quot;filename&quot;); 三、data/data 目录对于设备中每一个安装的App，系统都会在内部存储空间的data/data 目录下以应用包名为名字自动创建与之对应的文件夹。 123456789101112用户卸载App 时，系统自动删除data/data 目录下对应包名的文件夹及其内容。该目录下又把存储内容进行了分类：• data/data/包名/cache：存放的APP 的缓存信息。• data/data/包名/databases：存放APP 的数据库信息。• data/data/包名/files：存放APP 的文件信息。• data/data/包名/shared_prefs：存放APP内的SharedPreferences。• 若需要访问内部存储器data/data/包名/路径上的资源文件，可使用FileOutputStream和FileInputStream。• 若需要访问SD卡存储空间，需要先获取READ_EXTERNAL_STORAGE 或WRITE_EXTERNAL_STORAGE系统权限。• 外部存储在Android 文件系统中是sdcard目录，这里只是一个快捷方式，真正的目录是/storage/emulated/legacy 文件夹。• 仅能对data/data/包名/路径上的资源文件使用openFileOutput和openFileInput两个方法，不可进行其他操作。• 在AndroidMainfset.xml中获取SD卡文件写入、创建与删除权限： 四、上下文API 1234567891011121314151617181920212223242526272829303132333435Environment 常用方法：• getDataDirectory()：获取Android 数据目录。• getDownloadCacheDirectory()：获取Android 下载/缓存内容目录。• getExternalStorageDirectory()：获取外部存储目录即SDCard。• getExternalStorageState()：获取外部存储设备的当前状态。• getRootDirectory()：获取Android 的根目录。getExternalStorageState()：获取SD卡存储状态，返回值可能为以下一种：• MEDIA_BAD_REMOVAL：在没有挂载前存储媒体已经被移除。• MEDIA_CHECKING：正在检查存储媒体。• MEDIA_MOUNTED：存储媒体已经挂载，并且挂载点可读/写。• MEDIA_MOUNTED_READ_ONLY：存储媒体已经挂载，挂载点只读。• MEDIA_NOFS：存储媒体是空白或是不支持的文件系统。• MEDIA_REMOVED：存储媒体被移除。• MEDIA_SHARED：存储媒体正在通过USB共享。• MEDIA_UNMOUNTABLE：存储媒体无法挂载。• MEDIA_UNMOUNTED：存储媒体没有挂载。getExternalStoragePublicDirectory(String type)：提供十个公共目录用来存储相对应的文件，返回值如下：• DIRECTORY_MUSIC：/storage/emulated/0/Music• DIRECTORY_PODCASTS：/storage/emulated/0/Podcasts• DIRECTORY_RINGTONES：/storage/emulated/0/Ringtones• DIRECTORY_ALARMS：/storage/emulated/0/Alarms• DIRECTORY_NOTIFICATIONS：/storage/emulated/0/Notifications• DIRECTORY_PICTURES：/storage/emulated/0/Pictures• DIRECTORY_MOVIES：/storage/emulated/0/Movies• DIRECTORY_DOWNLOADS：/storage/emulated/0/Downloads• DIRECTORY_DCIM：/storage/emulated/0/Dcim• DIRECTORY_DOCUMENTS：/storage/emulated/0/DocumentsAndroid2.2 引入了基于扩展存储器的应用缓存目录，该目录指向大容量的扩展存储器。与应用的内存私有目录一样，缓存目录会随着应用的卸载一并删除。• 和内部存储一样，会在SD 卡的Android/data 目录下生成对应包名的文件夹：• getExternalFilesDir(type)：返回/storage/emulated/0/Android/data/包名/files。• getExternalCacheDir()：返回/storage/emulated/0/Android/data/应用包名/cache。• getObbDir()：返回/storage/emulated/0/Android/obb/包名。 五、文件API 1234567891011121314151617181920212223242526272829303132333435363738394041424344对象实例化：• File file= new File (&quot;/mnt/sdcard/test.txt&quot;);• File file= new File(&quot;/mnt/sdcard/temp&quot;, &quot;test.txt&quot;);判断文件是否存在：• file.exists();删除文件：• file.delete();创建文件夹：• file=new File(&quot;/mnt/sdcard/temp&quot;);• file.mkdir();创建文件：• File file= new File (&quot;/mnt/sdcard/temp/test.txt&quot;);• file.createNewFile();• booleanisDirectory() ：测试此File对象表示的文件是否是目录。• booleanmkdirs() ：创建包括父目录的目录。• String getAbsolutePath()：返回此对象表示的文件的绝对路径名。• String getName() ：返回此对象表示的文件的名称。• String getParent() ：返回此File对象的路径名的上一级,若路径名没有上一级，则返回null。• openFileOutput(String name,intmode);打开应用程序私有目录下的指定私有文件以写入数据，返回一个FileOutputStream对象，如果文件不存在就创建这个文件。• openFileInput(String fileName); 打开应用程序私有目录下的指定私有文件以读入数据，返回一个FileInputStream对象。openFileOutput()方法的第一参数用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。openFileOutput()方法的第二参数用于指定操作模式，有四种模式：• Context.MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。• Context.MODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。• MODE_WORLD_READABLE：表示当前文件可以被其他应用读取。• MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。• MODE_WORLD_READABLE+MODE_WORLD_WRITEABLE：既可以读又可以写。写文件：• FileOutputStreamfos = openFileOutput(fileName,MODE_PRIVATE);• byte[] bytes = message.getBytes();• fos.write(bytes);• fos.close();读文件：• FileInputStreamfin = openFileInput(fileName);• int length = fin.available();• byte[] buffer = new byte[length];• fin.read(buffer);• result = EncodingUtils.getString(buffer,ENCODING);• fin.close();","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 使用（五）","slug":"as-use-5","date":"2020-03-15T08:05:36.000Z","updated":"2021-10-07T08:25:31.012Z","comments":true,"path":"2020/03/15/as-use-5/","link":"","permalink":"https://shadowbynl.github.io/2020/03/15/as-use-5/","excerpt":"代码","text":"代码 （0）测试专用布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面4&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面3&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.1&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.25&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.4&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面1&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面2&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline17&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.55&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline18&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.7&quot; /&gt; &lt;Button android:id=&quot;@+id/button7&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面5&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.483&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button8&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面6&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button9&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面7&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.677&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt; &lt;Button android:id=&quot;@+id/button10&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面8&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （1）ScollView 滚动文本视图（未解决排版问题）布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main5Activity&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.92&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;ScrollView android:id=&quot;@+id/scrollView&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:scrollbars=&quot;none&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline5&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:singleLine=&quot;false&quot; /&gt; &lt;/ScrollView&gt; &lt;Button android:id=&quot;@+id/button5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;up&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline6&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline5&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;down&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline6&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline5&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; java 注意onTouchListner需要加注解压警告 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.annotation.SuppressLint;import android.content.Context;import android.os.Bundle;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.widget.Button;import android.widget.ScrollView;import android.widget.Scroller;import android.widget.TextView;@SuppressLint(&quot;ClickableViewAccessibility&quot;)public class Main5Activity extends AppCompatActivity implements View.OnTouchListener &#123; private Context context; private TextView tv1; private ScrollView sv1; private Button bt1; private Button bt2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main5); context = this; tv1 = findViewById(R.id.textView); tv1.setText(R.string.textView_text); sv1 = findViewById(R.id.scrollView); sv1.setOnTouchListener(this); bt1 = findViewById(R.id.button5); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sv1.scrollBy(0, -30); &#125; &#125;); bt2 = findViewById(R.id.button6); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sv1.scrollBy(0, 30); &#125; &#125;); &#125; @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; switch (motionEvent.getAction()) &#123; case MotionEvent.ACTION_MOVE: &#123; if (sv1.getScrollY() &lt;= 0) &#123; Log.i(&quot;Main&quot;, &quot;顶部状态&quot;); &#125; if (sv1.getChildAt(0).getMeasuredHeight() &lt;= sv1.getHeight() + sv1.getScrollY()) &#123; Log.i(&quot;Main&quot;, &quot;底部状态&quot;); tv1.append(getString(R.string.textView_text)); &#125; break; &#125; &#125; return false; &#125;&#125; （2）Gallery 缩略图 + ImageSwitcher 大图浏览布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main6Activity&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline7&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.18&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline8&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.52&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline9&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.02&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline10&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.86&quot; /&gt; &lt;Gallery android:id=&quot;@+id/gallery&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline7&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline9&quot; /&gt; &lt;ImageSwitcher android:id=&quot;@+id/imageSwitcher&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline8&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline7&quot; /&gt; &lt;ImageSwitcher android:id=&quot;@+id/imageSwitcher2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline10&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageSwitcher&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.view.View;import android.view.animation.AnimationUtils;import android.widget.AdapterView;import android.widget.Gallery;import android.widget.ImageSwitcher;import android.widget.ImageView;import android.widget.ViewSwitcher;import com.example.app_z.custom.ImageAdapter;public class Main6Activity extends AppCompatActivity implements ViewSwitcher.ViewFactory &#123; private Context context; private Gallery gallery; private ImageAdapter adapter; private ImageSwitcher imageSwitcher1; private ImageSwitcher imageSwitcher2; private int[] res = &#123;R.drawable.h1, R.drawable.h2, R.drawable.h3, R.drawable.h4&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main6); context = this; gallery = findViewById(R.id.gallery); adapter = new ImageAdapter(res, context); gallery.setAdapter(adapter); imageSwitcher1 = findViewById(R.id.imageSwitcher); imageSwitcher2 = findViewById(R.id.imageSwitcher2); imageSwitcher1.setFactory(this); imageSwitcher2.setFactory(this); imageSwitcher1.setInAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_in)); imageSwitcher1.setOutAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_out)); imageSwitcher2.setOutAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_in)); imageSwitcher2.setOutAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_out)); gallery.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; imageSwitcher1.setBackgroundResource(res[i % Integer.MAX_VALUE]); imageSwitcher2.setBackgroundResource(res[res.length - 1 - (i % Integer.MAX_VALUE)]); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) &#123; &#125; &#125;); &#125; @Override public View makeView() &#123; ImageView imageView = new ImageView(context); imageView.setScaleType(ImageView.ScaleType.FIT_CENTER); return imageView; &#125;&#125; （3）Log输出类型，确认/单选/复选/列表/自定义对话框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import androidx.constraintlayout.widget.ConstraintLayout;import android.app.AlertDialog;import android.content.Context;import android.content.DialogInterface;import android.os.Bundle;import android.text.Layout;import android.util.Log;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.Toast;public class Main7Activity extends AppCompatActivity &#123; private Context context; private Button button1; private Button button2; private Button button3; private Button button4; private Button button5; private Button button6; private Button button7; private Button button8; private String[] single_dialog = &#123;&quot;金星&quot;, &quot;木星&quot;, &quot;火星&quot;, &quot;水星&quot;, &quot;土星&quot;&#125;; private String[] muti_dialog = &#123;&quot;saber&quot;, &quot;violet&quot;, &quot;mikasa&quot;, &quot;yui&quot;&#125;; private String[] item_dialog = &#123;&quot;paworks&quot;, &quot;bone&quot;, &quot;whitefox&quot;, &quot;京都&quot;, &quot;madhouse&quot;&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main7); context = this; button1 = findViewById(R.id.button); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //最后日志输出结果说明，颜色并没有那么多，而且还有一种assert Log.v(&quot;tag&quot;, &quot;verbose模式，打印最详细的日志 黑色&quot;); Log.d(&quot;tag&quot;, &quot;debug级别 蓝色&quot;); Log.i(&quot;tag&quot;, &quot;info级别 绿色&quot;); Log.w(&quot;tag&quot;, &quot;warn级别 橙色&quot;); Log.e(&quot;tag&quot;, &quot;error级别 红色&quot;); &#125; &#125;); button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast toast = Toast.makeText(context, &quot;显示一条消息&quot;, Toast.LENGTH_LONG * 6); toast.setGravity(Gravity.CENTER, 0, 100); //自定义位置 LinearLayout toast_layout = (LinearLayout)toast.getView(); //设置图片 ImageView imageView = new ImageView(context); imageView.setBackgroundResource(R.drawable.v1); toast_layout.addView(imageView); toast.show(); &#125; &#125;); button3 = findViewById(R.id.button3); button3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //自定义Toast布局，事实证明约束布局无法显示 Toast toast = Toast.makeText(context, &quot;显示一条消息&quot;, Toast.LENGTH_LONG * 6); LayoutInflater inflater = LayoutInflater.from(context); View toast_layout = inflater.inflate(R.layout.toast_layout, null); toast.setView(toast_layout); toast.show(); &#125; &#125;); button4 = findViewById(R.id.button4); button4.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(&quot;确认对话框&quot;); builder.setIcon(R.drawable.v1); builder.setMessage(&quot;确认对话框提示内容&quot;); builder.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, &quot;点击了确认按钮&quot;, Toast.LENGTH_LONG * 10).show(); &#125; &#125;); builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, &quot;点击了取消按钮&quot;, Toast.LENGTH_LONG * 10).show(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button5 = findViewById(R.id.button7); button5.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //注意只有确认对话框可以设置message 其他若设置会影响项的显示 AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(&quot;单选对话框&quot;); builder.setIcon(R.drawable.v1); //builder.setMessage(&quot;单选对话框提示内容&quot;); builder.setSingleChoiceItems(single_dialog, 0, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, &quot;选择了&quot; + single_dialog[i], Toast.LENGTH_LONG * 10).show(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button6 = findViewById(R.id.button8); button6.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(&quot;多选对话框&quot;); builder.setIcon(R.drawable.v1); builder.setMultiChoiceItems(muti_dialog, null, new DialogInterface.OnMultiChoiceClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i, boolean b) &#123; if (b) &#123; Toast.makeText(context, &quot;选择了&quot; + muti_dialog[i], Toast.LENGTH_LONG * 3).show(); &#125; else &#123; Toast.makeText(context, &quot;取消选择了&quot; + muti_dialog[i], Toast.LENGTH_LONG * 3).show(); &#125; &#125; &#125;); builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; dialogInterface.dismiss(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button7 = findViewById(R.id.button9); button7.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(&quot;多选对话框&quot;); builder.setIcon(R.drawable.v1); builder.setItems(item_dialog, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, &quot;选择了&quot; + item_dialog[i], Toast.LENGTH_LONG * 3).show(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button8 = findViewById(R.id.button10); button8.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(&quot;自定义对话框&quot;); builder.setIcon(R.drawable.v1); LayoutInflater inflater = LayoutInflater.from(context); View dialog_lagout = inflater.inflate(R.layout.toast_layout, null); builder.setView(dialog_lagout); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); &#125;&#125; （4）notification状态栏 选项菜单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.Toast;import java.util.Locale;public class Main8Activity extends AppCompatActivity &#123; private Context context; private Button button1; private Button button2; private Button button3; private Button button4; private Button button5; private Button button6; private Button button7; private Button button8; private NotificationManager notificationManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main8); context = this; notificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE); button1 = findViewById(R.id.button); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0); Notification.Builder builder = new Notification.Builder(context); builder.setSmallIcon(R.drawable.v1); //设置图标 builder.setTicker(&quot;状态栏的提示&quot;); builder.setWhen(System.currentTimeMillis()); //设置时间 builder.setContentTitle(&quot;状态栏标题&quot;); builder.setContentText(&quot;状态栏通知内容&quot;); builder.setContentIntent(pendingIntent); //点击后的意图// builder.setDefaults(Notification.DEFAULT_LIGHTS); //设置指示灯// builder.setDefaults(Notification.DEFAULT_SOUND); //设置提示声音// builder.setDefaults(Notification.DEFAULT_LIGHTS); //设置振动 builder.setDefaults(Notification.DEFAULT_ALL); Notification notification = builder.build(); notificationManager.notify(1, notification); &#125; &#125;); button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() &#123; @Override //通过自定义的通知id即可取消通知 public void onClick(View view) &#123; notificationManager.cancel(1); &#125; &#125;); &#125; /* 创建选项菜单 */ @Override public boolean onCreateOptionsMenu(Menu menu) &#123; menu.add(0, 100, 1, &quot;菜单项一&quot;); //参数依次表示：分组序号、自定义id、优先级、项内容 menu.add(0, 101, 1, &quot;菜单项二&quot;); menu.add(0, 102, 1, &quot;菜单项三&quot;); return true; &#125; /* 给选项菜单列表项添加点击事件 */ @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case 100: &#123; Toast.makeText(context, &quot;点击了菜单项一&quot;, Toast.LENGTH_LONG * 3).show(); break; &#125; case 101: &#123; Toast.makeText(context, &quot;点击了菜单项二&quot;, Toast.LENGTH_LONG * 3).show(); break; &#125; case 102: &#123; Toast.makeText(context, &quot;点击了菜单项三&quot;, Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; return true; &#125;&#125; （5）上下文菜单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.ContextMenu;import android.view.MenuItem;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.Toast;import com.example.app_z.Data;public class Main9Activity extends AppCompatActivity &#123; private Context context; private ListView listView; private ArrayAdapter&lt;String&gt; adapter; private String[] vname = Data.vname; private String selected; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main9); context = this; listView = findViewById(R.id.listView); adapter = new ArrayAdapter&lt;&gt;(context, android.R.layout.simple_list_item_1, vname); listView.setAdapter(adapter); this.registerForContextMenu(listView); //注册 listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; selected = vname[i]; &#125; &#125;); &#125; @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; super.onCreateContextMenu(menu, v, menuInfo); menu.setHeaderTitle(&quot;上下文菜单&quot;); menu.setHeaderIcon(R.drawable.v1); menu.add(1, 1, 1, &quot;百度百科&quot;); menu.add(1, 2, 1, &quot;bangumi&quot;); &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case 1: &#123; Intent intent = new Intent(context, Main2Activity.class); intent.putExtra(&quot;url&quot;, &quot;https://baike.baidu.com/item/&quot; + selected); startActivity(intent); break; &#125; case 2: &#123; Toast.makeText(context, &quot;通过利用全局变量实现菜单和上下文的关联&quot;, Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; return true; &#125;&#125; （6）子菜单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.SubMenu;import android.widget.Toast;import javax.security.auth.Subject;public class Main10Activity extends AppCompatActivity &#123; private Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main10); context = this; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; SubMenu file = menu.addSubMenu(&quot;文件&quot;); SubMenu edit = menu.addSubMenu(&quot;编辑&quot;); file.setHeaderTitle(&quot;文件操作&quot;); file.setIcon(R.drawable.v1); file.add(1, 1, 1, &quot;新建&quot;); file.add(1, 2, 1, &quot;打开&quot;); file.add(1, 3, 1, &quot;保存&quot;); edit.setHeaderTitle(&quot;文本操作&quot;); edit.setIcon(R.drawable.v2); edit.add(2, 1, 1, &quot;复制&quot;); edit.add(2, 2, 1, &quot;粘贴&quot;); edit.add(2, 3, 1, &quot;剪切&quot;); return true; &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; if (item.getGroupId() == 1) &#123; switch (item.getItemId()) &#123; case 1: &#123; Toast.makeText(context, &quot;item.getTitle()不能用&quot;, Toast.LENGTH_LONG * 3).show(); break; &#125; case 2: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; case 3: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; &#125; else &#123; switch (item.getItemId()) &#123; case 1: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; case 2: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; case 3: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"android基本概念（三）","slug":"a-study-3","date":"2020-03-15T07:38:41.000Z","updated":"2021-10-07T08:24:30.065Z","comments":true,"path":"2020/03/15/a-study-3/","link":"","permalink":"https://shadowbynl.github.io/2020/03/15/a-study-3/","excerpt":"Activity生命周期","text":"Activity生命周期 一、Activity与状态改变 123456• Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件或查看地图等操作。• 每个Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。• 一个应用通常由多个彼此松散联系的Activity 组成。一般会指定应用中的某个Activity 为“主”Activity，即首次启动应用时呈现给用户的那个Activity。而且每个Activity 均可启动另一个Activity，以便执行不同的操作。每次新Activity 启动时，前一Activity 便会停止，但系统会在堆栈（“返回栈”）中保留该Activity。• 当新Activity 启动时，系统会将其推送到返回栈上，并取得用户焦点。返回栈遵循基本的“后进先出”堆栈机制，因此，当用户完成当前Activity 并按“返回”按钮时，系统会从堆栈中将其弹出（并销毁），然后恢复前一Activity。• 当一个Activity 因某个新Activity 启动而停止时，系统会通过该Activity 的生命周期回调方法通知其这一状态变化。• Activity 因状态变化—系统是创建Activity、停止Activity、恢复Activity 还是销毁Activity—而收到的回调方法可能有若干种，每一种回调都会为您提供执行与该状态变化相应的特定操作的机会。例如，停止时，您的Activity 应释放任何大型对象，例如网络或数据库连接。当Activity 恢复时，您可以重新获取所需资源，并恢复执行中断的操作。这些状态转变都是Activity 生命周期的一部分。 状态 1234567• onCreate：Activity创建时调用。• onStart：可见未获取焦点，无法与之交互。• onResume：可见已获取焦点，可与之交互。• onPause：可见，失去焦点。• onStop：不可见。• onRestart：Activity重启。• onDestory：Activity被销毁。 二、生命周期 123456789• Activity 的整个生命周期发生在onCreate() 调用与onDestroy() 调用之间。• 您的Activity 应在onCreate() 中执行“全局”状态设置（例如定义布局），并释放onDestroy() 中的所有其余资源。• 例如，如果您的Activity 有一个在后台运行的线程，用于从网络上下载数据，它可能会在onCreate() 中创建该线程，然后在onDestroy() 中停止该线程。• Activity 的可见生命周期发生在onStart() 调用与onStop() 调用之间。• 在这段时间，用户可以在屏幕上看到Activity 并与其交互。例如，当一个新Activity 启动，并且此Activity 不再可见时，系统会调用onStop()。您可以在调用这两个方法之间保留向用户显示Activity 所需的资源。• 例如，您可以在onStart() 中注册一个BroadcastReceiver以监控影响UI 的变化，并在用户无法再看到您显示的内容时在onStop() 中将其取消注册。在Activity 的整个生命周期，当Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用onStart() 和onStop()。• Activity 的前台生命周期发生在onResume() 调用与onPause() 调用之间。• 在这段时间，Activity 位于屏幕上的所有其他Activity 之前，并具有用户输入焦点。Activity 可频繁转入和转出前台—例如，当设备转入休眠状态或出现对话框时，系统会调用onPause()。• 由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待。 三、注意点常见行为与调用方法 事件处理一、概述 123456• 在Android 系统中，从用户与应用的交互中截获事件的方法不止一种。如考虑截获用户界面内的事件，则可从用户与之交互的特定视图对象中捕获事件。为此，View 类提供了多种方法。• 在您将用于构建布局的各种View 类中，您可能会注意到几种看起来适用于UI 事件的公共回调方法。当该对象上发生相应的操作时，Android 框架会调用这些方法。• 例如，在触摸一个视图对象（例如“按钮”）时，对该对象调用onTouchEvent() 方法。不过，为了截获此事件，您必须扩展View 类并重写该方法。然而，为了处理此类事件而扩展每个视图对象并不现实。• 正因如此，View 类还包含一系列嵌套接口以及您可以更加轻松定义的回调。这些接口称为事件侦听器，是您捕获用户与UI 之间交互的票证。• 尽管您通常会使用事件侦听器来侦听用户交互，但有时您确实需要扩展View 类以构建自定义组件。也许，您想扩展Button 类来丰富某些内容的样式。在这种情况下，您将能够使用该类的事件处理程序为类定义默认事件行为。• 事件侦听器是View 类中包含一个回调方法的接口。当用户与UI 项目之间的交互触发已注册此视图的侦听器时，Android 框架将调用这些方法。 二、Android事件侦听器的回调方法 1234567891011• onClick()：在View.OnClickListener中。当用户触摸项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，将调用此方法。• onLongClick()：在View.OnLongClickListener中。当用户触摸并按住项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按住适用的“Enter”键或按住轨迹球（持续一秒钟）时，将调用此方法。• onFocusChange()：在View.OnFocusChangeListener中。当用户使用导航键或轨迹球导航到或远离项目时，将调用此方法。• onKey()：在View.OnKeyListener中。当用户聚焦于项目并按下或释放设备上的硬按键时，将调用此方法。• onTouch()：在View.OnTouchListener中。当用户执行可视为触摸事件的操作时，其中包括按下、释放或屏幕上的任何移动手势（在项目边界内），将调用此方法。• onCreateContextMenu()：在View.OnCreateContextMenuListener中。当（因持续“长按”而）生成上下文菜单时，将调用此方法。请参见菜单开发者指南中有关上下文菜单的阐述。• onClick() 回调没有返回值，但是其他某些事件侦听器方法必须返回布尔值。具体原因取决于事件。• 对于这几个事件侦听器，必须返回布尔值的原因如下：• onLongClick()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。也就是说，返回true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何点击侦听器，则返回false。• onKey()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。也就是说，返回true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何按键侦听器，则返回false。• onTouch()：此方法返回一个布尔值，表示侦听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。因此，如果在收到关闭操作事件时返回false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。因此，您无需执行事件内的任何其他操作，如手势或最终操作事件。 三、事件侦听实现的三种方式 1234• 使用匿名类需要编写额外代码，安全性最高。• 使用Activity 类更为方便，可以避免加载额外的类和分配对象，但需要对View的ID进行识别，可能引入安全风险。• 使用布局文件最为简单，但无法实现比较复杂的功能。• 需要根据项目实际情况进行选择。","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"android基本概念（二）","slug":"a-study-2","date":"2020-03-15T04:09:57.000Z","updated":"2021-10-07T08:24:24.919Z","comments":true,"path":"2020/03/15/a-study-2/","link":"","permalink":"https://shadowbynl.github.io/2020/03/15/a-study-2/","excerpt":"Service","text":"Service 一、概述 可见不可交互：Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。 服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信(IPC)。例如，服务可以处理网络事务、播放音乐，执行文件I/O或与内容提供程序交互，而所有这一切均可在后台进行。 二、服务的两种状态与生命周期 两种状态 Started启动当应用组件（如Activity）通过调用startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。操作完成后，服务会自行停止运行。 Bound绑定当应用组件通过调用bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信(IPC) 跨进程执行这些操作。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 回调方法 onStartCommand()：当另一个组件（如Activity）通过调用startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。如果您实现此方法，则在服务工作完成后，需要由您通过调用stopSelf() 或stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。） onBind()：当另一个组件想通过调用bindService() 与服务绑定（例如执行RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回IBinder提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回null。 onUnbind()：当组件中断所有与服务绑定的连接时，系统调用该方法。 onRebind()：当新的组件与服务绑定，且此前它已经通过onUnbind(Intent)通知断开连接时，系统调用该方法。 onCreate()：首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用onStartCommand() 或onBind() 之前）。如果服务已在运行，则不会调用此方法。 生命周期12341.服务的整个生命周期从调用onCreate() 开始起，到onDestroy() 返回时结束。与Activity 类似，服务也在onCreate() 中完成初始设置，并在onDestroy() 中释放所有剩余资源。例如，音乐播放服务可以在onCreate() 中创建用于播放音乐的线程，然后在onDestroy() 中停止该线程。2.无论服务是通过startService() 还是bindService() 创建，都会为所有服务调用onCreate() 和onDestroy() 方法。3.服务的有效生命周期从调用onStartCommand() 或onBind() 方法开始。每种方法均有&#123;Intent 对象，该对象分别传递到startService() 或bindService()。4.对于启动服务，有效生命周期与整个生命周期同时结束（即便是在onStartCommand() 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在onUnbind() 返回时结束。 三、代码（1）布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.1&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.25&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.4&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;StartService&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;StopService&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;Button android:id=&quot;@+id/button4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;UnBindService&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;BindService&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline17&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.55&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline18&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.7&quot; /&gt; &lt;Button android:id=&quot;@+id/button5&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;播放&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.483&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;暂停&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button7&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;上一首&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.677&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt; &lt;Button android:id=&quot;@+id/button8&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;下一首&quot; android:textSize=&quot;24sp&quot; android:onClick=&quot;onClick&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （2）Activity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.example.app_service;import androidx.appcompat.app.AppCompatActivity;import android.app.Service;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Binder;import android.os.Bundle;import android.os.IBinder;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Context context; private Intent intent1; private Intent intent2; private ServiceConnection serviceConnection; private CustomBindService service; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; service = ((CustomBindService.CustomBinder) iBinder).getService(); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125;; &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button: &#123; intent1 = new Intent(context, CustomStartService.class); startService(intent1); break; &#125; case R.id.button2: &#123; stopService(intent1); break; &#125; case R.id.button3: &#123; intent2 = new Intent(context, CustomBindService.class); bindService(intent2, serviceConnection, Service.BIND_AUTO_CREATE); break; &#125; case R.id.button4: &#123; unbindService(serviceConnection); break; &#125; case R.id.button5: &#123; service.play(); break; &#125; case R.id.button6: &#123; service.pause(); break; &#125; case R.id.button7: &#123; service.previous(); break; &#125; case R.id.button8: &#123; service.next(); break; &#125; &#125; &#125; @Override protected void onDestroy() &#123; stopService(intent1); unbindService(serviceConnection); super.onDestroy(); &#125;&#125; （3）CustomStartService 12345678910111213141516171819202122232425262728293031323334353637package com.example.app_service;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.util.Log;public class CustomStartService extends Service &#123; public CustomStartService() &#123; &#125; @Override public void onCreate() &#123; Log.i(&quot;service&quot;, &quot;执行onCreate&quot;); super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i(&quot;service&quot;, &quot;执行onStartCommand&quot;); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; Log.i(&quot;service&quot;, &quot;执行onDestroy&quot;); super.onDestroy(); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.i(&quot;service&quot;, &quot;执行onBind&quot;); // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); &#125;&#125; （4）CustomBindService 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.app_service;import android.app.Service;import android.content.Intent;import android.content.ServiceConnection;import android.os.Binder;import android.os.IBinder;import android.util.Log;public class CustomBindService extends Service &#123; public CustomBindService() &#123; &#125; public class CustomBinder extends Binder &#123; public CustomBindService getService() &#123; return CustomBindService.this; &#125; &#125; @Override public void onCreate() &#123; Log.i(&quot;service&quot;, &quot;执行onCreate&quot;); super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.i(&quot;service&quot;, &quot;执行onBind&quot;); return new CustomBinder(); &#125; @Override public void unbindService(ServiceConnection conn) &#123; Log.i(&quot;service&quot;, &quot;执行unbindService&quot;); super.unbindService(conn); &#125; @Override public void onDestroy() &#123; Log.i(&quot;service&quot;, &quot;执行onDestroy&quot;); super.onDestroy(); &#125; public void play() &#123; Log.i(&quot;music&quot;, &quot;执行play&quot;); &#125; public void pause() &#123; Log.i(&quot;music&quot;, &quot;执行pause&quot;); &#125; public void previous() &#123; Log.i(&quot;music&quot;, &quot;执行previous&quot;); &#125; public void next() &#123; Log.i(&quot;music&quot;, &quot;执行next&quot;); &#125;&#125; BroadCast Receiver一、概述 Broadcast Receiver本质上是一个全局的监听器，属于Android四大组件之一。 Android广播分为两个方面：广播发送者、广播接收者（BroadcastReceiver） Broadcast Receiver用于监听（接收）应用发出的广播消息，并做出响应。 不同组件之间通信（包括应用内/ 不同应用之间），Android系统在特定情况下与App之间的消息通信，多线程通信。 二、实现原理 12345678• 自定义广播接收者BroadcastReceiver子类，并复写onRecvice（）方法；• 通过Binder机制向AMS（Activity Manager Service）进行注册；• 广播发送者通过Binder机制向AMS发送广播；• AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；• 消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。• 广播接收器接收到相应广播后，会自动回调onReceive()方法。• 一般情况下，onReceive方法会涉及与其他组件之间的交互，如发送Notification、启动service等。• 默认情况下，广播接收器运行在UI线程，因此，onReceive方法不能行耗时操作，否则将导致ANR（Application Not Responding）。 三、两种注册方式 静态注册：在AndroidManifest.xml里通过标签声明。 动态注册：动态注册，在代码中通过调用Context的registerReceiver（）方法进行动态注册BroadcastReceiver。 注意：Android Oreo已限制App在后台接收Intent广播信息，需要修改build.gradle中targetSdkVersion的值，使其小于等于25。 动态广播的注册销毁的时机12345• 动态广播最好在Activity的onResume()注册、onPause()注销。• 在onResume()注册、onPause()注销是因为onPause()在App死亡前一定会被执行，从而保证广播在App死亡前一定会被注销，从而防止内存泄露。• 不在onCreate() &amp; onDestory() 或onStart() &amp; onStop()注册、注销是因为：当系统因为内存不足要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。• 假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。• 但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。 两种方式的比较 四、系统广播与接收 系统广播123• Android中内置了多个系统广播（System Broadcast），只要涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播。• 当使用系统广播时，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播。• 每个广播都有特定的Intent -Filter（包括具体的action），Android系统广播action如下： 静态注册系统广播接收器 动态注册系统广播接收器 五、应用间广播和应用内广播 应用间广播的问题123• Android中的广播可以跨App直接通信（exported对于有intent-filter情况下默认值为true）。可能出现的问题：• 其他App针对性发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收广播并处理；• 其他App注册与当前App一致的intent-filter用于接收广播，获取广播具体信息。 App应用内广播（Local Broadcast）12• App应用内广播可理解为一种局部广播，广播的发送者和接收者都同属于一个App。• 相比于全局广播（普通广播），App应用内广播优势体现在：安全性高、效率高。 123• 注册广播时将exported属性设置为false，使得非本App内部发出的此广播不被接收；• 在广播发送和接收时，增设相应权限permission，用于权限验证；• 发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。 12• 使用封装好的LocalBroadcastManager类：• 使用方式上与全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将参数的context变成了LocalBroadcastManager的单一实例。 六、注意事项 对于不同注册方式的广播接收器回调OnReceive（Context context，Intent intent）中的context返回值是不一样的：1234• 对于静态注册（全局+应用内广播），回调onReceive(context, intent)中的context返回值是：ReceiverRestrictedContext；• 对于全局广播的动态注册，回调onReceive(context, intent)中的context返回值是：Activity Context；• 对于应用内广播的动态注册（LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Application Context；• 对于应用内广播的动态注册（非LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Activity Context。 其他参考（关于广播类型与特点）12345678910111213# 普通广播 同级别收到先后随机 指定优先级 是在 intent filter 里指定 android: priority 范围是-1000到1000指定优先级后，数值大的先收到截断广播（不能）也不能处理静态注册 在清单文件中 是全局有效的动态注册 优先级高于静态 缺点是 只有当前Activity在运行时才生效# 有序广播 同级别随机先收到的可以截断处理 可以传输数据之类# 异步广播 可以先发送 后注册接收者 需要加权限 七、代码（1）Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.example.app_bcr;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.content.IntentFilter;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private MyReceiver3 myReceiver3; private MyReceiver6 myReceiver6; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //动态注册与注销 @Override protected void onResume() &#123; super.onResume(); IntentFilter intentFilter = new IntentFilter(&quot;com.example.app_bcr&quot;); myReceiver3 = new MyReceiver3(); registerReceiver(myReceiver3, intentFilter); &#125; @Override protected void onPause() &#123; super.onPause(); unregisterReceiver(myReceiver3); unregisterReceiver(myReceiver6); &#125; //静态注册在清单文件中 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button: &#123; Intent intent = new Intent(); intent.putExtra(&quot;msg&quot;, &quot;这是一条普通广播&quot;); intent.setAction(&quot;com.example.app_bcr&quot;); sendBroadcast(intent); break; &#125; case R.id.button2: &#123; Intent intent = new Intent(); intent.putExtra(&quot;msg&quot;, &quot;这是一条有序广播&quot;); intent.setAction(&quot;com.example.app_bcr_o&quot;); sendOrderedBroadcast(intent, null); break; &#125; case R.id.button3: &#123; Intent intent = new Intent(); intent.putExtra(&quot;msg&quot;, &quot;这是一条异步广播&quot;); intent.setAction(&quot;com.example.app_bcr_a&quot;); sendStickyBroadcast(intent); IntentFilter intentFilter = new IntentFilter(&quot;com.example.app_bcr_a&quot;); myReceiver6 = new MyReceiver6(); registerReceiver(myReceiver6, intentFilter); break; &#125; &#125; &#125;&#125;// MyReceiver MyReceiver2 MyReceiver3接收的是 普通广播// 前两个输出的先后体现了优先级设置的作用，第三个和前两个比较体现了动态注册优先级高于静态// MyReceiver4 MyReceiver5接收的是 有序广播 在设置了优先级之后，可以实现广播的有序处理和传播// MyReceiver6接收的是 异步广播 可以看出已经不推荐使用 它能够先发送广播再注册// 注意动态注册与注销分别在onResume 和 onPause中进行// 至于系统广播，应用内广播可直接参考写 （2）清单文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.app_bcr&quot;&gt;&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot;/&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;receiver android:name=&quot;.MyReceiver6&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt;&lt;/receiver&gt; &lt;receiver android:name=&quot;.MyReceiver5&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;100&quot;&gt; &lt;action android:name=&quot;com.example.app_bcr_o&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;.MyReceiver4&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;200&quot;&gt; &lt;action android:name=&quot;com.example.app_bcr_o&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;.MyReceiver3&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; /&gt; &lt;receiver android:name=&quot;.MyReceiver2&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;100&quot;&gt; &lt;action android:name=&quot;com.example.app_bcr&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;.MyReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;200&quot;&gt; &lt;action android:name=&quot;com.example.app_bcr&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"android基本概念（一）","slug":"a-study-1","date":"2020-03-05T08:21:35.000Z","updated":"2021-10-07T08:24:16.953Z","comments":true,"path":"2020/03/05/a-study-1/","link":"","permalink":"https://shadowbynl.github.io/2020/03/05/a-study-1/","excerpt":"一、概述","text":"一、概述 （1）概述：Intent的中文意思是“意图，意向”，在Android中提供了Intent机制来协助应用间的交互与通讯，Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将Intent传递给调用的组件，并完成组件的调用。Intent不仅可用于应用程序之间，也可用于应用程序内部的Activity/Service之间的交互。因此，可以将Intent理解为不同组件之间通信的“媒介”专门提供组件互相调用的相关信息。（2）功能：Intent 是一个将要执行的动作的抽象的描述，一般来说是作为参数来使用，由Intent来协助完成android各个组件之间的通讯。比如说调用startActivity()来启动一个activity,或者由broadcaseIntent()来传递给所有感兴趣的broadcastReceiver, 再或者由startService()/bindservice()来启动一个后台的service。Intent可以启动一个Activity，也可以启动一个Service，还可以发起一个广播Broadcast。二、属性和方法: 12345678910111213141516171819202122 • component(组件) ：目的组件。 • action （动作）：用来表现意图的行动。 • category （类别）：用来表现动作的类别。 • data （数据）：表示与动作要操纵的数据。 • type （数据类型）：对于data范例的描写。 • extras （扩展信息）：扩展信息。 • Flags （标志位）：期望这个意图的运行模式。 • setClass(Context packageContext,Classcls)：设置该Intent将要启动的组件对应的类。• setClassName(Context packageContext,StringclassName)：设置该Intent将要启动的组件对应的类。• setClassName(String packageContext,StringclassName)：设置该Intent将要启动的组件对应的类。 （1）Component属性： 123456789101112131415• Component属性明确指定Intent的目标组件的类名称。 • ComponentName对象包含的构造器 ： • ComponentName(String pkg,String cls) ：创建在pkg所在包下的 cls类所对应的组件 • ComponentName(Context pkg,String cls) ：创建在pkg所在包下的 cls类所对应的组件 • ComponentName(Context pkg,Class cls)创建在pkg所在包下的cls 类所对应的组件 • 一个ComponentName需要指定包名和类名，这就可以唯一确定一 个组件类。 （2）Action属性： Action 是一个用户定义的普通字符串，代表该Intent索要完成的一个抽象“动作”。用于描述一个Android 应用程序组件，一个Intent Filter 可以包含多个Action。在AndroidManifest.xml 的Activity 定义时，可以在其节点指定一个Action列表用于标识Activity 所能接受的“动作”。 Action要完成的只是一个抽象的动作，这个动作具体由哪个组件(Activity,Service,BroadcastReceiver)来完成，Action这个字符不管。比如Android提供的标准Action：Intent.ACTION_VIEW，它只表示一个抽象的查看动作，但具体什么，启动哪个Activity来看，Intent.ACTION_VIEW并不知道—这取决于Activity的配置，只要某个Activity的配置中包含了该ACTION_VIEW，该Activity就有可能被启动。 常见的ActivityAction： 常见的Broadcast Action：（3）Category属性： Category是要执行动作的目标所具有的特质或行为归类，在Intent对象中可添加任意多个category。 常见的category（4）Data和Type: Data，也就是执行动作要操作的数据。Android中采用指向数据的一个URI来表示，如在联系人应用中，一个指向某联系人的URI可能为：content://contacts/1。 Type，即数据类型，显式指定Intent的数据类型（MIME）。一般Intent的数据类型能够根据数据本身进行判定，但是通过设置这个属性，可以强制采用显式指定的类型而不再进行推导。 在AndroidManifest.xml的标签中包含了以下几种子元素，他们定义了url的匹配规则：12345678910111213141516• android:scheme：匹配url中的前缀，除了“http”、“https”、“tel”...之外，我们可以定义自己的前缀。• android:host：匹配url中的主机名部分，如“google.com”，如果定义为“*”则表示任意主机名。• android:port：匹配url中的端口。• android:path：匹配url中的路径。&lt;activity android:name=&quot;.TargetActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.scott.intent.action.TARGET&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:scheme=&quot;scott&quot; android:host=&quot;com.scott.intent.data&quot; android:port=&quot;7788&quot; android:path=&quot;/target&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; Intent的Action和Data组合例子：（5）Extras属性 Extras属性主要用于传递目标组件所需要的额外的数据。通过putExtras()方法设置。 常用值如下所示：1234567EXTRA_BCC：存放邮件密送人地址的字符串数组。EXTRA_CC：存放邮件抄送人地址的字符串数组。EXTRA_EMAIL：存放邮件地址的字符串数组。EXTRA_SUBJECT：存放邮件主题字符串。EXTRA_TEXT：存放邮件内容。EXTRA_KEY_EVENT：以KeyEvent对象方式存放触发Intent的按键。EXTRA_PHONE_NUMBER：存放调用ACTION_CALL时的电话号码。 （6）Flag（标记） Flag（标记）用于为Intent添加额外控制标记。 常用值如下所示：123456789• FLAG_ACTIVITY_BROUGHT_TO_FRONT：这个标志一般不是由程序代码设置的，如在launchMode中设置singleTask模式时系统帮你设定。• FLAG_ACTIVITY_CLEAR_TOP：如果目标Activity已经运行于当前的Task中，则关闭Activity Stack中在此Activity上方的所有Activity，然后将此Intent传递到该Activity实例内。• FLAG_ACTIVITY_NEW_TASK：将使Activity成为一个新Task的开始。• FLAG_ACTIVITY_NO_ANIMATION：这个标志将阻止系统进入下一个Activity时应用Acitivity迁移动画。• FLAG_ACTIVITY_NO_HISTORY：新的Activity将不再历史stack中保留。一旦离开，此Activity就关闭了。 三、显式INTENT和隐式Intent 显式：直接指明Intent的接收者，可以利用Bundle传输多对数据。（Bundle bundle = getIntent().getExtras();） 隐式：不指定接收者，指定Action + Data等，因未指定接收者，其意图需要经过过滤，即需要配置INTENT FILTER来确定Intent的接收者（其实这样实现了一个Intent多个接受者，只要满足条件） INTENT FILTER：在清单文件中的接收组件中注册&emsp;（0）概述：未指定接收者的隐式Intent，需要经过Action,Category,Data三种过滤联合筛选出可以接收意图的应用或组件。接收者是其他的应用，那么配置都用android提供的应该即可，但要指定自己应用中的组件接收，则需要通过自定义Action等来具体指定注意一定是完全匹配才可接收。&emsp;（1）意图过滤器 IntentFilter翻译成中文就是“意图过滤器”，主要用来过滤隐式意图。当用户进行一项操作的时候，Android系统会根据配置的“意图过滤器”来寻找可以响应该操作的组件，服务。 例如当用户点击PDF文件的时候，Android系统就会通过设定好的意图过滤器，进行匹配测试。找到能够打开PDF文件的APP程序。（2）三重过滤 Android系统会根据我们配置的Intent Filter（意图过滤器），来进行匹配测试。匹配的时候，只会考虑三个方面：动作、数据（URI以及数据类型）和类别。 也就是说Android系统会进行“动作测试”，“数据测试”，“类别测试”，来寻找可以响应隐式意图的组件或服务。 另外，当对其他App程序开放组件和服务的时候也需要配置IntentFilter（意图过滤器），一个Activity可以配置多个。（3）具体规则:123456789101112131415161718192021对应&lt;intent-filter&gt;中的&lt;action/&gt;标签1.如果&lt;intent-filter&gt;标签中有多个&lt;action/&gt;，那么Intent请求的Action，只要匹配其中的一条&lt;action/&gt;就可以通过了这条&lt;intent-filter&gt;的动作测试。 2.如果&lt;intent-filter&gt;中没有包含任何&lt;action/&gt;，那么无论什么Intent请求都无法和这条&lt;intent-filter&gt;匹配。3.如果Intent请求中没有设定Action(动作)，那么这个Intent请求就将顺利地通过&lt;intent-filter&gt;的动作测试（前提是&lt;intent-filter&gt;中必须包含有&lt;action/&gt;，否则与第二条冲突）。对应&lt;intent-filter&gt;中的&lt;category /&gt;标签1.Intent中的类别必须全部匹配&lt;intent-filter&gt;中的&lt;category /&gt;，但是&lt;intent-filter&gt;中多余的&lt;category /&gt;将不会导致匹配失败。例如：Intent中有3个类别，而意图过滤器中定义了5个，如果Intent中的3个类别都与过滤器中的匹配，那么过滤器中的另外2个，将不会导致类别测试失败。2.注意有一个例外，Android把所有传给startActivity()的隐式意图当作他们包含至少一个类别：&quot;android.intent.category.DEFAULT&quot; （CATEGORY_DEFAULT常量）。因此，想要接收隐式意图的活动必须在它们的意图过滤器中包含&quot;android.intent.category.DEFAULT&quot;。对应&lt;intent-filter&gt;中的&lt;data&gt;标签1. &lt;data&gt;元素指定了可以接受的Intent传过来的数据URI和数据类型，当一个意图对象中的URI被用来和一个过滤器中的URI比较时，比较的是URI的各个组成部分。2. 例如：如果过滤器仅指定了一个scheme，所有该scheme的URIs都能够和这个过滤器相匹配；如果过滤器指定了一个scheme、主机名但没有路经部分，所有具有相同scheme和主机名的URIs都可以和这个过滤器相匹配，而不管它们的路经；如果过滤器指定了一个scheme、主机名和路经，只有具有相同scheme、主机名和路经的URIs才可以和这个过滤器相匹配。3. 当然，一个过滤器中的路径规格可以包含通配符，这样只需要部分匹配即可。 四、注意点经过后期编写代码，发现需要注意的几个点： action、data这些可以在构造intent时直接作为参数传入，也可以在后面用intent的相关set方法设置。 action的值除了android默认定义好的与系统有关的行为外，如果是涉及要发送intent交给对应的自定义的Activity或Service或Broadcast Receiver处理，那么一般的值应该定义成目标组件所在的包的完整的包名。 data，就目前来看，其值的指定是通过Uri.parse(uri)。 发送请求的action有一条和过滤器中的匹配即可（其实是接收的可以写多个action 但发送的只有一种action），请求时定义的category对应的接收者过滤器中必须全都有（注意DEFAULT） 例","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 使用（四）","slug":"as-use-4","date":"2020-03-04T12:34:55.000Z","updated":"2021-10-07T08:25:13.353Z","comments":true,"path":"2020/03/04/as-use-4/","link":"","permalink":"https://shadowbynl.github.io/2020/03/04/as-use-4/","excerpt":"一、代码","text":"一、代码 （1）测试专用布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面4&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面3&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline2&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.1&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.25&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.4&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面1&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面2&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline17&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.55&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline18&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.7&quot; /&gt; &lt;Button android:id=&quot;@+id/button7&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面5&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.483&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button8&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面6&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline17&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline2&quot; /&gt; &lt;Button android:id=&quot;@+id/button9&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面7&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintHorizontal_bias=&quot;0.677&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt; &lt;Button android:id=&quot;@+id/button10&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;页面8&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline18&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline17&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （2）ListView相关ListView主布局和列表项布局 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main2Activity&quot;&gt; &lt;ListView android:id=&quot;@+id/listView&quot; android:layout_width=&quot;409dp&quot; android:layout_height=&quot;729dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; &gt; &lt;/ListView&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;190dp&quot; android:layout_weight=&quot;1&quot; android:scaleType=&quot;centerCrop&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;130dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;TextView&quot; /&gt;&lt;/LinearLayout&gt; Activity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.SimpleAdapter;import com.example.app_e.Test;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class Main2Activity extends AppCompatActivity &#123; private Context context; private ListView lv1; private ArrayAdapter adapter1; private SimpleAdapter adapter2; private List&lt;Map&lt;String, Object&gt;&gt; dataList = new ArrayList&lt;&gt;(); private String[] texts = Test.s; private int[] pics = Test.i; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; lv1 = findViewById(R.id.listView); String[] objects = &#123;&quot;栉枝实乃梨&quot;,&quot;山田妖精&quot;,&quot;谷川柑菜&quot;,&quot;青山七海&quot;,&quot;五更琉璃（黑猫）&quot;,&quot;莓&quot;,&quot;英梨梨&quot;,&quot;空银子&quot;,&quot;尼娅&quot;,&quot;狛井莲季&quot;,&quot;小宫惠那&quot;,&quot;石动乃绘&quot;,&quot;小野寺小咲&quot;,&quot;练白龙&quot;,&quot;泰蕾莎&quot;,&quot;潮留美海&quot;,&quot;七宫智音&quot;,&quot;由比滨结衣&quot;,&quot;鲇川天理&quot;,&quot;菱川六花&quot;,&quot;桂雏菊&quot;,&quot;柏崎星奈&quot;,&quot;小豆梓&quot;,&quot;森宫苍乃&quot;,&quot;兰花·李&quot;,&quot;高宫丽娜&quot;,&quot;驹鸟莲华&quot;,&quot;婕希卡&quot;,&quot;羽川翼&quot;,&quot;一色彩羽&quot;,&quot;凉水玉青&quot;,&quot;相麻堇&quot;,&quot;冢本八云&quot;,&quot;苏茜亚&quot;,&quot;冰无小雪&quot;,&quot;三宅日向&quot;,&quot;流木野咲&quot;,&quot;法提娜&quot;,&quot;山田亚由美&quot;,&quot;科户濑伊札那&quot;,&quot;东云皐月&quot;,&quot;李莓玲&quot;,&quot;吉田一美&quot;,&quot;速水玲香&quot;,&quot;芙蓉枫&quot;,&quot;林明美&quot;,&quot;仓岛千百合&quot;,&quot;米拉洁&quot;&#125;; //adapter1 = new ArrayAdapter&lt;String&gt;(context, android.R.layout.simple_list_item_1, objects); //lv1.setAdapter(adapter1); adapter2 = new SimpleAdapter(context, getData(), R.layout.list_simple_item, new String[]&#123;&quot;pic&quot;, &quot;text&quot;&#125;, new int[]&#123;R.id.imageView, R.id.textView&#125;); lv1.setAdapter(adapter2); &#125; private List&lt;Map&lt;String, Object&gt;&gt; getData() &#123; for (int i = 0; i &lt; 48; i++) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;pic&quot;, pics[i]); map.put(&quot;text&quot;, texts[i]); dataList.add(map); &#125; return dataList; &#125;&#125; （3）GridView相关GridView主布局和列表项布局 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main3Activity&quot;&gt; &lt;GridView android:id=&quot;@+id/gridView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;1dp&quot; android:layout_marginTop=&quot;1dp&quot; android:layout_marginEnd=&quot;1dp&quot; android:layout_marginBottom=&quot;1dp&quot; android:horizontalSpacing=&quot;10dp&quot; android:verticalSpacing=&quot;10dp&quot; android:numColumns=&quot;3&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/h1&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; /&gt;&lt;/LinearLayout&gt; Activity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.EditText;import android.widget.GridView;import android.widget.ImageView;import android.widget.ListView;import android.widget.SimpleAdapter;import android.widget.TextView;import android.widget.Toast;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import com.example.app_e.Test;public class Main3Activity extends AppCompatActivity&#123; private int[] imgs = Test.i; private String[] texts = Test.s; private Context context; private GridView gv1; private SimpleAdapter adapter1; private String[] names = &#123;&quot;栉枝实乃梨&quot;,&quot;山田妖精&quot;,&quot;谷川柑菜&quot;,&quot;青山七海&quot;,&quot;五更琉璃（黑猫）&quot;,&quot;莓&quot;,&quot;英梨梨&quot;,&quot;空银子&quot;,&quot;尼娅&quot;,&quot;狛井莲季&quot;,&quot;小宫惠那&quot;,&quot;石动乃绘&quot;,&quot;小野寺小咲&quot;,&quot;练白龙&quot;,&quot;泰蕾莎&quot;,&quot;潮留美海&quot;,&quot;七宫智音&quot;,&quot;由比滨结衣&quot;&#125;; private int[] pics = &#123;R.drawable.h1,R.drawable.h2,R.drawable.h3,R.drawable.h4,R.drawable.h5,R.drawable.h6,R.drawable.h7,R.drawable.h8,R.drawable.h9,R.drawable.h10,R.drawable.h11,R.drawable.h12,R.drawable.h13,R.drawable.h14,R.drawable.h15,R.drawable.h16,R.drawable.h17,R.drawable.h18&#125;; private List&lt;Map&lt;String, Object&gt;&gt; dataList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; gv1 = findViewById(R.id.gridView); adapter1 = new SimpleAdapter(context, getData(), R.layout.grid_simple_item , new String[]&#123;&quot;pic&quot;, &quot;name&quot;&#125;, new int[]&#123;R.id.imageView3, R.id.textView2&#125;); gv1.setAdapter(adapter1); gv1.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;// ImageView iv1 = findViewById(R.id.imageView4);// TextView tv1 = findViewById(R.id.textView3);// iv1.setImageResource(imgs[i]);// tv1.setText(texts[i]); Intent intent = new Intent(context, Main4Activity.class); intent.putExtra(&quot;index&quot;, i); startActivity(intent); &#125; &#125;); &#125; private List&lt;Map&lt;String, Object&gt;&gt; getData() &#123; for (int i = 0; i &lt; 18; i++) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;pic&quot;, pics[i]); map.put(&quot;name&quot;, names[i]); dataList.add(map); &#125; return dataList; &#125;&#125; （4）Spinner 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ImageView;import android.widget.Spinner;import com.example.app_e.Test;public class Main5Activity extends AppCompatActivity &#123; private Context context; private ImageView iv1; private Spinner sp1; private ArrayAdapter adapter1; private int selected; //数据源 private int[] pics = Test.i; private String[] items = Test.objects; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main5); context = this; //实例化 iv1 = findViewById(R.id.imageView2); sp1 = findViewById(R.id.spinner); //适配器 adapter1 = new ArrayAdapter&lt;String&gt;(context, android.R.layout.simple_spinner_item, items); adapter1.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); //设置 sp1.setAdapter(adapter1); //选择项方法 sp1.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; iv1.setImageResource(pics[i]); selected = i; iv1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String url = &quot;https://baike.baidu.com/item/&quot; + items[selected]; Intent intent = new Intent(context, Main7Activity.class); intent.putExtra(&quot;url&quot;, url); startActivity(intent); &#125; &#125;); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) &#123; &#125; &#125;); &#125;&#125; （5）DatePicker和TimePicker 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import java.util.Calendar;import android.app.DatePickerDialog;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.DatePicker;import android.widget.TextView;import android.widget.TimePicker;public class Main6Activity extends AppCompatActivity &#123; private Context context; private DatePicker dp1; private TimePicker tp1; private DatePickerDialog dpd1; private TextView tv1; private Button bt1; private Calendar cal; private int year; private int month; private int day; private int hour; private int minute; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main6); context = this; cal = Calendar.getInstance(); year = cal.get(Calendar.YEAR); month = cal.get(Calendar.MONTH) + 1; day = cal.get(Calendar.DAY_OF_MONTH); hour = cal.get(Calendar.HOUR); minute = cal.get(Calendar.MINUTE); String date = year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;; setTitle(date); dp1 = findViewById(R.id.datePicker); tp1 = findViewById(R.id.timePicker); tv1 = findViewById(R.id.textView4); bt1 = findViewById(R.id.button6); dp1.init(year, month - 1, day, new DatePicker.OnDateChangedListener() &#123; @Override public void onDateChanged(DatePicker datePicker, int i, int i1, int i2) &#123; year = i; month = i1 + 1; day = i2; String date = year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;; tv1.setText(date); &#125; &#125;); tp1.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() &#123; @Override public void onTimeChanged(TimePicker timePicker, int i, int i1) &#123; hour = i; minute = i1; String time = year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot; + hour + &quot;时&quot; + minute + &quot;分&quot;; tv1.setText(time); &#125; &#125;); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, MainActivity.class); startActivity(intent); &#125; &#125;); &#125;&#125; 布局文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main6Activity&quot;&gt; &lt;TimePicker android:id=&quot;@+id/timePicker&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:headerBackground=&quot;#000000&quot; android:calendarViewShown=&quot;false&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline14&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline13&quot; /&gt; &lt;DatePicker android:id=&quot;@+id/datePicker&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:headerBackground=&quot;#000000&quot; android:calendarViewShown=&quot;false&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline13&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.493&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@id/guideline12&quot; app:layout_constraintVertical_bias=&quot;0.114&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline12&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.02&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline13&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.46&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline14&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.9&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline15&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.98&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline16&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.7&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline15&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline16&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline14&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;返回&quot; android:textSize=&quot;20sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline15&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toEndOf=&quot;@+id/textView4&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline14&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （6）WebView清单文件开启权限 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; Activity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.KeyEvent;import android.webkit.WebResourceRequest;import android.webkit.WebSettings;import android.webkit.WebView;import android.webkit.WebViewClient;public class Main7Activity extends AppCompatActivity &#123; private Context context; private WebView wv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main7); context = this; init(); &#125; private void init() &#123; Intent intent = getIntent(); String url = intent.getStringExtra(&quot;url&quot;); wv = findViewById(R.id.webView); wv.loadUrl(url); //覆盖默认通过第三方或系统浏览器打开网页的行为，使网页在WebView内打开 wv.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); //返回为true是在wv中打开，false则使用其他浏览器 return true; &#125; &#125;); WebSettings ws = wv.getSettings(); //启用支持JavaScript ws.setJavaScriptEnabled(true); //加载页面优先使用缓存 ws.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); &#125; //改写按键--返回的逻辑，实现页面的后退 @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (wv.canGoBack()) &#123; wv.goBack(); return true; &#125; else &#123; finish(); &#125; &#125; return super.onKeyDown(keyCode, event); &#125;&#125; （7）ProgressBar布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main8Activity&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline19&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.02&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline20&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.1&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline21&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.18&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline25&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.26&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline22&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.25&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline23&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline24&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.75&quot; /&gt; &lt;Button android:id=&quot;@+id/button11&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;增加&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline21&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline22&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline20&quot; /&gt; &lt;Button android:id=&quot;@+id/button12&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;4dp&quot; android:layout_marginEnd=&quot;6dp&quot; android:text=&quot;减少&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline21&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline23&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline22&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline20&quot; /&gt; &lt;Button android:id=&quot;@+id/button13&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;7dp&quot; android:layout_marginTop=&quot;4dp&quot; android:text=&quot;重置&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline21&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/guideline24&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline23&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline20&quot; /&gt; &lt;Button android:id=&quot;@+id/button14&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;3dp&quot; android:layout_marginEnd=&quot;6dp&quot; android:text=&quot;返回&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline21&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;@+id/guideline24&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline20&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline20&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline19&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView5&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline25&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline21&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; Activity代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ProgressBar;import android.widget.TextView;public class Main8Activity extends AppCompatActivity implements View.OnClickListener &#123; private Context context; private ProgressBar pb1; private TextView tv1; private Button bt1; private Button bt2; private Button bt3; private Button bt4; private int first; private int second; private int max; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main8); context = this; init(); &#125; private void init() &#123; pb1 = findViewById(R.id.progressBar); tv1 = findViewById(R.id.textView5); bt1 = findViewById(R.id.button11); bt2 = findViewById(R.id.button12); bt3 = findViewById(R.id.button13); bt4 = findViewById(R.id.button14); first = pb1.getProgress(); second = pb1.getSecondaryProgress(); max = pb1.getMax(); tv1.setText(&quot;第一进度条百分比为&quot; + (int)((float)first/max * 100) + &quot;% 第二进度条百分比为&quot; + (int)((float)second/max * 100) + &quot;%&quot;); bt1.setOnClickListener(this); bt2.setOnClickListener(this); bt3.setOnClickListener(this); bt4.setOnClickListener(this); &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button11: &#123; pb1.incrementProgressBy(10); pb1.incrementSecondaryProgressBy(10); break; &#125; case R.id.button12: &#123; pb1.incrementProgressBy(-10); pb1.incrementSecondaryProgressBy(-10); break; &#125; case R.id.button13: &#123; pb1.setProgress(0); pb1.setSecondaryProgress(10); break; &#125; case R.id.button14: &#123; Intent intent = new Intent(context, MainActivity.class); startActivity(intent); break; &#125; &#125; first = pb1.getProgress(); second = pb1.getSecondaryProgress(); max = pb1.getMax(); tv1.setText(&quot;第一进度条百分比为&quot; + (int)((float)first/max * 100) + &quot;% 第二进度条百分比为&quot; + (int)((float)second/max * 100) + &quot;%&quot;); &#125;&#125; （8）ViewPager子视图布局v1.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.2&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_percent=&quot;0.02&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; android:textSize=&quot;30sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/guideline3&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 主视图代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.example.app_s;import androidx.appcompat.app.AppCompatActivity;import androidx.viewpager.widget.PagerTabStrip;import androidx.viewpager.widget.ViewPager;import android.content.Context;import android.content.Intent;import android.graphics.Color;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.Toast;import com.example.app_s.custom.CustomPagerAdapter;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private Context context; private List&lt;View&gt; viewList; private List&lt;String&gt; titleList; private ViewPager vp; private PagerTabStrip tag; private Button bt1; private Button bt2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; //获得视图对象，加入视图列表，标题加入标题列表 viewList = new ArrayList&lt;&gt;(); titleList = new ArrayList&lt;&gt;(); View v1 = View.inflate(context, R.layout.v1, null); View v2 = View.inflate(context, R.layout.v2, null); viewList.add(v1); viewList.add(v2); titleList.add(&quot;页面一&quot;); titleList.add(&quot;页面二&quot;); //针对各个视图获取控件实例，编写逻辑实现代码 bt1 = v1.findViewById(R.id.button); bt2 = v2.findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, Main2Activity.class); startActivity(intent); &#125; &#125;); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Log.i(&quot;tag&quot;, &quot;测试无误&quot;); //Toast.makeText(context, &quot;测试无误&quot;, Toast.LENGTH_LONG); &#125; &#125;); //创建设置适配器 vp = findViewById(R.id.viewPager); CustomPagerAdapter customPagerAdapter = new CustomPagerAdapter(viewList, titleList); vp.setAdapter(customPagerAdapter); //设置页面标题的属性，虽然此处报错，但可以生效 tag = findViewById(R.id.tag);// tag = (PagerTabStrip)vp.getTag(); tag.setBackgroundColor(Color.BLACK); tag.setTextColor(Color.WHITE); tag.setDrawFullUnderline(false); tag.setTabIndicatorColor(Color.YELLOW); &#125;&#125; 自定义PagerAdapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.example.app_s.custom;import android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.viewpager.widget.PagerAdapter;import java.util.List;public class CustomPagerAdapter extends PagerAdapter &#123; private List&lt;View&gt; viewList; private List&lt;String&gt; titleList; public CustomPagerAdapter(List&lt;View&gt; viewList, List&lt;String&gt; titleList) &#123; this.viewList = viewList; this.titleList = titleList; &#125; /* 返回的是页卡的数量 */ @Override public int getCount() &#123; return viewList.size(); &#125; /* 判断页卡是否来自对象 */ @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) &#123; return view == object; &#125; /* 实例化一个页卡 */ @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) &#123; container.addView(viewList.get(position)); return viewList.get(position); &#125; /* 销毁一个页卡 */ @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; container.removeView(viewList.get(position)); &#125; /* 给每个视图添加标题 */ @Nullable @Override public CharSequence getPageTitle(int position) &#123; return titleList.get(position); &#125;&#125; （9）图片轮播ViewFlipper主布局 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main3Activity&quot;&gt; &lt;ViewFlipper android:id=&quot;@+id/viewFlipper&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 进出效果（anim文件夹下）left_in.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;2000&quot; android:fromXDelta=&quot;-100%p&quot; android:toXDelta=&quot;0&quot;/&gt; &lt;alpha android:fromAlpha=&quot;0.5&quot; android:toAlpha=&quot;1&quot; android:duration=&quot;2000&quot;/&gt;&lt;/set&gt; left_out.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;2000&quot; android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;100%p&quot;/&gt; &lt;alpha android:fromAlpha=&quot;1&quot; android:toAlpha=&quot;0.5&quot; android:duration=&quot;2000&quot;/&gt;&lt;/set&gt; Activity代码 1234567891011121314151617181920212223242526272829303132333435package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.widget.ImageView;import android.widget.ViewFlipper;public class Main3Activity extends AppCompatActivity &#123; private Context context; private ViewFlipper vf; private int[] pic = &#123;R.drawable.h1, R.drawable.h2, R.drawable.h3, R.drawable.h4&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; vf = findViewById(R.id.viewFlipper); for (int i = 0; i &lt; pic.length; i++) &#123; vf.addView(getImageView(pic[i])); &#125; vf.setInAnimation(context, R.anim.left_in); vf.setOutAnimation(context, R.anim.left_out); vf.setFlipInterval(3000); vf.startFlipping(); &#125; private ImageView getImageView(int p) &#123; ImageView imageView = new ImageView(context); imageView.setImageResource(p); return imageView; &#125;&#125; （10）Fragment静态加载fragment_blank.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;占位&quot; android:textSize=&quot;30sp&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;跳转&quot; android:textSize=&quot;30sp&quot;/&gt;&lt;/LinearLayout&gt; BlankFragment.java 1234567891011121314151617181920212223package com.example.app_n;import android.content.Context;import android.net.Uri;import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;public class BlankFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_blank, container, false); &#125;&#125; Main2Activity.java 1234567891011121314151617181920212223242526272829303132package com.example.app_n;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class Main2Activity extends AppCompatActivity &#123; private Context context; private Button bt1; private TextView tv1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; bt1 = findViewById(R.id.button6); tv1 = findViewById(R.id.textView2); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; tv1.setText(&quot;fragment静态加载&quot;); &#125; &#125;); &#125;&#125; （11）Fragment动态加载fragment_blank_fragment2.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;占位&quot; android:textSize=&quot;30sp&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;跳转&quot; android:textSize=&quot;30sp&quot;/&gt;&lt;/LinearLayout&gt; BlankFragment2.java 1234567891011121314151617181920212223242526272829303132333435package com.example.app_n;import android.content.Context;import android.net.Uri;import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.TextView;public class BlankFragment2 extends Fragment &#123; private Button bt1; private TextView tv1; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment View view = inflater.inflate(R.layout.fragment_blank_fragment2, container, false); tv1 = view.findViewById(R.id.textView2); bt1 = view.findViewById(R.id.button6); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; tv1.setText(&quot;fragment动态加载&quot;); &#125; &#125;); return view; &#125;&#125; Main3Activity.java 1234567891011121314151617181920212223package com.example.app_n;import androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentTransaction;import android.os.Bundle;public class Main3Activity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); BlankFragment2 blankFragment = new BlankFragment2(); FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); //注意这个R.id.frame表示的是放置fragment的布局控件 fragmentTransaction.add(R.id.frame, blankFragment); fragmentTransaction.commit(); &#125;&#125; （12）音乐播放将音频文件放在资源文件夹raw下 1234private MediaPlayer mp = new MediaPlayer();mp = MediaPlayer.create(this, R.raw.h);mp.start(); （13）无标题栏主题配置 1android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot; 参考：https://blog.csdn.net/lvxiangan/article/details/82783667 二、说明 经实践，以上代码均可较容易地重用。 存在问题，ListView和GridView的列表项无法用约束布局，导致显示效果有问题；Fragment主布局和自身布局均无法使用约束布局；DatePickerDialog和TimePickerDialog存在api版本问题报错，因而未进行完整测试，ProgressBarDialog同理；DatePicker和TimePicker的大小调整和日历显示存在问题。 学习项目：引导动画和过渡动画，自定义适配器等。 关于上篇RecycleListView的说明：事实上，RecycleView才是一种视图控件，而RecycleListView与其无关，不应使用和混淆，参考： https://blog.csdn.net/github_37130188/article/details/89648136https://blog.csdn.net/yuan1244487110/article/details/90401874https://blog.csdn.net/allen315410/article/details/40379159?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 使用（三）","slug":"as-use-3","date":"2020-03-01T02:43:06.000Z","updated":"2021-10-07T08:25:06.566Z","comments":true,"path":"2020/03/01/as-use-3/","link":"","permalink":"https://shadowbynl.github.io/2020/03/01/as-use-3/","excerpt":"一、AndroidManifest","text":"一、AndroidManifest 二、数据源–适配器–视图（使用默认适配器，视图ListView GridView）#### 三、案例实现 四、后续学习 全局配置 gradle模块此部分配置是放在build.gradle中，包括sdk版本等 组件配置四种组件的功能–注册–必要的标签利用intent-filter(可视为组件名片)实现组件间通信的方法 权限配置申请权限：https://www.cnblogs.com/AAAI/p/10899381.html权限参考：http://www.bejson.com/doc/AndroidManifest/自定义权限： 可以实现不同应用间组件的通信或阻止通信保护组件 二、数据源–适配器–视图（使用默认适配器，视图ListView GridView）#### 必要步骤layout 将ListView/GridView脱入主布局（约束布局）activity中 建立控件私有变量 并一定要先在onCreate中实例化 创建数据源分两类：a.格式单一的数据，由数组、集合等存储，常用的就是ArrayAdapter所用的字符串数组b.格式复杂的数据，由特定泛型的集合存储List&lt;Map&lt;Object,Object&gt;&gt;，一个Map表示一项（可包含文字图片）b类数据源涉及：定义私有数据源dataList 重写方法getData来给dataList添加数据并返回 定义适配器及设置数据源与SimpleAdapter的列表项布局准备根据两类数据源，分别对应两类适配器（常用情况下如此，但实际上还有重写适配器等实现方法，后面会记述）a.ArrayAdapter（数据源一般为字符串数组）b.SimpleAdapter（数据源一般为map列表） 特别注意参数（1） ArrayAdapter(上下文this,默认列表项布局(ID),数据源)常用的列表项布局是simple_list_item_1；android.R.layout中全部布局的效果参考：https://blog.csdn.net/qq_36408196/article/details/82819024 ，这些布局都是只有一个TextView，因此数据源只能是字符串数组；当然也可以自定义列表项布局，可能能实现展现其他形式数据的目的，也可以使用重写适配器的方法，这些以后再进行实践验证。总之，一般的ArrayAdapter使用就使用simple_list_item_1展示字符串。（2） SimpleAdapter(上下文this,数据源getData(),自定义列表项布局（ID),自定义数据源dataList中Map所有键的数组String[] from,对应Map每个键的列表项布局中控件的id组成的数组int[] to)后两个参数实现了定义数据源的map的键和布局文件中控件id的映射； 由参数可知，定义SimpleAdapter前，需先布局好列表项的形式和数据源形式（定义getData()方法）；SimpleAdapter必须自定义列表项布局，列表项如何布局与使用为ListView/GridView有关自定义列表项布局（1）应选择线性布局（2）ListView 案例布局参考：list_simple_item.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;190dp&quot; android:layout_weight=&quot;1&quot; android:scaleType=&quot;centerCrop&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;130dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;TextView&quot; /&gt;&lt;/LinearLayout&gt; （3）GridView 案例布局参考：grid_simple_item.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/h1&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;TextView&quot; /&gt;&lt;/LinearLayout&gt; 关键是android:gravity=”center”为使GridView生效，还应该在主布局中加上三个属性设置： 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.Main3Activity&quot;&gt; &lt;GridView android:id=&quot;@+id/gridView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;1dp&quot; android:layout_marginTop=&quot;1dp&quot; android:layout_marginEnd=&quot;1dp&quot; android:layout_marginBottom=&quot;1dp&quot; android:horizontalSpacing=&quot;10dp&quot; &lt;!--需加--&gt; android:verticalSpacing=&quot;10dp&quot; &lt;!--需加--&gt; android:numColumns=&quot;3&quot; &lt;!--自定义列数--&gt; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （4）就以上两种布局，均存在无法自适应，显示有问题的缺陷，需要以后实践改善重写适配器（1）参考：https://blog.csdn.net/qq_33399371/article/details/76285726https://blog.csdn.net/whycmpx/article/details/80580913https://www.cnblogs.com/penghuster/p/5001161.html（2）后续实践3. 给视图实例对象添加适配器4. 实现点击列表项事件方法，滚动方法（1）列表项从零计数 倒数第二个参数是点击的标号position（2）滚动事件 可实现动态增加数据源 三、案例实现（1）使用urlib爬取图片和描述，并用正则处理文本图片 123456789101112131415161718192021from urllib.request import urlopenfrom urllib.request import Requestimport requestsfrom lxml import etreeurl = &quot;https://baijiahao.baidu.com/s?id=1597344111243871701&amp;wfr=spider&amp;for=pc&quot;request = Request(url)response = urlopen(request)html = response.read()s = str(html, encoding=&quot;utf-8&quot;)# l = re.findall(&#x27;&lt;img class=&quot;large&quot; data-loadfunc=0 src=&quot;(.+)&quot; data-loaded=0&#x27;, s)exml = etree.HTML(s)links = exml.xpath(&quot;//img[@class=&#x27;large&#x27;]/@src&quot;)count = 1for l in links[1:]: request = Request(l) response = urlopen(request) path = &quot;p&quot; + str(count) + &quot;.jpg&quot; with open(path, &quot;wb&quot;) as f: f.write(response.read()) f.flush() count = count + 1 描述 12345678910111213141516from urllib.request import urlopenfrom urllib.request import Requestimport requestsfrom lxml import etreeurl = &quot;https://baijiahao.baidu.com/s?id=1597344111243871701&amp;wfr=spider&amp;for=pc&quot;request = Request(url)response = urlopen(request)html = response.read()s = str(html, encoding=&quot;utf-8&quot;)# l = re.findall(&#x27;&lt;img class=&quot;large&quot; data-loadfunc=0 src=&quot;(.+)&quot; data-loaded=0&#x27;, s)exml = etree.HTML(s)ss = exml.xpath(&quot;//div[@class=&#x27;article-content&#x27;]//span[@class=&#x27;bjh-p&#x27;]//text()&quot;)with open(&quot;2.txt&quot;, &quot;a&quot;) as f: for s in ss: f.write(s + &quot;\\n&quot;) f.flush() （2） 跳转页面时实现传输数据参考：https://jingyan.baidu.com/article/d621e8da20c67f2865913fe6.html 1234567//发送Intent intent = new Intent(context, target.class);intent.putExtra(key, value);startActivity(intent);//接收Intent intent = getIntent();//再由intent调用具体getExtra()方法获取 四、后续学习RecycleListView参考：https://blog.csdn.net/gongch0604/article/details/89025024https://blog.csdn.net/morgerton/article/details/78983976https://www.jianshu.com/p/b4bb52cdbeb7https://www.jianshu.com/p/4f9591291365重写适配器参考：https://blog.csdn.net/qq_33399371/article/details/76285726https://blog.csdn.net/whycmpx/article/details/80580913https://www.cnblogs.com/penghuster/p/5001161.html","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 使用（二）","slug":"as-use-2","date":"2020-02-27T08:18:48.000Z","updated":"2021-10-07T08:25:00.544Z","comments":true,"path":"2020/02/27/as-use-2/","link":"","permalink":"https://shadowbynl.github.io/2020/02/27/as-use-2/","excerpt":"基本控件练习","text":"基本控件练习 一、Activity Andoid四大组件：ActicityServiceBroadcastReceiverContent Provider Activity是一个应用程序组件，提供用户与程序交互的界面 Activity创建与注册：继承与自动生成的MainActivity相同的父类，在清单文件中注册。12345678910&lt;!-- 新建模块时自动生成的Activity --&gt;&lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;!-- 表示应用程序的首启动项 --&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;!-- 新创建的第二个Activity 会自动注册 --&gt;&lt;activity android:name=&quot;.Main2Activity&quot;&gt;&lt;/activity&gt; Activity生命周期 二、页面跳转 Intent可以理解为信使（意图），由其来协助完成Android各个组件间的通讯。 两种跳转方式：第一个Activity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.app_t;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private Button bt1; private Button bt2; private TextView tv1; private Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; //第一种跳转方式 简单的跳转到另一个页面 bt1 = findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //第一个参数为上下文对象，因匿名内部类无法直接取到外部类this，因此事先定义并赋this //第二个参数是目标Activity的类对象 Intent intent = new Intent(context, Main2Activity.class); startActivity(intent); &#125; &#125;); //第二种跳转方式 会携带请求码，与重写的onActivity方法接收的响应码共同决定一个指定操作，可获得返回数据 bt2 = findViewById(R.id.button2); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, Main2Activity.class); startActivityForResult(intent, 1); &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == 1 &amp;&amp; resultCode == 2) &#123; String content = data.getStringExtra(&quot;data&quot;); tv1 = findViewById(R.id.textView); tv1.setText(content); &#125; &#125;&#125; 第二个Activity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.app_t;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class Main2Activity extends AppCompatActivity &#123; private Button bt1; private Button bt2; private TextView tv1; private Context context; private String content = &quot;第二种跳转方法返回&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; //第一种跳转返回 bt1 = findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, MainActivity.class); startActivity(intent); &#125; &#125;); //第二种跳转返回 bt2 = findViewById(R.id.button2); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent data = new Intent(); //设置响应数据 data.putExtra(&quot;data&quot;, content); setResult(2, data); //此处必须有finish finish(); &#125; &#125;); &#125;&#125; 三、实践细节 现在Empty Activity继承的是AppCompatActivity而非Activity，其区别可参考：https://blog.csdn.net/today_work/article/details/79300181https://blog.csdn.net/u012602304/article/details/90756655 现在获取控件实例不需类型转换 四、基本控件练习（部分） 做了一个小案例，结合了TextView，EditText，ImageView，Button，ImageButton，ToggleButton，CheckBox，RadioGroup，RadioButton，CalendarView控件，基本上熟悉了基本界面的绘制和事件的设置。 问题与细节（1）绘制布局首先要用guideline划分好区域，并在xml文件中手动修改百分比为可控值，这是保证布局在真机上显示正常（完整不重叠）的先决条件，实践证明guideline非常重要且极有作用。参考： https://www.jianshu.com/p/862caaceccb1https://www.jianshu.com/p/a4a5f8c91fdehttps://www.jianshu.com/p/2ab12ba05dc8（2）关于控件属性设置的经验：显示文本的控件切忌高度要wrap， 不能充满约束，否则很可能显示不出来文本；显示图像和日历的控件水平垂直均充满约束；其他按钮等若要显示文本的，高度也是wrap。（3）关于继承父类的问题：在实现跑马灯效果时，发现as推荐继承的是AppCompatTextView，这个不影响什么， 但属性里关于focus的两个属性必须去掉，否则无法生效。参考： https://www.cnblogs.com/merbn/p/11351459.htmlhttps://blog.csdn.net/zhangphil/article/details/81388186https://www.jianshu.com/p/6e232196c511（4）关于如何在app里添加音乐： https://blog.csdn.net/pythontojava/article/details/48058087 https://blog.csdn.net/qq_31939617/article/details/79969796（5）连接逍遥模拟器的命令： adb connect 127.0.0.1:21503（6）关于ImageView 的 ScaleType 属性： https://www.jianshu.com/p/e046b4201289https://www.jianshu.com/p/b8e75430f3dchttps://blog.csdn.net/qq_34902522/article/details/76682293（7）关于android的文档：https://www.runoob.com/android/android-resources.htmlhttps://blog.csdn.net/whitenebula/article/details/81171095https://developer.android.google.cn/reference/android/widget/TextView?hl=enhttps://developer.android.google.cn/guide/topics/ui/declaring-layouthttps://www.jianshu.com/p/a567c5cf8e1ahttps://blog.csdn.net/carson_ho/category_5959547.html（8）需要特别注意的一点是，as设计页面可能不会显示部分控件，如本机的DatePicker、TimePicker等，既然无法直接拖动放置，那么就只能手动在xml文件中输入，自然会出现。（9）关于CalendarView：https://www.jianshu.com/p/0c06f71d0be8 主要代码MainActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example.app_f;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.ToggleButton;public class MainActivity extends AppCompatActivity &#123; private MediaPlayer mp = new MediaPlayer(); private Button bt1; private Context context; private ToggleButton tbt1; private ToggleButton tbt2; private ImageView iv1; private ImageView iv2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mp =MediaPlayer.create(this, R.raw.h); mp.start(); context = this; // Button 添加点击事件，跳转至第二页面 bt1 = findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mp.stop(); Intent intent = new Intent(context, Main2Activity.class); startActivity(intent); &#125; &#125;); //ToggleButton 和 ImageView结合使用，切换图片 tbt1 = findViewById(R.id.toggleButton3); iv1 = findViewById(R.id.imageView); tbt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (tbt1.getText().equals(getString(R.string.button3_text))) &#123; iv1.setImageResource(R.drawable.yml); &#125; else &#123; iv1.setImageResource(R.drawable.lrd); &#125; &#125; &#125;); tbt2 = findViewById(R.id.toggleButton4); iv2 = findViewById(R.id.imageView3); tbt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (tbt2.getText().equals(getString(R.string.button4_text))) &#123; iv2.setImageResource(R.drawable.gn); &#125; else &#123; iv2.setImageResource(R.drawable.st); &#125; &#125; &#125;); &#125;&#125; Main2Activity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.example.app_f;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.ImageButton;import android.widget.RadioButton;import android.widget.RadioGroup;import android.widget.TextView;import android.widget.Toast;public class Main2Activity extends AppCompatActivity &#123; private MediaPlayer mp = new MediaPlayer(); private ImageButton ibt1; private Context context; private TextView tv1; private TextView tv2; private RadioGroup rg1; private RadioButton rb1; private Button bt1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); mp = MediaPlayer.create(this, R.raw.z); mp.start(); context = this; //ImageButton 添加点击事件 跳回第一页面 ibt1 = findViewById(R.id.imageButton); ibt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mp.stop(); Intent intent = new Intent(context, MainActivity.class); startActivity(intent); &#125; &#125;); //为文字添加点击方法，以第二种形式跳转至第三页面 tv1 = findViewById(R.id.textView2); tv1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, Main3Activity.class); startActivityForResult(intent, 2); &#125; &#125;); tv2 = findViewById(R.id.textView3); //为最后的选择提供跳转 rg1 = findViewById(R.id.radioGroup); bt1 = findViewById(R.id.button3); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (tv2.getText().length() &gt; 0) &#123; int selected = rg1.getCheckedRadioButtonId(); if (selected == R.id.radioButton2) &#123; mp.stop(); Intent intent = new Intent(context, Main4Activity.class); startActivity(intent); &#125; else &#123; mp.stop(); Intent intent = new Intent(context, Main5Activity.class); startActivity(intent); &#125; &#125; if (tv2.getText() == null) &#123; Toast.makeText(context, &quot;为实现你的目的，请点击下方红字&quot;, Toast.LENGTH_LONG * 3); &#125; &#125; &#125;); &#125; //显示第三页面返回的结果 @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == 2 &amp;&amp; resultCode == 3) &#123; String content = data.getStringExtra(&quot;content&quot;); tv2.setText(content); &#125; &#125;&#125; Main3Activity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.example.app_f;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.CalendarView;import android.widget.CheckBox;import android.widget.EditText;import android.widget.Toast;public class Main3Activity extends AppCompatActivity &#123; private EditText et1; private EditText et2; private CalendarView cv1; private CheckBox cb1; private CheckBox cb2; private CheckBox cb3; private CheckBox cb4; private Button bt1; private String content; private Context context; private String date = &quot;&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; et1 = findViewById(R.id.editText); et2 = findViewById(R.id.editText2); cv1 = findViewById(R.id.calendarView); cb1 = findViewById(R.id.checkBox); cb2 = findViewById(R.id.checkBox2); cb3 = findViewById(R.id.checkBox3); cb4 = findViewById(R.id.checkBox4); bt1 = findViewById(R.id.button2); //拼凑结果 bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent data = new Intent(); StringBuffer sb = new StringBuffer(); if (et1.getText().length() &gt; 0) &#123; sb.append(&quot;你最怨恨的事是：&quot;); sb.append(et1.getText()); &#125; else &#123; Toast.makeText(context, &quot;输入不完整，重新输入&quot;, Toast.LENGTH_LONG * 3).show(); &#125; if (et2.getText().length() &gt; 0) &#123; sb.append(&quot;\\n&quot;); sb.append(&quot;你最怨恨的人是：&quot;); sb.append(et2.getText()); &#125; else &#123; Toast.makeText(context, &quot;输入不完整，重新输入&quot;, Toast.LENGTH_LONG * 3).show(); &#125; sb.append(&quot;\\n你选择的执行时间是&quot;); sb.append(date); sb.append(&quot;\\n你选择的本司员工为：&quot;); if (cb1.isChecked()) &#123; sb.append(cb1.getText() + &quot; &quot;); &#125; if (cb2.isChecked()) &#123; sb.append(cb2.getText() + &quot; &quot;); &#125; if (cb3.isChecked()) &#123; sb.append(cb3.getText() + &quot; &quot;); &#125; if (cb4.isChecked()) &#123; sb.append(cb4.getText() + &quot; &quot;); &#125; //Log.i(&quot;tag&quot;, date); //设置响应数据 content = sb.toString(); data.putExtra(&quot;content&quot;, content); setResult(3, data); finish(); &#125; &#125;); //获取选择的日期 cv1.setOnDateChangeListener(new CalendarView.OnDateChangeListener() &#123; @Override public void onSelectedDayChange(@NonNull CalendarView calendarView, int i, int i1, int i2) &#123; date = i + &quot;年&quot; + i1 + &quot;月&quot; + i2 + &quot;日&quot;; &#125; &#125;); &#125;&#125;","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 使用（一）","slug":"as-use-1","date":"2020-02-26T14:38:14.000Z","updated":"2021-10-07T08:24:53.556Z","comments":true,"path":"2020/02/26/as-use-1/","link":"","permalink":"https://shadowbynl.github.io/2020/02/26/as-use-1/","excerpt":"as使用：问题与解决参考（2020.2.25-2.26）","text":"as使用：问题与解决参考（2020.2.25-2.26） 一、消除清单文件的黄色警告 参考：https://blog.csdn.net/LJX_ahut/article/details/89711478&emsp;https://blog.csdn.net/qq_35003588/article/details/104192062 两种方法，我采用的是修改gradle文件,在module的build.gradle 的android {}下添加: 123lintOptions &#123; disable &#x27;GoogleAppIndexingWarning&#x27; &#125; 二、解决新增控件时布局xml文件中的报错 问题：This view is not constrained, it only has designtime positions；原因是默认约束布局，需要给控件添加约束，可以自己添加，也可以自动添加。 自动添加参考：2.x版本：https://www.jianshu.com/p/dcb76b24bbe9 https://www.jianshu.com/p/723811aa4dfe 3.x版本：https://blog.csdn.net/qunqunstyle99/article/details/81209031 https://blog.csdn.net/bssynhdjzmh/article/details/79728625 三、关于约束布局的使用（重点） 重点参考：csdn guolin：https://blog.csdn.net/guolin_blog/article/details/53122387 https://www.jianshu.com/p/6c9950d1789b 其他：https://www.jianshu.com/p/ac450f6386ee https://blog.csdn.net/guolin_blog https://www.jianshu.com/p/eff62726ea84 https://www.jianshu.com/p/81f85d761aa9 https://www.jianshu.com/p/6c9950d1789b 说明：约束布局因有发挥可视化开发优势、效率等优势（具体见上链接），而较为推荐使用，有很大的灵活性，可以自由根据自己想法调整空间具体位置、大小。要想继续学习控件，首先要知道约束布局下怎样给控件添加约束。 蓝图视图可以帮助你更清晰地查看约束和 guidelines (辅助线)，而不会被内容或背景分散注意力。 控件间垂直对齐是指控件竖直的中心线在同一条竖线上，将两控件的左右两边对应连起来或者连到相同的地方即可；水平对齐指控件水平方向的中心线在同一条横线上，将两控件上下两边对应相连或者连到相同的地方即可。 为使文字显示完全，垂直方向应用wrap，和约束没有关系。 四、关于基本控件 TextView和EditView ImageView 实际和预览不一致的可能性较大，最好将其作为组件而非背景。 Button和ImageButton：onClick事件 监听器 OnClickListner接口 R文件在生成文件夹中，不可改变，存放各控件和资源文件对应的id java文件中获取控件 返回的是View类型，需要类型转换 监听事件的三种写法：（1）匿名内部类： 是监听接口的实现类，每个控件可以实现自己独立的动作（2）外部类： 可以执行外部父类和内部匿名子类两种动作,适用于多个控件有共同动作和自己独立动作的情况 （3）接口方式实现：当前Activity实现监听器接口，需要绑定监听事件的实例调用set监听器方法，参数为this 给控件绑定监听事件的一般流程：（1）实例化控件（私有属性、类型转换、id）；（2）按照三种方法实现监听事件，注意set监听器的方法是监听器的实例。 属性：关于控件的相关尺寸，用dp，文字用sp AutoCompleteTextView和MultiAutoCompleteTextView均有自动匹配输入的功能：（1）AutoCompleteTextView均有属性completionThreshold=”n”，即设置输入n个字符时开始匹配，匹配产生的内容是自定义的；实现方法：由id获得控件实例，创建一个适配器，创建数据源并交给适配器，将适配器与控件实例绑定；（2）MultiAutoCompleteTextView与前者的区别在于支持一次输入的多关键词匹配，每次匹配的是分隔符之后的内容，需要指定分隔符；实现方法：前几步与前者同，此外还需要设置分隔符。 多状态按钮ToggleButton：实现通过更改ToggleButton状态来切换图片。实现方法：获取按钮和图片实例，给按钮设置监听器setOnCheckedChangedListner，实现监听方法切换图片源。 复选框CheckBox实现多选效果：CheckBox可单独使用，可多个共同使用；具有checked属性，默认为false;设置监听器setOnCheckedChangedListner RadioGroup与RadioButton：RadioButton不能单独使用；RadioGroup是RadioButton的集合，提供多选一的机制，可由orientation属性决定水平还是竖直排布；设置RadioGroup的监听器setOnCheckedChangedListner（注意是RadioGroup包下的） 五、一些效果的实现 使用TextView实现跑马灯效果:（1）修改布局文件控件属性的方法仅对单个TextView有效；（2）采 用自定义TextView的方法，重载isFocused方法，并在布局文件中指明；（3）注：所谓跑马灯实现，一个是内容当行单行显示+内容隐藏；一个是保持焦点，后者只有通过自定义控件类的方法才可使多个控件能同时具有焦点，从而实现效果。","categories":[{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]},{"title":"Android Studio 项目结构","slug":"Android-Studio-structure","date":"2020-02-25T10:41:59.000Z","updated":"2020-09-12T06:17:45.571Z","comments":true,"path":"2020/02/25/Android-Studio-structure/","link":"","permalink":"https://shadowbynl.github.io/2020/02/25/Android-Studio-structure/","excerpt":"Android Studio 目录结构","text":"Android Studio 目录结构 说明 据初步了解，as和idea新建项目时最大的区别就是：idea会创建两个模块，一个与项目名称相同，一个为app模块；而as只会创建一个app模块，更符合项目仅为工作空间的含义。 为更具普适性，接下来对项目目录结构的说明是在一个项目下建好两个模块app和app_o的基础上进行的。 需要特别注意的是，在as开发时呈现的项目机构、目录并不符合磁盘上的存储形式，即在as中同属一个目录的文件实际在磁盘上也许并不在同一目录，或者有的目录不存在，因此下面将会分as中和磁盘两种情况进行说明 可能是as版本问题，在网上搜索到的as目录结果均与现使用版本存在差异，因此下面也给出了这些情况的链接。 实际上，网上搜到的as目录结构应该和磁盘情况是一致的，但与本人不一致。 后续在使用as时，发现产生区别的原因仅在于as中存在多个项目浏览文件的视图，我用的是Android视图，其他用的是Project视图而已。 本机as项目结构 磁盘项目结构https://blog.csdn.net/qq_39312230/article/details/80314236 该博客中介绍的结构和本地磁盘中结构基本一致，可参考：一、项目目录1、.gradle和.idea这两个目录下放置的都是Android Studio自动生成的一些文件，我们无须关心，也不要去手动编辑。2、app项目中的代码、资源等内容几乎都是放置在这个目录下的，我们后面的开发工作也基本都是在这个目录下进行的，待会儿还会对这个目录单独展开进行讲解。3、build这个目录你也不需要过多关心，它主要包含了一些在编译时自动生成的文件。4、gradle这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认没有启动gradle wrapper的方式，如果需要打开，可以点击Android Studio导航栏 –&gt; File –&gt; Settings –&gt; Build，Execution，Deployment –&gt; Gradle，进行配置更改。5、.gitignore这个文件是用来将指定的目录或文件排除在版本控制之外的。6、build.gradle这是项目全局的gradle构建脚本，通常这个文件的内容是不需要修改的。下面回详细分析gradle构建脚本中的具体内容。7、gradle.properties这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。8、gradlew和gradlew.bat这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。9、xxx.imliml文件是所有IntelliJ IDEA项目都会自动生成的一个文件（Android Studio是基于IntelliJ IDEA开发的），用于标识这是一个IntelliJ IDEA项目，我们不需要修改这个文件中的任何内容。10、local.properties这个文件用于指定本机中的Android SDK路径，通常内容都是自动生成的，我们并不需要修改。除非你本机中的Android SDK位置发生了变化，那么就将这个文件中的路径改成新的位置即可。11、settings.gradle这个文件用于指定项目中所有引入的模块。二、app模块目录1、build这个目录和外层的build目录类似，主要也是包含了一些在编译时自动生成的文件，不过它里面的内容会更多更杂，我们不需要过多关系。2、libs如果你的项目中使用到了第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径里去。3、src/AndroidTest此处是用来编写Android Test测试用例的，可以对项目进行一些自动化测试。4、src/main/java毫无疑问，java目录是放置我们所有java代码的地方，展开该目录，你将看到我们刚才创建的HelloWorldActivity文件就在里面。5、src/main/res这个目录下的内容就有点多了。简单点说，就是你在项目中使用到的所有图片，布局，字符串等资源都要存放在这个目录下。当然这个目录下还有很多子目录，图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下，所以你不用担心会把整个res目录弄得乱糟糟的。6、main/AndroidManifest.xml这是你整个Android项目的配置文件，你在程序中定义的所以四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。7、test此处是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。8、.gitignore这个文件用于将app模块内的指定的目录或文件排除在版本控制之外，作用和外层的.gitignore文件类似。9、app.imlIntelliJ IDEA项目自动生成的文件，我们不需要关心或修改这个文件中的内容。10、build.gradle这是app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置。11、proguard-rules.pro这个文件用于指定项目代码的混淆规则，当代码开发完成后打成安装包文件，如果不希望代码被别人破解，通常会将代码混淆，从而让破解者难以阅读。三、项目中的资源以drawable开头的文件夹都是用来放图片的；以mipmap开头的文件夹都是用来放应用图标的；以values开头的文件夹都是用来放字符串、样式、颜色等配置的；layout文件夹是用来放布局文件的。 其他参考链接https://blog.csdn.net/admans/article/details/80921534https://www.cnblogs.com/ahochen/p/10676600.htmlhttps://www.jianshu.com/p/481b46cd5562","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://shadowbynl.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"https://shadowbynl.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"数据","slug":"数据","permalink":"https://shadowbynl.github.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"规划","slug":"规划","permalink":"https://shadowbynl.github.io/categories/%E8%A7%84%E5%88%92/"},{"name":"环境","slug":"环境","permalink":"https://shadowbynl.github.io/categories/%E7%8E%AF%E5%A2%83/"},{"name":"项目","slug":"项目","permalink":"https://shadowbynl.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"https://shadowbynl.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"随机","slug":"随机","permalink":"https://shadowbynl.github.io/categories/%E9%9A%8F%E6%9C%BA/"},{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"},{"name":"随记","slug":"随记","permalink":"https://shadowbynl.github.io/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"语法","slug":"语法","permalink":"https://shadowbynl.github.io/categories/%E8%AF%AD%E6%B3%95/"},{"name":"大四","slug":"大四","permalink":"https://shadowbynl.github.io/categories/%E5%A4%A7%E5%9B%9B/"},{"name":"知识点总结","slug":"知识点总结","permalink":"https://shadowbynl.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"name":"基础","slug":"基础","permalink":"https://shadowbynl.github.io/categories/%E5%9F%BA%E7%A1%80/"},{"name":"测试","slug":"测试","permalink":"https://shadowbynl.github.io/categories/%E6%B5%8B%E8%AF%95/"},{"name":"功能点学习","slug":"功能点学习","permalink":"https://shadowbynl.github.io/categories/%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AD%A6%E4%B9%A0/"},{"name":"随笔","slug":"随笔","permalink":"https://shadowbynl.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"记录","slug":"记录","permalink":"https://shadowbynl.github.io/categories/%E8%AE%B0%E5%BD%95/"},{"name":"Web框架","slug":"Web框架","permalink":"https://shadowbynl.github.io/categories/Web%E6%A1%86%E6%9E%B6/"},{"name":"安全","slug":"安全","permalink":"https://shadowbynl.github.io/categories/%E5%AE%89%E5%85%A8/"},{"name":"ORM","slug":"ORM","permalink":"https://shadowbynl.github.io/categories/ORM/"},{"name":"容器","slug":"容器","permalink":"https://shadowbynl.github.io/categories/%E5%AE%B9%E5%99%A8/"},{"name":"移动布局","slug":"移动布局","permalink":"https://shadowbynl.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80/"},{"name":"爬虫","slug":"爬虫","permalink":"https://shadowbynl.github.io/categories/%E7%88%AC%E8%99%AB/"},{"name":"Flask","slug":"Flask","permalink":"https://shadowbynl.github.io/categories/Flask/"},{"name":"数据可视化","slug":"数据可视化","permalink":"https://shadowbynl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"写法","slug":"写法","permalink":"https://shadowbynl.github.io/categories/%E5%86%99%E6%B3%95/"},{"name":"css","slug":"css","permalink":"https://shadowbynl.github.io/categories/css/"},{"name":"工具使用","slug":"工具使用","permalink":"https://shadowbynl.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://shadowbynl.github.io/tags/javase/"},{"name":"专业课","slug":"专业课","permalink":"https://shadowbynl.github.io/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"区块链","slug":"区块链","permalink":"https://shadowbynl.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Go","slug":"Go","permalink":"https://shadowbynl.github.io/tags/Go/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://shadowbynl.github.io/tags/JavaWeb/"},{"name":"版本控制","slug":"版本控制","permalink":"https://shadowbynl.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://shadowbynl.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"sql","slug":"sql","permalink":"https://shadowbynl.github.io/tags/sql/"},{"name":"总结","slug":"总结","permalink":"https://shadowbynl.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"前端","slug":"前端","permalink":"https://shadowbynl.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"PythonWeb","slug":"PythonWeb","permalink":"https://shadowbynl.github.io/tags/PythonWeb/"},{"name":"随笔","slug":"随笔","permalink":"https://shadowbynl.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"android","slug":"android","permalink":"https://shadowbynl.github.io/tags/android/"}]}