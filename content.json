{"meta":{"title":"Memory","subtitle":"永远相信美好的事情即将发生","description":null,"author":"nlby","url":"https://shadowbynl.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2021-08-28T04:29:51.390Z","updated":"2021-08-28T04:22:33.454Z","comments":true,"path":"archive.html","permalink":"https://shadowbynl.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"工具之一：一个爬虫小demo","slug":"tool-00","date":"2021-10-04T12:27:12.000Z","updated":"2021-10-04T14:53:43.269Z","comments":true,"path":"2021/10/04/tool-00/","link":"","permalink":"https://shadowbynl.github.io/2021/10/04/tool-00/","excerpt":"2021.10.04 恰逢绿群换届，加入绿群半年多了，深感绿群给我认识上的帮助还是不小的，为表纪念，编程实现一下把两个绿群当前的群成员信息（为了以后还能留在里面，得每天早上打卡了，）","text":"2021.10.04 恰逢绿群换届，加入绿群半年多了，深感绿群给我认识上的帮助还是不小的，为表纪念，编程实现一下把两个绿群当前的群成员信息（为了以后还能留在里面，得每天早上打卡了，） 先前的工作根据前两三天的测试，发现只能通过网页版群管理网站访问自己加入群的信息，且初始群成员仅显示几十条，随手动刷新变化，因此 121 需要登录信息cookie2 需要调整访问参数或者自己创建客户端 后面用chrome + postman进行了接口测试发现仿照chrome对接口https://qun.qq.com/cgi-bin/qun_mgr/search_group_members 的请求，自己填写请求头和cookie很难访问成功，后通过postman的拦截器，拦截到请求（主要是headers），再手动设置cookie，可以请求到数据，但现在两天后已经失效了，需要重新考虑，并且经过测试一次请求的数据最多为40条 那么 1 手动调整参数2 编程实现 1决定还是用python实现，有python脚本且python写爬虫和操作数据库简单多了 实现在用复杂方法实现之前，先试试能不能用xpath抓到不能 以下为成功实现（json数据存储在文本中，解析后的数据存入数据库） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import requestsimport jsonimport datetimeimport pymysqldef get_data(st, end): url = &quot;https://qun.qq.com/cgi-bin/qun_mgr/search_group_members&quot; payload=&#x27;bkn=17&amp;end=%d&amp;gc=60&amp;sort=0&amp;st=%d&#x27; % (end, st) print(payload) headers = &#123; &#x27;sec-ch-ua&#x27;: &#x27;&quot;Google Chrome&quot;;v=&quot;93&quot;, &quot; Not;A Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;93&quot;&#x27;, &#x27;Accept&#x27;: &#x27;application/json, text/javascript, */*; q=0.01&#x27;, &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;, &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;, &#x27;sec-ch-ua-mobile&#x27;: &#x27;?0&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36&#x27;, &#x27;sec-ch-ua-platform&#x27;: &#x27;&quot;Windows&quot;&#x27;, &#x27;Sec-Fetch-Site&#x27;: &#x27;same-origin&#x27;, &#x27;Sec-Fetch-Mode&#x27;: &#x27;cors&#x27;, &#x27;Sec-Fetch-Dest&#x27;: &#x27;empty&#x27;, &#x27;cookie&#x27;: &#x27;pgv_pvid=4807424512; RK=CnitUqaOzk; ptcz=2bff5fa480b335df4dea5136dd81406309b8f15f73ff199cd4a10aab809851c6; ptui_loginuin=1029253541@qq.com; o_cookie=1029253541; pac_uid=1_1029253541; pt_sms_phone=152******68; tvfe_boss_uuid=64df391d6a4d651e; luin=o1029253541; lskey=000100000e1cf2eae4b33b52500045ff70be94a0d1970a5bef9d1b131ed869f75fa730c46612f21ab51145fd; pgv_info=ssid=s7817371752; rv2=8071853B4A6553C74DF68DE54D4BA72CAE91A028BB765C5D46; property20=A93EDBD10D788C397EE1080CE04FEC49CCE5ED74FAD10405A78EB5850B3C3DFDDFD043AC9328A585; uin=o3347893023; _qpsvr_localtk=0.05728061992185873; p_uin=o3347893023; traceid=4260966dcc; midas_openid=F7D08CE2D8B70939D1A41C59F768CFD3; midas_openkey=BF1126A37F21BE7734072884A99E4C88; skey=@rLW4zF2XC; pt4_token=dFtpDgb38HJDsbh-LofFjunN7VgVFhV-nb62YQdGqDo_; p_skey=C9bpnITdlIJZ2w2697GG4yD4w*v*ccsw76wzZN6J-qA_; traceid=3bf6119017&#x27; &#125; response = requests.request(&quot;POST&quot;, url, headers=headers, data=payload) content = response.text # print(response.text) return contentdef parse(content, file): with open(file, &quot;a&quot;, encoding=&#x27;utf-8&#x27;) as f: f.write(content + &quot;\\n&quot;) # 转换为python对象 data = json.loads(content) mems = data[&quot;mems&quot;] conn = pymysql.connect(host=&quot;ip&quot;, port=3306, user=&quot;root&quot;, password=&quot;pwd&quot;, database=&quot;ggu&quot;, charset=&quot;utf8mb4&quot;) for mem in mems: qq_id = mem[&quot;uin&quot;] qq_name = mem[&quot;nick&quot;] print(qq_name) qq_card = mem[&quot;card&quot;] qq_age = str(mem[&quot;qage&quot;]) qq_join_time = mem[&quot;join_time&quot;] dateArray = datetime.datetime.utcfromtimestamp(qq_join_time) qq_join_time = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) qq_speak_time = mem[&quot;last_speak_time&quot;] dateArray = datetime.datetime.utcfromtimestamp(qq_speak_time) qq_speak_time = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) cursor = conn.cursor() sql = &quot;INSERT INTO membera(qq_id, qq_name, qq_card, qq_age, qq_join_time, qq_speak_time) VALUES (%s, %s, %s, %s, %s, %s);&quot; cursor.execute(sql, [qq_id, qq_name, qq_card, qq_age, qq_join_time, qq_speak_time]) conn.commit() cursor.close()# timeStamp = 1591780240# dateArray = datetime.datetime.utcfromtimestamp(timeStamp)# otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)# print(otherStyleTime)if __name__ == &#x27;__main__&#x27;: for st in range(0, 2800, 40): content = get_data(st, st + 40) parse(content, file=&quot;membera.txt&quot;) 问题与参考 python时间戳转换日期格式 https://www.runoob.com/python3/python-timstamp-str.html 123456import datetime timeStamp = 1557502800dateArray = datetime.datetime.utcfromtimestamp(timeStamp)otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)print(otherStyleTime) python json解析 https://www.runoob.com/python/python-json.html python格式化字符串 https://www.cnblogs.com/wilber2013/p/4641616.html python循环 https://www.cnblogs.com/anyview/p/5569016.html utf8编码和utf8mb4编码的差别 存数据库时报错 Incorrect string value: &#39;\\\\xF0\\\\x9F\\\\x92\\\\xAD\\\\xF0\\\\x9F... 经查是字段编码导致（原为utf8三字节存不下，需要换成utf8mb4四字节，注意必须在字段设计上换，单纯更改数据库编码不行）https://blog.csdn.net/qq_36090463/article/details/82353327https://blog.csdn.net/qq_17555933/article/details/101445526 总结 利用postman捕获分析请求有助于获取一般难以爬取的信息，且提供了多种语言的脚本，可以说作用很大了 utf8和utf8mb4的区别","categories":[],"tags":[]},{"title":"jaspider","slug":"jaspider","date":"2021-10-01T13:36:45.000Z","updated":"2021-10-03T06:48:11.329Z","comments":true,"path":"2021/10/01/jaspider/","link":"","permalink":"https://shadowbynl.github.io/2021/10/01/jaspider/","excerpt":"","text":"爬虫：采集–处理–存储用途：实现搜索引擎 获取更多的数据源 进行搜索引擎优化","categories":[],"tags":[]},{"title":"2021年9月保研结束后总结","slug":"202109summary","date":"2021-09-28T14:48:19.000Z","updated":"2021-09-28T15:04:03.458Z","comments":true,"path":"2021/09/28/202109summary/","link":"","permalink":"https://shadowbynl.github.io/2021/09/28/202109summary/","excerpt":"","text":"不多说了，勉强上个学，夏令营后两个月基本没有做保研相关的准备，拿到现在的结果也算是将就吧，之后的路就全看自己把握了。充足的写代码时间，自学时间，和短期的与长期的找工作的目标，将是我未来三年内的主题。未来的半年内，实习，毕设，写代码，学英语，深化对计算机知识的理解，尝试一些事，为研究生打工做准备，锻炼身体。。所有一切需要足够的自律和坚定的信念。这是一个新的起点，与我竞争的不单单是同校同专业的同学，更是全国千千万万学历或高或低经验或多或少的相关从业者。在这行立足，并做久，需要我持续慎重思考并践行。总会有遗憾，但要努力让自己以后不要做会让未来后悔的事。现在我的路已经很明确了。 目标10.8 前1 步入正轨 按920的安排进行2 做简历，准备投递（目标，了解）3 了解之后研究生的规划安排/情况（小概率考虑其他导师）","categories":[],"tags":[]},{"title":"npm相关环境","slug":"env-npm","date":"2021-09-22T01:42:20.000Z","updated":"2021-09-28T14:42:12.996Z","comments":true,"path":"2021/09/22/env-npm/","link":"","permalink":"https://shadowbynl.github.io/2021/09/22/env-npm/","excerpt":"","text":"npm查看全局安装过的包npm list -g –depth 0https://www.cnblogs.com/zhou-135/articles/11816745.html","categories":[],"tags":[]},{"title":"nk社区","slug":"pro-00","date":"2021-09-21T12:21:15.000Z","updated":"2021-10-03T06:28:31.710Z","comments":true,"path":"2021/09/21/pro-00/","link":"","permalink":"https://shadowbynl.github.io/2021/09/21/pro-00/","excerpt":"","text":"nk社区 1 首页 2 登录模块 3 核心功能 四 Redis缓存 nk社区（编写） 0 框架与环境 0-1 框架 0-2 数据库 1 基本环境 2 登录模块 nk社区1 首页123456789101112131415161718192021222324252627用户实体帖子实体帖子mapper1 （分页）查询帖子（用户id）2 查询帖子数量关于帖子关联的用户名的问题，采用得到帖子后，再查询的方式，不在mapper中统一关联查询，因此需要提供查询用户（id)的方法静态资源 static模板文件 templatesHomeController返回帖子-用户的键值列表首页渲染 帖子列表分页功能分页实体 方法 使用page实体 处理逻辑首页 分页实现项目调试技巧f8 7 9 日志默认logbacklogback-spring.xml 2 登录模块2-1 发送邮件12345678• 邮箱设置- 启用客户端SMTP服务• Spring Email- 导入 jar 包- 邮箱参数配置- 使用 JavaMailSender 发送邮件• 模板引擎- 使用 Thymeleaf 发送 HTML 邮件 2-2 开发注册功能12345678• 访问注册页面- 点击顶部区域内的链接，打开注册页面。• 提交注册数据- 通过表单提交数据。- 服务端验证账号是否已存在、邮箱是否已注册。- 服务端发送激活邮件。• 激活注册账号- 点击邮件中的链接，访问服务端的激活服务 拆解为三次请求 1234567首页跳转至注册页 首部的复用两个工具类 生成uuid md加盐加密注册业务 判空 验证账号 验证邮箱 注册用户 激活邮件注册controller 成功后到执行成功页注册页面 注册失败后跳回还需要留存信息th:value激活注册账号（邮箱链接）三种结果--常量类 激活业务激活controller 登录模板 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279# 首页跳转至注册页 首部的复用@GetMapping(&quot;/register&quot;)public String getRegisterPage() &#123; return &quot;/site/register&quot;;&#125;th:fragment=&quot;header&quot;th:href=&quot;@&#123;/index&#125;&quot;th:replace=&quot;index::header&quot;# 两个工具类 生成uuid md加盐加密&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;// 生成随机字符串public static String generateUUID() &#123; return UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);&#125;// MD5加密// hello -&gt; abc123def456// hello + 3e4a8 -&gt; abc123def456abcpublic static String md5(String key) &#123; if (StringUtils.isBlank(key)) &#123; return null; &#125; return DigestUtils.md5DigestAsHex(key.getBytes());&#125;# 注册业务 判空 验证账号 验证邮箱 注册用户 激活邮件@Servicepublic class UserService implements CommunityConstant &#123; @Autowired private UserMapper userMapper; @Autowired private MailClient mailClient; @Autowired private TemplateEngine templateEngine; @Value(&quot;$&#123;community.path.domain&#125;&quot;) private String domain; @Value(&quot;$&#123;server.servlet.context-path&#125;&quot;) private String contextPath; public User findUserById(int id) &#123; return userMapper.selectById(id); &#125; public Map&lt;String, Object&gt; register(User user) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 空值处理 if (user == null) &#123; throw new IllegalArgumentException(&quot;参数不能为空!&quot;); &#125; if (StringUtils.isBlank(user.getUsername())) &#123; map.put(&quot;usernameMsg&quot;, &quot;账号不能为空!&quot;); return map; &#125; if (StringUtils.isBlank(user.getPassword())) &#123; map.put(&quot;passwordMsg&quot;, &quot;密码不能为空!&quot;); return map; &#125; if (StringUtils.isBlank(user.getEmail())) &#123; map.put(&quot;emailMsg&quot;, &quot;邮箱不能为空!&quot;); return map; &#125; // 验证账号 User u = userMapper.selectByName(user.getUsername()); if (u != null) &#123; map.put(&quot;usernameMsg&quot;, &quot;该账号已存在!&quot;); return map; &#125; // 验证邮箱 u = userMapper.selectByEmail(user.getEmail()); if (u != null) &#123; map.put(&quot;emailMsg&quot;, &quot;该邮箱已被注册!&quot;); return map; &#125; // 注册用户 user.setSalt(CommunityUtil.generateUUID().substring(0, 5)); user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt())); user.setType(0); user.setStatus(0); user.setActivationCode(CommunityUtil.generateUUID()); user.setHeaderUrl(String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;, new Random().nextInt(1000))); user.setCreateTime(new Date()); userMapper.insertUser(user); // 激活邮件 Context context = new Context(); context.setVariable(&quot;email&quot;, user.getEmail()); // http://localhost:8080/community/activation/101/code String url = domain + contextPath + &quot;/activation/&quot; + user.getId() + &quot;/&quot; + user.getActivationCode(); context.setVariable(&quot;url&quot;, url); String content = templateEngine.process(&quot;/mail/activation&quot;, context); mailClient.sendMail(user.getEmail(), &quot;激活账号&quot;, content); return map; &#125; public int activation(int userId, String code) &#123; User user = userMapper.selectById(userId); if (user.getStatus() == 1) &#123; return ACTIVATION_REPEAT; &#125; else if (user.getActivationCode().equals(code)) &#123; userMapper.updateStatus(userId, 1); return ACTIVATION_SUCCESS; &#125; else &#123; return ACTIVATION_FAILURE; &#125; &#125;&#125;# 注册controller 成功后到执行成功页@Controllerpublic class LoginController implements CommunityConstant &#123; @Autowired private UserService userService; @RequestMapping(path = &quot;/register&quot;, method = RequestMethod.GET) public String getRegisterPage() &#123; return &quot;/site/register&quot;; &#125; @RequestMapping(path = &quot;/login&quot;, method = RequestMethod.GET) public String getLoginPage() &#123; return &quot;/site/login&quot;; &#125; @RequestMapping(path = &quot;/register&quot;, method = RequestMethod.POST) public String register(Model model, User user) &#123; Map&lt;String, Object&gt; map = userService.register(user); if (map == null || map.isEmpty()) &#123; model.addAttribute(&quot;msg&quot;, &quot;注册成功,我们已经向您的邮箱发送了一封激活邮件,请尽快激活!&quot;); model.addAttribute(&quot;target&quot;, &quot;/index&quot;); return &quot;/site/operate-result&quot;; &#125; else &#123; model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;)); model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;)); model.addAttribute(&quot;emailMsg&quot;, map.get(&quot;emailMsg&quot;)); return &quot;/site/register&quot;; &#125; &#125; // http://localhost:8080/community/activation/101/code @RequestMapping(path = &quot;/activation/&#123;userId&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET) public String activation(Model model, @PathVariable(&quot;userId&quot;) int userId, @PathVariable(&quot;code&quot;) String code) &#123; int result = userService.activation(userId, code); if (result == ACTIVATION_SUCCESS) &#123; model.addAttribute(&quot;msg&quot;, &quot;激活成功,您的账号已经可以正常使用了!&quot;); model.addAttribute(&quot;target&quot;, &quot;/login&quot;); &#125; else if (result == ACTIVATION_REPEAT) &#123; model.addAttribute(&quot;msg&quot;, &quot;无效操作,该账号已经激活过了!&quot;); model.addAttribute(&quot;target&quot;, &quot;/index&quot;); &#125; else &#123; model.addAttribute(&quot;msg&quot;, &quot;激活失败,您提供的激活码不正确!&quot;); model.addAttribute(&quot;target&quot;, &quot;/index&quot;); &#125; return &quot;/site/operate-result&quot;; &#125;&#125;# 注册页面 注册失败后跳回还需要留存信息th:value&lt;!-- 内容 --&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3&quot;&gt; &lt;h3 class=&quot;text-center text-info border-bottom pb-3&quot;&gt;注&amp;nbsp;&amp;nbsp;册&lt;/h3&gt; &lt;form class=&quot;mt-5&quot; method=&quot;post&quot; th:action=&quot;@&#123;/register&#125;&quot;&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;username&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;账号:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; th:class=&quot;|form-control $&#123;usernameMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;user!=null?user.username:&#x27;&#x27;&#125;&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;usernameMsg&#125;&quot;&gt; 该账号已存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; th:class=&quot;|form-control $&#123;passwordMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;user!=null?user.password:&#x27;&#x27;&#125;&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入您的密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;passwordMsg&#125;&quot;&gt; 密码长度不能小于8位! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;confirm-password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;确认密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; th:value=&quot;$&#123;user!=null?user.password:&#x27;&#x27;&#125;&quot; id=&quot;confirm-password&quot; placeholder=&quot;请再次输入密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 两次输入的密码不一致! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;email&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;邮箱:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;email&quot; th:class=&quot;|form-control $&#123;emailMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;user!=null?user.email:&#x27;&#x27;&#125;&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;请输入您的邮箱!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;emailMsg&#125;&quot;&gt; 该邮箱已注册! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即注册&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;# 激活注册账号（邮箱链接）三种结果--常量类 激活业务public interface CommunityConstant &#123; /** * 激活成功 */ int ACTIVATION_SUCCESS = 0; /** * 重复激活 */ int ACTIVATION_REPEAT = 1; /** * 激活失败 */ int ACTIVATION_FAILURE = 2;&#125;# 激活controller 登录模板&lt;!doctype html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;https://static.nowcoder.com/images/logo_87_87.png&quot;/&gt; &lt;title&gt;牛客网-激活账号&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;b th:text=&quot;$&#123;email&#125;&quot;&gt;xxx@xxx.com&lt;/b&gt;, 您好! &lt;/p&gt; &lt;p&gt; 您正在注册牛客网, 这是一封激活邮件, 请点击 &lt;a th:href=&quot;$&#123;url&#125;&quot;&gt;此链接&lt;/a&gt;, 激活您的牛客账号! &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2-3 会话管理12345678910• HTTP的基本性质- HTTP是简单的- HTTP是可扩展的- HTTP是无状态的，有会话的• Cookie- 是服务器发送到浏览器，并保存在浏览器端的一小块数据。- 浏览器下次访问该服务器时，会自动携带块该数据，将其发送给服务器。• Session- 是JavaEE的标准，用于在服务端记录客户端信息。- 数据存放在服务端更加安全，但是也会增加服务端的内存压力。 12cookie测试session测试 多服务器情况 粘性session 同步session session服务器 会话数据存储 数据库（非关系） 代码1234567891011121314151617181920212223242526272829303132333435// cookie示例@RequestMapping(path = &quot;/cookie/set&quot;, method = RequestMethod.GET)@ResponseBodypublic String setCookie(HttpServletResponse response) &#123; // 创建cookie Cookie cookie = new Cookie(&quot;code&quot;, CommunityUtil.generateUUID()); // 设置cookie生效的范围 cookie.setPath(&quot;/community/alpha&quot;); // 设置cookie的生存时间 cookie.setMaxAge(60 * 10); // 发送cookie response.addCookie(cookie); return &quot;set cookie&quot;;&#125;@RequestMapping(path = &quot;/cookie/get&quot;, method = RequestMethod.GET)@ResponseBodypublic String getCookie(@CookieValue(&quot;code&quot;) String code) &#123; System.out.println(code); return &quot;get cookie&quot;;&#125;// session示例@RequestMapping(path = &quot;/session/set&quot;, method = RequestMethod.GET)@ResponseBodypublic String setSession(HttpSession session) &#123; session.setAttribute(&quot;id&quot;, 1); session.setAttribute(&quot;name&quot;, &quot;Test&quot;); return &quot;set session&quot;;&#125;@RequestMapping(path = &quot;/session/get&quot;, method = RequestMethod.GET)@ResponseBodypublic String getSession(HttpSession session) &#123; System.out.println(session.getAttribute(&quot;id&quot;)); System.out.println(session.getAttribute(&quot;name&quot;)); return &quot;get session&quot;;&#125; 2-4 生成验证码1234Kaptcha- 导入 jar 包- 编写 Kaptcha 配置类- 生成随机字符、生成图片 生成验证码的配置类 controller login图片 js 统一路径 随机参数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# 导入 jar 包&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt;# 编写 Kaptcha 配置类@Configurationpublic class KaptchaConfig &#123; @Bean public Producer kaptchaProducer() &#123; Properties properties = new Properties(); properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;100&quot;); properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;40&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;32&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;0,0,0&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYAZ&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;); properties.setProperty(&quot;kaptcha.noise.impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;); DefaultKaptcha kaptcha = new DefaultKaptcha(); Config config = new Config(properties); kaptcha.setConfig(config); return kaptcha; &#125;&#125;# 生成随机字符、生成图片@RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET)public void getKaptcha(HttpServletResponse response, HttpSession session) &#123; // 生成验证码 String text = kaptchaProducer.createText(); BufferedImage image = kaptchaProducer.createImage(text); // 将验证码存入session session.setAttribute(&quot;kaptcha&quot;, text); // 将突图片输出给浏览器 response.setContentType(&quot;image/png&quot;); try &#123; OutputStream os = response.getOutputStream(); ImageIO.write(image, &quot;png&quot;, os); &#125; catch (IOException e) &#123; logger.error(&quot;响应验证码失败:&quot; + e.getMessage()); &#125;&#125;# 前端&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3&quot;&gt; &lt;h3 class=&quot;text-center text-info border-bottom pb-3&quot;&gt;登&amp;nbsp;&amp;nbsp;录&lt;/h3&gt; &lt;form class=&quot;mt-5&quot;&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;username&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;账号:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control is-invalid&quot; id=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 该账号不存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control is-invalid&quot; id=&quot;password&quot; placeholder=&quot;请输入您的密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 密码长度不能小于8位! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;verifycode&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;验证码:&lt;/label&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control is-invalid&quot; id=&quot;verifycode&quot; placeholder=&quot;请输入验证码!&quot;&gt; &lt;div class=&quot;invalid-feedback&quot;&gt; 验证码不正确! &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;img th:src=&quot;@&#123;/kaptcha&#125;&quot; id=&quot;kaptcha&quot; style=&quot;width:100px;height:40px;&quot; class=&quot;mr-2&quot;/&gt; &lt;a href=&quot;javascript:refresh_kaptcha();&quot; class=&quot;font-size-12 align-bottom&quot;&gt;刷新验证码&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;remember-me&quot; checked=&quot;checked&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;remember-me&quot;&gt;记住我&lt;/label&gt; &lt;a href=&quot;forget.html&quot; class=&quot;text-danger float-right&quot;&gt;忘记密码?&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;var CONTEXT_PATH = &quot;/community&quot;;&lt;script th:src=&quot;@&#123;/js/global.js&#125;&quot;&gt;&lt;/script&gt;&lt;script&gt; function refresh_kaptcha() &#123; var path = CONTEXT_PATH + &quot;/kaptcha?p=&quot; + Math.random(); $(&quot;#kaptcha&quot;).attr(&quot;src&quot;, path); &#125;&lt;/script&gt; 2-5 开发登录、退出功能123456789• 访问登录页面- 点击顶部区域内的链接，打开登录页面。• 登录- 验证账号、密码、验证码。- 成功时，生成登录凭证，发放给客户端。- 失败时，跳转回登录页。• 退出- 将登录凭证修改为失效状态。- 跳转至网站首页。 登录凭证实体登录业务（空值处理 验证账号|是否存在/是否激活 验证密码 生成登录凭证）controller（检查验证码 登录凭证超时时间设置 检查账号密码登录页 表单 请求参数（输入回显 提示文本）退出功能（凭证失效 重定向到登录页 退出链接） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155# 登录凭证public class LoginTicket &#123; private int id; private int userId; private String ticket; private int status; private Date expired;&#125;# 实体# 登录业务（空值处理 验证账号|是否存在/是否激活 验证密码 生成登录凭证）public Map&lt;String, Object&gt; login(String username, String password, int expiredSeconds) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 空值处理 if (StringUtils.isBlank(username)) &#123; map.put(&quot;usernameMsg&quot;, &quot;账号不能为空!&quot;); return map; &#125; if (StringUtils.isBlank(password)) &#123; map.put(&quot;passwordMsg&quot;, &quot;密码不能为空!&quot;); return map; &#125; // 验证账号 User user = userMapper.selectByName(username); if (user == null) &#123; map.put(&quot;usernameMsg&quot;, &quot;该账号不存在!&quot;); return map; &#125; // 验证状态 if (user.getStatus() == 0) &#123; map.put(&quot;usernameMsg&quot;, &quot;该账号未激活!&quot;); return map; &#125; // 验证密码 password = CommunityUtil.md5(password + user.getSalt()); if (!user.getPassword().equals(password)) &#123; map.put(&quot;passwordMsg&quot;, &quot;密码不正确!&quot;); return map; &#125; // 生成登录凭证 LoginTicket loginTicket = new LoginTicket(); loginTicket.setUserId(user.getId()); loginTicket.setTicket(CommunityUtil.generateUUID()); loginTicket.setStatus(0); loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000)); loginTicketMapper.insertLoginTicket(loginTicket); map.put(&quot;ticket&quot;, loginTicket.getTicket()); return map;&#125;# controller（检查验证码 登录凭证超时时间设置 检查账号密码@RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST)public String login(String username, String password, String code, boolean rememberme, Model model, HttpSession session, HttpServletResponse response) &#123; // 检查验证码 String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;); if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) &#123; model.addAttribute(&quot;codeMsg&quot;, &quot;验证码不正确!&quot;); return &quot;/site/login&quot;; &#125; // 检查账号,密码 int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS; Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds); if (map.containsKey(&quot;ticket&quot;)) &#123; Cookie cookie = new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString()); cookie.setPath(contextPath); cookie.setMaxAge(expiredSeconds); response.addCookie(cookie); return &quot;redirect:/index&quot;; &#125; else &#123; model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;)); model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;)); return &quot;/site/login&quot;; &#125;&#125;/** * 默认状态的登录凭证的超时时间 */int DEFAULT_EXPIRED_SECONDS = 3600 * 12;/** * 记住状态的登录凭证超时时间 */int REMEMBER_EXPIRED_SECONDS = 3600 * 24 * 100;# 登录页 表单 请求参数（输入回显 提示文本）&lt;!-- 内容 --&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3&quot;&gt; &lt;h3 class=&quot;text-center text-info border-bottom pb-3&quot;&gt;登&amp;nbsp;&amp;nbsp;录&lt;/h3&gt; &lt;form class=&quot;mt-5&quot; method=&quot;post&quot; th:action=&quot;@&#123;/login&#125;&quot;&gt; &lt;div class=&quot;form-group row&quot;&gt; &lt;label for=&quot;username&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;账号:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; th:class=&quot;|form-control $&#123;usernameMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;param.username&#125;&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入您的账号!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;usernameMsg&#125;&quot;&gt; 该账号不存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;password&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; th:class=&quot;|form-control $&#123;passwordMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; th:value=&quot;$&#123;param.password&#125;&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入您的密码!&quot; required&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;passwordMsg&#125;&quot;&gt; 密码长度不能小于8位! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;verifycode&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;验证码:&lt;/label&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &lt;input type=&quot;text&quot; th:class=&quot;|form-control $&#123;codeMsg!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; id=&quot;verifycode&quot; name=&quot;code&quot; placeholder=&quot;请输入验证码!&quot;&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;codeMsg&#125;&quot;&gt; 验证码不正确! &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;img th:src=&quot;@&#123;/kaptcha&#125;&quot; id=&quot;kaptcha&quot; style=&quot;width:100px;height:40px;&quot; class=&quot;mr-2&quot;/&gt; &lt;a href=&quot;javascript:refresh_kaptcha();&quot; class=&quot;font-size-12 align-bottom&quot;&gt;刷新验证码&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;remember-me&quot; name=&quot;rememberme&quot; th:checked=&quot;$&#123;param.rememberme&#125;&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;remember-me&quot;&gt;记住我&lt;/label&gt; &lt;a href=&quot;forget.html&quot; class=&quot;text-danger float-right&quot;&gt;忘记密码?&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;# 退出功能（凭证失效 重定向到登录页 退出链接）public void logout(String ticket) &#123; loginTicketMapper.updateStatus(ticket, 1);&#125;@RequestMapping(path = &quot;/logout&quot;, method = RequestMethod.GET)public String logout(@CookieValue(&quot;ticket&quot;) String ticket) &#123; userService.logout(ticket); return &quot;redirect:/login&quot;;&#125; 2-6 显示登录信息12345678• 拦截器示例- 定义拦截器，实现HandlerInterceptor- 配置拦截器，为它指定拦截、排除的路径• 拦截器应用- 在请求开始时查询登录用户- 在本次请求中持有用户数据- 在模板视图上显示用户数据- 在请求结束时清理用户数据 12345拦截器测试 interceptor mvc配置利用cookie获取凭证-用户实体获取cookie的工具类LoginTicketInterceptor（获取凭证 获取用户--持有用户信息的工具类 ThreadLocal）页面th:if 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# 拦截器测试 interceptor mvc配置@Componentpublic class AlphaInterceptor implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(AlphaInterceptor.class); // 在Controller之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; logger.debug(&quot;preHandle: &quot; + handler.toString()); return true; &#125; // 在Controller之后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; logger.debug(&quot;postHandle: &quot; + handler.toString()); &#125; // 在TemplateEngine之后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; logger.debug(&quot;afterCompletion: &quot; + handler.toString()); &#125;&#125;@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Autowired private AlphaInterceptor alphaInterceptor; @Autowired private LoginTicketInterceptor loginTicketInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(alphaInterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;) .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;); registry.addInterceptor(loginTicketInterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); &#125;&#125;# 利用cookie获取凭证-用户实体# 获取cookie的工具类public class CookieUtil &#123; public static String getValue(HttpServletRequest request, String name) &#123; if (request == null || name == null) &#123; throw new IllegalArgumentException(&quot;参数为空!&quot;); &#125; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(name)) &#123; return cookie.getValue(); &#125; &#125; &#125; return null; &#125;&#125;# LoginTicketInterceptor（获取凭证 获取用户--持有用户信息的工具类 ThreadLocal）/** * 持有用户信息,用于代替session对象. */@Componentpublic class HostHolder &#123; private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;&gt;(); public void setUser(User user) &#123; users.set(user); &#125; public User getUser() &#123; return users.get(); &#125; public void clear() &#123; users.remove(); &#125;&#125;@Componentpublic class LoginTicketInterceptor implements HandlerInterceptor &#123; @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 从cookie中获取凭证 String ticket = CookieUtil.getValue(request, &quot;ticket&quot;); if (ticket != null) &#123; // 查询凭证 LoginTicket loginTicket = userService.findLoginTicket(ticket); // 检查凭证是否有效 if (loginTicket != null &amp;&amp; loginTicket.getStatus() == 0 &amp;&amp; loginTicket.getExpired().after(new Date())) &#123; // 根据凭证查询用户 User user = userService.findUserById(loginTicket.getUserId()); // 在本次请求中持有用户 hostHolder.setUser(user); &#125; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; User user = hostHolder.getUser(); if (user != null &amp;&amp; modelAndView != null) &#123; modelAndView.addObject(&quot;loginUser&quot;, user); &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; hostHolder.clear(); &#125;&#125;# 页面th:if&lt;!-- 头部 --&gt;&lt;header class=&quot;bg-dark sticky-top&quot; th:fragment=&quot;header&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 导航 --&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark&quot;&gt; &lt;!-- logo --&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;!-- 功能 --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt; &lt;ul class=&quot;navbar-nav mr-auto&quot;&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot;&gt; &lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/index&#125;&quot;&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot; th:if=&quot;$&#123;loginUser!=null&#125;&quot;&gt; &lt;a class=&quot;nav-link position-relative&quot; href=&quot;site/letter.html&quot;&gt;消息&lt;span class=&quot;badge badge-danger&quot;&gt;12&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot; th:if=&quot;$&#123;loginUser==null&#125;&quot;&gt; &lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/register&#125;&quot;&gt;注册&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical&quot; th:if=&quot;$&#123;loginUser==null&#125;&quot;&gt; &lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item ml-3 btn-group-vertical dropdown&quot; th:if=&quot;$&#123;loginUser!=null&#125;&quot;&gt; &lt;a class=&quot;nav-link dropdown-toggle&quot; href=&quot;#&quot; id=&quot;navbarDropdown&quot; role=&quot;button&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; &lt;img th:src=&quot;$&#123;loginUser.headerUrl&#125;&quot; class=&quot;rounded-circle&quot; style=&quot;width:30px;&quot;/&gt; &lt;/a&gt; &lt;div class=&quot;dropdown-menu&quot; aria-labelledby=&quot;navbarDropdown&quot;&gt; &lt;a class=&quot;dropdown-item text-center&quot; href=&quot;site/profile.html&quot;&gt;个人主页&lt;/a&gt; &lt;a class=&quot;dropdown-item text-center&quot; href=&quot;site/setting.html&quot;&gt;账号设置&lt;/a&gt; &lt;a class=&quot;dropdown-item text-center&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;退出登录&lt;/a&gt; &lt;div class=&quot;dropdown-divider&quot;&gt;&lt;/div&gt; &lt;span class=&quot;dropdown-item text-center text-secondary&quot; th:utext=&quot;$&#123;loginUser.username&#125;&quot;&gt;nowcoder&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 搜索 --&gt; &lt;form class=&quot;form-inline my-2 my-lg-0&quot; action=&quot;site/search.html&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;search&quot; aria-label=&quot;Search&quot; /&gt; &lt;button class=&quot;btn btn-outline-light my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/header&gt; 2-7 账号设置12345678• 上传文件- 请求：必须是POST请求- 表单：enctype=“multipart/form-data”- Spring MVC：通过 MultipartFile 处理上传文件• 开发步骤- 访问账号设置页面- 上传头像- 获取头像 1234设置页配置上传路径上传controller方法（model返回提示信息）获取头像 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# 设置页&lt;!-- 上传头像 --&gt;&lt;h6 class=&quot;text-left text-info border-bottom pb-2&quot;&gt;上传头像&lt;/h6&gt;&lt;form class=&quot;mt-5&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; th:action=&quot;@&#123;/user/upload&#125;&quot;&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;label for=&quot;head-image&quot; class=&quot;col-sm-2 col-form-label text-right&quot;&gt;选择头像:&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;div class=&quot;custom-file&quot;&gt; &lt;input type=&quot;file&quot; th:class=&quot;|custom-file-input $&#123;error!=null?&#x27;is-invalid&#x27;:&#x27;&#x27;&#125;|&quot; id=&quot;head-image&quot; name=&quot;headerImage&quot; lang=&quot;es&quot; required=&quot;&quot;&gt; &lt;label class=&quot;custom-file-label&quot; for=&quot;head-image&quot; data-browse=&quot;文件&quot;&gt;选择一张图片&lt;/label&gt; &lt;div class=&quot;invalid-feedback&quot; th:text=&quot;$&#123;error&#125;&quot;&gt; 该账号不存在! &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group row mt-4&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-10 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即上传&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;# 配置上传路径community.path.domain=http://localhost:8080community.path.upload=d:/work/data/upload# 上传controller方法（model返回提示信息）@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; private static final Logger logger = LoggerFactory.getLogger(UserController.class); @Value(&quot;$&#123;community.path.upload&#125;&quot;) private String uploadPath; @Value(&quot;$&#123;community.path.domain&#125;&quot;) private String domain; @Value(&quot;$&#123;server.servlet.context-path&#125;&quot;) private String contextPath; @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @RequestMapping(path = &quot;/setting&quot;, method = RequestMethod.GET) public String getSettingPage() &#123; return &quot;/site/setting&quot;; &#125; @RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST) public String uploadHeader(MultipartFile headerImage, Model model) &#123; if (headerImage == null) &#123; model.addAttribute(&quot;error&quot;, &quot;您还没有选择图片!&quot;); return &quot;/site/setting&quot;; &#125; String fileName = headerImage.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); if (StringUtils.isBlank(suffix)) &#123; model.addAttribute(&quot;error&quot;, &quot;文件的格式不正确!&quot;); return &quot;/site/setting&quot;; &#125; // 生成随机文件名 fileName = CommunityUtil.generateUUID() + suffix; // 确定文件存放的路径 File dest = new File(uploadPath + &quot;/&quot; + fileName); try &#123; // 存储文件 headerImage.transferTo(dest); &#125; catch (IOException e) &#123; logger.error(&quot;上传文件失败: &quot; + e.getMessage()); throw new RuntimeException(&quot;上传文件失败,服务器发生异常!&quot;, e); &#125; // 更新当前用户的头像的路径(web访问路径) // http://localhost:8080/community/user/header/xxx.png User user = hostHolder.getUser(); String headerUrl = domain + contextPath + &quot;/user/header/&quot; + fileName; userService.updateHeader(user.getId(), headerUrl); return &quot;redirect:/index&quot;; &#125; @RequestMapping(path = &quot;/header/&#123;fileName&#125;&quot;, method = RequestMethod.GET) public void getHeader(@PathVariable(&quot;fileName&quot;) String fileName, HttpServletResponse response) &#123; // 服务器存放路径 fileName = uploadPath + &quot;/&quot; + fileName; // 文件后缀 String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); // 响应图片 response.setContentType(&quot;image/&quot; + suffix); try ( FileInputStream fis = new FileInputStream(fileName); OutputStream os = response.getOutputStream(); ) &#123; byte[] buffer = new byte[1024]; int b = 0; while ((b = fis.read(buffer)) != -1) &#123; os.write(buffer, 0, b); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;读取头像失败: &quot; + e.getMessage()); &#125; &#125;&#125;# 获取头像 2-8 检查登录状态123456789• 使用拦截器- 在方法前标注自定义注解- 拦截所有请求，只处理带有该注解的方法• 自定义注解- 常用的元注解：@Target、@Retention、@Document、@Inherited- 如何读取注解：Method.getDeclaredAnnotations​()Method.getAnnotation​(Class&lt;T&gt; annotationClass) 12自定义注解拦截器 代码1234567891011121314151617181920212223242526272829# 自定义注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LoginRequired &#123;&#125;# 拦截器@Componentpublic class LoginRequiredInterceptor implements HandlerInterceptor &#123; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (handler instanceof HandlerMethod) &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); LoginRequired loginRequired = method.getAnnotation(LoginRequired.class); if (loginRequired != null &amp;&amp; hostHolder.getUser() == null) &#123; response.sendRedirect(request.getContextPath() + &quot;/login&quot;); return false; &#125; &#125; return true; &#125;&#125;registry.addInterceptor(loginRequiredInterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); 3 核心功能3-1 过滤敏感词12345678• 前缀树- 名称：Trie、字典树、查找树- 特点：查找效率高，消耗内存大- 应用：字符串检索、词频统计、字符串排序等• 敏感词过滤器- 定义前缀树- 根据敏感词，初始化前缀树- 编写过滤敏感词的方法 12345678910111213141516如果使用jdk的字符串替换api 性能太差 用自己实现的前缀树进行过滤# 思想讲解1 定义敏感词 abc,bf,be 2 由敏感词构造前缀树（根节点空 标记）3 输入字符串 三个指针（两个指针指定一个单词，一个指针扫前缀树）4 示例过程 20min（以字符为单位，任意语言都可以）# 实现1 用文本记录敏感词2 工具类（敏感词过滤器）2.1 前缀树节点类（关键词结束标识 子节点--字符到节点的map 添加子节点方法 获取子节点方法2.2 初始化前缀树 根节点-替换符 init（字节流--字符缓冲流 遍历每个敏感词加入到前缀树）添加方法（传入敏感词 遍历每个字符）2.3 过滤方法（传入文本 判空 三个指针 判断是否为普通字符 逻辑）3 测试 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152@Componentpublic class SensitiveFilter &#123; private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class); // 替换符 private static final String REPLACEMENT = &quot;***&quot;; // 根节点 private TrieNode rootNode = new TrieNode(); @PostConstruct public void init() &#123; try ( InputStream is = this.getClass().getClassLoader().getResourceAsStream(&quot;sensitive-words.txt&quot;); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); ) &#123; String keyword; while ((keyword = reader.readLine()) != null) &#123; // 添加到前缀树 this.addKeyword(keyword); &#125; &#125; catch (IOException e) &#123; logger.error(&quot;加载敏感词文件失败: &quot; + e.getMessage()); &#125; &#125; // 将一个敏感词添加到前缀树中 private void addKeyword(String keyword) &#123; TrieNode tempNode = rootNode; for (int i = 0; i &lt; keyword.length(); i++) &#123; char c = keyword.charAt(i); TrieNode subNode = tempNode.getSubNode(c); if (subNode == null) &#123; // 初始化子节点 subNode = new TrieNode(); tempNode.addSubNode(c, subNode); &#125; // 指向子节点,进入下一轮循环 tempNode = subNode; // 设置结束标识 if (i == keyword.length() - 1) &#123; tempNode.setKeywordEnd(true); &#125; &#125; &#125; /** * 过滤敏感词 * * @param text 待过滤的文本 * @return 过滤后的文本 */ public String filter(String text) &#123; if (StringUtils.isBlank(text)) &#123; return null; &#125; // 指针1 TrieNode tempNode = rootNode; // 指针2 int begin = 0; // 指针3 int position = 0; // 结果 StringBuilder sb = new StringBuilder(); while (position &lt; text.length()) &#123; char c = text.charAt(position); // 跳过符号 if (isSymbol(c)) &#123; // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步 if (tempNode == rootNode) &#123; sb.append(c); begin++; &#125; // 无论符号在开头或中间,指针3都向下走一步 position++; continue; &#125; // 检查下级节点 tempNode = tempNode.getSubNode(c); if (tempNode == null) &#123; // 以begin开头的字符串不是敏感词 sb.append(text.charAt(begin)); // 进入下一个位置 position = ++begin; // 重新指向根节点 tempNode = rootNode; &#125; else if (tempNode.isKeywordEnd()) &#123; // 发现敏感词,将begin~position字符串替换掉 sb.append(REPLACEMENT); // 进入下一个位置 begin = ++position; // 重新指向根节点 tempNode = rootNode; &#125; else &#123; // 检查下一个字符 position++; &#125; &#125; // 将最后一批字符计入结果 sb.append(text.substring(begin)); return sb.toString(); &#125; // 判断是否为符号 private boolean isSymbol(Character c) &#123; // 0x2E80~0x9FFF 是东亚文字范围 return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c &gt; 0x9FFF); &#125; // 前缀树 private class TrieNode &#123; // 关键词结束标识 private boolean isKeywordEnd = false; // 子节点(key是下级字符,value是下级节点) private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); public boolean isKeywordEnd() &#123; return isKeywordEnd; &#125; public void setKeywordEnd(boolean keywordEnd) &#123; isKeywordEnd = keywordEnd; &#125; // 添加子节点 public void addSubNode(Character c, TrieNode node) &#123; subNodes.put(c, node); &#125; // 获取子节点 public TrieNode getSubNode(Character c) &#123; return subNodes.get(c); &#125; &#125;&#125; 3-2 发布帖子12345678910• AJAX- Asynchronous JavaScript and XML- 异步的JavaScript与XML，不是一门新技术，只是一个新的术语。- 使用AJAX，网页能够将增量更新呈现在页面上，而不需要刷新整个页面。- 虽然X代表XML，但目前JSON的使用比XML更加普遍。- https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX• 示例- 使用jQuery发送AJAX请求。• 实践- 采用AJAX请求，实现发布帖子的功能。 123456789101112131415161718192021# json处理--ajax1 引入 fastjson2 在CommunityUtil中编写json对象转换为字符串的方法（重载）3 AlphaController ajax示例 static/html/ajax-demo.html# 实现发布帖子功能1 discusspostmapper 增加帖子方法 xml中加上一个insert语句 2 帖子业务中 addDiscussPost2.1 判空2.2 对标题、内容进行转义处理（处理含有Html标签的内容）2.3 对标题、内容进行过滤敏感词处理 3 帖子Controller问题 为什么hostHolder能取代session的作用 作为存储当前用户的对象3.1 检查用户3.2 新增帖子4 页面4.1 index 弹出框 70多行 对发布按钮进行登录用户判定4.2 static/js/index.js publish方法4.2.1 弹出框隐藏4.2.2 获取标题和内容4.2.3 发布异步请求（显示返回消息 提示 刷新页面） 3-3 帖子详情123456789101112131415161718192021• DiscussPostMapper根据id查询的方法 mapper• DiscussPostServicefindxxx 根据id查询• DiscussPostControllergetxxx 根据id查询 id参数 model返回携带信息注意，一个帖子需要关联用户信息，此处如何处理？（1）效率更好的方法是 sql中关联查询 效率高 但可能会造成业务冗余（2）在controller中单独再查询 效率低 后续可用缓存优化根据帖子的用户id查到用户，也需返回此处先不处理帖子的评论回复相关• index.html- 在帖子标题上增加访问详情页面的链接在帖子列表的超链接上进行修改• discuss-detail.html- 处理静态资源的访问路径- 复用index.html的header区域- 显示标题、作者、发布时间、帖子正文等内容帖子详情 3-4 事务管理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364回顾• 什么是事务- 事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行。• 事务的特性（ACID）- 原子性（Atomicity）：事务是应用中不可再分的最小执行体。- 一致性（Consistency）：事务执行的结果，须使数据从一个一致性状态，变为另一个一致性状态。- 隔离性（Isolation）：各个事务的执行互不干扰，任何事务的内部操作对其他的事务都是隔离的。- 持久性（Durability）：事务一旦提交，对数据所做的任何改变都要记录到永久存储器中。事务的隔离性• 常见的并发异常- 第一类丢失更新、第二类丢失更新。- 脏读、不可重复读、幻读。• 常见的隔离级别- Read Uncommitted：读取未提交的数据。- Read Committed：读取已提交的数据。- Repeatable Read：可重复读。- Serializable：串行化。第一类丢失更新某一个事务的回滚，导致另外一个事务已更新的数据丢失了。第二类丢失更新某一个事务的提交，导致另外一个事务已更新的数据丢失了。脏读某一个事务，读取了另外一个事务未提交的数据。不可重复读某一个事务，对同一个数据前后读取的结果不一致。幻读某一个事务，对同一个表前后查询到的行数不一致。事务隔离级别隔离级别 第一类丢失更新 脏读 第二类丢失更新 不可重复读 幻读Read Uncommitted Y Y Y Y YRead Committed N N Y Y YRepeatable Read N N N N YSerializable N N N N N实现机制• 悲观锁（数据库）- 共享锁（S锁）事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。- 排他锁（X锁）事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。• 乐观锁（自定义）- 版本号、时间戳等在更新数据前，检查版本号是否发生变化。若变化则取消本次更新，否则就更新数据（版本号+1）。Spring事务管理• 声明式事务- 通过XML配置，声明某方法的事务特征。- 通过注解，声明某方法的事务特征。• 编程式事务- 通过 TransactionTemplate 管理事务，并通过它执行数据库的操作。 123456789多线程环境下，多个环境下同时访问同一数据隔离级别一般选中间两种# Spring事务测试Alpha业务中 save1 新增用户 新增帖子 注解：隔离机制 传播机制（业务方法相互调用）事务测试类 完整回滚编程式事务 save2 3-5 显示评论123456789• 数据层- 根据实体查询一页评论数据。- 根据实体查询评论的数量。• 业务层- 处理查询评论的业务。处理查询评论数量的业务。• 表现层- 显示帖子详情数据时，同时显示该帖子所有的评论数据。 1234567891011121314151617181920212218# 评论表可以对帖子评论 可以对评论评论1 设计一个entity_type 对应评论的对象 entity_id target_id是在回复某个回复时要指明针对的对象# 实体类 Mapper1 实体类2 方法：根据评论的对象查询评论、数量（分页辅助） 3 xml # 业务 控制器1 业务 两个方法2 控制器 getDiscussPost 获取评论分页信息+ 每个帖子有一个字段评论数量 实体类型 + 对每个评论，需要和用户关联 再逐一查询 和index帖子列表类似+ 评论的评论（回复）查所有 回复列表 对其也要设置一个Vo列表 比较特殊的是有一个指向性，回复的目标，普通的回复即回复评论target_id=0，特殊的是回复回复的回复，那么需要一个目标用户，vo里还需加一个键值对+ 帖子有评论数量字段 但评论的回复数量就需要单独查了# 页面1 index.html 帖子列表 回帖数2 帖子详情页 内容--回帖部分 回帖数量-回帖列表 基本--回复列表 特殊处理目标用户--回复回复的回复的情况 id3 复用分页 3-6 添加评论123456789• 数据层- 增加评论数据。- 修改帖子的评论数量。• 业务层- 处理添加评论的业务：先增加评论、再更新帖子的评论数量。• 表现层- 处理添加评论数据的请求。- 设置添加评论的表单 123456789101112131415191 comment mapper xml insert方法2 帖子 mapper xml 更新评论数量方法 帖子 service 更新评论数量方法3 评论 业务 增加评论方法（包含事务管理）3.1 参数判空3.2 评论 转义 敏感词过滤3.3 存入数据库3.4 更新评论数量（需要判断是帖子的评论，即需要判断entity_type，然后查到对应的帖子实体，调用帖子的更新评论数量业务方法进行更新）4 评论 controller 新增方法5 页面评论详情页5.1 回帖输入部分（表单 method action 文本域 隐藏域/两个entity_xxx）5.2 回复输入框（和5.1同 区别是针对的对象是评论/回复 还需要携带targetId 提示回复给xxx） 3-7 私信列表1234567• 私信列表- 查询当前用户的会话列表，每个会话只显示一条最新的私信。- 支持分页显示。• 私信详情- 查询某个会话所包含的私信。- 支持分页显示。 123456789101112131415161718192021222324252627282920# 表 messagefrom_id to_id 会话id（规则，小id_大id）# 实现1 Message实体2 MessageMapper（5个方法）xml（1）查询用户会话列表（分页）（2）会话数量（3）查询某个会话包含的私信列表（4）查询某个会话包含的私信数量（5）查询未读的私信的数量xml1/查询时status=2表删除 from_id=1表系统通知3 Mapper测试4 业务message 55 controller 私信列表 私信详情 注意逻辑6 页面6.1 index.html 消息链接6.2 letter.html引入css js 首部选项卡部分（链接 未读消息）私信列表-------------letter.html 详情链接6.3 私信详情页面目标用户私信列表返回和js方法 3-8 发送私信123456• 发送私信- 采用异步的方式发送私信。- 发送成功后刷新私信列表。• 设置已读- 访问私信详情时，将显示的私信设置为已读状态。 1234567891011121321# 两个地方可以发起私信# 进入私信详情，修改私信状态# 实现1 mapper 新增消息 修改消息状态2 业务 需要过滤 add read3 controller 异步send 用户业务补充一个根据用户名查询用户的方法 修改状态3.1 根据用户名查到发送的用户对象3.2 构造私信对象 from to 会话4 页面4.1 letter.js里send_letter方法4.2 私信详情页处理 3-9 统一处理异常12345678910• @ControllerAdvice- 用于修饰类，表示该类是Controller的全局配置类。- 在此类中，可以对Controller进行如下三种全局配置：异常处理方案、绑定数据方案、绑定参数方案。• @ExceptionHandler- 用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。• @ModelAttribute- 用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。• @DataBinder- 用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。 1231 错误页面模板 templates/error 自动跳转2 HomeController/getErrorPage3 异常处理类 区分处理异步请求和普通请求 3-10 统一处理日志（针对业务组件）12345678910111213141516171819202122AOP的概念• Aspect Oriented Programing，即面向方面（切面）编程。• AOP是一种编程思想，是对OOP的补充，可以进一步提高编程的效率。AOP的实现• AspectJ- AspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法。- AspectJ在编译期织入代码，它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。• Spring AOP- Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器。- Spring AOP在运行时通过代理的方式织入代码，只支持方法类型的连接点。- Spring支持对AspectJ的集成。Spring AOP• JDK动态代理- Java提供的动态代理技术，可以在运行时创建接口的代理实例。- Spring AOP默认采用此种方式，在接口的代理实例中织入代码。• CGLib动态代理- 采用底层的字节码技术，在运行时创建子类代理实例。- 当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码。 1234567拦截器等和上述方法是针对controller的对于业务组件来说，不应该把记录日志的代码在每个地方都明写出来（硬编码）目标对象 joinpoint 切面组件两个类 四 Redis缓存4.1 Redis入门12345• Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。• Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人。同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性。• Redis典型的应用场景包括：缓存、排行榜、计数器、社交网络、消息队列等。 12345678910111213141516171819202122232425262728293031323334353637381 快照存储 完全存储 不能实时2 日志存储AOF 实时命令 追加3 主要是 数据结构--对应命令--------常用命令select nflushdb&gt; stringset test:count 1get test:countincr test:countdecr test:counthset test:user id 1hset test:user username zshget test:user idlpush test:ids 101 102 103 列表左进右出 索引左到右递增llen test:idslindex test:ids 0lindex test:ids 2lrange test:ids 0 2rpop test:idssadd test:teachers aaa bbb cc dd eeescard test:teachersspop test:teacherssmembers test:teacherszadd test:students 10 aaa 20 bbb 30 ccc 40 dddzcard test:studentszscore test:students ccczrank test:studentszrange test:students 0 2keys *keys test*type test:userexists keydel key 4.2 spring整合redis1234567891011• 引入依赖- spring-boot-starter-data-redis• 配置Redis- 配置数据库参数- 编写配置类，构造RedisTemplate• 访问Redis- redisTemplate.opsForValue()- redisTemplate.opsForHash()- redisTemplate.opsForList()- redisTemplate.opsForSet()- redisTemplate.opsForZSet() 11 依赖 nk社区（编写） 2021.9.22开始做这个社区项目，后面几天就以此为主要任务，做完为止。一个典型的crud的单体应用。 0 框架与环境0-1 框架装载beanspringmvc注解 0-2 数据库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `password` varchar(50) DEFAULT NULL, `salt` varchar(50) DEFAULT NULL, `email` varchar(100) DEFAULT NULL, `type` int(11) DEFAULT NULL COMMENT &#x27;0-普通用户; 1-超级管理员; 2-版主;&#x27;, `status` int(11) DEFAULT NULL COMMENT &#x27;0-未激活; 1-已激活;&#x27;, `activation_code` varchar(100) DEFAULT NULL, `header_url` varchar(200) DEFAULT NULL, `create_time` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_username` (`username`(20)), KEY `index_email` (`email`(20))) ENGINE=InnoDB AUTO_INCREMENT=101 DEFAULT CHARSET=utf8;CREATE TABLE `discuss_post` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` varchar(45) DEFAULT NULL, `title` varchar(100) DEFAULT NULL, `content` text, `type` int(11) DEFAULT NULL COMMENT &#x27;0-普通; 1-置顶;&#x27;, `status` int(11) DEFAULT NULL COMMENT &#x27;0-正常; 1-精华; 2-拉黑;&#x27;, `create_time` timestamp NULL DEFAULT NULL, `comment_count` int(11) DEFAULT NULL, `score` double DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_user_id` (`user_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `message` ( `id` int(11) NOT NULL AUTO_INCREMENT, `from_id` int(11) DEFAULT NULL, `to_id` int(11) DEFAULT NULL, `conversation_id` varchar(45) NOT NULL, `content` text, `status` int(11) DEFAULT NULL COMMENT &#x27;0-未读;1-已读;2-删除;&#x27;, `create_time` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_from_id` (`from_id`), KEY `index_to_id` (`to_id`), KEY `index_conversation_id` (`conversation_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `comment` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) DEFAULT NULL, `entity_type` int(11) DEFAULT NULL, `entity_id` int(11) DEFAULT NULL, `target_id` int(11) DEFAULT NULL, `content` text, `status` int(11) DEFAULT NULL, `create_time` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_user_id` (`user_id`) /*!80000 INVISIBLE */, KEY `index_entity_id` (`entity_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `login_ticket` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL, `ticket` varchar(45) NOT NULL, `status` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;0-有效; 1-无效;&#x27;, `expired` timestamp NOT NULL, PRIMARY KEY (`id`), KEY `index_ticket` (`ticket`(20))) ENGINE=InnoDB DEFAULT CHARSET=utf8; 12345678UserMapper selectById selectByName selectByEmail insertUser updateStatus updateHeader updatePassword 1 基本环境1-1 用户实体相关先看着敲一遍，然后自己写一遍，再对照，在此前先熟悉下数据库 123456789101112131415create table `user` ( `id` int(11) not null auto_increment, `username` varchar(50) default null, `password` varchar(50) default null, `salt` varchar(50) default null, `email` varchar(100) default null, `type` int(11) default null, `status` int(11) default null, `activation_code` varchar(100) default null, `header_url` varchar(200) default null, `create_time` timestamp null default null, primary key(`id`), key `index_username`(`username`(20)), key `index_email`(`email`(20))) engine = innodb auto_increment=101 default charset=utf8; 编写测试完用户实体的总结 12345678流程依赖：数据库驱动+mybatis配置：数据源 连接池配置实体mapper 测试crud注意测试，用到容器中的bean 须用@SpringBootTest 1-2 基本环境配置 原始网页素材已经没有了，初始是配置好分页相关的 thymeleaf语法 https://fanlychie.github.io/post/thymeleaf.html 日志默认 logback-spring.xml 1-3 帖子实体与分页实现帖子实体 mapper分页实体 thymeleaf 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 帖子列表 --&gt;&lt;ul class=&quot;list-unstyled&quot;&gt; &lt;li class=&quot;media pb-3 pt-3 mb-3 border-bottom&quot; th:each=&quot;map:$&#123;discussPosts&#125;&quot;&gt; &lt;a href=&quot;site/profile.html&quot;&gt; &lt;img th:src=&quot;$&#123;map.user.headerUrl&#125;&quot; class=&quot;mr-4 rounded-circle&quot; alt=&quot;用户头像&quot; style=&quot;width:50px;height:50px;&quot;&gt; &lt;/a&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h6 class=&quot;mt-0 mb-3&quot;&gt; &lt;a href=&quot;#&quot; th:utext=&quot;$&#123;map.post.title&#125;&quot;&gt;备战春招，面试刷题跟他复习，一个月全搞定！&lt;/a&gt; &lt;span class=&quot;badge badge-secondary bg-primary&quot; th:if=&quot;$&#123;map.post.type==1&#125;&quot;&gt;置顶&lt;/span&gt; &lt;span class=&quot;badge badge-secondary bg-danger&quot; th:if=&quot;$&#123;map.post.status==1&#125;&quot;&gt;精华&lt;/span&gt; &lt;/h6&gt; &lt;div class=&quot;text-muted font-size-12&quot;&gt; &lt;u class=&quot;mr-3&quot; th:utext=&quot;$&#123;map.user.username&#125;&quot;&gt;寒江雪&lt;/u&gt; 发布于 &lt;b th:text=&quot;$&#123;#dates.format(map.post.createTime,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;2019-04-15 15:32:18&lt;/b&gt; &lt;ul class=&quot;d-inline float-right&quot;&gt; &lt;li class=&quot;d-inline ml-2&quot;&gt;赞 11&lt;/li&gt; &lt;li class=&quot;d-inline ml-2&quot;&gt;|&lt;/li&gt; &lt;li class=&quot;d-inline ml-2&quot;&gt;回帖 7&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 分页 --&gt;&lt;nav class=&quot;mt-5&quot; th:if=&quot;$&#123;page.rows&gt;0&#125;&quot;&gt; &lt;ul class=&quot;pagination justify-content-center&quot;&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=1)&#125;&quot;&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;|page-item $&#123;page.current==1?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current-1&#125;)&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li th:class=&quot;|page-item $&#123;i==page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;|&quot; th:each=&quot;i:$&#123;#numbers.sequence(page.from,page.to)&#125;&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;i&#125;)&#125;&quot; th:text=&quot;$&#123;i&#125;&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li th:class=&quot;|page-item $&#123;page.current==page.total?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current+1&#125;)&#125;&quot;&gt;下一页&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; th:href=&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.total&#125;)&#125;&quot;&gt;末页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 12345涉及到对象及运算的都用$&#123;&#125;th:href=@&#123;$&#123;&#125;()&#125;th:class=&quot;||&quot;th:each=&quot;map:$&#123;&#125;&quot;th:text=&quot;&quot; 分页测试报错 There is no getter for property named ‘userId’ in ‘class java.lang.Integer’https://blog.csdn.net/qq_30604989/article/details/81297400 2 登录模块2-1 邮件功能注意测试时有延迟，可能需要几分钟才能发送成功参考 https://blog.csdn.net/breakaway_01/article/details/111474564 2-2 注册123th:fragment=&quot;header&quot;th:href=&quot;@&#123;/index&#125;&quot;th:replace=&quot;index::header&quot; 2-3 问题thymeleaf找不到页面的问题注意@Controller配置@Slf4jhttps://www.jianshu.com/p/6e137ee836a1","categories":[],"tags":[]},{"title":"ls树相关","slug":"ls-tree","date":"2021-09-20T16:12:54.000Z","updated":"2021-09-28T14:44:24.702Z","comments":true,"path":"2021/09/21/ls-tree/","link":"","permalink":"https://shadowbynl.github.io/2021/09/21/ls-tree/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SQL相关","slug":"sql-00","date":"2021-09-20T14:51:34.000Z","updated":"2021-09-28T14:43:05.694Z","comments":true,"path":"2021/09/20/sql-00/","link":"","permalink":"https://shadowbynl.github.io/2021/09/20/sql-00/","excerpt":"sql相关的问题与练习","text":"sql相关的问题与练习 环境本机mysql配置初始化密码遗失的解决方案 https://blog.csdn.net/m0_46278037/article/details/113923726","categories":[],"tags":[]},{"title":"儒猿面试之一","slug":"ry-00","date":"2021-09-20T14:34:49.000Z","updated":"2021-09-28T14:44:07.451Z","comments":true,"path":"2021/09/20/ry-00/","link":"","permalink":"https://shadowbynl.github.io/2021/09/20/ry-00/","excerpt":"中华石杉面试专题 高频考题篇","text":"中华石杉面试专题 高频考题篇 一 概述二 集合1 HashMap相关 2","categories":[],"tags":[]},{"title":"test-qa","slug":"test-qa","date":"2021-09-15T08:17:23.000Z","updated":"2021-09-17T05:41:54.510Z","comments":true,"path":"2021/09/15/test-qa/","link":"","permalink":"https://shadowbynl.github.io/2021/09/15/test-qa/","excerpt":"","text":"mysqlNavicat运行SQL文件出错https://zhidao.baidu.com/question/525156367906044565.html 计算机网络TCP中的seq 什么意思https://zhidao.baidu.com/question/346839619.htmlhttps://www.cnblogs.com/vvull/p/10597881.html 项目创建springboot项目不成功的问题（网络连接） 网络换成热点（不一定） 创建不成功 https://blog.csdn.net/qq_26071319/article/details/106209405http://start.aliyun.com 代理 pom报红https://blog.csdn.net/feifeiwuxian/article/details/1093341011234567&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; https://blog.csdn.net/qq_41205651/article/details/114854831File -&gt; Invalidate Caches / Restart... -&gt; Invalidate and Restart","categories":[],"tags":[]},{"title":"jf","slug":"jf","date":"2021-09-13T13:10:02.000Z","updated":"2021-09-16T08:44:38.265Z","comments":true,"path":"2021/09/13/jf/","link":"","permalink":"https://shadowbynl.github.io/2021/09/13/jf/","excerpt":"","text":"java框架的基本概念与使用相关 ssm springboot等 mybatis配置解析映射文件和注解动态sql复杂实体关系缓存 spring控制反转 依赖注入代理模式 AOP整合声明式事务 springmvcdispatcherServlet原理 restful 请求参数 返回 乱码 json","categories":[],"tags":[]},{"title":"javaweb","slug":"javaweb","date":"2021-09-13T07:55:30.000Z","updated":"2021-09-13T09:08:05.879Z","comments":true,"path":"2021/09/13/javaweb/","link":"","permalink":"https://shadowbynl.github.io/2021/09/13/javaweb/","excerpt":"","text":"jdbcsmbms","categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"}],"tags":[]},{"title":"关于编程学习的问题","slug":"abstj","date":"2021-09-10T16:08:33.000Z","updated":"2021-09-11T12:26:54.797Z","comments":true,"path":"2021/09/11/abstj/","link":"","permalink":"https://shadowbynl.github.io/2021/09/11/abstj/","excerpt":"夏令营结束后的八月，心还是有些浮的，一直想回家回不成，所谓准备实习，但实际每天花在准备上的工夫很少，不够专注，效果很差。到九月初回顾自己的技术体系，发现有很多漏洞和模糊的地方，这时候认识到对于找这样的后端开发的工作来说，不专注地学习其基础的方方面面再去看面经总结，而是直接被动接收一些很粗略的知识，是绝对不能应付找工作的要求的。如果以后想干开发，在现在这么卷的情况下，不沉下心来学习准备，而是抱着一个“顺便”的态度，很难会有什么作为。近来先后找过同样学习后端开发的同学聊过两次（已有腾讯网易），对我有些启发，在这篇中简单总结下，同时后续关于总体学习的反思也在此记述。","text":"夏令营结束后的八月，心还是有些浮的，一直想回家回不成，所谓准备实习，但实际每天花在准备上的工夫很少，不够专注，效果很差。到九月初回顾自己的技术体系，发现有很多漏洞和模糊的地方，这时候认识到对于找这样的后端开发的工作来说，不专注地学习其基础的方方面面再去看面经总结，而是直接被动接收一些很粗略的知识，是绝对不能应付找工作的要求的。如果以后想干开发，在现在这么卷的情况下，不沉下心来学习准备，而是抱着一个“顺便”的态度，很难会有什么作为。近来先后找过同样学习后端开发的同学聊过两次（已有腾讯网易），对我有些启发，在这篇中简单总结下，同时后续关于总体学习的反思也在此记述。 一、一个专注的态度和学习方法其实回顾我过去这二十年，很难说我真正学会了什么技能，很多事浅尝辄止，很多事勉强应付。到现在能通过保研拿到这么一个打黑工的机会已经算是我牺牲比别人多几倍的时间（浪费）而争取到的一个并不怎么样的结果。未来靠什么才能生存，需要真正学会什么，我一直都很清楚，但态度和做法实际并不坚定。长久以来，我习惯看视频教程草草学习，看别人怎么做，但自己很少有练习思考，也很少有总结。往往事情一多起来，我就会中断技术的学习，很多东西一直反复，导致目前很难说掌握了什么技术。这种轻慢的应对技术学习的态度，导致的虚浮的技术水平，进而使我本人内心各方面其实都相当不自信。到现在这个阶段，今年的冬天我就要22周岁了，身体素质差，眼下较不抵触的路就是之后两年去南软外包公司去挣4k的月薪，而选择这条意味着未来我将走死开发这条路了。一个电子信息的硕士，学不到新的研究生阶段才能学到的知识，也不会有曾经渴望的导师的引导，有的只是在用身体换钱一条路走到黑的未来，对于我来说其实也算是较适合的了。不太想科研，也欠缺交际的能力，选择了计算机专业的话还是走开发较好，在这种意义上南软是个尚可的选择，算是有了title也有了一个缓冲学习的机会。如果我做了这样的选择，我未来三年内将完全以java开发为主了。和本科前三年的学习完全不同，前三年是在水绩点、竞赛等的同时自学编程，有一段没一段的，总会为完成课内的很多事而中断技术学习很长时间。而未来三年，在完全就业导向下，java这条线就是我主修的，学用、做项目就是我必须投入的。为了在研一的暑假能找到一份尚可不那么累的工作，我必须从现在开始，投入进去，可能这个学期的实习不太好找，但一定要开始打基础，奠定随时能找面试找工作的知识基础，本科毕业前，必须去尝试找实习找工作，至少得参加几十次面试积累经验，这样过渡到研究生再做一年开发后，才算好做一些。因此，我现在要做的是，明确该如何继续学习下去，需要看什么如何做，应该持有一个怎样的态度。 二、差异是如何造成的一年前的暑假基本算是我后端开发技能最熟练的时候了，那时候为完成课设和竞赛等差不多自己完整写过四五个web系统或桌面程序，到暑假给学院开发科研信息系统时我也是搭建基础环境框架、编写原始文档的主力，我的同学那时候刚接触web开发，还有很多问题需要问我。到大三以后，纠结于考研保研中很多时间不知不觉挥霍，结果保研考研没准备，项目也没怎么做，很多是在原来写的系统上修修改改，很多方面变得生疏了。而我的同学从今年年初开始准备面试和实习，每天花相当多的时间看书做笔记写算法题，逐一攻克java基础的各方面，稳扎稳打，其实半年左右，已经足够对javase、并发编程、虚拟机、框架等各方面有一个深入的认知了，同时做做项目，在校招中已经足够获得不错的offer了。可以说，一年过后，我现在不管从理论还是实操上都差了不少了。很大程度上是我过去半年的重心不在就业准备上面，但更重要的其实是我学习的方法和态度、认知不正确。我不管学什么，总是先找很多参考的资料，选择很长时间，再开始，但往往坚持不长时间就因其他事情而放弃，最终收效甚微。我可是太喜欢反思总结，而不去切实学习了。学而不思则罔，思而不学则殆。眼下最重要的就是调整认知，走入java技术体系的一个正常的学习路线。 三、方法通过与同学的交流，我认识到，对校招而言（暂时不谈社招），基础很重要，开发相关的理论也很多。 java相关的知识体系 javase 十几个方面 juc并发编程 netty rpc jvm 数据库 中间件 设计模式 计算机基础 而对于这样的基础理论的学习与实践，之前我的认知是视频教程+面经，可能很多人也是这么做的，但我确实这样做了之后感觉吸收不多，不踏实，可能是不够专注，但我同时也一直都清楚看书去学习技术，看文档才是搞开发最正的路线，再多的视频等也是给你提炼知识的，而且学习效果可能会比较差，所以这些基础理论的学习必须看书细过+实践。 考查的重心 微服务从来不是基础考核的重心，因此与其关注复杂的微服务项目，不如先学好基础的理论和做做基本全面的项目。 牛客的用处 算法题目 面经 项目 关键是什么 看的多，全面，关键是思想 具体123java这个ks路线还得走完框架，然后基础还得那么过但有些书得开始计划看了，初步决定在平板上看，博客做笔记，同时实践（需要先整下平板里以前的笔记） 书 java核心技术卷一/卷二 深入理解java虚拟机 第三版 java并发编程的艺术 java并发编程实战 网络 图解http 图解tcp 自顶向下 谢希仁 计算机基础 深入理解计算机系统 春风 1忽然意识到cs科班生应该沉下心研读些cs体系的东西","categories":[],"tags":[]},{"title":"java-qa","slug":"java-qa","date":"2021-09-05T15:12:24.000Z","updated":"2021-09-07T01:09:19.889Z","comments":true,"path":"2021/09/05/java-qa/","link":"","permalink":"https://shadowbynl.github.io/2021/09/05/java-qa/","excerpt":"","text":"可重入锁虚假唤醒COWcas compareandset","categories":[],"tags":[]},{"title":"wsl相关配置","slug":"env-wsl","date":"2021-09-03T02:35:30.000Z","updated":"2021-09-10T03:53:39.571Z","comments":true,"path":"2021/09/03/env-wsl/","link":"","permalink":"https://shadowbynl.github.io/2021/09/03/env-wsl/","excerpt":"为允许大四上人工神经网络的程序，需要配置wsl2上的cuda相关环境，现记述一下相关过程与参考","text":"为允许大四上人工神经网络的程序，需要配置wsl2上的cuda相关环境，现记述一下相关过程与参考 1 介绍 2 本机cuda相关配置 3 关于wsl2的测试 win10虚拟机的问题 修改用户密码 安装图形界面 安装MySql8.0 文件传送 备份 4 wsl2 cuda配置 4.1 官网文档（校园网打不开） 4.2 cuda相关 4.3 综上 4.4 其他方案 1 介绍https://docs.microsoft.com/zh-cn/windows/wsl/abouthttps://docs.microsoft.com/zh-cn/windows/wsl/install-win10本机在2021.4.30时安装过wsl2 ubuntu2 2 本机cuda相关配置本机目前环境为cuda11.0 gpu为rtx3060 3 关于wsl2的测试win10虚拟机的问题 这里先提一下之前在win10上安装vmware后没法开启虚拟机的问题 这里进行详细记述，简单说就是win10本身的虚拟机功能和vmware冲突参考 https://www.chenkaihua.com/2019/09/23/hyper-off/ 12345安装virtualbox后发现开启不了虚拟机，根据网上资料得知，是因为微软默认开启了hyper-v,即便是在启用或关闭Windows功能里不启用Hyper-V,也不能解决问题，需要解决的话就需要彻底关闭hyper-v功能。从知乎问题上(Windows 10 下如何彻底关闭 Hyper-V 服务？ - 张林军的回答 - 知乎)找到了最简单的解决办法。快捷键win+x,使用管理员权限打开Windows Powershell关闭：bcdedit /set hypervisorlaunchtype off开启: bcdedit /set hypervisorlaunchtype auto 修改用户密码123456789win10中WSL登录是不用密码的，当需要使用用户权限但是忘记密码的时候，可以使用如下办法以root身份登录WSL并重置密码1、以管理员身份打开 PowerShell ;2、输入命令 wsl.exe --user root ;3、命令 passwd root 修改 root 用户密码。忘记其他用户密码supasswd 用户名 参考https://www.cnblogs.com/my-blogs-for-everone/articles/13973872.htmlhttps://blog.csdn.net/qq_28120227/article/details/100677167 安装图形界面https://www.bilibili.com/video/BV1LA411n7BK?spm_id_from=333.999.0.0 12345678910sudo apt update &amp;&amp; apt upgradesudo apt install xrdpsudo apt install xfce4 xfce4-goodiessudo vim /etc/xrdp/xrdp.iniecho xfce4-session &gt; ~/.xsessionsudo vim /etc/xrdp/startwm.shsudo /etc/init.d/xrdp startip asudo apt install firefox 安装MySql8.01234567891011121314151617181920212223安装mysqlsudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev查看默认密码sudo cat /etc/mysql/debian.cnf默认方式登陆mysql -u debian-sys-maint -p // 用户名以自己的配置文件为准更改密码mysql&gt;use mysql;mysql&gt;flush privileges;mysql&gt;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;你的密码&#x27;;mysql&gt;flush privileges;重启服务sudo service mysql restart开启端口vim /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉 bind-address = 127.0.0.1允许访问use mysql;select host from user where user = &#x27;root&#x27;;update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;flush privileges; 参考https://www.jianshu.com/p/99c4baca1983https://www.cnblogs.com/xiaozhounandu/p/14497835.htmlhttps://www.cnblogs.com/patrickding/p/6435459.htmlhttps://blog.csdn.net/iiiiiilikangshuai/article/details/100905996补充vimhttps://blog.csdn.net/yang1393214887/article/details/106233991https://blog.csdn.net/weixin_40853073/article/details/81707177 文件传送https://blog.csdn.net/x356982611/article/details/80077085 备份4 wsl2 cuda配置 先说结论：总体上完成配置的要求有1 硬件2 驱动3 wsl上的专用cuda4 dev通道的windows先后参照一个去年的视频教程、多篇博客、官网文档，在20.04 18.04等上先后安了三个版本的cuda，均测试失败，暂认为是没有安装dev预览版windows所致，但若进入dev通道升级为win11，对本机系统的稳定性有影响，也不容易回退，所以暂时放弃这个方案。下面记述一下过程及参考 4.1 官网文档（校园网打不开）https://docs.nvidia.com/cuda/wsl-user-guide/index.html#rel-460-15本机安装驱动和dev通道情况下，执行以下命令 1234567$ wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin$ sudo mv cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600$ wget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda-repo-wsl-ubuntu-11-4-local_11.4.0-1_amd64.deb$ sudo dpkg -i cuda-repo-wsl-ubuntu-11-4-local_11.4.0-1_amd64.deb$ sudo apt-key add /var/cuda-repo-wsl-ubuntu-11-4-local/7fa2af80.pub$ sudo apt-get update$ sudo apt-get -y install cuda 测试 123$ cd /usr/local/cuda-11.4/samples/4_Finance/BlackScholes$ make BlackScholes$ ./BlackScholes 在本机上，测试失败，提示大意为找不到驱动/gpuCUDA error at ../../common/inc/helper_cuda.h:779 code=35(cudaErrorInsufficientDriver) &quot;cudaGetDevicehttps://developer.nvidia.com/cuda/wsl/download 4.2 cuda相关安装好没有自动配置环境变量，手动配置https://blog.csdn.net/yinxian9019/article/details/106756280/ 阿里云cuda镜像https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/https://mirrors.aliyun.com/nvidia-cuda/ubuntu2004/x86_64/ 卸载现有驱动/cuda1234$ sudo apt-get remove --purge nvidia-* $ sudo apt-get autoremovedpkg -l | grep -i nvidia https://blog.csdn.net/weixin_32820767/article/details/83818885https://qastack.cn/ubuntu/206283/how-can-i-uninstall-a-nvidia-driver-completely 几种方案，但没有参考价值（都更新太快了）https://www.bilibili.com/video/BV1FZ4y1p7Qp?spm_id_from=333.999.0.0https://blog.csdn.net/qq_20291997/article/details/106897324https://blog.csdn.net/weixin_36815313/article/details/107641262https://zhuanlan.zhihu.com/p/152533150https://zhuanlan.zhihu.com/p/122286055 各种报错NVIDIA-SMI has failed because it couldn&#39;t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.https://zhuanlan.zhihu.com/p/89714824https://blog.csdn.net/weixin_42084747/article/details/84371079?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link ubuntu卸载https://blog.csdn.net/weixin_33711641/article/details/90386490?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.control&amp;spm=1001.2101.3001.4242https://blog.csdn.net/qq_38410428/article/details/82930814 比较有价值的参考方案，但还是失败了，和官网错误类似https://blog.csdn.net/u010953692/article/details/113830046 123456wget https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/cuda-ubuntu1804.pinsudo mv cuda-ubuntu1804.pin /etc/apt/preferences.d/cuda-repository-pin-600sudo apt-key adv --fetch-keys https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/7fa2af80.pubsudo add-apt-repository &quot;deb https://mirrors.aliyun.com/nvidia-cuda/ubuntu1804/x86_64/ /&quot;sudo apt-get updatesudo apt-get -y install cuda 4.3 综上基本可以判断是没有用dev通道的问题，参考一篇博客的评论（五月左右）提到切换到dev通道按官网方式就成功了，但这样风险有些大，所以不再尝试。https://zhuanlan.zhihu.com/p/386362341 极不容易回退，也不稳定 4.4 其他方案1.本机上是有完整可用的cuda+opencv的环境的，就看代码怎么改了。。2.先下数据集，数据集官方的下载速度很慢（校园网），一般找不到其他的就得耗流量了。。 hmdb51https://www.pianshen.com/article/1325689931/https://serre-lab.clps.brown.edu/resource/hmdb-a-large-human-motion-database/ucf101https://blog.csdn.net/weixin_40162095/article/details/111870161 其他https://blog.csdn.net/alec1987/article/details/69388699?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.no_search_link","categories":[],"tags":[]},{"title":"输入输出","slug":"dsa-io","date":"2021-09-01T09:52:41.000Z","updated":"2021-09-01T09:56:53.571Z","comments":true,"path":"2021/09/01/dsa-io/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/dsa-io/","excerpt":"","text":"c++https://www.cnblogs.com/Mary-Sue/p/8678462.html java","categories":[],"tags":[]},{"title":"信息检索系统","slug":"ds-xxjsxt","date":"2021-09-01T06:00:27.000Z","updated":"2021-10-04T12:31:20.405Z","comments":true,"path":"2021/09/01/ds-xxjsxt/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/ds-xxjsxt/","excerpt":"该篇是为完成大四上信息检索系统作业，对其基础理论和相关参考进行学习的一个随记，并记录完成作业的思路过程。","text":"该篇是为完成大四上信息检索系统作业，对其基础理论和相关参考进行学习的一个随记，并记录完成作业的思路过程。 理论部分jdnlp的课件：信息检索及倒排技术 信息检索 Information Retrieval(IR)：从大规模非结构化数据（通常是文本）的集合（通常保存在计算机上）中找出满足用户信息需求的资料（通常是文档） 的过程。作为一门学科，是研究信息的获取(acquisition)、表示(representation)、 存储(storage)、组织(organization)和访问(access)的一门学问。 信息检索的历史 123456789101112131415# 计算机出现以前目录--索引（从词和概念指向相关信息或文档的指针）手工方式建立索引：如词典的拼音检字 部首笔画检字# 1948第一次出现信息检索的术语# 60s-70s为文献摘要建立文本检索系统产生了布尔模型、向量空间模型和概率检索模型的概念# 80s商用较大规模数据库检索系统# 90s网络搜索工具 web搜索引擎# 2000信息抽取 问答系统 演化出了很多nlp任务，不仅仅是搜索引擎 信息检索例子 倒排索引 布尔检索模型 现代信息检索信息检索：实现和评价搜索引擎相较上本书，这本书更直接地介绍了基本概念 实现部分 由于是作业驱动，没有必要先把概念全部先看一遍，不理解的地方回看即可 lzw报告理解复现两段程序都比较清晰容易理解，算法并不复杂，繁琐的还是文件处理1 tf-idf 英文的话实现很简单 但中文就要考虑分词了，所以会更加负责2 倒排索引 需要自己实现b+树/前缀树 因此如果使用java实现的话，首先是要解决文本处理的问题 其他参考程序1 拼写检查功能只实现了一半2 中文分词3 commonsio maven项目中绝对路径4 中文分词 实现 10.4 下午六点 基本把三份代码完成了 完成情况 tf-idf 1234561.完成了中文和英文两种计算2.对中文2.1 前缀树存储词库2.2 分词工具类：前缀树初始化 文本预处理 分词2.3 测试类 计算父类 中文处理子类3.对英文 倒排索引 121.主要是修改了前缀树的数据结构 改动不多2.只实现了对英文单文本的 逐行处理 记录一个单词在一个文本中的行号，列好 不处理行尾一个单词未结束的情况 爬虫 12341.为方便1测试，写个简单的爬取中文文本的方法2.原定计划是中文+英文 但没必要就不写了3.搜过一些xpath解析的方法 dom4j jsoupxpath等等 但都不能利用xpath表达式最后还是老老实实用jsoup解析 + 连接池 问题 12程序1中的中文处理中无论如何无法去掉部分词语的空格，多处处理无法过滤，暂时留着这个问题程序2中仅限处理约定的情况 一些问题与参考java解析处理相关1.java去除空格符的方法https://blog.csdn.net/weixin_33851177/article/details/92001703 12345678910111213141516JAVA中去掉空格 1. String.trim() trim()是去掉首尾空格 2.str.replaceAll(&quot; &quot;, &quot;&quot;); 去掉所有空格，包括首尾、中间 String str = &quot; hell o &quot;; String str2 = str.replaceAll(&quot; &quot;, &quot;&quot;); System.out.println(str2); 3.或者replaceAll(&quot; +&quot;,&quot;&quot;); 去掉所有空格 4.str = .replaceAll(&quot;\\\\s*&quot;, &quot;&quot;); 可以替换大部分空白字符， 不限于空格 \\s 可以匹配空格、制表符、换页符等空白字符的其中任意一个 2.notepad++查看所有字符（没用）https://jingyan.baidu.com/article/ce4366494960083773afd32e.html3 java xpath解析方法https://blog.csdn.net/weixin_42022555/article/details/82775916https://www.cnblogs.com/wanghaomiao/p/4899355.htmlhttps://blog.csdn.net/baidu_36336788/article/details/89875926?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link4 java格式化输出方法https://blog.csdn.net/qq_44111805/article/details/1128505505 TreeMap按照value进行排序https://blog.csdn.net/liuxiao723846/article/details/50454622 1234567891011121314151617181920public static void sortByValue() &#123; Map&lt;String,String&gt; map = new TreeMap&lt;String,String&gt;(); map.put(&quot;a&quot;, &quot;dddd&quot;); map.put(&quot;d&quot;, &quot;aaaa&quot;); map.put(&quot;b&quot;, &quot;cccc&quot;); map.put(&quot;c&quot;, &quot;bbbb&quot;); List&lt;Entry&lt;String, String&gt;&gt; list = new ArrayList&lt;Entry&lt;String, String&gt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() &#123; //升序排序 public int compare(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2) &#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for (Entry&lt;String, String&gt; e: list) &#123; System.out.println(e.getKey()+&quot;:&quot;+e.getValue()); &#125; &#125; 6 Java遍历Map的4种方式https://blog.csdn.net/chpllp/article/details/109073224 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; // 循环遍历Map的4中方法 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(1, 2); // 1. entrySet遍历，在键和值都需要时使用（最常用） for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key = &quot; + entry.getKey() + &quot;, value = &quot; + entry.getValue()); &#125; // 2. 通过keySet或values来实现遍历,性能略低于第一种方式 // 遍历map中的键 for (Integer key : map.keySet()) &#123; System.out.println(&quot;key = &quot; + key); &#125; // 遍历map中的值 for (Integer value : map.values()) &#123; System.out.println(&quot;key = &quot; + value); &#125; // 3. 使用Iterator遍历 Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(&quot;key = &quot; + entry.getKey() + &quot;, value = &quot; + entry.getValue()); &#125; // 4. java8 Lambda // java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value， // 不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式 map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot;:&quot; + value); &#125;); &#125; 7 java列出目录文件https://blog.csdn.net/hlanting/article/details/92854033?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.no_search_link 12345678910111213141516package com.jn.test; import java.io.File; public class ListFile2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub File file=new File(&quot;E:\\\\&quot;); for(File temp:file.listFiles())&#123; if(temp.isDirectory())&#123; System.out.println(temp.toString()); &#125; &#125; &#125;&#125; 8 commons-io的常用方法https://blog.csdn.net/backbug/article/details/99572931?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_linkhttps://blog.csdn.net/weixin_44035017/article/details/102526767https://blog.csdn.net/weixin_44035017/article/details/1025267679 Java之StringUtils的常用方法https://blog.csdn.net/weixin_42290280/article/details/8259116110 java正则https://www.runoob.com/java/java-regular-expressions.html11 Java删除/清除/过滤标点（所有中英文标点）的正则表达式https://blog.csdn.net/yuan882696yan/article/details/52276210 123(1) s.replaceAll( &quot;\\\\p&#123;Punct&#125;&quot;, &quot;&quot; ); (2) s.replaceAll(&quot;\\\\pP&quot; , &quot;&quot;); (3) s.replaceAll(&quot;\\\\p&#123;P&#125;&quot; , &quot;&quot;); 12 commons-lang 常用apishttps://max.book118.com/html/2017/0325/96858094.shtm13 中文分词方法https://blog.csdn.net/weixin_42242538/article/details/84754491 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697中文分词通俗来讲，中文分词是指将一句中文句子中的所有中文词汇相互分隔开来。它是文本挖掘的基础，有着十分广阔的应用前景。下面，我们来看一看对于这个技术的简单实现。算法对于中文分词技术的实现，有许多算法可以完成，目前大致可以把算法分为三大类：基于字符串匹配的分词方法；基于理解的分词方法；基于统计的分词方法。其中，基于字符串匹配的分词方法是把中文句子按照一定的策略将待分析的汉字串与已知且足够大的中文词典库进行比对，从而达到分词效果。而我们通常使用最多的分词策略，大致有三类，正向最大匹配法，逆向最大匹配法和最少切分法。基于理解的分词方法是指让计算机模拟人对句子的理解进行分词。基于统计的分词方法是指找出上下文中出现较多的汉字组合，将这些组合视为词汇，代入到原文中进行分词。在这里，我们就使用字符串匹配的分词方法，利用逆向最大匹配的策略，对中文句子进行简单的分词。算法思路逆向最大匹配法大致思想为：将整个字符串作为一个“词组”带入到词典中进行比对，若不成功，删除第一个字符，继续进行如此操作，直到成功或者只剩下最后一个字，再把结果放入一个字符串的数组中，最后删除原句中的结果，继续上面的操作。下面我将用一个例子解释这个操作：原句：今晚月亮真漂亮啊词典：“今晚”，“月亮”，“漂亮”第一次代入：今晚月亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）删除首字符：晚月亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）删除首字符：月亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）删除首字符：亮真漂亮啊（在词典中没有该词汇，删除首字符继续比对）…删除首字符：啊（在词典中没有该词汇，只剩下一个字，放入结果数组，并删除位于句尾的最后这个字，进行第二次代入）第二次代入：今晚月亮真漂亮（在词典中没有该词汇，删除首字符继续比对）…删除首字符：漂亮（在词典中找到词汇“漂亮”，放入结果数组，并删除位于句尾的结果“漂亮”，进行第三次代入）…————————————————版权声明：本文为CSDN博主「birches」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_42242538/article/details/84754491public class secondwork &#123; public static void main(String args[]) &#123; String[] cs = &#123;&quot;你好&quot;,&quot;请问&quot;,&quot;什么&quot;,&quot;名字&quot;&#125;;//词典 String a = &quot;你好！请问你叫什么名字？&quot;; System.out.print(&quot;原句：&quot;); System.out.print(a + &#x27;\\n&#x27;); System.out.print(&quot;拆分后为：&quot;); String[] cs2 = new String[100]; //结果数组 int jud=0;//找到匹配字符串与否的标志 int j=0; String temp=null;//初始化临时字符串 for(;a.length()&gt;0;) &#123; for(int i = 0;i&lt;a.length();i++) &#123; temp = a.substring(i);//每次截取掉首个字符 if(isin(cs,temp) == true)//如果目标字符串在数组中 &#123; cs2[j] = temp; jud = 1; int number = temp.length(); a = a.substring(0,a.length()-number); &#125; &#125; if(jud == 0)//没有找到匹配字符串 &#123; cs2[j] = a.substring(a.length()-1,a.length());//将最后一个元素放在cs2里面 a = a.substring(0, a.length()-1);//截掉最后一个元素继续循环。 &#125; jud = 0; j++; &#125; for(;j &gt;= 0;j--) &#123; if(cs2[j] != null) System.out.print(cs2[j]+&quot; &quot;); &#125; &#125; /* * 下面为判断字符串是否在词典中的函数方法 */ static public boolean isin(String[] cs,String temp)//判断目标字符串是否在对比字符串数组中 &#123; int i; for(i = 0;i&lt;cs.length;) &#123; if(temp.equals(cs[i])) i = cs.length+1; else i++; &#125; if(i == cs.length+1) return true; else return false; &#125;&#125; 相关资源1 英文文本http://www.enread.com/news/life/114823.htmlhttp://www.enread.com/2 小说https://www.tycqxs.com/57_57672/21597158.html3 python splithttps://www.jb51.net/article/63592.htm4 敏感词过滤方法https://blog.csdn.net/qq_42956993/article/details/1094915565 用于存储中文字符的字典树https://blog.csdn.net/ccwlisha/article/details/895254556 maven项目就别想用相对路径读写文件了7 java实现b+树8 中文分词工具https://search.gitee.com/?q=%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D&amp;skin=rec&amp;type=repository&amp;pageno=2https://blog.csdn.net/qq_41154871/article/details/893755879 中文文本纠错算法实现https://blog.csdn.net/demm868/article/details/107096661","categories":[{"name":"大四","slug":"大四","permalink":"https://shadowbynl.github.io/categories/%E5%A4%A7%E5%9B%9B/"}],"tags":[]},{"title":"网络安全","slug":"ds-net","date":"2021-09-01T01:55:32.000Z","updated":"2021-10-01T02:27:01.037Z","comments":true,"path":"2021/09/01/ds-net/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/ds-net/","excerpt":"大四上学期网络安全选修课课程内容","text":"大四上学期网络安全选修课课程内容 1 概述12345678910111213141516171. TCP连接为什么需要三次握手？两次握手是否可以？答：为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。举例表述：防止失效的连接请求报文段被服务端接收，从而产生错误。 首先需要解释失效的连接请求是什么：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是失效的连接请求。假如建立连接只需两次握手，对于客户端来说并没有太大的变化。但仍然需要获得服务端的应答后才进入ESTABLISHED（建立）状态。而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。https://blog.csdn.net/lengxiao1993/article/details/82771768?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.essearch_pc_relevanthttps://blog.csdn.net/AntdonYu/article/details/1037655532. 什么是TCP半开连接？客户端向服务端发送SYN建立连接请求，服务端响应SYN-ACK建立连接，即为TCP半开连接。3. SYN Flood属于哪种攻击？SYN Flood (SYN泛洪) 是种典型的DoS (Denial of Service，拒绝服务) 攻击，效果是服务器TCP连接资源耗尽，停止响应正常的TCP连接请求。https://blog.csdn.net/chenyulancn/article/details/788325974.什么是字典攻击？在破解密码或密钥时，逐一尝试用户自定义词典中的可能密码（单词或短语）的攻击方式。与暴力破解的区别是，暴力破解会逐一尝试所有可能的组合密码，而字典式攻击会使用一个预先定义好的单词列表（可能的密码）。5. ARP欺骗的原理是什么？ARP(Address Resolution Protocol，地址解析协议)是一个位于TCP/IP协议栈中的低层协议，负责将某个IP地址解析成对应的MAC地址。从影响网络连接通畅的方式来看，ARP欺骗分为二种，一种是对路由器ARP表的欺骗;另一种是对内网PC的网关欺骗。第一种ARP欺骗的原理是——截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的路由器途径上网。在PC看来，就是上不了网了，“网络掉线了”。https://www.xuexila.com/luyouqi/120948.htmlhttps://jingyan.baidu.com/article/fea4511a7a2020f7bb91252a.html 2 密码体制与技术12345678910111213141516171.三重DES为什么是加密-解密-加密三重DES(triple-des)是为了增加DES的强度,将DES重复3次所得到的一种密码算法,也称为TDEA(Triple Date Encryption Algorithm),通常缩写为3DES。三重DES并不是进行三次DES加密(加密→加密→加密),而是加密→解密→加密的过程,目的是为了让三重DES能够兼容普通的DES。当三重DES中所有的密钥都相同时,三重DES也就等同于普通的DES了。这是因为在前两步加密→解密之后,得到的就是最初的明文。因此,以前用DES加密的密文,就可以通过这种方式用三重DES来进行解密。也就是说,三重DES对DES具备向下兼容性。2.密钥是不是越长越好密码体制的安全性，其并不是仅仅由密钥的长度决定的，但是在同一个密码体制中，越长的密钥意味着密钥空间越大，敌手通过暴力穷举的方式得到真实密钥的情况更加难以发生，在这种意义上讲，同一种密码体制中，体制的安全性与密钥的长度相关。3.对称密码的优点是什么以及缺点是什么优点算法简单、速度快、适合加密大量数据缺点密钥管理方面如何安全的共享秘密密钥，不可能与你未曾谋面的人通信每对通信者间都需要一个不同的密钥，当用户量增大时密钥空间急剧增大。没有解决不可抵赖问题没有解决不可抵赖问题 参考https://www.cnblogs.com/songwenlong/p/5944139.htmlhttps://www.sohu.com/a/278245376_100245441https://www.zhihu.com/question/365630892 matlab图像置乱参考https://blog.csdn.net/qq_33472557/article/details/79668662https://ww2.mathworks.cn/help/matlab/ref/rgb2gray.htmlhttps://www.cnblogs.com/wxl845235800/p/7216785.htmlhttps://jingyan.baidu.com/article/ed15cb1b3e94da5be269810f.htmlhttps://ww2.mathworks.cn/help/matlab/ref/imread.html matlab 图片相关的问题 imshow image https://tieba.baidu.com/p/6492190181图片分量提取 https://jingyan.baidu.com/article/456c463b41de5f0a5831448e.htmllinux移动文件 https://www.cnblogs.com/aiyr/p/7395738.htmlubuntu创建用户https://blog.csdn.net/taolusi/article/details/81304057“const char *” 类型的实参与 “char *” 类型的形参不兼容错误的解决方法https://blog.csdn.net/qinshiyang/article/details/83213664cvwaitkey未定义标识符https://blog.csdn.net/baidu_38172402/article/details/87982268hhu推免 https://cies.hhu.edu.cn/2020/0924/c4093a213007/page.pspimresizehttps://baike.baidu.com/item/imresize/9948188?fr=aladdinmatlab输入输出https://blog.csdn.net/yewuzhitou/article/details/81906379matlab 技巧 figurehttps://blog.csdn.net/hyz301/article/details/64130405matlab将灰度图转化为彩图https://blog.csdn.net/felix_zhangshou/article/details/88915229?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&amp;spm=1001.2101.3001.4242http://blog.sina.com.cn/s/blog_a5fdbf010101hhyk.html置乱https://blog.csdn.net/qq_25884463/article/details/52463788https://wenku.baidu.com/view/7c3c84f2580102020740be1e650e52ea5418ce81.html?rec_flag=default&amp;fr=Recommend_RelativeDoc-60354,60273,60321,40251-kpdrec_doc_pc_view-203b4e017dd5360cba1aa8114431b90d6d85895a&amp;sxts=1631104444164https://wenku.baidu.com/view/203b4e017dd5360cba1aa8114431b90d6d85895a.htmlhttps://blog.csdn.net/qq_33472557/article/details/79668662 非对称加密技术组合A–B1 会话密钥加密明文2 明文哈希–数字签名–A私钥加密3 B公钥加密会话密钥B–A1 B私钥解密会话密钥2 获取明文3 明文哈希–数字签名+A公钥–比较 3 PKI技术123456中间人攻击数字证书 权威机构CA内容 格式 数字签名 CA的私钥对哈希过的数字证书进行签名根证书通信实例 3.1 数字证书 引入 安全功能：认证 授权 保密性（防偷听） 完整性（防篡改）防抵赖网络通信的四个安全要素如何解决安全要素 12345信任类型 现实世界 数字世界身份认证 身份证、护照、信用卡、驾照 数字证书、数字签名完 整 性 签名、支票、第三方证明 数字签名或MAC保 密 性 保险箱、信封、警卫、密藏 对称加密或公钥加密不可否认性 签名、挂号信、公证、邮戳 数字签名 PKI 公钥基础设施 数字证书 数字证书的提出A需要用B的公钥加密信息，那么在发送前，需要获取B公钥，一种是B发给A，一种是提供一个公共访问地址若有人假冒B的公钥发消息，这样能获得A的信息，中间人攻击 数字证书 用户身份+公钥 权威机构CA证实身份 身份+公钥–证书 数字证书的内容名称 序列号 签发者 发布时间 有效时间 公钥 数字证书格式–标准X.509如何保证数字证书的不可篡改性1 数字签名 对数字证书内容进行哈希后，再用CA的私钥进行数字签名2 CA对证书签名后，大家如何验证这个签名用证书发布机构的公钥3 如何获得CA的公钥CA给自己颁发的证书–根证书–包含CA公钥4 如何获取根证书 系统安装时已有一些默认安装的根证书例 签名算法 sha1RSA 哈希算法 sha1 公钥加密算法 rsa 3.2 数字证书安全通信实例1 客户向服务端发送通信请求2 服务器给客户自己的数字证书 有公钥加密信息 私钥服务器持有3 客户端收到服务端的证书，对其进行验证（是否过期–&gt;根证书（公钥）解密 哈希–&gt;比较–&gt;是否是CA颁发证书，是否是指定通信对象–&gt;取出公钥）4 身份认证 客户给服务端一个随机字符串，让其用私钥加密 服务器把结果返回 客户用公钥解密，说明匹配了5 验证服务器身份后，客户生成一个对称加密算法和密钥，用于后面通信的加密和解密（公钥加密后发送给服务器） 后续双方可以使用对称加密算法来加密解密通信内容问题1：服务器随便加密一个来路不明的字符串是不安全的问题2：黑客可以扰乱通信过程 重发 3.3 PKI的组成组成：证书持有者证书认证机构CA：必须有一个可信机构对一个主体公钥进行公证（签发证书 证书管理 密钥管理 证书状态查询）证书注册机构RA：分担CA的任务证书注册机构RA：辅助证书存储和发布系统：负责证书的分发（证书库：证书的集中存放）证书应用系统：应用接口和基于此的应用服务 证书撤销： 在有效期内由于某些原因需要废除 证书撤销列表CRL 3.4 PKI的应用查看数字证书Internet选项–内容–证书 国内外CA数字证书的申请证书的获得和安装（安装根证书 表格申请 下载数字证书安装） 数字证书应用操作实例添加数字签名 4 VPN技术4.1 VPN概述为什么需要VPN–VPN产生的原因总公司和分公司间有大量的数据要传输1 专线费用高 灵活性差2 若不使用任何技术措施在公共网上传输数据端到端数据安全问题（拨入段 外部段 内部段）风险：（1）拨入段 用户明文到ISP（攻击者和ISP存在问题）（2）因特网上数据泄露的风险（逐段加密也不能防范恶意的ISP，路由器上肯定会解密，且ISP可能伪造网关）（3）安全网关中数据泄露的风险（4）内部网中数据泄露的风险 需要一个综合一致的解决方案，提供端到端的、逐段的数据保护 VPN的定义和分类虚拟专用网VPN 在公共网络中建立的安全网络连接 采用了专有的协议虚拟 不再需要拥有实际的专线专用 VPN能做什么–功能数据机密性、完整性保护、身份认证数据完整性：VPN网关hash后摘要+数据包加密–解密数据包-&gt;hash-&gt;比对摘要数据认证：签名（数据包hash后摘要-&gt;私钥签名DSS，附在数据包后发送–&gt;取出DSS，公钥解密–原始数据包hash–比对 VPN的分类根据网络类型差异，分为两种类型Client-LAN 远程访问 客户端到网关（需要在LAN中加一个VPN设备）LAN-LAN 总部到分支机构 远程办公室（不同的局域网之间，每个LAN中都需要VPN设备） 4.2 VPN原理实现VPN的关键技术1 安全隧道技术一种封装，将一种协议封装在另一种协议中传输隧道协议包括三种：乘客 封装 运载 隧道技术和隧道协议 隧道协议类型 分类依据：被封装的数据在OSI/RM的层次二层隧道协议：封装数据链路层的数据包 构建远程访问型的VPN L2F PPTP L2TP三层隧道协议：网络层协议封装到隧道协议中传输 应用于构建LAN-LAN型的VPN 第二层隧道协议 PPTP 点到点 第一个广泛使用建立VPN的协议 PPP协议的问题 工作在专线上才能保证安全性 但专线贵 希望PPP工作在Internet上而不是专线上，但PPP是点对点的，只是一个链路层协议 PPTP 点对点隧道 还是基于PPP的 接入集中器AC（客户端-因特网间）：封装数据包，加上IP地址等可以路由的部分 乘客PPP 封装GRE 运载IP 第二层隧道协议 L2TP 以PPTP和L2F为基础，结合了两者的优点 工业标准 PPP PPTP L2TP比较 第三层隧道协议 IP–&gt;IPSec 传输模式只加密数据，隧道模式加密整个IP包，安全性更高。隧道模式开销更大 AH协议 ESP协议 认证+加密 IKE协议 安全地交换一套密钥 SA 安全联盟 SA和DH交换算法 DH原理 如何获得一致的密钥 且防止攻击者获得密钥的拷贝 混色原理正向很容易，逆向很难（单向函数）1 相同的初始颜色2 各有一个私有颜色 混合之后给对方 再与私有混合后即可获得相同颜色3 攻击者可能获得两者的混合颜色 但无法获取两者的私有颜色对一个数字过程 找一个单向函数数学原理 IKE密钥交换两个阶段","categories":[{"name":"大四","slug":"大四","permalink":"https://shadowbynl.github.io/categories/%E5%A4%A7%E5%9B%9B/"}],"tags":[]},{"title":"排序","slug":"dsa-sort","date":"2021-09-01T01:05:58.000Z","updated":"2021-09-01T03:52:31.934Z","comments":true,"path":"2021/09/01/dsa-sort/","link":"","permalink":"https://shadowbynl.github.io/2021/09/01/dsa-sort/","excerpt":"排序相关算法与问题","text":"排序相关算法与问题 排序算法模板快速排序1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int a[100010];void quick_sort(int n[], int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int p = n[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while (i &lt; j) &#123; while(n[++i] &lt; p); while(n[--j] &gt; p); if (i &lt; j) &#123; swap(n[i], n[j]); &#125; &#125; quick_sort(n, l, j); quick_sort(n, j + 1, r);&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; quick_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125; 123456789101112131415161718192021222324252627public class TestSort &#123; public static void main(String[] args) &#123; int[] nums = &#123;22, 34, 1, 2, 0, 44, 553, 2, 3&#125;; quickSort(nums, 0, nums.length - 1); for (int x : nums) &#123; System.out.println(x); &#125; &#125; public static void quickSort(int[] nums, int l, int r) &#123; if (l &gt;= r) return; int xi = (int)(Math.random() * (r - l) + l); int x = nums[xi]; int i = l - 1, j = r + 1; while (i &lt; j) &#123; while (nums[++i] &lt; x); while (nums[--j] &gt; x); if (i &lt; j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125; &#125; quickSort(nums, l, j); quickSort(nums, j + 1, r); &#125;&#125; 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N];int b[N];void merge_sort(int a[], int l, int r) &#123; if (l &gt;= r) &#123; return; &#125; int m = l + r &gt;&gt; 1; merge_sort(a, l, m); merge_sort(a, m + 1, r); int k = 0; int i = l, j = m + 1; while (i &lt;= m &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) &#123; b[k++] = a[i++]; &#125; else &#123; b[k++] = a[j++]; &#125; &#125; while (i &lt;= m) &#123; b[k++] = a[i++]; &#125; while (j &lt;= r) &#123; b[k++] = a[j++]; &#125; for (int i = 0; i &lt; k; i++) &#123; a[l + i] = b[i]; &#125;&#125;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; merge_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125; 排序相关问题第k个数（快速排序）acwing786 leetcode215https://www.acwing.com/problem/content/788/https://www.acwing.com/solution/content/63587/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 时间复杂度：O(n), 空间复杂度: 递归栈空间O(logn)// y总 代码 没有 随机选取 x , 导致 用时比较长 44ms. 随机后 4ms// 如果 x 每次都选 nums[l] 或 nums[r], 碰到 升序或降序的 极端样例, 时间O(n^2),, 用时会很久// 而且 nums[l] 和 nums[r] 的代码边界不一样, 容易出错, 建议选 nums[l + r &gt;&gt; 1]// 选取 nums[l] 的 用时 在 40ms 左右, 选取 nums[r]需要修改一下边界情况, 没有改, 应该也40ms左右// 选取 nums[l + r &gt;&gt; 1] 跟 随机选取 nums[rand() % (r - l + 1) + l] 时间差不多, 在 4ms 左右class Solution &#123;public: int quick_select(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123; if (l &gt;= r) return nums[l]; // int i = l - 1, j = r + 1, x = nums[l + r &gt;&gt; 1]; // 选取 nums[l], 极端样例 时间会很久 int x = nums[rand() % (r - l + 1) + l], i = l - 1, j = r + 1; // 随机选取 while (i &lt; j) &#123; do i ++ ; while (nums[i] &gt; x); do j -- ; while (nums[j] &lt; x); if (i &lt; j) swap(nums[i], nums[j]); &#125; if (k &lt;= j - l + 1) return quick_select(nums, l, j, k); else return quick_select(nums, j + 1, r, k - (j - l + 1)); &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; srand(time(0)); // 随机种子 return quick_select(nums, 0, nums.size() - 1, k); &#125;作者：yxc链接：https://www.acwing.com/video/1589/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。// 时间复杂度：O(n), 空间复杂度: O(1)// y总 代码 去掉递归栈空间, 用 while 循环, 就不用 递归栈空间 了.// 原来的 递归 只是 相同的代码, 只不过 递归时 递归的参数 区间端点值 l,r 以及 k变了// 这里 while 每次循环 也是 用 相同的代码, 只不过 是 每次循环之后 将 l,r 以及 k 更新class Solution &#123;public: int quick_select(vector&lt;int&gt;&amp; nums, int l, int r, int k) &#123; while(true) &#123; if (l == r) return nums[l]; // int i = l - 1, j = r + 1, x = nums[l + r &gt;&gt; 1]; // 选取 nums[l], 极端样例 时间会很久 int x = nums[rand() % (r - l + 1) + l], i = l - 1, j = r + 1; // 随机选取 while (i &lt; j) &#123; do i ++ ; while (nums[i] &gt; x); do j -- ; while (nums[j] &lt; x); if (i &lt; j) swap(nums[i], nums[j]); &#125; // 将 递归 的 参数l,r,k变化 改为 while 循环中 l,r,k 更新, 省去递归栈空间 // if (k &lt;= j - l + 1) return quick_select(nums, l, j, k); if (k &lt;= j - l + 1) r = j; // else return quick_select(nums, j + 1, r, k - (j - l + 1)); else k = k - (j - l + 1), l = j + 1; // 注意 k更新用到 l, 所以 l 更新应该在 k更新之后 &#125; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; srand(time(0)); // 随机种子 return quick_select(nums, 0, nums.size() - 1, k); &#125;&#125;;作者：yxc链接：https://www.acwing.com/video/1589/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 注意 c++的rand()函数https://blog.csdn.net/cmm0401/article/details/54599083 123456789101112131415161718192021222324252627282930313233343536373839404142C++中rand() 函数的用法1、rand()不需要参数，它会返回一个从0到最大随机数的任意整数，最大随机数的大小通常是固定的一个大整数。2、如果你要产生0~99这100个整数中的一个随机整数，可以表达为：int num = rand() % 100; 这样，num的值就是一个0~99中的一个随机数了。3、如果要产生1~100，则是这样：int num = rand() % 100 + 1; 4、总结来说，可以表示为：int num = rand() % n +a; 其中的a是起始值，n-1+a是终止值，n是整数的范围。5、一般性：rand() % (b-a+1)+ a ; 就表示 a~b 之间的一个随机整数。6、若要产生0~1之间的小数，则可以先取得0~10的整数，然后均除以10即可得到“随机到十分位”的10个随机小数。 若要得到“随机到百分位”的随机小数，则需要先得到0~100的10个整数，然后均除以100，其它情况依 此类推。7、通常rand()产生的随机数在每次运行的时候都是与上一次相同的，这样是为了便于程序的调试。 若要产生每次不同的随机数，则可以使用srand( seed )函数进行产生随机化种子，随着seed的不同，就能够产生 不同的随机数。8、还可以包含time.h头文件，然后使用srand(time(0))来使用当前时间使随机数发生器随机化，这样就可以保证每两 次运行时可以得到不同的随机数序列，同时这要求程序的两次运行的间隔超过1秒。9、举例如下：rand（产生随机数）表头文件: #include&lt;stdlib.h&gt;定义函数 :int rand(void)函数说明 :因为rand() 的内部实现是用线性同余法做的，它不是真的随机数，只不过是因为其周期特别长，所以有一定的范围里可看成是随机的，rand() 会返回一随机数值，范围在 0 至 RAND_MAX 间。在调用此函数产生随机数前，必须先利用 srand()设置好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为 1。rand()产生的是假随机数字，每次执行时是相同的。若要不同,以不同的值来初始化它.初始化的函数就是 srand()。返回值:返回 0 至 RAND_MAX 之间的随机整数值，RAND_MAX 的范围最少是在 32767 之间（int），即双字节（16位数）。若用unsigned int 双字节是 65535，四字节是 4294967295 的整数范围。0~RAND_MAX 每个数字被选中的机率是相同的。 java随机数https://www.cnblogs.com/blogxjc/p/9687297.html","categories":[{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"字符串","slug":"dsa-string","date":"2021-08-31T07:13:08.000Z","updated":"2021-09-01T03:52:43.860Z","comments":true,"path":"2021/08/31/dsa-string/","link":"","permalink":"https://shadowbynl.github.io/2021/08/31/dsa-string/","excerpt":"对字符串相关问题进行记录","text":"对字符串相关问题进行记录 字符串匹配朴素模式匹配 KMP算法 相关题目leetcode214https://leetcode-cn.com/problems/shortest-palindrome/ 1234567891011121314151617181920212223242526/*给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。0 &lt;= s.length &lt;= 5 * 10^4s 仅由小写英文字母组成*/class Solution &#123;public: string shortestPalindrome(string s) &#123; string t(s.rbegin(), s.rend()); int n = s.size(); s = s + &#x27;#&#x27; + t; vector&lt;int&gt; ne(n * 2 + 2); ne[0] = -1; int i = 0, k = -1; while (i &lt; s.size()) &#123; while (k &gt;= 0 &amp;&amp; s[i] != s[k]) k = ne[k]; i++; k++; ne[i] = k; //cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ne[i] &lt;&lt; &quot; &quot; &lt;&lt; s[i]&lt;&lt; endl; &#125; int len = ne[2 * n + 1]; string left = s.substr(0, len), right = s.substr(len, n - len); return string(right.rbegin(), right.rend()) + left + right; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"南软服务端开发","slug":"njuse-sever-development","date":"2021-08-30T15:42:34.000Z","updated":"2021-09-01T03:53:00.090Z","comments":true,"path":"2021/08/30/njuse-sever-development/","link":"","permalink":"https://shadowbynl.github.io/2021/08/30/njuse-sever-development/","excerpt":"南大软件本科服务端开发课程笔记","text":"南大软件本科服务端开发课程笔记","categories":[],"tags":[]},{"title":"javase之一","slug":"java-base-00","date":"2021-08-30T08:47:11.000Z","updated":"2021-09-07T12:57:43.160Z","comments":true,"path":"2021/08/30/java-base-00/","link":"","permalink":"https://shadowbynl.github.io/2021/08/30/java-base-00/","excerpt":"","text":"为重新巩固java基础，个人决定从javase开始到微服务等过一遍java技术体系。经过几天比对，发现很多培训课程为顾及学生讲的很繁琐，b站ks的视频相对较简洁。虽然可能存在不全、不准确、资料不太够的问题，但也有很大的学习参考价值。因此从本篇开始将按照ks提供的顺序，看视频、敲代码，并在这些文档中做些笔记。https://gitee.com/kuangstudy/kuang_livenote?_from=gitee_search","categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://shadowbynl.github.io/tags/javase/"}]},{"title":"idea学习","slug":"idea-study","date":"2021-08-28T15:01:52.000Z","updated":"2021-08-30T02:09:13.147Z","comments":true,"path":"2021/08/28/idea-study/","link":"","permalink":"https://shadowbynl.github.io/2021/08/28/idea-study/","excerpt":"用了idea也快两年了，在此系统看一下idea专门的教程","text":"用了idea也快两年了，在此系统看一下idea专门的教程 模板参考先前的配置，具体配置方法参考下面的图 使新建类默认有类注释123456/*** @Auther: nlby* @Date: $&#123;DATE&#125; $&#123;TIME&#125; * @Description: $&#123;PACKAGE_NAME&#125;* @version: 1.0*/ 自定义类注释、方法注释模板1234567891011121314151617181920212223/** * * @name $NAME$ * @author nlby * @date $DATE$ */ /** * @author nlby * @description $description$ * @updateTime $date$ $TIME$ $param$ $return$ * @throws $throws$ */ 参数groovyScript(&quot;def result=&#x27;&#x27;; def stop=false; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); if (params.size()==1 &amp;&amp; (params[0]==null || params[0]==&#x27;null&#x27; || params[0]==&#x27;&#x27;)) &#123; stop=true; &#125;; if(!stop) &#123; for(i=0; i &lt; params.size(); i++) &#123;result +=((i==0) ? &#x27;\\\\r\\\\n&#x27; : &#x27;&#x27;) + ((i &lt; params.size() - 1) ? &#x27; * @param: &#x27; + params[i] + &#x27;\\\\r\\\\n&#x27; : &#x27; * @param: &#x27; + params[i] + &#x27;&#x27;)&#125;; &#125;; return result;&quot;, methodParameters())groovyScript(&quot;def result=&#x27;&#x27;; def stop=false; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); if (params.size()==1 &amp;&amp; (params[0]==null || params[0]==&#x27;null&#x27; || params[0]==&#x27;&#x27;)) &#123; stop=true; &#125;; if(!stop) &#123; for(i=0; i &lt; params.size(); i++) &#123;result +=((i==0) ? &#x27;\\\\r\\\\n&#x27; : &#x27;&#x27;) + ((i &lt; params.size() - 1) ? &#x27; * @param: &#x27; + params[i] + &#x27;\\\\r\\\\n&#x27; : &#x27; * @param: &#x27; + params[i] + &#x27;&#x27;)&#125;; &#125;; return result;&quot;, methodParameters())返回值groovyScript(&quot;def result=&#x27;&#x27;; def data=\\&quot;$&#123;_1&#125;\\&quot;; def stop=false; if(data==null || data==&#x27;null&#x27; || data==&#x27;&#x27; || data==&#x27;void&#x27; ) &#123; stop=true; &#125;; if(!stop) &#123; result += &#x27;\\\\r\\\\n&#x27; + &#x27; * @return: &#x27; + data; &#125;; return result;&quot;, methodReturnType())groovyScript(&quot;def result=&#x27;&#x27;; def data=\\&quot;$&#123;_1&#125;\\&quot;; def stop=false; if(data==null || data==&#x27;null&#x27; || data==&#x27;&#x27; || data==&#x27;void&#x27; ) &#123; stop=true; &#125;; if(!stop) &#123; result += &#x27;\\\\r\\\\n&#x27; + &#x27; * @return: &#x27; + data; &#125;; return result;&quot;, methodReturnType()) 注意：123一般步骤：创建模板组、创建模板、指定变量值、指定对某种语言使用上述模板中的方法注释需要在方法中生成注释，否则可能参数等生成有问题，且对返回值为void的情况，还需手动修改 插件https://www.bilibili.com/video/BV1zb4y1U7Fv配置https://www.bilibili.com/video/BV1Tg4y1B7nM11. 创建一个empty project让多个模块在项目空间同级显示（没有默认父模块）","categories":[{"name":"环境","slug":"环境","permalink":"https://shadowbynl.github.io/categories/%E7%8E%AF%E5%A2%83/"}],"tags":[]},{"title":"2021年八月底总结","slug":"202108summary","date":"2021-08-27T16:35:13.000Z","updated":"2021-08-28T08:32:45.133Z","comments":true,"path":"2021/08/28/202108summary/","link":"","permalink":"https://shadowbynl.github.io/2021/08/28/202108summary/","excerpt":"在该站点重新开始维护个人博客。 从2020年2月开始接触hexo博客，其后到2020年11月左右断断续续写了一百多篇博客，但后面由于到大三的一个比较迷茫和紧张的时期就慢慢不再维护博客了，总体上先前的博客分类和标签有些混乱冗余了，同时域名也到期，图床也存在一些失效的风险，于是决定在本人的这第二个github账号下建立仓库重新开始维护一个新的个人博客，计划是长期性的，因此：域名就采用github.io的域名，图片直接存储在本地和仓库中，而先前的文章后续有时间再作整理和迁移。这篇写于2021年8月底，本人大四上学期开始前几天，算是一个大学与未来研究生生活承前启后的一个阶段，因此在该站点的这第一篇文章中打算记述一下前一段时间（保研，简要记述，详细内容以后有时间或者等完全结束再写）和之后的两个月内的一个大致的安排。","text":"在该站点重新开始维护个人博客。 从2020年2月开始接触hexo博客，其后到2020年11月左右断断续续写了一百多篇博客，但后面由于到大三的一个比较迷茫和紧张的时期就慢慢不再维护博客了，总体上先前的博客分类和标签有些混乱冗余了，同时域名也到期，图床也存在一些失效的风险，于是决定在本人的这第二个github账号下建立仓库重新开始维护一个新的个人博客，计划是长期性的，因此：域名就采用github.io的域名，图片直接存储在本地和仓库中，而先前的文章后续有时间再作整理和迁移。这篇写于2021年8月底，本人大四上学期开始前几天，算是一个大学与未来研究生生活承前启后的一个阶段，因此在该站点的这第一篇文章中打算记述一下前一段时间（保研，简要记述，详细内容以后有时间或者等完全结束再写）和之后的两个月内的一个大致的安排。 创建该站点第一篇博客的时间 简单说明一下2021年前八个月的情况到大三下学期，基本要确定未来的规划安排了，从寒假开始到大三下学期，一直焦虑于能否稳定保研名额，能否保到外校，因为没有经历过、信息源匮乏心态一直有些颓丧，同时还想做做考研和工作的准备，但到现在来看浪费那些时间基本没啥意义。从来没能准备周全，被各种事和人推着走。到6月底，随着计算机保研生的大流投了差不多15个左右的夏令营，毫无准备地同时应对夏令营活动和7月初的期末考试。6月20号左右由于没拿到西交的夏令营资格，使我将对夏令营的期望放到了能入营就是成功的程度上，也因此多投了很多中下游的985。后面半个月左右，是比较消耗精力的，总体上就是一个拼运气和心态的阶段。从6月25日之后，我陆续接到了北交cs、华师se、西工大cs、吉大ai、山大se、东北cs、中南cs、浙大se、南大se、本校、东南cs的入营通知，参加了其中一多半，最终也拿到了5个优营，这个结果对没啥追求的我来说已经算是确定了一些事了。后面这一个多月，总体上过得相当随性，所以即便还是有很多很久以前就想做去解决的事，到现在大四快开始了还没什么进展。纠结于保研与实习之中，在原地徘徊不定，致使现在的处境比较尴尬（hh 本来打算回家学车，结果因为暴雨和疫情一年都回不了家了，在学校每天待着浪费人生）现在也算是再做一次计划人，再做做后续的一些安排，搞搞心理建设。 个人的一些情况大学前三年学的东西太杂不够深入，也很少动手实践，因此实际现在对于编码面试的事还是不太敢尝试。总是想着必须重新建立一下技术体系，但基本没时间，也不敢去费时间去尝试。但现在的情况为今后考虑，不管是纯去做开发，还是搞几年研究，必须先把一门语言学到比较熟悉的程度。对本人来说，学了两年多java，周边技术知道不少，但很难做到随手编程实现和随口讲清相关的概念，基础相当薄弱，实践也不足，而java的相关知识是极多的，我也总是有些抗拒再头像大一时那样看起，总感觉浪法时间。但显然，越看一些概念，我越认识到我的基础到处是窟窿，不去拼一把真的是只能永远处于一个会做点简单应用但实际并不熟悉语言的程度。 先整理下hexo相关的8.27晚，经过测试我确认了： hexo editor可直接将复制的图片拷到本地对应目录下，可以直接在编辑器中显示，但上传时注意补充/images 博客主题更换 使用这位比我小三岁的大佬做的主题 https://nexmoe.com/ 更新hexo版本 参考 https://www.jianshu.com/p/98ac1e253e6e 配置gitalk https://www.cnblogs.com/bigyoung/p/14154060.html 本人第一个github账号的github.io之后作工作展示用 该账号是作日常生活学习记录用 技术体系重建（主要是java)计算机基础408相关 考研材料 面经上的问题背记 几本图解 数据结构的java实现 常用基本算法 leetcode整理 java基础 尚硅谷基础（集合异常等） 面试常考 南大se服务端开发 一入 石杉 juc并发编程 尚硅谷 大厂学院 os原理 jvm 大厂学院 框架 尚硅谷spring相关 spring全家桶 设计模式与框架模式源码解析 大厂学院 web基本技术 数据库 Mysql redis 消息队列 web基本技术 前端技术总体上，应先重点看三个部分： 计算机基础（数据结构与典型算法的多次实现 leetcode整理讲解）几本书+面经+复习资料 java基础回顾 宋+mb+面经 石杉经典问题 后续再针对各专项进入深入学习。 附相关资源 小马哥java https://ke.segmentfault.com/teacher/mercyblitz https://github.com/mercyblitzhttps://www.bilibili.com/video/BV1GT4y1P76R https://github.com/leiguorui/programming-video-tutorials 南大服务端开发 https://github.com/Software-Knowledge/2021-Server-Development 南大se git@github.com:NJU-SE-15-share-review/professional-class.git https://github.com/NJU-SE-15-share-review/professional-class 南大se笔记 https://github.com/stormbroken/SpriCoder-Notes 有配一下as环境的打算 几个南大se本科的up https://space.bilibili.com/349257951/video https://www.bilibili.com/video/BV1fh411U7KR/ taoci https://zhuanlan.zhihu.com/p/172476313 短期安排 文都几本过完 j/c面经过完 dsa稳定实现 dc数据结构整理类型 java基础 面经 + 尚 + mb 石杉","categories":[{"name":"规划","slug":"规划","permalink":"https://shadowbynl.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"https://shadowbynl.github.io/categories/java/"},{"name":"大四","slug":"大四","permalink":"https://shadowbynl.github.io/categories/%E5%A4%A7%E5%9B%9B/"},{"name":"算法","slug":"算法","permalink":"https://shadowbynl.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"环境","slug":"环境","permalink":"https://shadowbynl.github.io/categories/%E7%8E%AF%E5%A2%83/"},{"name":"规划","slug":"规划","permalink":"https://shadowbynl.github.io/categories/%E8%A7%84%E5%88%92/"}],"tags":[{"name":"javase","slug":"javase","permalink":"https://shadowbynl.github.io/tags/javase/"}]}