<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>block_paper_1 | Memory</title>
  <meta name="description" content="数据流测试调查">
<meta property="og:type" content="article">
<meta property="og:title" content="block_paper_1">
<meta property="og:url" content="http://nlbyd1119.online/2020/04/02/block_paper_1/index.html">
<meta property="og:site_name" content="Memory">
<meta property="og:description" content="数据流测试调查">
<meta property="og:locale" content="zh">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_1/20200402103158035.png">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_1/20200402103520307.png">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_1/20200402110014352.png">
<meta property="article:published_time" content="2020-04-02T01:44:28.000Z">
<meta property="article:modified_time" content="2020-05-29T00:23:22.981Z">
<meta property="article:author" content="nlby">
<meta property="article:tag" content="区块链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nlbyd1119.online/block_paper_1/20200402103158035.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://nlbyd1119.online/2020/04/02/block_paper_1/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Memory" type="application/atom+xml">
  
  
    <link rel="icon" href="https://i.loli.net/2020/09/12/4y1TBOItE9w8WFq.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css">
  
  
  
<meta name="generator" content="Hexo 4.2.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/nlby" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">nlby</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> NanJing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
      </ul>
      
	

	  <embed src="https://jxiaoc.github.io/animeMusic/demo.html" width="100%"/>
	  <iframe frameborder="no" border="0" marginwidth="0"
						marginheight="0" width="100%" height=86 src="//music.163.com/outchain/player?type=0&id=4872500795&auto=0&height=66">
	  </iframe>
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>记录和总结一下学习过程及其他</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2005/">2005</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2006/">2006</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2007/">2007</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2008/">2008</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2009/">2009</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2011/">2011</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2012/">2012</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2013/">2013</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2014/">2014</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2017/">2017</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/70/">70</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flask/">Flask</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JSP/">JSP</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NoSql/">NoSql</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ORM/">ORM</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E6%A1%86%E6%9E%B6/">Web框架</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fabric/">fabric</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/live2d/">live2d</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/numpy/">numpy</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/pandas/">pandas</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/plot/">plot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%A8%E9%83%A8%E6%88%90%E4%B8%BAF/">全部成为F</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%99%E6%B3%95/">写法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AD%A6%E4%B9%A0/">功能点学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8/">安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%B9%E5%99%A8/">容器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%A7%E5%88%B6%E5%99%A8/">控制器</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%BF%97/">日志</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/">框架使用</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A6%82%E5%BF%B5/">概念</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A8%A1%E6%9D%BF/">模板</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/">版本控制工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8C%AB%E8%85%BB/">猫腻</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%AF%E5%A2%83/">环境</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A1%AC%E4%BB%B6/">硬件</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80/">移动布局</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%B0%E5%BD%95/">记录</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a><span class="tag-list-count">32</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-Science/" rel="tag">Python Science</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PythonWeb/" rel="tag">PythonWeb</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/" rel="tag">博客框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A3%B0%E4%BC%98%E8%AE%B0%E5%BD%95/" rel="tag">声优记录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E8%AF%B4%E6%95%B4%E7%90%86/" rel="tag">小说整理</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%88%E6%9E%9C/" rel="tag">效果</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/" rel="tag">番剧记录</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E7%94%A8/" rel="tag">通用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a><span class="tag-list-count">10</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Go/" style="font-size: 13.44px;">Go</a> <a href="/tags/JavaWeb/" style="font-size: 14px;">JavaWeb</a> <a href="/tags/Python-Science/" style="font-size: 13.56px;">Python Science</a> <a href="/tags/PythonWeb/" style="font-size: 13.33px;">PythonWeb</a> <a href="/tags/android/" style="font-size: 13.78px;">android</a> <a href="/tags/sql/" style="font-size: 13px;">sql</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 13.22px;">前端</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 13.33px;">区块链</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/" style="font-size: 13px;">博客框架</a> <a href="/tags/%E5%A3%B0%E4%BC%98%E8%AE%B0%E5%BD%95/" style="font-size: 13px;">声优记录</a> <a href="/tags/%E5%B0%8F%E8%AF%B4%E6%95%B4%E7%90%86/" style="font-size: 13.11px;">小说整理</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 13.33px;">总结</a> <a href="/tags/%E6%95%88%E6%9E%9C/" style="font-size: 13px;">效果</a> <a href="/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/" style="font-size: 13.89px;">番剧记录</a> <a href="/tags/%E9%80%9A%E7%94%A8/" style="font-size: 13px;">通用</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 13.67px;">随笔</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">51</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">13</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
              </p>
              <p class="item-title">
                <a href="/2020/09/15/mybatis-plus/" class="title">mybatis-plus</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-15T11:42:28.000Z" itemprop="datePublished">2020-09-15</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%A1%AC%E4%BB%B6/">硬件</a>
              </p>
              <p class="item-title">
                <a href="/2020/09/12/a-hw-1/" class="title">传感器</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-12T14:49:21.000Z" itemprop="datePublished">2020-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
              </p>
              <p class="item-title">
                <a href="/2020/09/12/vue-elementui/" class="title">vue-elementui</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-12T06:50:15.000Z" itemprop="datePublished">2020-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
              </p>
              <p class="item-title">
                <a href="/2020/09/12/vue%E5%9F%BA%E6%9C%AC-%E7%BB%84%E4%BB%B6%E8%B7%AF%E7%94%B1-%E8%84%9A%E6%89%8B%E6%9E%B6/" class="title">vue基本/组件路由/脚手架</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-12T06:48:52.000Z" itemprop="datePublished">2020-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/NoSql/">NoSql</a>
              </p>
              <p class="item-title">
                <a href="/2020/09/12/redis/" class="title">redis</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-12T06:47:40.000Z" itemprop="datePublished">2020-09-12</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
	<!------ 位置可自定义 ------>
<div class="Canvas" style="position: fixed; right: 0px; bottom: 0px;z-index: 99999999" id="L2dCanvas"></div>

<!------ 依赖 JS | Dependent JS ------>
<!---- 可选 | Optional ---->
<!-- 兼容低版本浏览器 | Compatible with low-level browsers -->
<script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"> </script>
<!-- 音频播放兼容 | Audio playback compatible -->
<script src="https://cdn.jsdelivr.net/npm/howler@2.1.3/dist/howler.min.js"></script>
<!---- 必需 | Required ---->
<script src="https://cdn.jsdelivr.net/gh/nlby/live2dCDN@1.0.2/static/live2dcubismcore.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi.js@4.6.1/dist/pixi.min.js"></script>
<!-- live2dv3.js -->
<script src="https://cdn.jsdelivr.net/gh/nlby/live2dCDN@1.0.2/static/live2dv3.js"></script>

<!------ 加载Live2d模型 | Load Live2d model ------>	
<script>
    window.onload = () => {
        new l2dViewer({
             el: document.getElementById('L2dCanvas'),
                basePath: 'https://cdn.jsdelivr.net/gh/Eikanya/live2dCDN@1.2.1/live2dv3/assets', // 模型根目录
                modelName: 'xuefeng_3', // 模型目录
                sizeLimit: false,
                mobileLimit: false
            
            
        })
    }
</script>
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-block_paper_1" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      block_paper_1
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/04/02/block_paper_1/" class="article-date">
	  <time datetime="2020-04-02T01:44:28.000Z" itemprop="datePublished">2020-04-02</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/04/02/block_paper_1/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p><strong>数据流测试调查</strong></p>
<a id="more"></a>
<p><strong>零、概述</strong><br><strong>1.数据流测试定义</strong><br>数据流测试（DFT）是一系列<strong>测试策略</strong>，旨在验证<strong>每个程序变量的定义及其用途之间的相互作用</strong>。这种感兴趣的测试目标称为“ def-use”对。<br><strong>2.DFT发展</strong><br>DFT根据各种<strong>测试充足性标准</strong>（即<strong>数据流覆盖标准</strong>）选择测试数据，以练习每一对。 DFT的最初概念是由Herman于1976年提出的。从那时起，已经进行了许多理论和经验研究，以分析DFT的复杂性和有效性。在过去的四十年中，DFT一直受到关注，并且提出了来自不同方面的各种方法来追求自动和高效的数据流测试。<br><strong>3.论文工作</strong><br>这项调查对数据流测试进行了详细的概述，包括执行和自动化数据流的挑战和方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）介绍了用于识别def-use对的数据流分析技术； </span><br><span class="line">（2）分类并讨论了基于数据流的测试数据生成技术，例如基于搜索的测试，随机测试，基于抵押品覆盖率的测试，基于符号执行的测试以及基于模型检查的测试； </span><br><span class="line">（3）讨论了跟踪数据流覆盖范围的技术； </span><br><span class="line">（4）提出了几种DFT应用程序，包括软件故障定位，Web安全测试和规范一致性检查； </span><br><span class="line">（5）总结了最近的进展，并讨论了对更实际的数据流测试的未来研究方向。</span><br></pre></td></tr></table></figure>
<p><strong>一、介绍</strong></p>
<h5>DFT概念</h5>数据流测试（DFT）是一系列测试策略，它们选择**程序路径**来行使与数据对象有关的**定义使用关系**。它在所有路径测试和分支/语句测试之间进行定位，以查明潜在的数据流异常。当用作测试选择标准时，DFT可以提供更全面的测试方法，以确保某个软件的测试充分性，并检测要求不高的标准未必发现的错误。
<h5>DFT研究</h5>数据流测试的概念源自编译器优化中使用的**数据流分析**[Allen and Cocke 1976]，最初是由Herman [1976]在1976年提出的。从那时起，各种基于数据流的覆盖率的概念略有不同。准则[RappsandWeyuker1982; Laski and Korel 1983； Rapps和Weyuker 1985；弗兰克和韦尤克（Frankl and Weyuker）1988；克拉克等。 1989年； Harrold and Rothermel 1994]已经提出并进行了研究。这种**多样性的主要原因在于行使定义-使用关系的方式不同**，以及在过程和面向对象的**编程语言**中的不同适应方式。后来，通过一些实证研究证明了DFT的有效性[Frankl and Weiss 1993; Foreman and Zweben 1993； Weyuker 1993；哈钦斯等。 1994年；（Frankl and Iakounenko 1998），这表明**基于数据流的覆盖标准优于基于控制流的标准**（例如，语句或分支覆盖）。此外，由Khannur [2011]组织的在线软件测试知识中心报告说，在实践中，“通过将90％的数据覆盖率作为标准所检测到的错误数量能够发现缺陷的数量是90％所检测到的缺陷的两倍。分支机构的覆盖标准（控制流）。
在过去的四十年中，对数据流测试进行了持续的研究（如图1所示）。为了实现实用且有效的DFT，已经进行了大量研究工作。但是，很少有文献对它的技术水平进行过深入的调查或分析，这使学术研究人员和软件从业人员不了解该领域的**成熟度**。例如，关于数据流测试的介绍性章节可以在许多软件测试教程中找到，例如Beizer [1990]，Pezze和Young [2007]以及Ammann和Offutt [2008]的书。他们介绍了基本概念并确定了挑战，但没有讨论其**自动化**。此外，DFT提供了一种更密集的选择测试用例的方法，这是其执行中最耗费人力的任务之一（对于其他结构测试标准也是如此），并且对其测试有效性和效率产生了重大影响科学。但是，尚未专门研究DFT的**自动测试数据生成技术**。尽管有Edvardsson [1999]和Anand等人。[2013]调查了自动测试数据生成的各种技术，他们主要在基于控制流的覆盖标准的背景下讨论了这些技术。
<h5>本文研究内容</h5>尽管DFT具有检测数据交互故障的能力，但实际程序与所提出的DFT技术的实用性之间仍然存在很大差距。从而，我们认为，对于学术研究人员和工业从业人员，都非常需要审查当前的研究状态，认识到其**应用中的困难**，并指出未来的**研究方向**以缩小差距。为了提供DFT的系统概述，我们从DFT的三个基本阶段开始：（1）数据流分析，（2）数据流测试数据生成和（3）数据流覆盖率计算。在本文中，我们主要集中在后两个步骤中使用的技术，并提供了一个相对简短的DFT中数据流分析技术的摘要，因为Kennedy [1979]已经对数据流分析本身进行了研究。
此外，我们提出了关于数据流测试的首次调查：我们建立了DFT发布资料库，其中包含1976年至2015年期间的97篇论文。几个流行的在线数字图书馆（例如ACM数字图书馆，IEEE搜索Xplore，Springer Online，ElsevierOnline，Wiley Online和ScienceDirect）以收集有效的论文，这些论文的标题或摘要均包含以下关键字（在搜索过程中不断完善）：“def-use对”，“数据流关系”，“数据流测试+分析”，“数据流测试+测试生成”，“数据流覆盖范围”和“停用测试”。然后，遵循这些相同的关键字规则，我们遍历了这些论文的每个参考文献以收集缺失的出版物。现在可以在线获取该信息库。1我们将其分为七个主要类别：
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-测试数据生成。研究通用方法或技术以自动化基于数据流的测试生成</span><br><span class="line">-数据流分析。在不同编程语言及其特征的背景下研究用于分析数据流关系（即def-use对）的技术</span><br><span class="line">—覆盖率跟踪（计算）。对用于跟踪数据流覆盖范围的技术的研究，即确定满足哪些使用定义对</span><br><span class="line">-实证分析。分析执行数据流测试的复杂性并将其故障检测有效性与其他覆盖标准进行比较的研究</span><br><span class="line">-应用。将数据流测试应用于其他研究领域的研究，例如软件故障定位，Web安全测试和规范一致性检查</span><br><span class="line">-理论。数据流覆盖标准的基础理论和理论分析研究</span><br><span class="line">-工具。有关构建，说明和评估数据流测试工具的研究</span><br></pre></td></tr></table></figure>
请注意，有些论文可能涉及多个类别。例如，一篇论文可以介绍一种工具，也可以提出一种新的覆盖率计算方法。我们**根据其主要目标将每篇论文归为一类**。因此，我们的分类在某种程度上可能是**主观**的。尽管如此，我们相信图2中显示的每个研究主题的百分比仍可以公平地代表DFT中的当前研究状态。
本调查的其余部分安排如下。
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第2部分通过示例说明对DFT进行了概述，然后介绍了DFT的基本测试过程以及其应用中的各种挑战。</span><br><span class="line">第3节总结了用于查找def-use对的数据流分析技术。</span><br><span class="line">第4部分研究了DFT测试数据生成的一般方法，并讨论了它们的原理，优点和缺点。</span><br><span class="line">第5节介绍了DFT的覆盖率跟踪技术和工具。</span><br><span class="line">第6节讨论了最新的研究进展，</span><br><span class="line">第7节讨论了DFT的应用程序。</span><br><span class="line">第8节介绍了我们对数据流测试的新见解和未来的研究方向。</span><br><span class="line">第9节得出结论。</span><br></pre></td></tr></table></figure>
**二、数据流测试概述**
本节介绍数据流测试中的一些基本概念。然后讨论了DFT的基本测试过程及其遇到的困难。
**1. 基本概念**
程序路径可以表示为控制点的序列，形式为l1，l2，...，ln。我们区分两种类型的路径。**控制流路径是沿着程序的控制流图的一系列控制点；执行路径是由程序输入驱动的一系列执行控制点。**
<h5>定义2.1（使用定义对def-use）。</h5>按照Herman [1976]的经典定义，当变量的赋值（即定义或def）中至少**存在一个控制流路径时**，会出现def-use对**du（ld，lu，x）**。在控制点ld处的x到在控制点lu处的语句，其中**使用了相同的变量x**（即use），在该变量上**没有出现x的重新定义**（即，从def到use的路径是def-clear）。
尤其是，在数据流测试中区分了两种类型的变量用途[Rapps和Weyuker1982，1985]。如果x在计算或输出语句中使用，则将该使用称为**计算使用（或c使用）**，并将该对表示为**dcu（ld，lu，x）**，其中x在ld处定义并使用在lu。如果在条件语句中使用x，则其使用称为**谓词使用（或p-使用）**。此时，出现了两个def-use对，分别表示为**dpu（ld，（lu，lt），x）和dpu（ld，（lu，lf），x）**，其中x在ld处定义，在lu处使用，但是具有两个相反的流向（lu，lt）和（lu，lf）：前者表示使用x的条件语句的真实边；后者是错误边。

<p>在整篇文章中，我们专注于<strong>动态数据流测试</strong>，这是大多数研究工作中的目标问题。下面，我们给出（动态）数据流测试的定义。</p>
<h5>定义2.2（动态数据流测试）</h5>给定程序P中的使用对du（ld，lu，x），数据流测试的目的是找到一个输入t，该**输入t诱导执行路径p穿过ld，然后不经过中间重新定义就穿过lu**（即，在ld和lu之间杀死x。我们说这个**测试用例t满足du对**。
<h5>覆盖标准</h5>Rapps和Weyuker [1982，1985]首先[5]定义了**所有def-use对至少覆盖一次的要求**，这是**所有def-use覆盖标准（或全部用途覆盖率）的标准**，这意味着每对至少应有一个def-clear路径被掩盖。特别是，对于c型使用对，p应该覆盖ld和lu；对于p用法对，p应该覆盖ld和真或假边缘，即（lu，lt）或（lu，lf）。

<p><strong>2. 例子</strong><br><img src="/block_paper_1/20200402103158035.png" alt=""><br>上图图显示了一个示例程序power，它以两个整数x和y作为输入并输出x y。其控制流图（CFG）显示在图3的右列中。遵循Rapps和Weyuker[1982]的定义，下图显示了power中变量的定义和使用以及相应的def-use对。 。我们可以看到该示例程序总共有19条语句，8个分支和20个def-use对。<br> <img src="/block_paper_1/20200402103520307.png" alt=""></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps:关于控制点 就是输入返回 条件判断 变量定义赋值</span><br></pre></td></tr></table></figure>
<p>例如，以下是关于变量res的两个def-use对：<br>du1=（l8，l17，res），    （1）<br>du2=（l8，l18，res）。    （2）<br>这里，du1是一个def-use对，因为关于变量res的定义（在第8行）可以通过控制流达到相应的用途（在第17行），路径为pathl8, l9, l13, 114, l17。这对可行因为可以找到满足该对的测试输入。. For example, t = ( x →1, y →0) can induce an execution path p（4 6 7 8 9 13 14 16 17).对于du2，它是一个def-use对，因为它的定义（在第8行）可以通过路径18、19、113、118到达相应的用途（在18行）。但是，du2是不可行的：如果有测试可以使用的输入，在l13必须满足y&gt; 0。由于y尚未在代码中修改，因此y&gt; 0在l4处也成立。结果，由于19处的环路保护为true，因此将在10处重新定义res。显然，这一对没有这样的输入，既可以避免循环中的重新定义，也可以使用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps:由此可见，所谓重新定义是变量重新赋值 du2因为最后use点需要输入必须满足一定条件，而满足该条件必定会进入改变变量res值的分支，因此不会存在满足条件的输入</span><br><span class="line">还有个问题，定义必须是赋值才可是吗 比如double res;就不算定义 res = 1;才算</span><br><span class="line">还有个问题，def必须是初次赋值的点对吧，不能是中间的再次赋值作为def</span><br></pre></td></tr></table></figure>
<p><strong>3. 基本测试流程</strong><br>数据流测试包括三个基本阶段：<strong>数据流分析，测试数据生成和覆盖范围跟踪</strong>（如图所示），如调查结果所示，它们总共占研究工作的近50％。<br><img src="/block_paper_1/20200402110014352.png" alt=""></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">—数据流分析阶段。数据流分析算法将被测程序P作为输入来计算测验目标（即使用定义对）。</span><br><span class="line">—测试数据生成阶段。采用一种测试方法来生成测试输入t，以满足目标限定使用对du。</span><br><span class="line">—覆盖率跟踪阶段。针对覆盖对du的程序P执行测试输入t。如果du被覆盖且未重新定义，则将t合并到测试套件T中。</span><br></pre></td></tr></table></figure>
<p>整个测试过程将继续进行，直到<strong>满足所有对或测试预算（例如测试时间）用完为止</strong>。最后，将针对程序P重放生成的测试套件T，以使用测试预告片检查正确性。<br><strong>4. 难点</strong><br>尽管DFT能够检测数据流故障，但仍然存在一些困难[Weyuker 1990； 2003； 3。 Denaro等。 [2013]阻止了它在工业实践中的广泛应用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不可扩展的数据流分析。 DFT中需要一种数据流分析算法，以从被测程序中识别使用定义对。但是，数据流分析过程很难针对大型实际程序进行扩展，尤其是在考虑了所有程序功能（例如别名，数组，结构和类对象）的情况下。必须做出适当的近似以在精度和可伸缩性之间进行权衡。</span><br><span class="line">数据流测试设计的复杂性。与程序中的数据流标准相关的测试目标数量远比简单的控制流准则要大得多。6此外，需要付出更多的努力才能得出数据流测试用例：测试人员必须涵盖了变量定义及其相应的用途，而没有变量的重新定义，而不仅仅是覆盖语句或分支。</span><br><span class="line">不可行的测试目标。由于将静态数据流分析技术应用于确定测试目标时比较保守，因此，def-use对可能包括不可行的对。如果存在可以通过的执行路径，则一对是可行的。否则，它是不可行的（例如，第2.2节中的对（18、18，res）是不可行的）。在没有关于目标对是否可行的事先知识的情况下，测试方法可能徒劳地花费大量时间来覆盖不可行的停用使用对。</span><br></pre></td></tr></table></figure>
<p>在这里，<strong>确定不可行的测试目标的问题实际上是不确定</strong>的，并且没有任何技术可以可靠地给出可行性的明确结论。它在DFT中不是唯一的，但在结构测试中也存在。尽管存在上述困难，但如本调查所示，借助现有技术和最新进展，DFT可以<strong>实现自动化，并且可以缓解这些问题</strong>。</p>
<p><strong>三、经典数据流分析–提取def-use对的研究</strong><br>为了识别DFT中的测试目标（即使用定义对），通常使用达到定义的程序[Allen and Cocke 1976]（它也启发了数据流覆盖标准的定义），实际上回答了这个问题。 ：对于每种变量使用，哪些定义可以潜在地为其提供值？<br>Harrold和Soffa [1994]使用标准的迭代数据流分析来计算高级语言的定义-使用关系。通过控制流图为每个过程提取过程内定义和使用信息，然后将其用于计算跨越过程边界的过程间定义使用对。 Pande等。 [1994]扩展了到达定义分析，以处理具有C语言单级指针的程序。该算法考虑了特定于程序点的指针引起的别名，并且具有多项式时间复杂度。<br>为了应对传统的穷举式和增量式数据流分析的复杂性，Duesterwald等人。 [1996，1997]提出了一种<strong>需求驱动的数据流分析技术</strong>，以在集成测试用于验证程序接口时辅助DFT。该分析是作为面向目标的搜索执行的，而不是使用详尽的信息传播。它可以在每个自下而上的集成步骤中高效地计算新建立的数据流信息，而无需在每个步骤之间存储到达定义解决方案。<br>Harrold and Rothermel[1994]扩展了面向对象语言的数据流分析，它不仅考虑了方法内的定义-使用关系（即，方法内部定义使用对），还通过实例变量（即方法间和类内部定义使用对）计算数据流关系。 Chatterjee和Ryder [1999]提出了一种基于指向分析的流和上下文敏感算法，以计算面向对象库的定义使用对。该算法解决了参数之间的未知混叠，参数的未知具体类型以及动态分配和异常的难题。 Souterand Pollock[2003]和Denaro等。[2008]也将经典的数据流分析<strong>扩展到了面向对象的程序</strong>，尤其是考虑了由类对象创建的上下文def-use对的构造。<br>为了提高静态def-use对分析的精度，Bod´ik等人。 [1997]提出了一种方法，通过利用在编译时可以检测到的一些不可行路径的信息来排除部分不可行的def-use对（请注意，识别所有不可行路径的问题尚不确定）。该方法检测静态分支相关性以标识不可行的程序子路径，然后排除跨越这些不可行子路径的定义使用对。该算法在过程内和过程间级别均以需求驱动方式实现，适用于回归测试和集成测试中的DFT。<br><strong>经典的数据流分析属于静态分析</strong>，在实践中可能必须通过别名分析以不同的精度级别（例如，对流和/或上下文敏感）进行增强。实际上，应该做出适当的近似以在精度和可伸缩性之间进行权衡。<br><strong>四、基于数据流的测试数据生成方法</strong><br>本节介绍了各种<strong>自动化基于数据流的测试数据生成的方</strong>法，这些方法对DFT的有效性和效率有很大的影响。从出版物存储库中，我们发现测试生成问题是数据流测试研究中最活跃的研究主题，并且在过去20年中一直受到关注。共有27篇技术研究论文与该主题相关。根据他们的测试技术，我们将它们分为五个主要组：<strong>基于搜索的测试，随机测试，基于抵押物覆盖的测试，基于符号执行的测试以及基于模型检查的测试</strong>。<br>我们计算了这些论文中使用的每种测试方法的百分比7（如图6所示）。我们发现基于搜索的测试方法（包括<strong>遗传算法和优化算法</strong>）是研究最广泛的方法，它占了近50％研究工作。基于抵押物覆盖的方法和随机测试也很流行。但是，很少研究更复杂的测试方法，例如符号执行和模型检查。<br>在下文中，我们将在独立的部分中详细介绍这些方法，从研究最广泛的到研究最少的部分，即基于搜索的测试（4.1节），随机测试（4.2节），基于抵押物覆盖率的测试（第4.3节），基于符号执行的测试（第4.4节）和基于模型检查的测试（第4.5节）。最后，在4.6节中讨论了其他一些方法。<br><strong>1. 基于搜索的数据流测试方法</strong><br>基于搜索的软件测试[Harman等。 [2015年]，作为基于搜索的一般软件工程领域的一个实例，在过去的几十年中一直受到广泛的研究兴趣。</p>
<h5>1.1基于搜索的方法原理</h5>基于搜索的方法包括各种**元启发式技术**[McMinn2004]，并利用它们来识别诸如测试用例生成之类的组合问题的解决方案。通常，测试数据生成的问题是无法确定的，但是可以将其**解释为搜索问题**，在该问题中，它会**从程序输入域中搜索所需的值来满足测试要求**。
<h5>遗传算法</h5>1975年提出的**遗传算法（GA）**[荷兰，1992年]是元启发式搜索技术的代表，它受到遗传学和自然选择的启发。在测试数据生成期间，GA从**一组候选个体（即测试用例）**开始，然后使用**搜索运算符**（例如选择，交叉和变异）来生成下一个有希望的测试用例。选择**从种群中选择有效的个体进行重组**（即交叉和突变）。两个独立个体之间的交叉产生了两个新的测试案例，这些案例共享了父母的遗传物质，而突变使部分人口的变化很小。
已经提出了几种**基于GA的测试方法**来解决DFT问题[Girgis 2005; Ghiduk等。 2007年； Vivanti等。 2013]。
（一）
Girgis [2005]首先使用GA进行数据流测试所有用途的覆盖范围。在Girgis [2005]中，GA使用**长度为m的二进制字符串s作为染色体（即测试用例）来表示输入变量的值**。假设被测程序有k个输入变量（例如v1，...，vi，...，vk，1ik），vi的输入范围是[ai，bi]，而di是期望的精度。vi的值。然后，通过公式建立从二进制字符串si到具有域[ai，bi]的变量值vi的映射：
![](/block_paper_1/20200402113226764.png)
其中vij是二进制字符串si的十进制值。以图3（第2节）中的程序为例，并假设x和y的输入范围分别为[-2，9]和[-4，13]。**染色体是长度为9的二进制字符串**，其中从左起的前4位代表x的值，接下来的5位代表x的值y。例如，二进制字符串s 010100110表示一个x 5和y 6的测试用例。在生成测试之前，GA使用Michalewicz [1994]提出的这种编码方法来生成测试用例的**初始填充**。
在Girgis [2005]中，GA**使用涵盖的def-use路径数与总的def-use路径数之间的比率作为适应度函数，该函数专门使用覆盖率信息来确定单个测试用例的有效性**。这种基于GA的方法的**工作原理**如下。首先，它生成一组以二进制字符串形式编码的测试用例。然后，它使用基于轮盘算法的选择方法[Michalewicz 1994]根据适合度的个体来选择有前途的个体。接下来，GA使用搜索运算符（即交叉和变异）产生新的选定亲本的染色体。在预定义的迭代次数之后，GA可以输出一组可以覆盖目标def-use路径的所需测试用例（由于此搜索问题的不确定性，可能仍然存在未发现的def-use路径）。
（二）
Ghiduk等[2007]后来发现，Girgis[2005]使用的适应度函数内部存在**一些缺陷**，这些缺陷可能过于粗糙，无法在以下情况下确定测试用例的接近性：（1）如果两个测试用例覆盖相同的数字对于def-use路径，它们将被赋予相同的适用性值；（2）如果一个测试用例没有涵盖任何def-use路径，则其适应性值将被赋予“ 0”。结果，当选择有前途的个体进行重组时，它可能会丢失有用的信息。为了解决这个问题，他们遵循Girgis [2005]中的类似程序，提出了一种**新的多目标适应度函数**。该功能根据其支配性（Lengauer和Tarjan 1979）与数据流需求的定义和使用之间的关系，来评估测试数据的适用性。特别是，它将def-use对视为**def和use这两个目标**。为了评估测试用例相对于目标def-use对的接近程度，它针对这两个目标使用了优势路径的遗漏节点。该功能的建立基于两个观察结果：（1）覆盖def的测试用例比不覆盖def和use或仅覆盖use的测试用例更近，以及（2）遗漏但包含但不存在的测试用例尝试覆盖def或使用比未命中且不尝试覆盖def或使用的测试用例更接近（尝试覆盖目标语句的测试用例意味着，在随后的搜索中，其变体接近目标。 ）。他们遵循这样一种测试方法：一次针对一个使用期限对，一次可以满足特定的测试要求。在评估中，他们发现这种GA方法比随机测试花费更少的搜索时间并且需要更少的程序迭代。但是，目前尚不清楚该技术在性能上比Girgis [2005]有多少，因为没有提供相关结果。
（三）
Vivanti等。[2013]使用遗传算法来处理**面向对象程序**的数据流测试。对于面向对象程序中的类测试，测试用例以一系列方法调用的形式表示[Tonella 2004]。按照对类进行测试的概念[Harrold andRothermel 1994]，他们确定了**三种def-use对：方法内对，方法间对和类内对**。他们使用**“节点-节点”适应度函数**[Wegener等。[2001]，其中搜索首先被导向到达第一个节点（即def节点），然后从那里导向到达第二个节点（即使用节点）。但是，作者发现，一次针对单个测试目标时，测试人员面临在所有测试目标之间合理分配测试资源的问题。此外，对于不可行的测试目标，将浪费在其上的测试资源。为了克服这些问题，他们没有使用一次一次定位一对对象的经典方法，而是将整个测试套件[Fraser andArcuri 2013]应用于数据流测试，从而优化了涵盖所有测试的测试用例集目标。预期该方法受不可行的测试目标的影响较小。通过对SF100类语料库的评估[Fraser和Arcuri2012]，他们确认数据流测试的测试目标远比分支测试的目标要大，但最终的测试套件在故障检测方面更有效。
（四）
Denaro等。 [2015]也使用类似的遗传算法在面向对象系统中使用基于数据流的测试数据来扩展**初始测试套件**。Liaskos等。 [2007]和Liaskos和Roper[2008]将GA与人工免疫系统（AIS）混合[Liaskos和Roper 2007]算法来完成针对Java库类的数据流测试。这种组合技术显示了其在提高测试性能方面的潜力。
（五）
Baresi等。开发基于GA的测试工具Testful [Baresi等。 2010; Baresi and Miraz 2010]，用于Java类的结构测试。这个GA变体使用了**多目标适应度函数**，并且在类级别以及方法级别上都可以工作。前者为类对象生成有用的状态，后者使用它们到达未发现的状态类中的代码。在Miraz [2010]中，Matteo应用了该GA变体来覆盖定义使用对。作者指出，对面向对象的程序明确使用def-use对通常会有所收获，因为它可以正确地关联通过交换数据（例如，对象的字段）相互协作的方法。其他工作包括Oster [2005]和Deng等。 [2009]，他们也使用GA来自动化数据流测试，但只评估了一些小例子。
还尝试使用基于优化的搜索技术来解决DFT问题。 Nayak和Mohapatra [2010]和Singla等。 [2011a，2011b]使用粒子群优化，而Ghiduk[2010]使用蚁群优化。受自然行为的启发，这些优化算法模拟了这些行为，以在DFT的上下文中找到最佳解决方案。但是，这些方法仅在玩具程序上进行了评估。它们在大型程序上的有效性仍不清楚。
<h5>1.2讨论</h5>基于搜索的技术已经被用于执行简单的覆盖标准（例如，语句和分支测试[Anand等，2013]）以及一些高级覆盖标准[Ammann等。 2003; Inc 1992]（例如逻辑覆盖率[Awedikian等，2009； Ghani和Clark，2009]）和数据流覆盖率，如前所述。这种方法将测试数据生成视为一个**域搜索问题**，因此，它在**解决非线性约束和查找浮点输入方面更有能力**[Lakhotia等。 2009年，2010年； Bagnara等。 2013]，而不是那些基于约束的方法（例如，符号执行）。
但是，仍然存在一些需要注意和研究的问题：首先，基于搜索的技术的**测试性能在很大程度上取决于基础的适应度函数**（可能需要很长时间才能找到好的解决方案），因此要足够谨慎在设计和优化中需要。其次，与遗传算法相比，一些基于优化的算法（例如，粒子群优化和菌落优化）研究较少，它们在现实程序中的**可扩展性**仍然不清楚。第三，尽管多目标适应功能[Lakhotia等。2007年； Fraser andArcuri 2013]可以减轻不可行对的影响，但仍然**无法检测到不可行对**。
**2. 基于随机测试的数据流测试方法**
随机测试[Bird andMunoz 1983]是使用最广泛且最具成本效益的测试方法之一。在其经典实现中，从程序**规范的值范围中随机选择测试输入**，然后针对测试中的程序执行测试输入。
这种经典的随机测试技术已被用作易于执行但相当有效的基线方法，用于几项工作中的数据流测试[Girgis 2005; Ghiduk等。 2007年； Su等。 2015]。对于面向对象的系统，测试用例是一系列的类构造函数调用和方法调用的序列[Pacheco等。 2007]。适应于随机产生这些序列以行使被测类别的随机测试也已用于数据流测试领域[Alexander等。2010;Denaro等。 2015]。此外，其他形式的随机测试[Girgis等。[2014]，例如，从程序图中随机选择测试路径以覆盖定义使用对（然后使用测试生成器从那些测试路径中导出相应的测试用例），用于实现数据流测试。
<h5>讨论</h5>随机测试具有成本效益低并且易于实现，但是只能区分**有限的程序行为集**。结果，在没有任何优化的情况下，随机测试通常**无法实现令人满意的数据流覆盖范围**。但是，借助一些优化技术，随机测试可以成为DFT的一种**竞争性测试**生成方法。
例如，研究人员发现，如果先前选择的测试无法揭示程序错误，那么应该选择新的测试，使其远离已执行的测试。
从而提高触发故障的机会。自适应随机测试[Chen2008; Ciupa等。 2008年； Lin等。 2009年； Arcuri and Briand 2011]，例如增强传统随机测试，将测试用例平均分布在其输入域中，可以提高数据流测试的效率。此外，反馈导向的随机测试[Pacheco等。 2007]）通过合并从创建测试用例时获得的反馈信息来改善随机测试，也可以使DFT受益。
**3. 基于抵押品覆盖率的数据流测试方法**
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps:应该是附带覆盖的含义</span><br></pre></td></tr></table></figure>
在软件测试中，已利用抵押物覆盖范围来优化测试套件的生成[Harman等。 2010; Fraser and Arcuri 2013]。它基于以下观察结果：满足测试目标的测试用例可以**“意外地”涵盖其他测试目标**。因此，如果我们**排除这些涵盖的测试目标**，并将测试预算投入到其余未发现的目标中，则可以减少所得测试套件的大小以及测试执行和Oracle检查的成本。同样，在执行程序以满足给定的测试标准（例如分支覆盖范围）时，与**其他覆盖标准**（例如数据流覆盖范围）有关的测试目标也可能被意外覆盖，这是附带覆盖的另一种形式[Malevris and Yates 2006]。
形式上，如果对于所有程序P，满足P的所有测试目标（针对C1）的测试用例也满足针对C2的那些测试用例，则测试标准C1包含另一个标准C2。例如，下图（在Rapps和Weyuker [1982，1985]中给出）显示了**不同测试覆盖率标准之间的包含关系**。8箭头尾部的标准包含了箭头头的标准（例如，分支标准包含了）声明标准）。由于包含关系是传递性的，因此它实际上定义了各种覆盖标准之间的关系。阴影标准是七种类型的数据流测试标准（有关详细定义，请参见Rapps和Weyuker [1982，1985]），这些标准强调了行使定义-使用关系的不同方法。所有用途的覆盖范围是所有实际用途的覆盖范围（请参阅第2.1节中的定义2.2），它包含所有c用途和所有p用途覆盖范围。此外，所有用途的覆盖范围也包含分支机构的覆盖范围。
![](/block_paper_1/20200402022553498.png)
**尝试基于附带覆盖的想法来解决数据流测试**
（一）
ing[Malevris and Yates 2006; Santelices和Harrold 2007；梅洛和安东尼奥1999；
Marre和Bertolino 1996，2003;Santelices等。2006]。 Malevris和Yates[2006]在打算进行分支测试时研究了数据流覆盖的水平。在实证研究中，他们从控制流图中选择路径，以用不同的编程语言（包括Fortran，Pascal，C和Java）编写的59个单元来满足所有分支的覆盖范围，并**衡量同时实现的数据流覆盖范围到七个数据流标准**（上图中的阴影）。在他们的实验中，执行分支测试并选择平均每单位6.44条路径时，平均可以实现超过35％的所有du路径覆盖和超过40％的所有用途覆盖。该研究还表明，可以**将实际数据流覆盖范围建模为一个函数**，该函数将有关分支测试的选定路径数和其中的可行路径数作为参数。此外，他们还发现（1）数据流覆盖范围与单位使用的语言无关；（2）可以根据抵押覆盖范围来估计DFT所需的可能的测试预算，以及（3）在数据流测试之前进行分支测试可能更具成本效益，因为在分支测试期间将涵盖部分使用数据对。
（二）
Merlo和Antoniol [1999]利用def-use对和节点（即语句）之间的覆盖率含义来实现过程内数据流测试。前支配器和后支配器分析用于识别一组节点，这些节点的覆盖范围可能暗示def-use对子集的覆盖范围。他们在16KLOC Gnu查找工具上评估了该方法，发现当覆盖每个例程的节点时，平均而言，肯定有75％的def-use对被覆盖。
（三）
Santelices等。[2006]提出了一种**基于谓词条件的任何类型的程序实体（例如分支，定义使用对和调用序列）的包含算法**。此谓词条件是路径条件的特殊形式[Robschink and Snelting 2002]，从系统依赖图计算得出，以表示实体对其覆盖范围的必要但不充分的条件。构建包括每个实体的所有这些谓词条件的表，以创建实体的包含关系以进行有效的覆盖范围跟踪。
后来，Santelices和Harrold [2007]提出了一种**从分支结构覆盖范围自动推断数据流覆盖范围的方法**。在静态分析阶段，使用可推断性分析将def-use对分为三类：可推断的（覆盖范围始终可以从分支覆盖范围中推断出来），有条件的可推断性（可以从某些但不是全部的分支覆盖范围中推断出覆盖范围）程序执行）和不可推断的（无法从分支覆盖率推断出覆盖率）。在动态测试套件执行阶段，将针对三种类型的实体记录分支覆盖范围：定义，用途和定义用途对的销毁。最后，覆盖率跟踪阶段将静态和动态分析的结果作为输入，并报告已明确覆盖，可能覆盖或未覆盖的def-use对。尽管这种方法可能会损失一些覆盖精度，但是显着的好处是，由于该程序是在分支覆盖级别而不是数据流覆盖级别进行检测的，因此可以大大减轻覆盖跟踪的开销。
（四）
Marre和Bertolino [1996，2003]提出了一种方法，用于识别最小数量的def-use对，以便覆盖这些对的路径可以覆盖程序中的所有对。换句话说，可以通**过集合中那些对的覆盖范围来推断集合外的那些对的覆盖范围**。该集合称为扩展集合，其中的对称为无约束对。该集合的基数实际上是实现所有用途覆盖范围所需的测试套件大小的上限。结果，它可以帮助估计数据流测试的成本。 Harrold等。[1993]提出了一种从测试套件中生成具有代表性的测试用例集的技术，该方法可以达到与原始整个测试套件相同的覆盖率。该技术通过利用抵押物覆盖范围来最小化测试套件的大小，并且独立于测试方法。它仅需要测试需求和满足以下条件的测试案例之间的关联这个要求。对数据流测试的评估表明，该技术可以有效地删除多余的测试用例，但又不影响覆盖率，这在回归测试中特别有用，可以降低测试成本。
<h5>讨论</h5>借助现有的测试数据，基于抵押物覆盖范围的方法在数据流测试中具有多个优点：（1）仅考虑非约束对，它可以减少测试套件的大小以及开销。覆盖范围跟踪； （2）可以通过无约束对的数量来估计应该分配多少测试预算； （3）它可以帮助理解程序中不同级别的实体（例如，语句，分支和def-use对）之间的关系。
但是，由于此方法**使用低级程序实体（例如，语句或分支）的覆盖范围来推断高级实体（例如，def-use对）的覆盖范围**，因此可能无法为其覆盖范围不易推断。而且，它也不能区分不可行的对。
**4. 基于符号执行的数据流测试方法**
符号执行由金[1976]首次提出，是一种经典的程序分析技术，已**广泛应用于软件测试**中[Cadar andSen 2013]。
**符号执行原理**
符号执行**使用符号值而不是具体值作为程序输入**。结果，由这些**输入组成的符号表达式可用于表示程序变量的值**。在符号执行期间，程序状态在任何时候都包括（1）程序变量的符号表达式（值），（2）符号输入上的布尔约束形式的路径约束（pc），需要满足以下条件：到达该程序点，并且（3）一个程序计数器，表示要执行的下一个程序语句。
该技术的**工作原理**如下：在执行过程中，将使用每个分支点上输入的新约束来更新pc。如果新PC不满足要求，则将停止对相应路径的探索。否则，执行将沿着该分支点继续，这样pc的任何解决方案都将执行相应的路径。特别是，当条件语句的两个方向（即分支）都可行时，路径探索将继续进行下去。搜索策略[Cadar等。 2008年； Burnim and Sen 2008； Cadar等。 2006]将被指定搜索方向的优先顺序。符号执行的这种经典方法也称为静态符号执行（SSE）。在图8中，我们说明了在图3（第2节）中的示例程序上的符号执行。在这里，探索了三个程序路径，并通过**解决所收集的路径约束来生成测试输入**（如图8（a）所示）。执行树在图8（b）中给出。
![](/block_paper_1/20200402023706520.png)
**基于静态符号执行的方法**
Girgis [1993]首先使用了类似的静态符号执行系统来生成基于数据流的测试数据。该方法首先从被测试程序的CFG到特定的控制流标准（例如分支覆盖范围）生成一组程序路径。由于来自CFG的循环可能会生成无限的程序路径，因此它通过使用称为ZOT子集的路径子集，通过要求路径遍历循环零次，一次和两次来近似整个路径空间。然后，将重点放在可以覆盖感兴趣的def-use对的那些可执行路径上。在该系统中，测试人员可以通过检查沿该路径收集的路径约束是否可满足来确定路径可行性。通过**解决可行路径的路径约束，该系统可以生成满足给定数据流测试标准的测试套件**。
对于图3中的示例程序，该方法首先相对于控制流标准（例如分支覆盖）静态地探索尽可能多的路径。假设它找到一个静态路径p = l4，l5，l8，l9，l10，l11，l9，l13，l18。在此，p遍历循环（位于19和12之间）一次并静态覆盖dua（l10，l18，res）。对应的pc（即y==1 y> 0）的解（x›→0，y›→1）可以满足该对。
**基于动态符号执行的方法**
Godefroid等。 [2005]和Sen等。 [2005]**将符号执行与具体执行交织**在一起，以提高静态符号执行的可伸缩性。这种混合技术（称为**动态符号执行或约束测试**[Godefroid et al。2005; Sen et al。2005]）沿执行路径（与静态符号执行相同）收集路径约束，该约束由具体程序触发输入。如果路径约束变得过于复杂并且超出了约束求解器的范围，则可以使用这些具体值通过值替换来简化它。
Su等。 [2015]首先采用了这种**动态符号执行技术**，以在称为CAUT的DSE引擎之上进行数据流测试。 2009年； Yu等。 2011; Sun等。 2009年； Su等。 2014]。在他们的方法中，数据流测试被视为目标搜索问题。它首先找出一组切点，任何切入点都必须经过这些切点才能覆盖一对定义使用对。这些切点可以缩小路径搜索空间，并引导路径探索尽快到达该对。为了进一步提高测试性能，它使用了有向符号执行方法的最短距离分支优先启发式方法（优先级最高的指令距离指定目标的分支方向）[Zamfir andCandea 2010; Ma等。 2011]）和重新定义路径修剪技术（def和使用之间的子路径上不能出现重新定义）。
对于图3中的示例程序，假设目标def-use对为du（8,17，res）。DSE通过获取任意测试输入t开始，例如，t=（x›→0，y›→42）。这个测试输入触发执行路径p
![](/block_paper_1/20200402024221388.png)
它已经涵盖了du1的定义。为了涵盖其使用，经典的DSE方法
（例如，使用深度优先或随机路径搜索[Burnim and Sen 2008]），系统地对p上的分支节点进行翻转，以探索新路径，直到覆盖使用为止。但是，路径爆炸的问题（路径p上的数百个分支节点（包括来自p的新生成路径的节点）可以翻转为派生新路径）可能会使探索非常缓慢。
![](/block_paper_1/20200402024437802.png)
**讨论**
经典的符号执行是**基于路径的测试方法，可以系统地探索路径以覆盖目标定义使用对**。在早期工作中[Girgis 1993]，Girgis使用控制流标准作为覆盖率度量标准来指导路径探索，这可以缓解路径爆炸问题，但**可能会带来无法覆盖某些使用期限对**的风险。例如，图8（a）中的三个路径已经覆盖了功能函数中的所有分支，但是不满足使用定义对du（l10，l17，res）（新的测试输入（x 1，y 1））对应于路径l4，l7，l8，l9，l10，l11，l9，l13，l14，l17的路径可以覆盖这对）。原因是控制流准则可能不包含数据流准则。此外，使用符号推理时，经典的符号执行必须做出一些近似，这**可能会丢失数据流测试的精度**。例如，当x的具体值未知时（一种方法是将a[x]视为整个数组的使用a）。相反，基于动态符号执行的方法可以更加精确和高效。例如，使用动态执行信息可以更轻松，更准确地检测到由别名引起的变量重新定义，并且动态程序执行比静态程序执行快得多。
但是，基于SSE的方法和基于DSE的方法都无法识别不可行的对，因为基于符号执行的测试是基于显式路径的方法，在所有程序路径都被确定之前，无法得出对的可行性的结论。探索。在没有关于目标对是否可行的事先知识的情况下，这些测试方法可能徒劳地花费大量时间来覆盖不可行的对。
**5. 基于模型检查的数据流测试方法**
**模型检查原理**
模型检查[Clarke等。 [1999]是一种经典的形式验证方法。**进行属性检查时，模型检查器可以构造见证人或找到反样本。**在较高的层次上，模型检查器将系统规范和感兴趣的属性作为输入；然后检查是否违反了该属性。如果该属性被违反，则会生成一个反例来证明该违反。否则，该财产被认定为满意（即未违反）。结果，这种模型检查方法可用于测试目的[Fraser等。 [2009]，尤其是当这些反例被解释为测试用例时，这可以帮助分析人员识别并修复故障。
**基于WCTL的模型检查**
![](/block_paper_1/20200402025101268.png)
![](/block_paper_1/20200402025132180.png)
**讨论**
这种基于Kripke结构的模型检查方法具有以下优点：（1）由于它适用于**抽象模型**，因此该方法与语言无关。它甚至可以扩展规范模型上的数据流测试[Hong等。 2000;乌拉尔等。 2000]。（2）这种方法将数据流测试问题转化为**模型检查问题**，这可以从模型检查器的未来发展中受益。
但是，它也可能会受到一些限制：（1）从理论上讲，此方法中最常用的定义使用对数可以是O（n2），其中n是图中顶点（即语句）的数目G。因此，相对于G，公式的数量可以是二次的。如果将其应用于基于过程间程序的测试，则由所有函数构建的整个图G将包含大量顶点。此方法的**可伸缩性**可能会受到影响。（2）此外，这种方法无法轻松检测不可行的对，因为它所基于的抽象模型并不了解潜在的路径约束。
**基于CEGAR的模型检查**
另一种软件模型检查方法称为CounterExample-Guided基于**抽象提炼**（CEGAR）模型检查[Ball and Rajamani2002; Henzinger等。 2002年；Chaki等。 [2003年]是在2002年提出的。给定程序源代码和时间安全规范，CE-GAR**要么静态地证明程序满足该规范，要么生成一个程序。**
反例路径以证明违规。从那时起，它被应用于自动检查OS设备驱动程序的安全属性[Ball and Rajamani 2002; Beyer等。 2007年； Beyer和Keremoglu 2011]以及生成测试用例[Beyer等。 [2004]。
Beyer等。[2004]提出了一种基于CEGAR的两阶段方法，即从反例进行模型检查和测试，以自动生成结构测试用例。它首先检查感兴趣的程序位置q是否可到达，以使q处的谓词p（即安全性）为真。从在q处显示p的程序路径，基于CEGAR的模型检查器可以生成一个测试用例，以证明p在q处的真相。类似地，它也可以产生一个测试用例，以表明p在q处的虚假性。如果在谓词p设置为true的情况下检查了所有程序位置或分支，则可以很好地实现语句或分支的覆盖范围。
Su等。[2015]进一步调整了这种基于CEGAR的模型检查方法，以针对所有使用定义标准进行数据流测试。提出了一种简单但功能强大的程序转换方法，将测试需求直接编码到被测程序中。它将原始程序P插入Pj，并将数据流测试的问题减少到对Pj的可达性检查。在目标定义使用对的定义位置之前，引入了一个变量cover_flag并将其初始化为false。该标志在def之后立即设置为true。为了找到从def位置到使用位置的def-clear路径，在相同变量的其他定义之后，将cover_flag变量立即设置为false。在使用之前，它将目标谓词p设置为cover_flag true。结果，如果可以到达使用位置，我们将得到一个很好的例子，并得出结论，该对在测试案例中是可行的。否则，将证明该对是不可行的（或者，由于问题无法确定，该算法不会在受约束的时间预算内终止，并且会将结果报告为未知）。
对于图3中的示例程序以及方程式（1）中的两对du1和du2和（2），用这两个测试要求编码的转换程序分别如图10（a）和图10（b）所示。对于du1（18,17，res）对，图10（a）在突出显示的语句中显示了du1的变换函数功效和编码测试要求。变量cover_flag在l2处引入。初始化为false并在l7的def之后立即将其设置为true，并在l10的变量res的其他定义之后立即将其设置为false。在使用之前，在14点设置检查点以验证cover_flag是否可以为true。如果检查点不可达，则可以证明这对不可行。否则，可能会产生反例（即涵盖该对的测试用例）。在该示例中，模型检查器可以找到可能的路径l2，l3，l4，l6，l7，l8，l9，l13，l14，l16，l17。但是对于图10（b）中的du2（l8，l18，res）对，模型检查器可以快速得出结论：没有路径可以到达检查点并见证cover_flag的真实性。因此，du2是不可行的。
**讨论**
这种基于CEGAR的模型检查方法具有以下优点：（1）数据流测试问题可以轻松**转换为路径可达性检查问题。** CEGAR可以为可行的def-use对生成反例（即测试用例），还可以检测没有误报的不可行对。这项技术本身甚至可以受益于基于CEGAR的模型检查器的未来发展。 （2）在CEGAR中，可以**将测试要求直接编码到被测程序中**，而无需手动编写诸如CTL / WCTL公式的时间属性。与其他基于模型检查的方法相比，它更加灵活且易于实现。
但是，一般而言，CEGAR无法确定所有def-use对的可行性，因为检查路径可行性本身的问题尚不确定。在这种情况下，CEGAR可能不会终止，只能得出未知结论。另外，CEGAR本质上是静态方法。生成可行对的测试用例时，其**测试性能可能不及其他动态测试方法**（例如，基于动态符号执行的方法[Su等人2015]）高。
**6. 其他方法**
Khamis等。 [2011]增强动态域减少程序[Offutt等。 1999]（DRR）对Pascal程序执行数据流测试。 DDR技术基本上**集成了符号执行和基于约束的测试的思想**。它从输入变量的初始域以及程序流程图开始，并通过指定的路径动态驱动执行，以达到目标测试目标。在路径探索过程中，采用符号执行来减小输入变量的范围。然后使用搜索算法来找到可以满足路径约束的一组值。作者还通过一些处理循环和数组的方法来增强此技术。但是它仅通过一些概念证明示例来说明该想法，其实用性尚不清楚。
Buy 等。 [2000]结合数据流分析，**静态符号执行和自动演绎来执行数据流测试**。符号执行首先确定类中每种方法的输入和输出值之间的关系，然后从可行且清晰的路径（包括目标对）收集方法的前提条件。后来，使用一种自动向后推导技术来找到满足这些先决条件的方法调用（例如，测试用例）的顺序。但是，几乎没有证据表明这种方法的实用性。后来，Martena等人。 [2002]将该技术从单个类扩展到多个类，即测试类间的交互。它从简单的类到更复杂的类逐步生成测试用例。
Baluda等。 [2010]，Baluda[2011]和Baluda等人。 [2011]提出了一种称为抽象提炼和粗化（ARC）的新颖方法，通过**识别不可行的分支来提高分支覆盖率测试的准确性**。这种方法源于属性检查算法[Beckman等。 2008年； Gulavani等。 [2006年]，其目的是证明错误的陈述不可达或产生执行该陈述的测试用例。 Baluda等。将该算法用于结构测试并通过“粗化”对其进行增强，以提高其可扩展性。 Baluda [2011]声称这种方法独立于覆盖标准，并且特别适用于这样的覆盖标准，这些覆盖标准由于存在不可行的测试目标（如数据流测试标准）而遭受了极大的折磨。
<hr>
**总结**
尽管在识别基于数据流的测试数据方面遇到了许多挑战，但研究人员已经开发出各种使该过程自动化的通用方法。**基于搜索的测试和基于附带覆盖的测试是用于自动生成测试数据的两种研究最为广泛的技术**（如图6所示）。合理的解释是，这两种技术对于DFT而言**相对容易实现**。基于符号执行和基于模型检查的技术相当早就引起了人们的注意，但是直到最近它们还没有应用于大型的现实程序，而仅应用于实验室程序。这些技术比其他方法**更难以实施，而且在很大程度上依赖于其他技术的进步**（例如约束解决），这一事实可以解释这种现象。另外，对于过程语言（例如，C）和面向对象的语言（例如，Java），都存在几种学术工具。但是，根据我们的调查，仍然**没有支持DFT的商业工具**。开发高效且易于实现的技术需要付出更多的努力。
我们还需要注意的是，由于存在根本的不确定性问题，**没有任何现有的测试技术能够可靠地识别出不可行的线对（其他结构测试也是如此）**。当应用其中任何一个时，一个人可能总是无法覆盖某些对，并且不知道是因为没有进行足够的测试还是因为它们永远无法覆盖。
**五、覆盖跟踪的方法**
本节讨论了现有文献中用于**跟踪数据流覆盖范围**的一些方法，并总结了可用的数据流覆盖范围工具。
**1. 覆盖跟踪技术**
测试覆盖率是衡量**软件测试的彻底程度以及软件开发人员对其可靠性的信心程度**的常用工具。几种技术[Frankl 1987; Ostrand和Weyuker 1991a； Horgan and London 1992； Misurda等。 2005b； Santelices和Harrold 2007； Harrold和Soffa（1994）的开发是为了追踪def-use对的覆盖范围。
（一）
弗兰克（Frankl）（1987）提出了一种基于确定性有限自动机的方法来跟踪定义使用对的覆盖状态。在她的方法中，一对du与一个正则表达式相关，该正则表达式描述了覆盖它的控制流路径。与du关联的每个自动机都针对所有执行路径进行检查。一旦某个路径被某个自动机接受，就将du对设置为覆盖。但是，当被测过程递归调用自身时，此方法必须进行特殊处理。 
（二）
Ostrand和Weyuker [1991a]使用记忆跟踪技术来精确确定覆盖了哪些对，而Kamkar等人（1991年）则采用了这种方法。 [1993]使用动态切片来提高覆盖精度。一些工作[Harrold and Malloy 1992; Su等。 [2015]利用动态数据流分析提高跟踪数据流覆盖率的精度。
（三）
Horgan和London [1992]利用代码工具来跟踪DFT覆盖范围，此后称为最后定义技术。在他们的方法中，从数据流图生成一张停用关系表，并在每个代码块处插入一个探针。运行时例程记录每个已定义的变量以及定义该变量的块。执行使用该已定义变量的块时，将验证该变量的最后定义，并将该对设置为覆盖。
（四）
Misurda等。 [2005b]提出了一种以需求为导向的策略来跟踪def-use对的覆盖，其目的是提高静态检测方法的性能（例如Horgan和London [1992]）。该方法的工作方式如下：首先，确定测试区域中的所有可变定义，并将种子探针插入其位置；第二，达到定义后，将按其所有可能的用途按需插入覆盖范围探针；第三，达到用途后，将立即删除该用途的探测，并将由最近访问的定义和该用途组成的配对标记为已覆盖。
（五）
Santelices和Harrold [2007]开发了一种有效的基于矩阵的策略来直接跟踪数据流覆盖范围。在此策略中，将创建一个coverage矩阵并将其初始化为零，其中每一列代表一个变量用途（与用途ID关联），并且列中的每个单元格记录该用途的定义（与定义ID关联）（也就是说，一个单元对应于一个def-use对。在这种结构中，可以通过使用ID和定义ID快速访问矩阵单元，以减少探针的运行时成本。在运行时，探针跟踪变量的最后定义。每次使用时，都会插入一个探针，该探针使用用途ID和最后定义ID更新矩阵中该对的覆盖状态。
在Santelices和Harrold [2007]中，设计了一种新颖的覆盖率推断策略，该策略使用分支覆盖率来推断数据流覆盖率。通过在动态执行之前使用静态分析，将对分为树类型，即可推断的，有条件可推断的和不可推断的对。在运行时，此方法跟踪分支覆盖，这是一种成本较低的代码工具。**测试套件执行后，它输出实际覆盖和有条件覆盖的对**。有关详细信息，请参阅第4.3节中基于抵押物覆盖率的测试方法。
为了使覆盖范围跟踪更具可扩展性，Harrold [1994]开发了一种在多处理器系统上接受测试的技术，并产生了可并行的覆盖范围跟踪工作量。工作负载可以静态或动态地调度到不同的平台上。对多处理器系统的评估表明，与单处理器系统相比，它具有良好的加速性能。
**讨论**
数据流覆盖在跟踪其覆盖范围时会**增加高昂的开销**。主要原因是：（1）基于数据流的**测试目标通常比语句或分支要多得多**；（2）数据流覆盖范围将约束（即，满足清晰清晰的路径）置于**程序路径**上，而不是简单地编写程序实体，这会使跟踪更加昂贵。现有方法主要诉诸有效的数据结构或利用覆盖推断来减轻开销。
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 覆盖到底指的是什么呢</span><br></pre></td></tr></table></figure>
**2. 覆盖工具**
有很多健壮的覆盖工具[Yang等。 [2009年]进行报表和分支机构的覆盖，但是只**有少数几个可用于数据流覆盖**。表一总结了用于数据流测试的覆盖工具，包括ASSET [Frankl and Weyuker 1985;弗兰克（Frankl）等人。 1985年；弗兰克（Frankl）1987； Frankl和Weyuker 1988年（第一个数据流覆盖工具），ATAC [Horgan and London 1992年]，Coverlipse，DaTec[Denaro等人。2008，2009]，DuaF [Santelices andHarrold 2007]，TACTIC [Ostrand and Weyuker 1991b]，POKE-TOOL [Chaim1991]，JaBUTi [Vincenzi等。 2005]，JMockit和Jazz [Misurda等。2005a]，DFC[Bluemke和Rembiszewski 2009、2012]和BA-DUA [Chaim和de Araujo2013a；de Araujo and Chaim 2014]。对于每种工具，该表列出了其支持的语言，是否跟踪过程内或过程间对或两者，基于它的分析基础结构，所使用的覆盖率跟踪技术及其可用性。在总共12种工具中，有6种是公开可用的，但它们都不是商业工具，Hassan和Andrews[2013]以及de Araujo和Chaim [2014]最近也对此进行了报道。
![](/block_paper_1/20200402031648506.png)
**六、近期进展**
本节讨论数据流测试的最新进展的三个方面：（1）新的覆盖标准，（2）动态数据流分析和（3）有效的覆盖跟踪。
**1. 新的覆盖标准**
Hassan和Andrews[2013]引入了一个新的覆盖标准系列，称为多点跨度覆盖率（MPSC）。具有间隙g和p点的MPSC的仪器记录所取分支的元组（b1，b2，...，bp）的覆盖范围，其中元组中的每个分支是在前一个之后的g个分支。经验评估表明，从分支机构的覆盖范围概括出的MPSC覆盖范围，在衡量测试有效性时，可以达到比所有常规使用覆盖范围更高的准确性。而且MPSC覆盖的工具也比数据流覆盖的工具更有效。
亚历山大等。 [2010]扩展了经典的数据流标准，以测试和分析面向对象系统中的多态关系。新的覆盖标准考虑了类的状态变量之间的定义和使用，特别是在存在继承，动态绑定以及状态变量和方法的多态覆盖的情况下。目的是提高面向对象程序中DFT的故障检测能力。
**2. 动态数据流分析**
 Denaro等。 [2014]和Vivanti [2014]研究了DFT中使用的传统静态数据流分析的局限性。他们使用动态数据流分析技术，通过**观察具体的程序执行来识别相关的数据流关系**。这种方法利用了可从具体执行中获得的精确别名信息，以将内存数据和类状态变量相互关联。结果，它比考虑静态计算的别名关系要精确得多。
对五个Java项目的评估表明，传统的静态数据流分析遗漏了大量数据流关系，这破坏了以前DFT方法的有效性。这种动态技术为数据流测试的新方向提供了启示，该方向可以更好地涵盖基于数据流的测试目标。
Denaro等。 [2015]将该动态数据流分析技术调整为测试面向对象的系统。这种方法不是先验地计算所有对，而是运行一些带有动态分析的测试，合并跟踪以推断从未执行过的对，生成新的测试以覆盖它们，然后进行迭代，直到找不到新的东西为止。结果比现有分支机构覆盖率测试套件的变异分数高出约30％。
**3. 高效的覆盖率追踪**
阻碍DFT广泛采用的一个因素是通过测试跟踪def-use对的覆盖范围的成本。由于DFT旨在实现更全面的程序测试，因此由代码工具施加的运行时成本大大高于其他结构标准。一些技术[Misurda等。 2005b； Santelices和Harrold [2007]提出了基于昂贵的计算和数据结构来解决此问题的建议。
Chaim andAraujo [Chaim anddeAraujo 2013a; 1998年；对数据流问题的经典解决方案（例如，达到定义[Aho et al。1986]）的启发。 de Araujo and Chaim 2014]发明了一种按位算法（BA）算法，该算法使用具有按位运算的位向量来跟踪Java字节码程序的数据流覆盖率。对于每条指令，此方法都使用已知的数据流分析技术来计算定义和使用的变量（局部变量或字段）。之后，它将在每个指令（或块）处检测BA代码，该代码用于确定线对的覆盖范围。 BA代码跟踪三个工作集，即活动对，覆盖对和当前困对，它们在测试执行期间进行更新。这些工作集以位向量实现，并通过有效的按位运算进行操作，其大小由被测方法对的数量给出。
作者还给出了正确性证明[Chaim and de Araujo 2013b]和理论分析，表明他们的算法比以前的需求驱动和基于矩阵的方法[Misurda等人，要求的内存和执行时间更少。 2005b； Santelices and Harrold 2007]。在他们的评估中[Chaim and de Araujo 2013a]，通过模拟这些仪器策略进一步证实了这一结论[Chaim等。 2011]。在de Araujo和Chaim [2014]中，此方法适用于处理具有200KLOC和300K对的大型系统，其执行开销可与流行的控制流测试工具强加。
**七、应用领域**
本节讨论了DFT应用程序的三个方面：（1）软件故障定位，（2）Web应用程序测试和（3）规范一致性检查。
**1. 软件故障定位**
在程序调试中，软件故障定位是一项繁琐且耗时的工作，以查找程序错误和错误。 Agrawal等。 [1995]提出了一种将DFT和执行切片结合在一起以实现更有效的故障定位的新颖方法。他们的工作基于这样一个假设，即错误在于测试用例的一部分，该部分无法执行而不是成功执行。结果，测试人员可以将语句集中在失败的片段上。称为ATAC的数据流测试工具[Horgan and London 1992]用于生成数据流测试。这些测试后来被用来检测种子故障并从Unix排序程序中计算执行片段。他们发现数据流测试可以有效地检测出那些种子错误，并且骰子可以显着提高故障定位性能。
Santelices等。 [2009]提出了一种轻量级的故障定位技术，该技术使用不同的覆盖标准来检测程序中的可疑错误语句。在他们的方法中，他们使用针对轻量级覆盖实体（包括语句，分支和def-use对）的测试来调查不同覆盖类型在故障定位中的好处。研究表明，通过不同的覆盖类型可以发现不同的故障，但是将这些不同的覆盖类型进行组合可以实现总体最佳性能。
**2. Web应用测试**
近年来，网络应用的快速发展丰富了人们的日常生活。但是，当体系结构和实现变得越来越复杂时，测试Web应用程序将变得艰巨。已经做出了一些努力来针对Web应用程序进行数据流测试。
由于Web应用程序中的数据可以存储在HTML文档中，因此可能会影响服务器和客户端之间的数据交互。刘等。 [2000]扩展了DFT方法用于Web应用程序，以检查此类数据交互的正确性。在他们的方法中，他们提出了一个Web应用程序测试模型来描述被测应用程序，并提出了一种DFT结构模型来捕获数据流信息。在WATM中，应用程序中的每个部分都将被建模为一个对象，该对象可以是HTML文档的客户端页面，Common GatewayInterface脚本的服务器页面以及Java applet或ActiveX工具的组件等等。这些模型中的每个模型都由属性和操作组成，以存储基本信息。 DFT结构模型使用四个流程图来捕获相关的数据流信息。在获得数据流信息之后，将生成测试用例以涵盖对象内，对象间和客户间方面。通过这种方式，DFT被扩展为测试Web应用程序。
Qi等。[2006]开发了一种基于多重代理的DFT方法来测试Web应用程序。他们将测试任务分为三个级别：方法级别，对象级别和对象群集级别。这些级别的每个测试代理将构建一个带有数据流信息的相应程序模型。数据流测试的整个任务可以分为子任务，并由这些测试代理执行。
Mei等。 [2008]利用DFT测试面向服务的工作流应用程序，例如WS-BPEL应用程序。他们发现XPath在工作流集成中起着重要作用，但可能包含从XML消息中提取的错误数据，这破坏了这些应用程序的可靠性。因此，他们将XPath重写图开发为一种数据结构，以对WS-BPEL中的XPath进行建模。然后，他们从概念上确定了XRG中的def-use对，并提出了一组数据流测试标准来测试WS-BPEL应用程序。
Alshahwan和Harman [2012]提出了一种基于状态的DFT技术用于Web应用程序，该技术会生成HTTP请求的新序列，以增强现有测试套件的覆盖范围和故障检测。新测试旨在执行状态变量（例如，会话变量）的定义，并确保这些值不变地达到相应的用途。他们发现，结果测试套件确实可以提高测试套件的质量。
**3. 规格一致性检查**
在软件开发中广泛使用各种规范模型来构建可靠的系统，这有助于自动生成一致的实现。因此，**检查模型的一致性**是确保实现正确性的重要手段。 Wang和Cavarra [2009]提出了一种基于DFT的方法来检查需求模型的一致性。该方法可以概括为四个过程：
（1）根据系统需求构建需求模型；（2）构建相关的调用序列以覆盖这些模型中的方法间用法；（3）从这些调用序列中获取布尔约束，并得出测试套件；（4）检查模型con -通过应用基于DFT的测试套件来保持一致性。此外，开发人员可以通过检查此测试套件将其最初的理解与要求进行比较。
还有一些工作可以从诸如SDL（规范和描述语言）之类的规范模型中生成基于数据流的测试套件。 2000]和状态图[Hong等。 2000]。生成的测试套件提供了测试实现是否符合高级规范模型的功能。
**4. 其他应用**
DFT也已应用于测试其他程序或应用程序。 Zhao [2003]使用DFT**测试面向方面的程序**。 Harrold和Malloy [1992]使用DFT**检查并行化的代码**。 DFT也已应用于**测试面向对象的库**[Chatterjee and Ryder 1999]和**服务编排**[Mei等。 2009]。
此外，我们调查了已应用DFT的每种语言的百分比（如图11所示）。我们可以观察到以下情况：首先，DFT最初应用于过程语言（例如Fortran，Pascal，C），但是近年来，面向对象的程序得到了更多的重视，因为DFT可以在检查对象状态时帮助发现更多细微的错误。。其次，在执行数据流测试时，面向对象的语言（例如C ++和Java）是最受欢迎的语言。第三，规范语言和Web服务也吸引了研究兴趣。
图12显示了1990年以来出版物每年报告的评估程序数量（我们在1990年之前省略了论文，因为它们主要关注理论和形式分析）。我们可以观察到（1）DFT在在过去的10年中，受评估程序的数量不断增加，并且（2）DFT逐渐应用于除实验室程序之外的实际程序。此外，我们发现数据流分析和覆盖跟踪技术（最大规模为200KLOC）比测试生成技术（最大规模为15KLOC）具有更高的可扩展性。这表明需要更多的研究工作来缩小这一差距。
**八、新见解和未来工作**
本节介绍了我们在此次调查中获得的新见解。遵循DFT的三个基本测试过程，即数据流分析，测试数据生成和覆盖率跟踪，我们建议以下未来研究方向。
**数据流分析：数据流分析负责识别使用定义对**
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)	为了更好地涵盖测试目标，可以将已知的静态数据流分析技术与动态数据流分析技术相结合[Denaro等。2014、2015]，并在可扩展性和精度之间取得平衡。</span><br><span class="line">(2)	数据流分析过程可以利用抵押物覆盖的概念来推断在def-use对本身之间或在def-use对与其他程序结构（例如，语句和分支）之间的覆盖关系。目的是确定对最小的对，其覆盖范围暗示其他对的覆盖范围，以便数据流测试可以专注于这些关键对，从而可以降低测试成本。</span><br><span class="line">(3)	数据流分析技术的类型应根据测试方案确定。例如，对于单元测试，可以使用传统的详尽数据流分析。但是对于回归测试或集成测试，需求驱动的数据流分析技术更合适，因为它可以避免不必要的开销。</span><br><span class="line">(4)	可以开发新的数据流分析技术并将其适应于不同的编程语言。例如，过程语言和面向对象语言在def-use对的构造上有很大不同。</span><br></pre></td></tr></table></figure>
**测试数据生成：测试数据的生成旨在有效地为def-use对生成合适的测试用例。**
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)	可以组合各种动态测试方法，包括随机测试，基于遗传/优化的测试和基于符号执行的测试，以满足定义使用对。尽管它们无法处理不可行的配对，但它们在测试生成方面具有不同的优势。</span><br><span class="line">(2)	基于模型检查的方法可用于补充动态测试方法。它可以为可行的de-use对生成测试，并处理不可行对的一部分。可以将成对的测试需求转换为可接受的模型检查器形式，然后可以使用模型检查器检查路径可行性并作为测试用例输出反例。</span><br><span class="line">(3)	基于符号执行的方法在基于路径的测试生成中有效，但面临路径爆炸问题，而模型检查方法（CEGAR）在检查路径可行性时有效。结果，CEGAR的运行时信息可以通知符号执行，从而避免不必要的路径探索并提高其在DFT中的性能。</span><br><span class="line">(4)	基于搜索和基于符号执行的测试技术的结合已经被用于实现更有效的分支测试[Inkumsah and Xie 2008; Baars等。 2011]。它们的组合也可以改善DFT。</span><br></pre></td></tr></table></figure>
**覆盖范围跟踪：可以提出有效的覆盖率跟踪**
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">算法来提高大型现实系统中数据流测试的可用性。可以采用诸如BA算法[de Araujo and Chaim 2014]之类的仪器方法。基于前面提到的新见识和研究方向，可以提出一种新颖的混合数据流测试框架（如图13所示）以实现更实用的数据流测试。它由三个基本组件组成：数据流分析仪，测试数据生成器和覆盖率监视器。给定一个程序作为输入，此混合框架（1）输出用于可行测试目标的测试数据，（2）消除不可行的测试目标。它介于动态测试方法和静态模型检查器之间，以最大化数据流覆盖范围。希望它可以通过结合其组件方法的优势来获得更好的性能，并从数据流分析，测试数据生成和覆盖范围跟踪的未来发展中受益。此外，该框架可以从两个方面促进DFT研究。一种是在更公平的基础上评估和比较不同的测试技术。另一个是对更多实际程序执行数据流覆盖率测试，以更深入地了解其有效性和复杂性[Namin</span><br><span class="line">和Andrews 2009； Inozemtseva和Holmes，2014年]。</span><br><span class="line">此外，未来的研究工作可能会努力开发新的具有成本效益的覆盖标准，以补充数据流覆盖标准。新标准应该易于执行，并且具有与DFT相当的故障检测能力（例如，Hassan和Andrews [2013]和Li等人[2013]）。数据流覆盖标准也可以扩展到各种测试场景（例如，面向对象的系统，Web应用程序和移动应用程序），以检查数据操作的正确性。</span><br></pre></td></tr></table></figure>
**九、结论**
在过去的40年中，数据流测试已经得到越来越广泛的研究。鉴于其检查数据交互的能力，已开发出各种方法和技术来追求高效和自动化的数据流测试。据我们所知，这是第一个针对数据流测试的系统调查。我们已经建立了包含97篇研究论文的出版物资料库，展示了研究的现状，并提供了该领域的综合分析。我们将基于数据流的测试生成方法分为五类。对于每个类别，我们都解释了其技术原理并讨论了其优缺点。技术还概述了覆盖跟踪和数据流分析。基于此调查，我们提出了新的见解和未来的研究方向，旨在使DFT更加有效和实用。

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 覆盖率是如何计算的</span><br></pre></td></tr></table></figure>









      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://nlbyd1119.online/2020/04/02/block_paper_1/" title="block_paper_1" target="_blank" rel="external">http://nlbyd1119.online/2020/04/02/block_paper_1/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/nlby" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/nlby" target="_blank"><span class="text-dark">nlby</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    <div id="git"></div>
<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script>
<script>
var gitment = new Gitment({
  id: window.decodeURIComponent(window.location.pathname),
  owner: 'nlby',
  repo: 'nlbyvh.github.io',
  oauth: {
    client_id: '6d53a92df707fc123e7a',
    client_secret: '2bd9e28afe88cb142fa8fa7092c9a8c20ae25555',
  },
})
gitment.render('git')
</script>
  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/04/03/block_paper_2/" title="block_paper_2"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/03/26/version-control/" title="version-control"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	

    <div class="copyright">
    	
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
<script src="//cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js"></script>
<script>
var gitment = new Gitment({
  // id默认为当前页面url，如果url后带参数或锚点，gitment要重新初始化
  // https://github.com/imsun/gitment/issues/55
  // 解决方案：id:window.location.pathname,或者将id设置为当前页面标题
  id: 'block_paper_1', 
  owner: 'nlby', // 可以是你的GitHub用户名，也可以是github id
  repo: 'nlbyvh.github.io',
  oauth: {
    client_id: '6d53a92df707fc123e7a',
    client_secret: '2bd9e28afe88cb142fa8fa7092c9a8c20ae25555',
  }
})
gitment.render('comments')
</script>









<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/violet.model.json"},"display":{"position":"left","width":180,"height":360},"mobile":{"show":true},"log":false});</script></body>
</html>